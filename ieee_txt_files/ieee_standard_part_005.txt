IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
16.5.2 Assertion clock
The timing model employed in a concurrent assertion specification is based on clock ticks and uses a
generalized notion of clock cycles. The definition of a clock is explicitly specified by the user and can vary
from one expression to another.
In an assertion, the sampled value is the only valid value of a variable during a clock tick. Figure16-1 shows
the values of a variable as the clock progresses. The value of signal is low at clock ticks 1 and 2. At
req
clock tick 3, the value is sampled as high and remains high until clock tick 6. The sampled value of variable
at clock tick 6 is low and remains low up to and including clock tick 9. Notice that the simulation value
req
transitions to high at clock tick 9. However, the sampled value at clock tick 9 is low.
simulation
time steps
clock ticks 1 2 3 4 5 6 7 8 9 10 11 12 13 14
req
Figure16-1—Sampling a variable in a simulation time step
An expression used in an assertion is always tied to a clock definition, except for the use of constant or
automatic values from procedural code (see 16.14.6). The sampled values are used to evaluate value change
expressions or Boolean subexpressions that are required to determine a match of a sequence.
For concurrent assertions, the following statements apply:
— It is important that the defined clock behavior be glitch free. Otherwise, wrong values can be
sampled.
— If a variable that appears in the expression for clock also appears in an expression with an assertion,
the values of the two usages of the variable can be different. The current value of the variable is used
in the clock expression, while the sampled value of the variable is used within the assertion.
The clock expression that controls evaluation of a sequence can be more complex than just a single signal
name. Expressions such as can be used to represent a gated clock. Other more
clk iff gating_signal
complex expressions are possible. However, in order to verify proper behavior of the system and conform as
closely as possible to truly cycle-based semantics, the user should ensure that the clock expression is glitch-
free and only transitions once at any simulation time. (See 9.4.2.3 for the reasons that the expression
clk
avoids the potential glitch in the expression .)
iff gating_signal clk && gating_signal
A reference to (see 14.14) is understood to be a reference to a clocking_event defined in a
$global_clock
declaration. A global clock behaves just as any other clocking event. In formal
globalclocking
verification, however, has additional significance, as it is considered to be the primary
$global_clock
system clock (see F.3.1 ). Thus, in the following example:
global clocking @clk; endclocking
...
assert property(@$global_clock a);
the assertion states that is true at each tick of the global clock. This assertion is logically equivalent to:
a
assert property(@clk a);
An example of a concurrent assertion is as follows:
376
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
base_rule1: assert property (cont_prop(rst,in1,in2)) $display("%m, passing");
else $display("%m, failed");
The keyword distinguishes a concurrent assertion from an immediate assertion. The syntax of
property
concurrent assertions is discussed in 16.14.
16.6 Boolean expressions
The outcome of the evaluation of an expression is Boolean and is interpreted the same way as an expression
is interpreted in the condition of a procedural statement. In other words, if the expression evaluates to ,
if X
, or , then it is interpreted as being false. Otherwise, it is true.
Z 0
Expressions that appear in concurrent assertions shall satisfy the following requirements:
— An expression shall result in a type that is cast compatible with an integral type. Subexpressions
need not meet this requirement as long as the overall expression is cast compatible with an integral
type.
— Elements of dynamic arrays, queues, and associative arrays that are sampled for assertion expression
evaluation may get removed from the array or the array may get resized before the assertion
expression is evaluated. These specific array elements sampled for assertion expression evaluation
shall continue to exist within the scope of the assertion until the assertion expression evaluation
completes.
— Expressions that appear in procedural concurrent assertions may reference automatic variables as
described in 16.14.6.1. Otherwise, expressions in concurrent assertions shall not reference automatic
variables.
— Expressions shall not reference non-static class properties or methods.
— Expressions shall not reference variables of the data type.
chandle
— Sequence match items with a local variable as the variable_lvalue may use the C assignment,
increment, and decrement operators. Otherwise, evaluation of an expression shall not have any side
effects (e.g., the increment and decrement operators are not allowed).
— Functions that appear in expressions shall not contain output or arguments ( is
ref const ref
allowed).
— Functions shall be automatic (or preserve no state information) and have no side effects.
Care should be taken when accessing large data structures, especially large dynamic data structures, in
concurrent assertions. Some types of access may require creating a copy of the entire data structure, which
could incur a significant performance penalty. The following example illustrates how the need to copy an
entire data structure may arise. In only a single byte of must be sampled by the assertion, and the
p1 q
location of that byte is constant. However, in there will be multiple active threads with potentially
p2
different values of . This increases the difficulty of determining which bytes of to sample and likely
l_b q
results in sampling all of .
q
bit a;
integer b;
byte q[$];
property p1;
$rose(a) |-> q[0];
endproperty
property p2;
integer l_b;
($rose(a), l_b = b) |-> ##[3:10] q[l_b];
endproperty
377
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
There are two places where Boolean expressions occur in concurrent assertions. They are as follows:
— In a sequence or property expression
— In the disable condition inferred for an assertion, specified either in a top-level clause
disableiff
(see 16.12) or in a declaration (see 16.15)
defaultdisable iff
The Boolean expressions used in defining a sequence or property expression shall be evaluated over the
sampled values of all variables. The preceding rule shall not, however, apply to expressions in a clocking
event (see 16.5).
The expressions in a disable condition are evaluated using the current values of variables (not sampled) and
may contain the sequence Boolean method . They shall not contain any reference to local
triggered
variables or to the sequence method .
matched
Assertions that perform checks based on time values should capture these values in the same context. It is
not recommended to capture time outside of the assertion. Time should be captured within the assertion
using local variables. The following example illustrates how a problem may arise when capturing time in
different contexts. In property , a time value, , is captured in a procedural context based on the current
p1 t
value of . Within the assertion, a comparison is made between the time value and the time value
count t
returned by in the assertion context based on the sampled value of . In both contexts,
$realtime count
returns the current time value. As a result, the comparison between values of time captured in
$realtime
the different contexts yields an inconsistent result. The inconsistency results in the computation for
p1
checking the amount of time that elapses between 8 periods of instead of the intended 7. In property ,
clk p2
both time values are captured within the assertion context. This strategy yields a consistent result.
bit [2:0] count;
realtime t;
initial count = 0;
always @(posedge clk) begin
if (count == 0) t = $realtime; //capture t in a procedural context
count++;
end
property p1;
@(posedge clk)
count == 7 |-> $realtime – t < 50.5;
endproperty
property p2;
realtime l_t;
@(posedge clk)
(count == 0, l_t = $realtime) ##1 (count == 7)[->1] |->
$realtime – l_t < 50.5;
endproperty
16.7 Sequences
sequence_expr ::= // from A.2.10
cycle_delay_range sequence_expr { cycle_delay_range sequence_expr }
| sequence_expr cycle_delay_range sequence_expr { cycle_delay_range sequence_expr }
| expression_or_dist [ boolean_abbrev ]
| sequence_instance [ sequence_abbrev ]
| sequence_expr { sequence_match_item } [ sequence_abbrev ]
( , )
378
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| sequence_expr sequence_expr
and
| sequence_expr sequence_expr
intersect
| sequence_expr sequence_expr
or
| sequence_expr { sequence_match_item}
first_match( , )
| expression_or_dist sequence_expr
throughout
| sequence_expr sequence_expr
within
| clocking_event sequence_expr
cycle_delay_range ::=
constant_primary
##
| cycle_delay_const_range_expression
##[ ]
|
##[*]
|
##[+]
sequence_match_item ::=
operator_assignment
| inc_or_dec_expression
| subroutine_call
sequence_instance ::=
ps_or_hierarchical_sequence_identifier [ [ sequence_list_of_arguments ] ]
( )
sequence_list_of_arguments ::=
[sequence_actual_arg] { [sequence_actual_arg] } { identifier [sequence_actual_arg] }
, , . ( )
| identifier [sequence_actual_arg] { identifier [sequence_actual_arg] }
. ( ) , . ( )
sequence_actual_arg ::=
event_expression
| sequence_expr
boolean_abbrev ::=
consecutive_repetition
| non_consecutive_repetition
| goto_repetition
sequence_abbrev ::= consecutive_repetition
consecutive_repetition ::=
const_or_range_expression
[* ]
|
[*]
|
[+]
non_consecutive_repetition ::= const_or_range_expression
[= ]
goto_repetition ::= const_or_range_expression
[-> ]
const_or_range_expression ::=
constant_expression
| cycle_delay_const_range_expression
cycle_delay_const_range_expression ::=
constant_expression constant_expression
:
| constant_expression
: $
expression_or_dist ::= expression [ dist_list ]
dist{ }
Syntax16-3—Sequence syntax (excerpt from AnnexA)
Properties are often constructed out of sequential behaviors. The feature provides the capability
sequence
to build and manipulate sequential behaviors. The simplest sequential behaviors are linear. A linear
sequence is a finite list of SystemVerilog Boolean expressions in a linear order of increasing time. The linear
sequence is said to match along a finite interval of consecutive clock ticks provided the first Boolean
expression evaluates to true at the first clock tick, the second Boolean expression evaluates to true at the
second clock tick, and so forth, up to and including the last Boolean expression evaluating to true at the last
379
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
clock tick. A single Boolean expression is an example of a simple linear sequence, and it matches at a single
clock tick provided the Boolean expression evaluates to true at that clock tick.
More complex sequential behaviors are described by SystemVerilog sequences. A sequence is a regular
expression over the SystemVerilog Boolean expressions that concisely specifies a set of zero, finitely many,
or infinitely many linear sequences. If at least one of the linear sequences from this set matches along a finite
interval of consecutive clock ticks, then the sequence is said to match along that interval.
A property may involve checking of one or more sequential behaviors beginning at various times. An
attempted evaluation of a sequence is a search for a match of the sequence beginning at a particular clock
tick. To determine whether such a match exists, appropriate Boolean expressions are evaluated beginning at
the particular clock tick and continuing at each successive clock tick until either a match is found or it is
deduced that no match can exist.
A sequence may admit an empty match, a match that occurs over an interval of length 0. (See a formal
definition at 16.12.22, and see 16.9.2.1 for more discussion of empty matches). An end point of a sequence
is the time step of any nonempty match of the sequence. An end point is reached whenever the ending clock
tick of a match of the sequence is reached, regardless of the starting clock tick of the match. A match point
includes both empty and nonempty matches, and is reached either at an end point or, in the case of an empty
match, at the length-0 time interval at the beginning of the time step when sequence evaluation begins. A
sequence that admits only empty matches is referred to as an empty sequence.
Sequences can be composed by concatenation, analogous to a concatenation of lists. The concatenation
specifies a delay, using , from the end of the first sequence until the beginning of the second sequence.
##
The syntax for sequence concatenation is shown in Syntax16-4.
sequence_expr ::= // from A.2.10
cycle_delay_range sequence_expr { cycle_delay_range sequence_expr }
| sequence_expr cycle_delay_range sequence_expr { cycle_delay_range sequence_expr }
...
cycle_delay_range ::=
constant_primary
##
| cycle_delay_const_range_expression
##[ ]
|
##[*]
|
##[+]
cycle_delay_const_range_expression ::=
constant_expression constant_expression
:
| constant_expression
: $
Syntax16-4—Sequence concatenation syntax (excerpt from AnnexA)
In this syntax, the following statements apply:
— constant_primary is a constant_expression, which is computed at compile time and shall result in an
integer value. Furthermore, constant_expression and the bounds in
cycle_delay_const_range_expression can only be 0 or greater.
— The token is used to indicate a finite, but unbounded, maximum.
$
— is used as an equivalent representation of .
##[*] ##[0:$]
— is used as an equivalent representation of .
##[+] ##[1:$]
— When a range is specified with two expressions, the second expression shall be greater than or equal
to the first expression.
380
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— In a cycle_delay_range, it shall be illegal for a constant_primary to contain a
constant_mintypmax_expression that is not also a constant_expression.
The context in which a sequence occurs determines when the sequence is evaluated. The first expression in a
sequence is checked at the first occurrence of the clock tick at or after the expression that triggered
evaluation of the sequence. Each successive element (if any) in the sequence is checked at the next
subsequent occurrence of the clock.
A ## followed by a number or range specifies the delay from the current clock tick to the beginning of the
sequence that follows. The delay ##1 indicates that the beginning of the sequence that follows is one clock
tick later than the current clock tick. The delay ##0 indicates that the beginning of the sequence that follows
is at the same clock tick as the current clock tick.
When used as a concatenation between two sequences, the delay is from the end of the first sequence to the
beginning of the second sequence. The delay ##1 indicates that the beginning of the second sequence is one
clock tick later than the end of the first sequence. The delay ##0 indicates that the beginning of the second
sequence is at the same clock tick as the end of the first sequence.
In the examples in this clause, is a Boolean expression that always evaluates to and is used for
`true 1'b1
visual clarity. It is defined as follows:
`define true 1'b1
##0 a // means a
##1 a // means `true ##1 a
##2 a // means `true ##1 `true ##1 a
##[0:3]a // means (a) or (`true ##1 a) or (`true ##1 `true ##1 a) or
// (`true ##1 `true ##1 `true ##1 a)
a ##2 b // meansa ##1 `true ##1 b
The sequence
req ##1 gnt ##1 !req
specifies that be true on the current clock tick, shall be true on the first subsequent tick, and
req gnt req
shall be false on the next clock tick after that. The operator specifies one clock tick separation. A delay
##1
of more than one clock tick can be specified, as in the following:
req ##2 gnt
This specifies that shall be true on the current clock tick, and shall be true on the second subsequent
req gnt
clock tick, as shown in Figure16-2.
s0 s1 s2
clk
req
gnt
Figure16-2—Concatenation of sequences
The following specifies that signal shall be true on the Nth clock tick after signal :
b a
a ##N b // check b on the Nth sample
381
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
To specify a concatenation of overlapped sequences, where the end point of one sequence coincides with the
start of the next sequence, a value of is used, as follows:
0
a ##1 b ##1 c // first sequence seq1
d ##1 e ##1 f // second sequence seq2
(a ##1 b ##1 c) ##0 (d ##1 e ##1 f) // overlapped concatenation
In the preceding example, must be true at the end point of sequence , and must be true at the start of
c seq1 d
sequence . When concatenated with clock tick delay, and must be true at the same time, resulting
seq2 0 c d
in a concatenated sequence equivalent to the following:
a ##1 b ##1 c&&d ##1 e ##1 f
It should be noted that no other form of overlapping between the sequences can be expressed using the
concatenation operation.
In cases where the delay can be any value in a range, a time window can be specified as follows:
req ##[4:32] gnt
In the preceding case, signal must be true at the current clock tick, and signal must be true at some
req gnt
clock tick between the 4th and the 32nd clock tick after the current clock tick.
The time window can extend to a finite, but unbounded, range by using as in the following example:
$
req ##[4:$] gnt
A sequence can be unconditionally extended by concatenation with .
`true
a ##1 b ##1 c ##3 `true
After satisfying signal , the sequence length is extended by three clock ticks. Such adjustments in the
c
length of sequences can be required when complex sequences are constructed by combining simpler
sequences.
16.8 Declaring sequences
A named may be declared in the following:
sequence
— A module
— An interface
— A program
— A block
clocking
— A package
— A compilation-unit scope
— A checker
— A generate block
Named sequences are declared using Syntax16-5.
382
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
assertion_item_declaration ::= // from A.2.10
...
| sequence_declaration
sequence_declaration ::=
sequence_identifier [ [ sequence_port_list ] ]
sequence ( ) ;
{ assertion_variable_declaration }
sequence_expr [ ]
;
[ sequence_identifier ]
endsequence :
sequence_port_list ::=
sequence_port_item { sequence_port_item}
,
sequence_port_item ::=
{ attribute_instance } [ [ sequence_lvar_port_direction ] ] sequence_formal_type
local
formal_port_identifier {variable_dimension} [ sequence_actual_arg ]
=
sequence_lvar_port_direction ::= | |
input inout output
sequence_formal_type ::=
data_type_or_implicit
|
sequence
|
untyped
formal_port_identifier ::= identifier // from A.9.3
sequence_instance ::= // from A.2.10
ps_or_hierarchical_sequence_identifier [ [ sequence_list_of_arguments ] ]
( )
sequence_list_of_arguments ::=
[sequence_actual_arg] { [sequence_actual_arg] } { identifier [sequence_actual_arg] }
, , . ( )
| identifier [sequence_actual_arg] { identifier [sequence_actual_arg] }
. ( ) , . ( )
sequence_actual_arg ::=
event_expression
| sequence_expr
assertion_variable_declaration ::=
var_data_type list_of_variable_decl_assignments
;
Syntax16-5—Sequence declaration syntax (excerpt from AnnexA)
A named sequence may be declared with formal arguments in the optional sequence_port_list.
A formal argument may be typed by specifying the type prior to the formal_port_identifier of the formal
argument. A type shall apply to all formal arguments whose identifiers both follow the type and precede the
next type, if any, specified in the port list. Rules particular to the specification and use of typed formal
arguments are discussed in 16.8.1.
Rules particular to the specification and use of local variable formal arguments are discussed in 16.8.2.
A formal argument is said to be untyped if there is no type specified prior to its formal_port_identifier in the
port list. There is no default type for a formal argument.
The supported data types for sequence formal arguments are the types that are allowed for operands in
assertion expressions (see 16.6) and the keyword .
untyped
A default actual argument may be specified for a formal argument in the optional associated declaration
assignment. The default_expression is resolved in the scope containing the sequence declaration.
Requirements for the type of the default actual argument of a typed formal argument are described in 16.8.1.
383
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The default actual argument of an untyped formal argument may be of any type provided its substitution
results in a valid sequence as described in the rewriting algorithm (see F.4.1).
A formal argument may be referenced in the body of the declaration of the named sequence. A reference to
a formal argument may be written in place of various syntactic entities, such as the following:
— identifier
— expression
— sequence_expr
— event_expression
— terminal $ in a cycle_delay_const_range_expression
A named sequence may be instantiated by referencing its name. The reference may be a hierarchical name
(see 23.6). A named sequence may be instantiated anywhere that a sequence_expr may be written, including
prior to its declaration. A named sequence may also be instantiated as part of a sequence_method_call (see
16.9.11, 16.13.5) or as an event_expression (see 9.4.2.4). It shall be an error if a cyclic dependency among
named sequences results from their instantiations. A cyclic dependency among named sequences results if,
and only if, there is a cycle in the directed graph whose nodes are the named sequences and whose edges are
defined by the following rule: there is a directed edge from one named sequence to a second named
sequence if, and only if, either the first named sequence instantiates the second named sequence within its
declaration, including an instance within the declaration of a default actual argument, or there is an instance
of the first named sequence that instantiates the second named sequence within an actual argument.
In an instance of a named sequence, actual arguments may be passed to formal arguments. The instance shall
provide an actual argument in the list of arguments for each formal argument that does not have a default
actual argument declared. The instance may provide an actual argument for a formal argument that has a
default actual argument, thereby overriding the default. Actual arguments in the list of arguments may be
bound to formal arguments by name or by position.
The terminal $ may be an actual argument in an instance of a named sequence, either declared as a default
actual argument or passed in the list of arguments of the instance. If $ is an actual argument, then the
corresponding formal argument shall be untyped and each of its references either shall be an upper bound in
a cycle_delay_const_range_expression or shall itself be an actual argument in an instance of a named
sequence.
If an instance of a named sequence is within the scope of a local variable (see 16.10), then an actual
argument in the list of arguments of the instance may reference the local variable.
Names other than formal arguments that appear in the declaration of a named sequence, including those that
appear in default actual arguments, shall be resolved according to the scoping rules from the scope of the
declaration of the named sequence. Names appearing in actual arguments in the list of arguments of the
instance shall be resolved according to the scoping rules from the scope of the instance of the named
sequence.
The sequential behavior and matching semantics of an instance of a named sequence are the same as those of
the flattened sequence that is obtained from the body of the declaration of the named sequence by the
rewriting algorithm defined in F.4.1. The rewriting algorithm substitutes actual arguments for references to
the corresponding formal arguments in the body of the declaration of the named sequence. The rewriting
algorithm does not itself account for name resolution and assumes that names have been resolved prior to the
substitution of actual arguments. If the flattened sequence is not legal, then the instance is not legal and there
shall be an error.
The substitution of an actual argument for a reference to the corresponding untyped formal argument in the
rewriting algorithm retains the actual as an expression term. An actual argument shall be enclosed in
384
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
parentheses and shall be cast to its self-determined type before being substituted for a reference to the
corresponding formal argument unless one of the following conditions holds:
— The actual argument is $.
— The actual argument is a variable_lvalue.
If the result of the rewriting algorithm is an invalid sequence, an error shall occur.
For example, a reference to an untyped formal argument may appear in the specification of a
cycle_delay_range, a boolean_abbrev, or a sequence_abbrev (see 16.9.2) only if the actual argument is an
elaboration-time constant. The following example illustrates such usage of formal arguments:
sequence delay_example(x, y, min, max, delay1);
x ##delay1 y[*min:max];
endsequence
// Legal
a1: assert property (@(posedge clk) delay_example(x, y, 3, $, 2));
int z, d;
// Illegal: z and d are not elaboration-time constants
a2_illegal: assert property (@(posedge clk) delay_example(x, y, z, $, d));
In the following example, named sequences and are evaluated on successive events of .
s1 s2 posedge clk
The named sequence is evaluated on successive events of . The named sequence is
s3 negedge clk s4
evaluated on successive alternating and events of .
posedge negedge clk
sequence s1;
@(posedge clk) a ##1 b ##1 c;
endsequence
sequence s2;
@(posedge clk) d ##1 e ##1 f;
endsequence
sequence s3;
@(negedge clk) g ##1 h ##1 i;
endsequence
sequence s4;
@(edge clk) j ##1 k ##1 l;
endsequence
Another example of named sequence declaration, which includes arguments, follows:
sequence s20_1(data,en);
(!frame && (data==data_bus)) ##1 (c_be[0:3] == en);
endsequence
Named sequence does not specify a clock. In this case, a clock would be inherited from some
s20_1
external source, such as a or an statement. An example of instantiating a named
property assert
sequence is shown as follows:
sequence s;
a ##1 b ##1 c;
endsequence
sequence rule;
@(posedge sysclk)
trans ##1 start_trans ##1 s ##1 end_trans;
endsequence
385
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Named sequence in the preceding example is equivalent to the following:
rule
sequence rule;
@(posedge sysclk)
trans ##1 start_trans ##1 (a ##1 b ##1 c) ##1 end_trans ;
endsequence
The following example illustrates an illegal cyclic dependency among the named sequences and :
s1 s2
sequence s1;
@(posedge sysclk) (x ##1 s2);
endsequence
sequence s2;
@(posedge sysclk) (y ##1 s1);
endsequence
16.8.1 Typed formal arguments in sequence declarations
The data type specified for a formal argument of a sequence may be the keyword . A formal
untyped
argument shall be untyped (see 16.8) if its data type is . The semantics of binding an actual
untyped
argument expression to a formal with a data type of shall be the same as the semantics for an
untyped
untyped formal. The keyword shall be used if an untyped formal argument follows a data type in
untyped
the formal argument list.
If a formal argument of a named sequence is typed, then the type shall be or one of the types
sequence
allowed in 16.6. The following rules apply to typed formal arguments and their corresponding actual
arguments, including default actual arguments declared in a named sequence:
a) If the formal argument is of type , then the actual argument shall be a sequence_expr. A
sequence
reference to the formal argument of type shall either be in a place where a sequence_expr
sequence
is legal, or as an operand of sequence methods and .
triggered matched
b) If the formal argument is of type , then the actual argument shall be an event_expression and
event
each reference to the formal argument shall be in a place where an event_expression may be written.
c) Otherwise, the self-determined result type of the actual argument shall be cast compatible (see
6.22.4) with the type of the formal argument. If the actual argument is a variable_lvalue, references
to the formal shall be considered as having the formal’s type with any assignment to the formal
being treated as though there was a subsequent assignment from the formal to the actual argument. If
the actual argument is not a variable_lvalue, the actual argument shall be cast to the type of the
formal argument before being substituted for a reference to the formal argument in the rewriting
algorithm (see F.4.1).
For example, a Boolean expression may be passed as an actual argument to a formal argument of type
because a Boolean expression is a sequence_expr. A formal argument of type may
sequence sequence
not be referenced as the expression_or_dist operand of a goto_repetition (see 16.9.2), regardless of the
corresponding actual argument, because a sequence_expr may not be written in that position.
A reference to a typed formal argument within a sequence_match_item (see 16.10) shall not stand as the
variable_lvalue in either an operator_assignment or an inc_or_dec_expression unless the formal argument
is a local variable argument (see 16.8.2, 16.12.19).
Two examples of declaring formal arguments follow. All of the formal arguments of are untyped. The
s1
formal arguments and of are untyped, while the formal argument has type .
w y s2 x bit
sequence s1(w, x, y);
w ##1 x ##[2:10] y;
endsequence
386
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
sequence s2(w, y, bit x);
w ##1 x ##[2:10] y;
endsequence
The following instances of and are equivalent:
s1 s2
s1(.w(a), .x(bit'(b)), .y(c))
s2(.w(a), .x(b), .y(c))
In the instance of above, if happens to be 8 bits wide then it will be cast to by truncation since it is
s2 b bit
being passed to a formal argument of type . Similarly, if an expression of type is passed as actual
bit bit
argument to a formal argument of type , then the expression is extended to a .
byte byte
If a reference to a typed formal argument appears in the specification of a cycle_delay_range, a
boolean_abbrev, or a sequence_abbrev (see 16.9.2), then the type of the formal argument shall be
, , or . The following example illustrates such usage of formal arguments:
shortint int longint
sequence delay_arg_example (max, shortint delay1, delay2, min);
x ##delay1 y[*min:max] ##delay2 z;
endsequence
parameter my_delay=2;
cover property (delay_arg_example($, my_delay, my_delay-1, 3));
The cover property in the preceding example is equivalent to the following:
cover property (x ##2 y[*3:$] ##1 z);
The following shows an example of a formal argument with type:
event
sequence event_arg_example (event ev);
@(ev) x ##1 y;
endsequence
cover property (event_arg_example(posedge clk));
The cover property in the preceding example is equivalent to the following:
cover property (@(posedge clk) x ##1 y));
If the intent is to pass as actual argument an expression that will be combined with an edge_identifier to
create an event_expression, then the formal argument shall not be typed with type . The following
event
example illustrates such usage:
sequence event_arg_example2 (reg sig);
@(posedge sig) x ##1 y;
endsequence
cover property (event_arg_example2(clk));
The cover property in the preceding example is equivalent to the following:
cover property (@(posedge clk) x ##1 y));
387
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Another example, in which a local variable is used to sample a formal argument, shows how to get the effect
of “pass by value.” Pass by value is not currently supported as a mode of argument passing.
sequence s(bit a, bit b);
bit loc_a;
(1'b1, loc_a = a) ##0
(t == loc_a) [*0:$] ##1 b;
endsequence
16.8.2 Local variable formal arguments in sequence declarations
This subclause describes mechanisms for declaring local variable formal arguments and rules specific to
their use. Local variable formal arguments are special cases of local variables (see 16.10).
A formal argument of a named sequence may be designated as a local variable argument by specifying the
keyword in the port item, followed optionally by one of the directions , , or . If
local input inout output
no direction is specified explicitly, then the direction shall be inferred. If the keyword is
input local
specified in a port item, then the type of that argument shall be specified explicitly in that port item and shall
not be inferred from a previous argument. The type of a local variable argument shall be one of the types
allowed in 16.6. If one of the directions , , or is specified in a port item, then the
input inout output
keyword shall be specified in that port item.
local
The designation of a formal argument as a local variable argument of a given direction and type shall apply
to subsequent identifiers in the port list as long as none of the subsequent port items specifies the keyword
or an explicit type. In other words, if a port item consists only of an identifier and if the nearest
local
preceding argument with an explicitly specified type also specifies the keyword , then the port item is
local
a local variable argument with the same direction and type as that preceding argument.
If a local variable formal argument has direction , then a default actual argument may be specified for
input
that argument in the optional declaration assignment in the port item, subject to the rules for default actual
arguments described in 16.8. It shall be illegal to specify a default actual argument for a local variable
argument of direction or .
inout output
An example showing legal declaration of a named sequence using local variable formal arguments is as
follows:
logic b_d, d_d;
sequence legal_loc_var_formal (
local inout logic a,
local logic b = b_d, // input inferred, default actual argument b_d
c, // local input logic inferred, no default
// actual argument
d = d_d, // local input logic inferred, default actual
// argument d_d
logic e, f // e and f are not local variable formal arguments
);
logic g = c, h = g || d;
...
endsequence
An example showing illegal declaration of a named sequence using local variable formal arguments is
shown as follows:
sequence illegal_loc_var_formal (
output logic a, // illegal: local must be specified with
// direction
388
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
local inout logic b,
c = 1'b0,// default actual argument illegal for inout
local d = expr,// illegal: type must be specified explicitly
local event e, // illegal: event is a type disallowed in
// 16.6
local logic f = g // g shall not refer to the local variable
// below and must be resolved upward from
// this declaration
);
logic g = b;
...
endsequence
In general, a local variable formal argument behaves in the same way as a local variable declared in an
assertion_variable_declaration. The rules in 16.10 for assigning to and referencing local variables,
including the rules of local variable flow, apply to local variable formal arguments with the following
provisions:
— Without further specification, the term local variable shall mean either a local variable formal
argument or a local variable declared in an assertion_variable_declaration.
— At the beginning of each evaluation attempt of an instance of a named sequence, a new copy of each
of its local variable formal arguments shall be created.
— A local variable formal argument with direction or shall be treated like a local
input inout
variable declared in an assertion_variable_declaration with a declaration assignment. The initial
value for the local variable formal argument is provided by the associated actual argument for the
instance. The self-determined result type of the actual argument shall be cast compatible (see 6.22.4)
with the type of the local variable formal argument. The value of the actual argument shall be cast to
the type of the local variable formal argument before being assigned as initial value to the local
variable formal argument. This assignment is referred to as the initialization assignment of the local
variable formal argument. Initialization of all input and inout local variable formal arguments shall
be performed before initialization of any local variable declared in an
assertion_variable_declaration. The expression of a declaration assignment to a local variable
declared in an assertion_variable_declaration may refer to a local variable formal argument of
direction or .
input inout
— If a local variable formal argument of direction or is bound to an actual argument in
input inout
the argument list of an instance and if the actual argument references a local variable, then it shall be
an error if that local variable is unassigned at the point of the reference in the context of the instance.
— A local variable formal argument of direction shall be unassigned at the beginning of the
output
evaluation attempt of the instance.
— The entire actual argument expression bound to an or local variable formal argument
inout output
shall itself be a reference to a local variable whose scope includes the instance and with whose type
the type of the local variable formal argument is cast compatible. It shall be an error if references to
the same local variable are bound as actual arguments to two or more local variable formal
arguments of direction or . It shall be an error if there exists a match of the named
inout output
sequence for which an inout or output local variable formal argument is unassigned at the
completion of the match. At the completion of a match of the instance of the named sequence, the
value of the inout or output local variable formal argument shall be cast to the type of and assigned
to the local variable whose reference is the associated actual argument. If multiple threads of
evaluation of the instance of the named sequence match, then multiple threads of evaluation shall
continue in the instantiation context, each with its own copy of the actual argument local variable.
For each matching thread of the instance of the named sequence, at the completion of the match of
that thread the value of the local variable formal argument in that thread shall be cast to the type of
and assigned to the associated copy of the actual argument local variable.
389
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— It shall be an error for an instance of a named sequence with an or local variable
inout output
formal argument to admit an empty match (see 16.12.22).
— It shall be an error to apply any of the sequence methods (see 16.9.11, 16.13.6) or
triggered
(see 16.13.5) to an instance of a named sequence with an input or inout local variable
matched
formal argument.
The following example illustrates legal usage of a local variable formal argument:
sequence sub_seq2(local inout int lv);
(a ##1 !a, lv += data_in)
##1 !b[*0:$] ##1 b && (data_out == lv);
endsequence
sequence seq2;
int v1;
(c, v1 = data)
##1 sub_seq2(v1) // lv is initialized by assigning it the value of v1;
// when the instance sub_seq2(v1) matches, v1 is
// assigned the value of lv
##1 (do1 == v1);
endsequence
The matching behavior of is equivalent to that of as follows:
seq2 seq2_inlined
sequence seq2_inlined;
int v1, lv;
(c, v1 = data) ##1
(
(1, lv = v1) ##0
(a ##1 !a, lv += data_in)
##1 (!b[*0:$] ##1 b && (data_out == lv), v1 = lv)
)
##1 (do1 == v1);
endsequence
Untyped arguments provide an alternative mechanism for passing local variables to an instance of a
subsequence, including the capability to assign to the local variable in the subsequence and later reference
the value assigned in the instantiation context (see 16.10).
16.9 Sequence operations
16.9.1 Operator precedence
Operator precedence and associativity are listed in Table16-1. The highest precedence is listed first.
Table16-1—Operator precedence and associativity
SystemVerilog expression operators Associativity
—
[* ] [= ] [-> ]
Left
##
Right
throughout
Left
within
Left
intersect
390
A u t h o r i z e Codpyrig ht © 2l018 iIEEEc. All rigehts renservesd. e d u s e l i m i t e d t o : S i e m e n s A G G B S B & S S O L G M S . D o w n l o a d e d o n D e c e m b e r 0 3 , 2 0 2 5 a t 0 5 : 4 4 : 4 9 U T C f r o m I E E E X p l o r e . R e s t r i c t i o n s a p p l y .

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table16-1—Operator precedence and associativity (continued)
SystemVerilog expression operators Associativity
Left
and
Left
or
16.9.2 Repetition in sequences
The syntax for sequence repetition is shown in Syntax16-6.
sequence_expr ::= // from A.2.10
...
| expression_or_dist [ boolean_abbrev ]
| sequence_instance [ sequence_abbrev ]
| sequence_expr { sequence_match_item} [ sequence_abbrev ]
( , )
...
boolean_abbrev ::=
consecutive_repetition
| non_consecutive_repetition
| goto_repetition
sequence_abbrev ::= consecutive_repetition
consecutive_repetition ::=
const_or_range_expression
[* ]
|
[*]
|
[+]
non_consecutive_repetition ::= const_or_range_expression
[= ]
goto_repetition ::= const_or_range_expression
[-> ]
const_or_range_expression ::=
constant_expression
| cycle_delay_const_range_expression
cycle_delay_const_range_expression ::=
constant_expression constant_expression
:
| constant_expression
: $
Syntax16-6—Sequence repetition syntax (excerpt from AnnexA)
The number of iterations of a repetition can either be specified by exact count or be required to fall within a
finite range. If specified by exact count, then the number of iterations is defined by a non-negative integer
constant expression. If required to fall within a finite range, then the minimum number of iterations is
defined by a non-negative integer constant expression; and the maximum number of iterations either is
defined by a non-negative integer constant expression or is $, indicating a finite, but unbounded, maximum.
If both the minimum and maximum numbers of iterations are defined by non-negative integer constant
expressions (see 11.2.1), then the minimum number shall be less than or equal to the maximum number.
See 16.9.2.1 for discussion of the special case where the number of iterations is 0.
The following three kinds of repetition are provided:
— Consecutive repetition ( [*const_or_range_expression ): Consecutive repetition specifies finitely
]
many iterative matches of the operand sequence, with a delay of one clock tick from the end of one
391
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
match to the beginning of the next. The overall repetition sequence matches at the end of the last
iterative match of the operand. is an equivalent representation of and is an
[*] [*0:$] [+]
equivalent representation of .
[*1:$]
— Goto repetition ( const_or_range_expression ): Goto repetition specifies finitely many
[-> ]
iterative matches of the operand Boolean expression, with a delay of one or more clock ticks from
one match of the operand to the next successive match and no match of the operand strictly in
between. The overall repetition sequence matches at the last iterative match of the operand.
— Nonconsecutive repetition ( const_or_range_expression ): Nonconsecutive repetition specifies
[= ]
finitely many iterative matches of the operand Boolean expression, with a delay of one or more
clock ticks from one match of the operand to the next successive match and no match of the operand
strictly in between. The overall repetition sequence matches at or after the last iterative match of the
operand, but before any later match of the operand.
The effect of consecutive repetition of a subsequence within a sequence can be achieved by explicitly
iterating the subsequence, as follows:
a ##1 b ##1 b ##1 b ##1 c
Using the consecutive repetition operator , which indicates three iterations, this sequential behavior is
[*3]
specified more succinctly:
a ##1 b [*3] ##1 c
A consecutive repetition specifies that the operand sequence shall match a specified number of times. The
consecutive repetition operator specifies that the operand sequence must match N times in succession.
[*N]
For example:
a [*3] means a ##1 a ##1 a
The syntax allows the combination of a delay and repetition in the same sequence. The following are both
allowed:
a ##3 (b[*3]) // means a ##1 `true ##1 `true ##1 (b ##1 b ##1 b)
(a ##2 b)[*3] // means (a ##2 b) ##1 (a ##2 b) ##1 (a ##2 b),
// which in turn means
// (a ##1 `true ##1 b) ##1 (a ##1 `true ##1 b) ##1 (a ##1 `true ##1 b)
A repetition with a range of minimum and maximum number of iterations can be expressed with
min max
the consecutive repetition operator .
[*min:max]
For example:
(a ##2 b)[*1:5]
is equivalent to
(a ##2 b)
or (a ##2 b ##1 a ##2 b)
or (a ##2 b ##1 a ##2 b ##1 a ##2 b)
or (a ##2 b ##1 a ##2 b ##1 a ##2 b ##1 a ##2 b)
or (a ##2 b ##1 a ##2 b ##1 a ##2 b ##1 a ##2 b ##1 a ##2 b)
Similarly,
(a[*0:3] ##1 b ##1 c)
392
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
is equivalent to
(b ##1 c)
or (a ##1 b ##1 c)
or (a ##1 a ##1 b ##1 c)
or (a ##1 a ##1 a ##1 b ##1 c)
To specify a finite, but unbounded, number of iterations, the dollar sign ( ) is used. For example, the
$
repetition
a ##1 b [*1:$] ##1 c
matches over an interval of three or more consecutive clock ticks if is true on the first clock tick, is true
a c
on the last clock tick, and is true at every clock tick strictly in between the first and the last.
b
Specifying the number of iterations of a repetition by exact count is equivalent to specifying a range in
which the minimum number of repetitions is equal to the maximum number of repetitions. In other words,
is equivalent to .
seq[*n] seq[*n:n]
The goto repetition (nonconsecutive exact repetition) takes a Boolean expression rather than a sequence as
operand. It specifies the iterative matching of the Boolean expression at clock ticks that are not necessarily
consecutive and ends at the last iterative match. For example:
a ##1 b [->2:10] ##1 c
matches over an interval of consecutive clock ticks provided is true on the first clock tick, is true on the
a c
last clock tick, is true on the penultimate clock tick, and, including the penultimate, there are at least 2 and
b
at most 10 not necessarily consecutive clock ticks strictly in between the first and last on which is true.
b
This sequence is equivalent to the following:
a ##1 ((!b[*0:$] ##1 b) [*2:10]) ##1 c
The nonconsecutive repetition is like the goto repetition except that a match does not have to end at the last
iterative match of the operand Boolean expression. The use of nonconsecutive repetition instead of goto
repetition allows the match to be extended by arbitrarily many clock ticks provided the Boolean expression
is false on all of the extra clock ticks. For example:
a ##1 b [=2:10] ##1 c
matches over an interval of consecutive clock ticks provided is true on the first clock tick, is true on the
a c
last clock tick, and there are at least 2 and at most 10 not necessarily consecutive clock ticks strictly in
between the first and last on which is true. This sequence is equivalent to the following:
b
a ##1 ((!b [*0:$] ##1 b) [*2:10]) ##1 !b[*0:$] ##1 c
The consecutive repetition operator can be applied to general sequence expressions, but the goto repetition
and nonconsecutive repetition operators can be applied only to Boolean expressions. In particular, goto
repetition and nonconsecutive repetition cannot be applied to a Boolean expression to which a sequence
match item (see 16.10, 16.11) has been attached. For example, the following is a legal sequence expression:
(b[->1], v = e)[*2]
but the following is illegal:
(b, v = e)[->2]
393
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
16.9.2.1 Repetition, concatenation, and empty matches
Using as a sequence repetition number, an empty sequence (see 16.7) results, as in this example:
0
a [*0]
Because empty matches occur over an interval of zero clock ticks and are thus of length 0, they follow the
set of concatenation rules specified below. In the following rules, an empty sequence is denoted as empty,
and another sequence (which may be empty or nonempty) is denoted as seq.
— does not result in a match.
(empty ##0 seq)
— does not result in a match.
(seq ##0 empty)
— , where is greater than 0, is equivalent to .
(empty ##n seq) n (##(n-1) seq)
— , where is greater than 0, is equivalent to .
(seq ##n empty) n (seq ##(n-1) `true)
For example, compare the following two sequences:
a[*0] ##0 b
`true ##0 b
As defined by the preceding rules, the first sequence can never be matched: there is no point in time when
the end point of the length-0 sequence and the length-1 sequence are aligned. In contrast, the
a[*0] ##0 b
second is a well-defined sequence representing the fusion of two sequences of length 1. It will match during
any time step when the sampled value of is true.
b
To apply these rules to a sequence admitting both empty and nonempty matches, rewrite the sequence as the
OR of its empty and nonempty cases. Consider the multiple concatenation example:
b ##1 a[*0:1] ##2 c
This is equivalent to:
(b ##1 a[*0] ##2 c) or (b ##1 a[*1] ##2 c)
which can be rewritten as:
(b ##1 ##1 c) or (b ##1 a ##2 c)
or, more concisely:
(b ##2 c) or (b ##1 a ##2 c)
From this example, we can see that when matching the 0-tick interval specified by the empty case ,
a[*0]
the total execution time of the sequence is one less than when using the 1-tick interval specified by .
a[*1]
16.9.3 Sampled value functions
This subclause describes the system functions available for accessing sampled values of an expression.
These functions include the capability to access current sampled value, access sampled value in the past, or
detect changes in sampled value of an expression. Sampling of an expression is explained in 16.5.1. Local
variables (see 16.10) and the sequence method are not allowed in the argument expressions passed
matched
to these functions. The following functions are provided:
394
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
expression
$sampled( )
expression [ [clocking_event] ]
$rose( , )
expression [ [clocking_event] ]
$fell( , )
expression [ [clocking_event] ]
$stable( , )
expression [ [ clocking_event ] ]
$changed( , )
expression1 [ [number_of_ticks ] [ [expression2 ] [ [clocking_event]]] ]
$past( , , , )
The use of these functions is not limited to assertion features; they may be used as expressions in procedural
code as well. The clocking event, although optional as an explicit argument to the functions , ,
$past $rose
and , is required for their semantics. The clocking event is used to sample
$stable, $changed, $fell
the value of the argument expression.
The function does not use a clocking event.
$sampled
For a sampled value function other than , the clocking event shall be explicitly specified as an
$sampled
argument or inferred from the code where the function is called. The following rules are used to infer the
clocking event:
— If called in an assertion, sequence, or property, the appropriate clocking event as determined by
clock flow rules (see 16.13.3) is used.
— Otherwise, if called in a disable condition or a clock expression in an assertion, sequence, or
property, it shall be explicitly clocked.
— Otherwise, if called in an action block of an assertion, the leading clock of the assertion is used.
— Otherwise, if called in a procedure, the inferred clock, if any, from the procedural context (see
16.14.6) is used.
— Otherwise, if called outside an assertion, default clocking (see 14.12) is used.
The function returns the sampled value of its argument (see 16.5.1). The use of in
$sampled $sampled
concurrent assertions, although allowed, is redundant, as the result of the function is identical to the sampled
value of the expression itself used in the assertion. The use of in a clause is
$sampled disable iff
meaningful since the disable condition by default is not sampled (see 16.12).
The function is useful to access the value of expressions used in concurrent assertions in their
$sampled
action blocks. Consider the following example:
logic a, b, clk;
// ...
a1_bad: assert property (@clk a == b)
else $error("Different values: a = %b, b = %b", a, b);
a2_ok: assert property (@clk a == b)
else $error("Different values: a = %b, b = %b",
$sampled(a), $sampled(b));
If in some clock tick the sampled value of is 0 and of is 1, but their current values in the Reactive region
a b
of this tick are 0, then assertion will report . This is because
a1_bad Different values: a = 0, b = 0
action blocks are evaluated in the Reactive region (see 16.14.1). Assertion reports the intended
a2_ok
message because the values of and in its action block are
Different values: a = 0, b = 1 a b
evaluated in the same context as in the assertion.
The following functions are called value change functions and are provided to detect changes in sampled
values: , , , and .
$rose $fell $stable $changed
A value change function detects a change (or, in the case of , lack of change) in the sampled value
$stable
of an expression. The change (or lack of change) is determined by comparing the sampled value of the
395
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
expression with the sampled value of the expression from the most recent strictly prior time step in which
the clocking event occurred (see 16.5.1 for the definition of sampling in past clock ticks and the following
description of for how past values are evaluated). The result of a value change function is true or
$past
false and a call to a value change function may be used as a Boolean expression. The results of value change
functions shall be determined as follows:
— returns true ( ) if the LSB of the expression changed to . Otherwise, it returns false
$rose 1'b1 1
( ).
1'b0
— returns true ( ) if the LSB of the expression changed to . Otherwise, it returns false
$fell 1'b1 0
( ).
1'b0
— returns true ( ) if the value of the expression did not change. Otherwise, it returns
$stable 1'b1
false ( ).
1'b0
— returns true ( ) if the value of the expression changed. Otherwise, it returns false
$changed 1'b1
( ).
1'b0
When these functions are called at or before the simulation time step in which the first clocking event
occurs, the results are computed by comparing the sampled value of the expression with its default sampled
value (see 16.5.1).
Figure16-3 illustrates two examples of value changes:
— Value change expression is defined as .
e1 $rose(req)
— Value change expression is defined as .
e2 $fell(ack)
The clock ticks used for sampling the variables are derived from the clock for the property, which is
different from the simulation time steps. Assume, for now, that this clock is defined elsewhere. At clock tick
3, occurs because the value of at clock tick 2 was low and the value at clock tick 3 is high. Similarly,
e1 req
occurs at clock tick 6 because the value of was sampled as high at clock tick 5 and sampled as low at
e2 ack
clock tick 6.
simulation
time steps
clock ticks 1 2 3 4 5 6 7 8 9 10 11 12 13 14
req
ack
e1
e2
Figure16-3—Value change expressions
The following example illustrates the use of in SystemVerilog code outside assertions:
$rose
always @(posedge clk)
reg1 <= a & $rose(b);
In this example, the clocking event is applied to . is true whenever the
@(posedge clk) $rose $rose
sampled value of changed to from its sampled value at the previous tick of the clocking event.
b 1
396
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Past sampled values can be accessed with the function. The following three optional arguments are
$past
provided:
— expression2 is used as a gating expression for the clocking event.
— number_of_ticks specifies the number of clock ticks in the past.
— clocking_event specifies the clocking event for sampling expression1.
expression1 and expression2 may be any expression allowed in assertions. If expression2 is not specified,
then it defaults to .
1'b1
number_of_ticks shall be 1 or greater and shall be an elaboration-time constant expression. If
number_of_ticks is not specified, then it defaults to 1.
returns the sampled value of expression1 in a particular time step strictly prior to the one in which
$past
is evaluated (see 16.5.1 for the definition of sampling in past clock ticks). If number_of_ticks equals
$past
k and if ev is the event expression underlying clocking_event, then the particular time step is the kth strictly
prior time step in which the event ev expression2 occurred. If there do not exist k strictly prior time
iff
steps in which the event ev expression2 occurred, then the value returned from the function is the
iff $past
default sampled value of expression1 (see 16.5.1).
The clocking event for shall be explicitly specified through the clocking_event argument or inferred
$past
from the code where is called. The rules for inferring the clocking event are described previously.
$past
When intermediate optional arguments between two arguments are not needed, a comma shall be placed for
each omitted argument. For example:
$past(in1, , enable);
Here, a comma is specified to omit number_of_ticks. The default of is used for the empty number_of_ticks
1
argument. There is no need to include a comma for the omitted clocking_event argument, as it does not fall
within the specified arguments.
can be used in any SystemVerilog expression. An example follows.
$past
always @(posedge clk)
reg1 <= a & $past(b);
In this example, the inferred clocking event is applied to . is evaluated in
@(posedge clk) $past $past
the current occurrence of ( ) and returns the value of sampled at the previous occurrence of
posedgeclk b
( ).
posedgeclk
The function may refer to automatic variables, e.g., to procedural loop variables, as follows:
$past
always @(posedge clk)
for (int i = 0; i < 4; i ++)
if (cond[i])
reg1[i] <= $past(b[i]);
According to the definition of the past sampled value (see 16.5.1), returns at each loop iteration the
$past
past value of the -th bit of .
i b
When expression2 is specified, the sampling of expression1 is performed based on its clock gated with
expression2. For example:
397
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
always @(posedge clk)
if (enable) q <= d;
always @(posedge clk)
assert property (done |=> (out == $past(q, 2,enable)) );
In this example, the sampling of for evaluating is based on the following clocking expression:
q $past
posedge clk iff enable
The clocking event argument of a sampled value function may be different from the clocking event of the
context in which it is called, as determined by the clock resolution (see 16.16).
Consider the following assertions:
bit clk, fclk, req, gnt, en;
...
a1: assert property
(@(posedge clk) en && $rose(req) |=> gnt);
a2: assert property
(@(posedge clk) en && $rose(req, @(posedge fclk)) |=> gnt);
Both assertions and read: “whenever is high and rises, at the next cycle must be asserted.”
a1 a2 en req gnt
In both assertions, the rise of occurs if and only if the sampled value of at the current posedge of
req req
is and the sampled value of at a particular prior point is distinct from . The assertions
clk 1'b1 req 1'b1
differ in the specification of the prior point. In the prior point is the preceding posedge of , while in
a1 clk
the prior point is the most recent prior posedge of .
a2 fclk
As another example,
always_ff @(posedge clk1)
reg1 <= $rose(b, @(posedge clk2));
Here, is updated in each time step in which occurs, using the value returned from the
reg1 posedgeclk1
sampled value function in that time step. compares the sampled value of the LSB of from
$rose $rose b
the current time step (one in which occurs) with the sampled value of the LSB of in the
posedgeclk1 b
strictly prior time step in which occurs.
posedgeclk2
The following example is illegal if it is not within the scope of a default clocking because no clock can be
inferred:
always @(posedge clk) begin
...
@(negedge clk2);
x = $past(y, 5); // illegal if not within default clocking
end
This example is legal if it is within the scope of a default clocking.
16.9.4 Global clocking past and future sampled value functions
This subclause describes the system functions available for accessing the nearest past and future values of an
expression as sampled by the global clock. They may be used only if global clocking is defined (see 14.14).
These functions include the capability to access the sampled value at the global clock tick that immediately
398
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
precedes or follows the time step at which the function is called. Sampled value is explained in 16.5.1. The
following functions are provided.
Global clocking past sampled value functions are as follows:
expression
$past_gclk( )
expression
$rose_gclk( )
expression
$fell_gclk( )
expression
$stable_gclk( )
expression
$changed_gclk( )
Global clocking future sampled value functions are as follows:
expression
$future_gclk( )
expression
$rising_gclk( )
expression
$falling_gclk( )
expression
$steady_gclk( )
expression
$changing_gclk( )
The behavior of the global clocking past sampled value functions can be defined using the sampled value
functions as follows (the symbol means here “is equivalent by definition”):
$past_gclk(v) $past(v,,, @$global_clock)
$rose_gclk(v) $rose(v, @$global_clock)
$fell_gclk(v) $fell(v, @$global_clock)
$stable_gclk(v) $stable(v, @$global_clock)
$changed_gclk(v) $changed(v, @$global_clock)
The global clocking future sampled value functions are similar except that they use the subsequent value of
the expression.
is the sampled value of at the next global clock tick (see 16.5.1 for the definition of
$future_gclk(v) v
sampling in future clock ticks).
The other functions are defined as follows:
— returns true ( ) if the sampled value of the LSB of the
$rising_gclk(expression) 1'b1
expression is changing to 1 at the next global clocking tick. Otherwise, it returns false ( ).
1'b0
— returns true ( ) if the sampled value of the LSB of the
$falling_gclk(expression) 1'b1
expression is changing to 0 at the next global clocking tick. Otherwise, it returns false ( ).
1'b0
— returns true ( ) if the sampled value of the expression does not
$steady_gclk(expression) 1'b1
change at the next global clock tick. Otherwise, it returns false ( ).
1'b0
— is the complement of , i.e.,
$changing_gclk(expression) $steady_gclk
.
!$steady_gclk(expression)
The global clocking future sampled value functions may be invoked only in property_expr or in
sequence_expr; this implies that they shall not be used in assertion action blocks. The global clocking past
sampled value functions are a special case of the sampled value functions, and therefore the regular
restrictions imposed on the sampled value functions and their arguments apply (see 16.9.3). In particular, the
global clocking past sampled value functions are usable in general procedural code and action blocks.
Additional restrictions are imposed on the usage of the global clocking future sampled value functions: they
shall not be nested and they shall not be used in assertions containing sequence match items (see 16.10,
16.11).
399
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The following example illustrates the illegal usage of the global clocking future sampled value functions:
// Illegal: global clocking future sampled value functions
// shall not be nested
a1: assert property (@clk $future_gclk(a || $rising_gclk(b));
sequence s;
bit v;
(a, v = a) ##1 (b == v)[->1];
endsequence : s
// Illegal: a global clocking future sampled value function shall not
// be used in an assertion containing sequence match items
a2: assert property (@clk s |=> $future_gclk(c));
Even though global clocking future sampled value functions depend on future values of their arguments, the
interval of simulation time steps for an evaluation attempt of an assertion containing global clocking future
sampled value functions is defined as though the future sampled values were known in advance. The end of
the evaluation attempt is defined to be the last tick of the assertion clock and is not delayed any additional
time steps up to the next global clocking tick.
The behavior of and other asynchronous assertion related controls such as
disableiff $assertcontrol
(see 20.12) is with respect to the interval of the evaluation attempt previously defined. If, for example,
with 5 (Kill) is executed in a time step strictly after the last tick of the
$assertcontrol control_type
assertion clock for the evaluation attempt, then it shall not affect that attempt, even if is
$assertcontrol
executed no later than the next global clocking tick.
Execution of the action block of an assertion containing global clocking future sampled value functions shall
be delayed until the global clocking tick that follows the last tick of the assertion clock for the attempt. If the
evaluation attempt fails and is called by default (see 16.14.1), then shall be called at the
$error $error
global clocking tick that follows the last tick of the assertion clock.
A tool specific message that reports the starting or ending time step of an evaluation attempt of an assertion
containing global clocking future sampled functions shall be consistent with the preceding definition of the
interval of simulation time steps for the evaluation attempt. The message may also report the time step in
which it is written, which may be that of the global clocking tick that follows the last tick of the assertion
clock.
Example 1:
Table16-2 shows the values returned by the global clocking future sampled value functions for at
sig
different time moments.
The following assertion states that the signal may change only on falling clock:
a1: assert property (@$global_clock $changing_gclk(sig)
|-> $falling_gclk(clk))
else $error(”sig is not stable”);
In Figure16-4, the vertical arrows indicate the ticks of the global clock. The assertion is violated at time
a1
80 because is true and is false. Because the assertion
$changing_gclk(sig) $falling_gclk(clk)
contains global clocking future sampled value functions, the error task
$error("sig is not stable")
in the action block is executed at time 90. If, as part of the tool-specific message printed by , a tool
$error
reports the ending or failing time of this evaluation attempt, the time reported is 80.
400
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
0 10 20 30 40 50 60 70 80 90 100 110
$global_clock
clk
sig
Figure16-4—Future value change
Table16-2—Global clocking future sampled value functions
Time $sampled(sig) $future_gclk(sig) $rising_gclk(sig) $falling_gclk(sig) $changing_gclk(sig) $steady_gclk(sig)
10 1'b1 1'b0 1'b0 1'b1 1'b1 1'b0
30 1'b0 1'b0 1'b0 1'b0 1'b0 1'b1
40 1'b0 1'b0 1'b0 1'b0 1'b0 1'b1
50 1'b0 1'b1 1'b1 1'b0 1'b1 1'b0
80 1'b1 1'b0 1'b0 1'b1 1'b1 1'b0
Example 2:
The following assumption states that a signal must remain stable between two falling edges of a clock
sig
as sampled by global clocking. This differs from the property in Example 1 in the case where the first
clk
falling edge of has not yet occurred. In Example 1, is not allowed to change in that case, but in this
clk sig
example can toggle freely while waiting for to begin.
sig clk
a2: assume property(@$global_clock
$falling_gclk(clk) ##1 (!$falling_gclk(clk)[*1:$]) |->
$steady_gclk(sig));
Example 3:
Assume that the signal is high between times 82 and 84, and is low at all other time moments. Then the
rst
following assertion:
a3: assert property (@$global_clock disable iff (rst) $changing_gclk(sig)
|-> $falling_gclk(clk))
else $error(”sig is not stable”);
fails at time 80 (see Figure16-4) since is inactive at time 80. The interval of the failing evaluation
rst
attempt starts and ends at time 80. Although is active prior to the execution of the action block at time
rst
90, the attempt is not disabled.
Example 4:
In some cases, the global clocking future value functions provide a more natural expression of a property
than the past value functions. For example, the following two assertions are equivalent:
// A ##1 is needed in a4 due to the corner case at cycle 0
a4: assert property (##1 $stable_gclk(sig));
401
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
// In a5, there is no issue at cycle 0
a5: assert property ($steady_gclk(sig));
16.9.5 AND operation
The binary operator is used when both operands are expected to match, but the end times of the operand
and
sequences can be different (see Syntax16-7).
sequence_expr ::= // from A.2.10
...
| sequence_expr sequence_expr
and
Syntax16-7—And operator syntax (excerpt from AnnexA)
The two operands of are sequences. The requirement for the match of the operation is that both the
and and
operands shall match. The operand sequences start at the same time. When one of the operand sequences
matches, it waits for the other to match. The end time of the composite sequence is the end time of the
operand sequence that completes last.
When and are sequences, then the composite sequence
te1 te2
te1 and te2
matches if and match. The end time is the end time of either or , whichever matches last.
te1 te2 te1 te2
The following example is a sequence with operator , where the two operands are sequences:
and
(te1 ##2 te2) and (te3 ##2 te4 ##2 te5)
The operation as illustrated in Figure16-5 shows the evaluation attempt at clock tick 8. Here, the two
operand sequences are and . The first operand sequence
(te1 ##2 te2) (te3 ##2 te4 ##2 te5)
requires that first evaluates to true followed by two clock ticks later. The second sequence requires
te1 te2
that first evaluates to true followed by two clock ticks later, followed by two clock ticks later.
te3 te4 te5
This attempt results in a match because both operand sequences match. The end times of matches for the
individual sequences are clock ticks 10 and 12. The end time for the composite sequence is the later of the
two end times; therefore, a match is recognized for the composite sequence at clock tick 12.
In the following example, the first operand sequence has a concatenation operator with range from 1 to 5:
(te1 ##[1:5] te2) and (te3 ##2 te4 ##2 te5)
The first operand sequence requires that evaluate to true and that evaluate to true 1, 2, 3, 4, or 5
te1 te2
clock ticks later. The second operand sequence is the same as in the previous example. To consider all
possibilities of a match of the composite sequence, the following steps can be taken:
a) Five threads of evaluation are started for the five possible linear sequences associated with the first
sequence operand.
b) The second operand sequence has only one associated linear sequence; therefore, only one thread of
evaluation is started for it.
402
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
clk 1 2 3 4 5 6 7 8 9 10 11 12 13 14
te1
te2
te3
te4
te5
te1 ##2 te2
te3 ##2 te4 ##2 te5
(te1 ##2 te2) and
(te3 ##2 te4 ##2 te5)
Figure16-5—ANDing (and) two sequences
c) Figure16-6 shows the evaluation attempt beginning at clock tick 8. All five linear sequences for the
first operand sequence match, as shown in a time window; therefore, there are five matches of the
first operand sequence, ending at clock ticks 9, 10, 11, 12, and 13, respectively. The second operand
sequence matches at clock tick 12.
d) Each match of the first operand sequence is combined with the single match of the second operand
sequence, and the rules of the AND operation determine the end time of the resulting match of the
composite sequence.
The result of this computation is five matches of the composite sequence, four of them ending at clock tick
12, and the fifth ending at clock tick 13. Figure16-6 shows the matches of the composite sequence ending at
clock ticks 12 and 13.
If and are sampled expressions (not sequences), the sequence ( ) matches if and
te1 te2 te1andte2 te1
both evaluate to true.
te2
An example is illustrated in Figure16-7, which shows the results for attempts at every clock tick. The
sequence matches at clock tick 1, 3, 8, and 14 because both and are simultaneously true. At all
te1 te2
other clock ticks, match of the AND operation fails because either or is false.
te1 te2
403
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
clk 1 2 3 4 5 6 7 8 9 10 11 12 13 14
te1
te2
te3
te4
te5
te1 ##[1:5] te2
te3 ##2 te4 ##2 te5
(te1 ##[1:5] te2) and
(te3 ##2 te4 ##2 te5)
Figure16-6—ANDing (and) two sequences, including a time range
clock 1 2 3 4 5 6 7 8 9 10 11 12 13 14
te1
te2
te1 and te2
Figure16-7—ANDing (and) two Boolean expressions
16.9.6 Intersection (AND with length restriction)
The binary operator is used when both operand sequences are expected to match, and the end
intersect
times of the operand sequences must be the same (see Syntax16-8).
sequence_expr ::= // from A.2.10
...
| sequence_expr sequence_expr
intersect
Syntax16-8—Intersect operator syntax (excerpt from AnnexA)
The two operands of are sequences. The requirements for match of the operation
intersect intersect
are as follows:
— Both the operands shall match.
— The lengths of the two matches of the operand sequences shall be the same.
404
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The additional requirement on the length of the sequences is the basic difference between and
and
.
intersect
An attempted evaluation of an sequence can result in multiple matches. The results of such an
intersect
attempt can be computed as follows:
— Matches of the first and second operands that are of the same length are paired. Each such pair
results in a match of the composite sequence, with length and match point equal to the shared length
and match point of the paired matches of the operand sequences.
— If no such pair is found, then there is no match of the composite sequence.
Figure16-8 is similar to Figure16-6, except that is replaced by . In this case, unlike in
and intersect
Figure16-6, there is only a single match at clock tick 12.
clk 1 2 3 4 5 6 7 8 9 10 11 12 13 14
te1
te2
te3
te4
te5
te1 ##[1:5] te2
te3 ##2 te4 ##2 te5
(te1 ##[1:5] te2) intersect
(te3 ##2 te4 ##2 te5)
Figure16-8—Intersecting two sequences
16.9.7 OR operation
The operator is used when at least one of the two operand sequences is expected to match (Syntax16-9).
or
sequence_expr ::= // from A.2.10
...
| sequence_expr sequence_expr
or
Syntax16-9—Or operator syntax (excerpt from AnnexA)
The two operands of are sequences.
or
If the operands and are expressions, then
te1 te2
te1 or te2
405
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
matches at any clock tick on which at least one of and evaluates to true.
te1 te2
Figure16-9 illustrates an OR operation for which the operands and are expressions. The composite
te1 te2
sequence does not match at clock ticks 7 and 13 because and are both false at those times. At all
te1 te2
other clock ticks, the composite sequence matches, as at least one of the two operands evaluates to true.
clock 1 2 3 4 5 6 7 8 9 10 11 12 13 14
te1
te2
te1 or te2
Figure16-9—ORing (or) two Boolean expressions
When and are sequences, then the sequence
te1 te2
te1 or te2
matches if at least one of the two operand sequences and matches. Each match of either or
te1 te2 te1 te2
constitutes a match of the composite sequence, and its end time as a match of the composite sequence is the
same as its end time as a match of or of . In other words, the set of matches of or is the
te1 te2 te1 te2
union of the set of matches of with the set of matches of .
te1 te2
The following example shows a sequence with operator where the two operands are sequences.
or
Figure16-10 illustrates this example.
(te1 ##2 te2) or (te3 ##2 te4 ##2 te5)
The two operand sequences in the preceding example are and .
(te1 ##2 te2) (te3 ##2 te4 ##2 te5)
The first sequence requires that first evaluates to true, followed by two clock ticks later. The second
te1 te2
sequence requires that evaluates to true, followed by two clock ticks later, followed by two
te3 te4 te5
clock ticks later. In Figure16-10, the evaluation attempt for clock tick 8 is shown. The first sequence
matches at clock tick 10, and the second sequence matches at clock tick 12. Therefore, two matches for the
composite sequence are recognized.
In the following example, the first operand sequence has a concatenation operator with range from 1 to 5:
(te1 ##[1:5] te2) or (te3 ##2 te4 ##2 te5)
The first operand sequence requires that evaluate to true and that evaluate to true 1, 2, 3, 4, or 5
te1 te2
clock ticks later. The second operand sequence requires that evaluate to true, that evaluate to true
te3 te4
twoclock ticks later, and that evaluate to true another two clock ticks later. The composite sequence
te5
matches at any clock tick on which at least one of the operand sequences matches. As shown in
Figure16-11, for the attempt at clock tick 8, the first operand sequence matches at clock ticks 9, 10, 11, 12,
and 13, while the second operand matches at clock tick 12. The composite sequence, therefore, has one
match at each of clock ticks 9, 10, 11, and 13 and has two matches at clock tick 12.
406
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
clk 1 2 3 4 5 6 7 8 9 10 11 12 13 14
te1
te2
te3
te4
te5
te1 ##2 te2
te3 ##2 te4 ##2 te5
(te1 ##2 te2) or
(te3 ##2 te4 ##2 te5)
Figure16-10—ORing (or) two sequences
clk 1 2 3 4 5 6 7 8 9 10 11 12 13 14
te1
te2
te3
te4
te5
te1 ##[1:5] te2
te3 ##2 te4 ##2 te5
(te1 ##[1:5] te2) or
(te3 ##2 te4 ##2 te5)
Figure16-11—ORing (or) two sequences, including a time range
407
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
16.9.8 First_match operation
The operator matches only the first of possibly multiple matches for an evaluation attempt of
first_match
its operand sequence. This allows all subsequent matches to be discarded from consideration. In particular,
when a sequence is a subsequence of a larger sequence, then applying the operator has
first_match
significant effect on the evaluation of the enclosing sequence (see Syntax16-10).
sequence_expr ::= // from A.2.10
...
| sequence_expr { sequence_match_item}
first_match( , )
Syntax16-10—First_match operator syntax (excerpt from AnnexA)
An evaluation attempt of (seq) results in an evaluation attempt for the operand seq beginning
first_match
at the same clock tick. If the evaluation attempt for seq produces no match, then the evaluation attempt for
(seq) produces no match. Otherwise, the match of seq with the earliest ending clock tick is a
first_match
match of (seq). If there are multiple matches of seq with the same ending clock tick as the
first_match
earliest one, then all those matches are matches of (seq).
first_match
The following example shows a variable delay specification:
sequence t1;
te1 ## [2:5] te2;
endsequence
sequence ts1;
first_match(te1 ## [2:5] te2);
endsequence
Here, and are expressions. Each attempt of sequence can result in matches for up to four of the
te1 te2 t1
following sequences:
te1 ##2 te2
te1 ##3 te2
te1 ##4 te2
te1 ##5 te2
However, sequence can result in a match for only one of the preceding four sequences. Whichever
ts1
match of the preceding four sequences ends first is a match of sequence .
ts1
For example:
sequence t2;
(a ##[2:3] b) or (c ##[1:2] d);
endsequence
sequence ts2;
first_match(t2);
endsequence
Each attempt of sequence can result in matches for up to four of the following sequences:
t2
a ##2 b
a ##3 b
c ##1 d
c ##2 d
408
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Sequence matches only the earliest ending match of these sequences. If , , , and are expressions,
ts2 a b c d
then it is possible to have matches ending at the same time for both.
a ##2 b
c ##2 d
If both of these sequences match and ( ) does not match, then evaluation of results in these two
c##1d ts2
matches.
Sequence match items can be attached to the operand sequence of the operator. The sequence
first_match
match items are placed within the same set of parentheses that enclose the operand. Thus, for example, the
local variable assignment can be attached to the first match of seq via
x = e
first_match(seq, x = e)
which is equivalent to the following:
first_match((seq, x = e))
See 16.10 and 16.11 for discussion of sequence match items.
16.9.9 Conditions over sequences
Sequences often occur under the assumptions of some conditions for correct behavior. A logical condition
must hold true, for instance, while processing a transaction. Also, occurrence of certain values is prohibited
while processing a transaction. Such situations can be expressed directly using the construct shown in
Syntax16-11.
sequence_expr ::= // from A.2.10
...
| expression_or_dist sequence_expr
throughout
Syntax16-11—Throughout construct syntax (excerpt from AnnexA)
The construct is an abbreviation for the following:
expthroughoutseq
(exp) [*0:$] intersect seq
The composite sequence, , matches along a finite interval of consecutive clock ticks
expthroughoutseq
provided matches along the interval and evaluates to true at each clock tick of the interval.
seq exp
The following example is illustrated in Figure16-12.
sequence burst_rule1;
@(posedge mclk)
$fell(burst_mode) ##0
((!burst_mode) throughout (##2 ((trdy==0)&&(irdy==0)) [*7]));
endsequence
409
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
mclk 1 2 3 4 5 6 7 8 9 10 11 12 13 14
burst_mode
irdy
trdy
(trdy==0) && 1 2 3 4 5 6 7
(irdy==0)
burst_rule1
Figure16-12—Match with throughout restriction fails
Figure16-13 illustrates the evaluation attempt for sequence beginning at clock tick 2.
burst_rule1
Because signal is high at clock tick 1 and low at clock tick 2, is true at
burst_mode $fell(burst_mode)
clock tick 2. To complete the match of , the value of is required to be low
burst_rule1 burst_mode
throughout a match of the subsequence ( ) beginning at clock tick 2.
##2((trdy==0)&&(irdy==0))[*7]
This subsequence matches from clock tick 2 to clock tick 10. However, at clock tick 9
burst_mode
becomes high, thereby failing to match according to the rules for .
throughout
If signal were instead to remain low through at least clock tick 10, then there would be a match
burst_mode
of from clock tick 2 to clock tick 10, as shown in Figure16-13.
burst_rule1
mclk 1 2 3 4 5 6 7 8 9 10 11 12 13 14
burst_mode
irdy
trdy
(trdy==0) && 1 2 3 4 5 6 7
(irdy==0)
burst_rule1
Figure16-13—Match with throughout restriction succeeds
16.9.10 Sequence contained within another sequence
The containment of a sequence within another sequence is expressed as follows in Syntax16-12.
410
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
sequence_expr ::= // from A.2.10
...
| sequence_expr sequence_expr
within
Syntax16-12—Within construct syntax (excerpt from AnnexA)
The construct is an abbreviation for the following:
seq1withinseq2
(1[*0:$] ##1 seq1 ##1 1[*0:$]) intersect seq2
The composite sequence matches along a finite interval of consecutive clock ticks
seq1 within seq2
provided matches along the interval and matches along some subinterval of consecutive clock
seq2 seq1
ticks. In other words, the matches of and must satisfy the following:
seq1 seq2
— The start point of the match of shall be no earlier than the start point of the match of .
seq1 seq2
— The match point of shall be no later than the match point of .
seq1 seq2
For example, the sequence
!trdy[*7] within ($fell(irdy) ##1 !irdy[*8])
matches from clock tick 3 to clock tick 11 on the trace shown in Figure16-13.
16.9.11 Composing sequences from simpler subsequences
There are two ways in which a complex sequence can be composed using simpler subsequences.
One is to instantiate a named sequence by referencing its name. Evaluation of such a reference requires the
named sequence to match starting from the clock tick at which the reference is reached during the evaluation
of the enclosing sequence. For example:
sequence s;
a ##1 b ##1 c;
endsequence
sequence rule;
@(posedge sysclk)
trans ##1 start_trans ##1 s ##1 end_trans;
endsequence
Sequence is evaluated beginning one tick after the evaluation of in the sequence .
s start_trans rule
Another way to use a sequence is to detect its end point in another sequence. The reaching of the end point
(see 16.7) can be tested by using the method .
triggered
To detect the end point, the method may be applied to a named sequence instance, with or
triggered
without arguments, an untyped formal argument, or a formal argument of type , where such is
sequence
allowed, as follows:
sequence_instance.triggered
or
formal_argument_sequence.triggered
411
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
is a method on a sequence. The result of its operation is true ( ) or false ( ) . When
triggered 1'b1 1'b0
method is evaluated in an expression, it tests whether its operand sequence has reached its end
triggered
point at that particular point in time. The result of does not depend upon the starting point of the
triggered
match of its operand sequence. An example is shown as follows:
sequence e1;
@(posedge sysclk) $rose(ready) ##1 proc1 ##1 proc2 ;
endsequence
sequence rule;
@(posedge sysclk) reset ##1 inst ##1 e1.triggered ##1 branch_back;
endsequence
In this example, sequence must match one clock tick after . If the method is replaced
e1 inst triggered
with an instance of sequence , a match of must start one clock tick after . Notice that method
e1 e1 inst
only tests for the end point of and has no bearing on the starting point of .
triggered e1 e1
The following example demonstrates an application of the method on a named sequence
triggered
instance with arguments:
sequence e2(a,b,c);
@(posedge sysclk) $rose(a) ##1 b ##1 c;
endsequence
sequence rule2;
@(posedge sysclk) reset ##1 inst ##1 e2(ready,proc1,proc2).triggered
##1 branch_back;
endsequence
is equivalent to as follows:
rule2 rule2a
sequence e2_instantiated;
e2(ready,proc1,proc2);
endsequence
sequence rule2a;
@(posedge sysclk) reset ##1 inst ##1 e2_instantiated.triggered ##1
branch_back;
endsequence
The following example demonstrates an application of method on a formal argument of type
triggered
:
sequence
sequence e3(sequence a, untyped b);
@(posedge sysclk) a.triggered ##1 b;
endsequence
sequence rule3;
@(posedge sysclk) reset ##1 e3(ready ##1 proc1, proc2) ##1 branch_back;
endsequence
There are additional restrictions on passing local variables into an instance of a sequence to which
is applied (see 16.10).
triggered
The method can be used in the presence of multiple clocks. However, the ending clock of the
triggered
sequence instance to which is applied shall always be the same as the clock in the context where
triggered
the application of method appears (see 16.13.5).
triggered
412
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If a sequence admits an empty match, such empty matches shall not activate the method. For
.triggered
example, consider the following sequence, which admits both empty and nonempty matches:
sequence zero_or_one_req;
(req==1'b1)[*0:1];
endsequence
The method will only return true ( ) when the sampled value of
zero_or_one_req.triggered() 1'b1
is , resulting in a nonempty match.
req 1'b1
16.10 Local variables
Data can be manipulated within named sequences (see 16.8) and properties (see 16.12) using dynamically
created local variables. The use of a static SystemVerilog variable implies that only one copy exists. If data
values need to be checked in pipelined designs, then for each quantum of data entering the pipeline, a
separate variable can be used to store the predicted output of the pipeline for later comparison when the
result actually exits the pipe. This storage can be built by using an array of variables arranged in a shift
register to mimic the data propagating through the pipeline. However, in more complex situations where the
latency of the pipe is variable and out of order, this construction could become very complex and error
prone. Therefore, variables are needed that are local to and are used within a particular transaction check that
can span an arbitrary interval of time and can overlap with other transaction checks. Such a variable will
thus be dynamically created when needed within an instance of a sequence and removed when the end of the
sequence is reached.
The dynamic creation of a local variable and its assignment is achieved by either using a local variable
formal argument declaration (see 16.8.2, 16.12.18) or using an assertion variable declaration within the
declaration of a named sequence or property (see 16.12). Without further specification, the term local
variable shall mean either a local variable formal argument or a local variable declared in an
assertion_variable_declaration. Without further specification, the term local variable initialization
assignment shall mean either an initialization assignment to a local variable formal argument of direction
or of the value of the corresponding actual argument or a declaration assignment to a local
input inout
variable declared in an assertion_variable_declaration (see Syntax16-13).
assertion_variable_declaration ::= // from A.2.10
var_data_type list_of_variable_decl_assignments
;
Syntax16-13—Assertion variable declaration syntax (excerpt from AnnexA)
The data type of an assertion variable declaration shall be specified explicitly. The data type shall be one of
the types allowed within assertions as defined in 16.6. The data type shall be followed by a comma-
separated list of one or more identifiers with optional declaration assignments. A declaration assignment, if
present, defines the initial value to be placed in the corresponding local variable. The initial value is defined
by an expression, which need not be constant.
The sampled value of a local variable is defined as the current value (see 16.5.1).
At the beginning of each evaluation attempt of an instance of a named sequence or property, a new copy of
each of its local variables shall be created and, if present, the corresponding initialization assignment shall
be performed. Initialization assignments shall be performed in the Observed region in the order that they
appear in the sequence or property declaration. For the purposes of this rule, all initialization assignments to
local variable formal arguments shall be performed before any initialization assignment to a local variable
declared in an assertion_variable_declaration. An initialization assignment to a local variable uses the
413
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
sampled value of its expression in the time slot in which the evaluation attempt begins. The expression of an
initialization assignment to a given local variable may refer to a previously declared local variable. In this
case the previously declared local variable shall itself have an initialization assignment, and the initial value
assigned to the previously declared local variable shall be used in the evaluation of the expression assigned
to the given local variable. Local variables do not have default initial values. A local variable without an
initialization assignment shall be unassigned at the beginning of the evaluation attempt.
For example, at the beginning of an evaluation attempt of an instance of
sequence s;
logic u, v = a, w = v || b;
...
endsequence
the assignment of to is performed first, and the assignment of to is performed second. The
a v v || b w
value assigned to is the same as would result from the declaration assignment . The local
w w = a || b
variable is unassigned at the beginning of the evaluation attempt.
u
Local variables may be assigned and reassigned within the body of the sequence or property in which they
are declared.
sequence_expr ::= // from A.2.10
...
| sequence_expr { sequence_match_item} [ sequence_abbrev ]
( , )
...
sequence_match_item ::=
operator_assignment
| inc_or_dec_expression
...
Syntax16-14—Variable assignment syntax (excerpt from AnnexA)
One or more local variables may be assigned at the end point of a syntactic subsequence by placing the
subsequence, comma-separated from the list of local variable assignments, in parentheses. At the end of any
nonempty match of the subsequence, the local variable assignments are performed in the order that they
appear in the list. For example, if in
a ##1 b[->1] ##1 c[*2]
it is desired to assign and then at the match of , the sequence can be rewritten as
x = e y = x && f b[->1]
a ##1 (b[->1], x = e, y = x && f) ##1 c[*2]
A local variable may be reassigned later in the sequence or property, as in
a ##1 (b[->1], x = e, y = x && f) ##1 (c[*2], x &= g)
The subsequence to which a local variable assignment is attached shall not admit an empty match (see
16.12.22). For example, the sequence
a ##1 (b[*0:1], x = e) ##1 c[*2] // illegal
is illegal because the subsequence can match the empty word. The sequence
b[*0:1]
414
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
(a ##1 b[*0:1], x = e) ##1 c[*2] // legal
is legal because the concatenated subsequence cannot match the empty word.
a ##1 b[*0:1]
A local variable may be referenced within the sequence or property in which it is declared. The sequence or
property shall assign a value to the local variable prior to the point at which the reference is made. The prior
assignment may be an initialization assignment or an assignment attached to a subsequence. There is an
implicit reference associated with the use of an inc_or_dec_operator or an assignment operator other than
“ ”. Therefore, a local variable shall be assigned a value prior to being updated with an
=
inc_or_dec_operator or with an assignment operator other than “ ”.
=
Under certain circumstances, a local variable that is assigned later becomes unassigned. If a local variable
does not flow out of a subsequence (see the following), then the local variable shall become unassigned at
the end of that subsequence, regardless of whether it was assigned a value prior to that point. The local
variable shall not be referenced after the point from which it does not flow until after it has again been
assigned a value. See F.5.4 for precise conditions defining local variable flow.
Hierarchical references to a local variable are not allowed.
As an example of local variable usage, assume a pipeline that has a fixed latency of five clock cycles. The
data enter the pipe on when is true, and the value computed by the pipeline appears five
pipe_in valid_in
clock cycles later on the signal . The data as transformed by the pipe are predicted by a function
pipe_out1
that increments the data. The following property verifies this behavior:
property e;
int x;
(valid_in, x = pipe_in) |-> ##5 (pipe_out1 == (x+1));
endproperty
Property is evaluated as follows:
e
— When is true, is assigned the value of . If five cycles later, is
valid_in x pipe_in pipe_out1
equal to , then property is true. Otherwise, property is false.
x+1 e e
— When is false, property evaluates to true.
valid_in e
A local variable can be used to form expressions in the same way that a static variable of the same type can
be used. This includes the use of local variables in expressions for bit-selects and part-selects of vectors or
for indices of arrays. A local variable shall not be used in a clocking event expression.
Local variables may be used in sequences or properties.
sequence data_check;
int x;
a ##1 (!a, x = data_in) ##1 !b[*0:$] ##1 b && (data_out == x);
endsequence
property data_check_p
int x;
a ##1 (!a, x = data_in) |=> !b[*0:$] ##1 b && (data_out == x);
endproperty
Local variable assignments may be attached to the operand sequence of a repetition and accomplish
accumulation of values.
sequence rep_v;
int x = 0;
415
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
(a[->1], x += data)[*4] ##1 b ##1 c && (data_out == x);
endsequence
An accumulating local variable may be used to count the number of times a condition is repeated, as in the
following example:
sequence count_a_cycles;
int x;
($rose(a), x = 1)
##1 (a, x++)[*0:$]
##1 !a && (x <= MAX);
endsequence
The local variables declared within a sequence or property are not visible in the context where the sequence
or property is instantiated. The following example illustrates an illegal access to local variable of
v1
sequence in sequence .
sub_seq1 seq1
sequence sub_seq1;
int v1;
(a ##1 !a, v1 = data_in) ##1 !b[*0:$] ##1 b && (data_out == v1);
endsequence
sequence seq1;
c ##1 sub_seq1 ##1 (do1 == v1); // error because v1 is not visible
endsequence
It can be useful to assign a value to a local variable within an instance of a named sequence and reference the
local variable in the instantiating context at or after the completion of a match of the instance. The rules for
assigning values to a local variable within an instance of a named sequence are described in 16.8.2. This
capability is also supported under the following conditions:
— The local variable shall be declared outside the named sequence, and its scope shall include both the
instance of the named sequence and the desired reference in the instantiating context.
— The local variable shall be passed as an entire actual argument in the list of arguments of the
instance of the named sequence.
— The corresponding formal argument shall be untyped.
The named sequence may specify assignments to the formal argument in one or more
sequence_match_items.
The following example illustrates this usage:
sequence sub_seq2(lv);
(a ##1 !a, lv = data_in) ##1 !b[*0:$] ##1 b && (data_out == lv);
endsequence
sequence seq2;
int v1;
c ##1 sub_seq2(v1) // v1 is bound to lv
##1 (do1 == v1); // v1 holds the value that was assigned to lv
endsequence
An alternative way to achieve a similar capability is by using local variable formal arguments (see 16.8.2).
Local variables can be passed into an instance of a named sequence to which is applied and
triggered
accessed in a similar manner. For example:
416
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
sequence seq2a;
int v1; c ##1 sub_seq2(v1).triggered ##1 (do1 == v1);
// v1 is now bound to lv
endsequence
There are additional restrictions when passing local variables into an instance of a named sequence to which
is applied:
triggered
— Local variables can be passed in only as entire actual arguments, not as proper subexpressions of
actual arguments.
— In the declaration of the named sequence, the formal argument to which the local variable is bound
shall not be referenced before it is assigned.
The second restriction is met by because the assignment occurs before the
sub_seq2 lv = data_in
reference to in .
lv data_out == lv
If a local variable is assigned before being passed into an instance of a named sequence to which
is applied, then the restrictions prevent this assigned value from being visible within the named
triggered
sequence. The restrictions are important because the use of means that there is no guaranteed
triggered
relationship between the point in time at which the local variable is assigned outside the named sequence
and the beginning of the match of the instance.
A local variable that is passed in as actual argument to an instance of a named sequence to which
is applied will flow out of the application of to that instance provided both of the
triggered triggered
following conditions are met:
— The local variable flows out of the end of the named sequence instance, as defined by the local
variable flow rules for sequences. (See the following and F.5.4.)
— The application of to this instance is a maximal Boolean expression. In other words, the
triggered
application of cannot have negation or any other expression operator applied to it.
triggered
Both conditions are satisfied by and . Thus, in , the value in in the comparison
sub_seq2 seq2a seq2a v1
is the value assigned to in by the assignment . However, in
do1 == v1 lv sub_seq2 lv = data_in
sequence seq2b;
int v1; c ##1 !sub_seq2(v1).triggered ##1 (do1 == v1); // v1 unassigned
endsequence
the second condition is violated because of the negation applied to . Therefore,
sub_seq2(v1).triggered
does not flow out of the application of to this instance, and the reference to in
v1 triggered v1 do1 ==
is to an unassigned variable.
v1
In a single cycle, there can be multiple matches of a sequence instance to which is applied, and
triggered
these matches can have different valuations of the local variables. The multiple matches are treated
semantically the same way as matching both disjuncts of an (see the following). In other words, the
or
thread evaluating the instance to which is applied will fork to account for such distinct local
triggered
variable valuations.
When a local variable is a formal argument of a sequence declaration, it is illegal to declare the variable, as
shown in the following example:
sequence sub_seq3(lv);
int lv; // illegal because lv is a formal argument
(a ##1 !a, lv = data_in) ##1 !b[*0:$] ##1 b && (data_out == lv);
endsequence
417
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
There are special considerations when using local variables in sequences involving the branching operators
, , and . The evaluation of a composite sequence constructed from one of these operators
or and intersect
can be thought of as forking two threads to evaluate the operand sequences in parallel. A local variable may
have been assigned a value before the start of the evaluation of the composite sequence, either from an
initialization assignment or from an assignment attached to a preceding subsequence. Such a local variable
is said to flow in to each of the operand sequences. The local variable may be assigned or reassigned in one
or both of the operand sequences. In general, there is no guarantee that evaluation of the two threads results
in consistent values for the local variable, or even that there is a consistent view of whether the local variable
has been assigned a value. Therefore, the values assigned to the local variable before and during the
evaluation of the composite sequence are not always allowed to be visible after the evaluation of the
composite sequence.
In some cases, inconsistency in the view of the local variable’s value does not matter, while in others it does.
Precise conditions are given in F.5.4 to define static (i.e., compile-time computable) conditions under which
a sufficiently consistent view of the local variable’s value after the evaluation of the composite sequence is
provided. If these conditions are satisfied, then the local variable is said to flow out of the composite
sequence. Otherwise, the local variable shall become unassigned at the end of the composite sequence. An
intuitive description of the conditions for local variable flow follows:
a) Variables assigned on parallel threads cannot be accessed in sibling threads. For example:
sequence s4;
int x;
(a ##1 (b, x = data) ##1 c) or (d ##1 (e==x)); // illegal
endsequence
b) In the case of , a local variable flows out of the composite sequence if, and only if, it flows out of
or
each of the operand sequences. If the local variable is not assigned before the start of the composite
sequence and it is assigned in only one of the operand sequences, then it does not flow out of the
composite sequence.
c) Each thread for an operand of an that matches its operand sequence continues as a separate
or
thread, carrying with it its own latest assignments to the local variables that flow out of the
composite sequence. These threads do not have to have consistent valuations for the local variables.
For example:
sequence s5;
int x,y;
((a ##1 (b, x = data, y = data1) ##1 c)
or (d ##1 (`true, x = data) ##0 (e==x))) ##1 (y==data2);
// illegal because y is not in the intersection
endsequence
sequence s6;
int x,y;
((a ##1 (b, x = data, y = data1) ##1 c)
or (d ##1 (`true, x = data) ##0 (e==x))) ##1 (x==data2);
// legal because x is in the intersection
endsequence
d) In the case of and , a local variable that flows out of at least one operand shall flow
and intersect
out of the composite sequence unless it is blocked. A local variable is blocked from flowing out of
the composite sequence if either of the following statements applies:
1) The local variable is assigned in and flows out of each operand of the composite sequence, or
2) The local variable is blocked from flowing out of at least one of the operand sequences.
The value of a local variable that flows out of the composite sequence is the latest assigned value.
The threads for the two operands are merged into one at completion of evaluation of the composite
sequence.
418
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
sequence s7;
int x,y;
((a ##1 (b, x = data, y = data1) ##1 c)
and (d ##1 (`true, x = data) ##0 (e==x))) ##1 (x==data2);
// illegal because x is common to both threads
endsequence
sequence s8;
int x,y;
((a ##1 (b, x = data, y = data1) ##1 c)
and (d ##1 (`true, x = data) ##0 (e==x))) ##1 (y==data2);
// legal because y is in the difference
endsequence
16.11 Calling subroutines on match of a sequence
Tasks, task methods, void functions, void function methods, and system tasks can be called at the end of a
successful nonempty match of a sequence. The subroutine calls, like local variable assignments, appear in
the comma-separated list that follows the sequence. The subroutine calls are said to be attached to the
sequence. It shall be an error to attach a subroutine call or any sequence_match_item to a sequence that
admits an empty match (see 16.12.22). The sequence and the list that follows are enclosed in parentheses
(see Syntax16-15).
sequence_expr ::= // from A.2.10
...
| sequence_expr { sequence_match_item} [ sequence_abbrev ]
( , )
...
sequence_match_item ::=
operator_assignment
| inc_or_dec_expression
| subroutine_call
Syntax16-15—Subroutine call in sequence syntax (excerpt from AnnexA)
For example:
sequence s1;
logic v, w;
(a, v = e) ##1
(b[->1], w = f, $display("b after a with v = %h, w = %h\n", v, w));
endsequence
defines a sequence that matches at the first occurrence of strictly after an occurrence of . At the match,
s1 b a
the system task is executed to write a message that announces the match and shows the values
$display
assigned to the local variables and .
v w
All subroutine calls attached to a sequence are executed at every end point of the sequence. For each end
point, the attached calls are executed in the order they appear in the list. Assertion evaluation does not wait
on or receive data back from any attached subroutine. The subroutines are scheduled in the Reactive region,
like an action block.
Each argument of a subroutine call attached to a sequence shall either be passed by value as an input or be
passed by reference (either or ; see 13.5.2). Actual argument expressions that are passed by
ref constref
value use sampled values of the underlying variables and are consistent with the variable values used to
419
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
evaluate the sequence match. The variable passed by value as an input shall be of a type allowed in 16.6. An
automatic variable may be passed as a constant input for a subroutine call from an assertion statement in
procedural code (see 16.14.6.1). An automatic variable shall not be passed by reference nor passed as a non-
constant input to a subroutine call from an assertion statement in procedural code. The rules for passing
elements of dynamic arrays, queues, and associative arrays as ref arguments are described in 13.5.2.
Local variables can be passed into subroutine calls attached to a sequence. Any local variable that flows out
of the sequence or that is assigned in the list following the sequence, but before the subroutine call, can be
used in an actual argument expression for the call. If a local variable appears in an actual argument
expression, then that argument shall be passed by value.
16.12 Declaring properties
A property defines a behavior of the design. A named property may be used for verification as an
assumption, an obligation, or a coverage specification. In order to use the behavior for verification, an
, , or statement must be used. A property declaration by itself does not produce any
assert assume cover
result.
A named may be declared in any of the following:
property
— A module
— An interface
— A program
— A block
clocking
— A package
— A compilation-unit scope
— A generate block
— A checker
To declare a named property, the construct is used as shown in Syntax16-16.
property
assertion_item_declaration ::= // from A.2.10
property_declaration
...
property_declaration ::=
property_identifier [ [ property_port_list ] ]
property ( ) ;
{ assertion_variable_declaration }
property_spec [ ]
;
[ property_identifier ]
endproperty :
property_port_list ::=
property_port_item { property_port_item}
,
property_port_item ::=
{ attribute_instance } [ [ property_lvar_port_direction ] ] property_formal_type
local
formal_port_identifier {variable_dimension} [ property_actual_arg ]
=
property_lvar_port_direction ::=
input
property_formal_type ::=
sequence_formal_type
|
property
property_spec ::=
[clocking_event ] [ expression_or_dist ] property_expr
disable iff( )
420
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
property_expr ::=
sequence_expr
| sequence_expr
strong( )
| sequence_expr
weak( )
| property_expr
( )
| property_expr
not
| property_expr property_expr
or
| property_expr property_expr
and
| sequence_expr property_expr
|->
| sequence_expr property_expr
|=>
| ( expression_or_dist ) property_expr [ property_expr ]
if else
| ( expression_or_dist ) property_case_item { property_case_item }
case endcase
| sequence_expr property_expr
#-#
| sequence_expr property_expr
#=#
| property_expr
nexttime
| constant _expression property_expr
nexttime[ ]
| property_expr
s_nexttime
| constant_expression property_expr
s_nexttime[ ]
| property_expr
always
| cycle_delay_const_range_expression property_expr
always[ ]
| constant_range property_expr
s_always[ ]
| property_expr
s_eventually
| constant_range property_expr
eventually[ ]
| cycle_delay_const_range_expression property_expr
s_eventually[ ]
| property_expr property_expr
until
| property_expr property_expr
s_until
| property_expr property_expr
until_with
| property_expr property_expr
s_until_with
| property_expr property_expr
implies
| property_expr property_expr
iff
| expression_or_dist property_expr
accept_on( )
| expression_or_dist property_expr
reject_on( )
| expression_or_dist property_expr
sync_accept_on( )
| expression_or_dist property_expr
sync_reject_on( )
| property_instance
| clocking_event property_expr
property_case_item ::=
expression_or_dist { expression_or_dist } property_expr
, : ;
| [ ] property_expr
default : ;
assertion_variable_declaration ::=
var_data_type list_of_variable_decl_assignments
;
property_instance ::=
ps_or_hierarchical_property_identifier [ [ property_list_of_arguments ] ]
( )
property_list_of_arguments ::=
[property_actual_arg] { [property_actual_arg] } { identifier [property_actual_arg] }
, , . ( )
| identifier [property_actual_arg] { identifier [property_actual_arg] }
. ( ) , . ( )
property_actual_arg ::=
property_expr
| sequence_actual_arg
Syntax16-16—Property construct syntax (excerpt from AnnexA)
421
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A named property may be declared with formal arguments in the optional property_port_list.
Except as described in 16.12.18, 16.12.19, and 16.12.17, the rules for declaring formal arguments and
default actual arguments in named properties and for instantiating named properties with actual arguments
are the same as those for named sequences as described in 16.8, 16.8.1, and 16.8.2.
Rules particular to the specification and use of typed formal arguments in named properties are discussed in
16.12.18.
Rules particular to the specification and use of local variable formal arguments in named properties are
discussed in 16.12.19.
A formal argument may be referenced in the body property_spec of the declaration of the named property. A
reference to a formal argument may be written in place of various syntactic entities, including, in addition to
those listed in 16.8, the following:
— property_expr
— property_spec
A named property may be instantiated prior to its declaration. A named property may be instantiated
anywhere a property_spec may be written. A named property may be instantiated in a place where a
property_expr may be written provided the instance does not produce an illegal clause (see
disable iff
the following). There may be cyclic dependencies among named properties resulting from their
instantiations. A cyclic dependency among named properties results if, and only if, there is a cycle in the
directed graph whose nodes are the named properties and whose edges are defined by the following rule:
there is a directed edge from one named property to a second named property if, and only if, either the first
named property instantiates the second named property within its declaration, including an instance within
the declaration of a default actual argument, or there is an instance of the first named property that
instantiates the second named property within an actual argument. Named properties with such cyclic
dependencies are called recursive and are discussed in 16.12.17.
If $ is an actual argument to an instance of a named property, then the corresponding formal argument shall
be untyped and each of its references either shall be an upper bound in a
cycle_delay_const_range_expression or shall itself be an actual argument in an instance of a named
sequence or property.
The behavior and semantics of an instance of a nonrecursive named property are the same as those of the
flattened property that is obtained from the body of the declaration of the named property by the rewriting
algorithm defined in F.4.1. The rewriting algorithm substitutes actual arguments for references to the
corresponding formal arguments in the body of the declaration of the named property. The rewriting
algorithm does not itself account for name resolution and assumes that names have been resolved prior to the
substitution of actual arguments. If the flattened property is not legal, then the instance is not legal and there
shall be an error.
The result of property evaluation is either true or false. Properties may be built from other properties or
sequences using instantiation and the operators described in the following subclauses.
Table16-3 lists the sequence and property operators from highest to lowest precedence and shows the
associativity of the non-unary operators. The precedence for the strong and weak sequence operators is not
defined because these operators require parentheses. The operators described in Table11-2 have higher
precedence than the sequence and property operators.
422
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table16-3—Sequence and property operator precedence and associativity
Sequence operators Property operators Associativity
—
[*], [=], [->]
Left
##
Right
throughout
Left
within
Left
intersect
, , —
not nexttime s_nexttime
Left
and and
Left
or or
Right
iff
, , , , Right
until s_until until_with s_until_with implies
, , , Right
|-> |=> #-# #=#
, , , , —
always s_always eventually s_eventually
, , , ,
if-else case accept_on reject_on
,
sync_accept_on sync_reject_on
A clause can be attached to a property_expr to yield a property_spec.
disable iff
disable iff (expression_or_dist) property_expr
The expression of the is called the disable condition. The clause allows
disableiff disableiff
preemptive resets to be specified. For an evaluation of the property_spec, there is an evaluation of the
underlying property_expr. If the disable condition is true at anytime between the start of the attempt in the
Observed region, inclusive, and the end of the evaluation attempt, inclusive, then the overall evaluation of
the property results in disabled. A property has disabled evaluation if it was preempted due to a
condition. A disabled evaluation of a property does not result in success or failure.
disable iff
Otherwise, the evaluation of the property_spec is the same as that of the property_expr. The disable
condition is tested independently for different evaluation attempts of the property_spec. The values of
variables used in the disable condition are those in the current simulation cycle, i.e., not sampled. The
expression may contain a reference to an end point of a sequence by using the method of that
triggered
sequence. The disable conditions shall not contain any reference to local variables or the sequence method
. If a sampled value function other than is used in the disable condition, the sampling
matched $sampled
clock shall be explicitly specified in its actual argument list as described in 16.9.3. Nesting of
disableiff
clauses, explicitly or through property instantiations, is not allowed.
16.12.1 Property instantiation
An instance of a named property can be used as a property_expr or property_spec. In general, the instance is
legal provided the body property_spec of the named property can be substituted in place of the instance,
with actual arguments substituted for formal arguments, and result in a legal property_expr or
property_spec. For example, if an instance of a named property is used as a property_expr operand for any
property-building operator, then the named property must not have a clause.
disableiff
423
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
16.12.2 Sequence property
Sequence properties have three forms: sequence_expr, sequence_expr , and
weak( )
sequence_expr . The and operators are called sequence operators.
strong( ) strong weak
sequence_expr evaluates to true if, and only if, there is a nonempty match of the sequence_expr.
strong( )
sequence_expr evaluates to true if, and only if, there is no finite prefix that witnesses inability to
weak( )
match the sequence_expr. The sequence_expr of a sequential property shall not admit an empty match (see
16.12.22).
If the or operator is omitted, then the evaluation of the sequence_expr depends on the
strong weak
assertion statement in which it is used. If the assertion statement is or
assert property
, then the sequence_expr is evaluated as sequence_expr . Otherwise, the
assume property weak( )
sequence_expr is evaluated as sequence_expr .
strong( )
NOTE—The semantics for a sequence_expr definition in IEEE Std 1800-2009 and on is not backward compatible with
IEEE Std 1800-2005. The current equivalent to a sequence_expr as defined in IEEE Std 1800-2005 is
sequence_expr .
strong( )
Since only one match of a sequence_expr is needed for sequence_expr to hold, a property of the
strong( )
form sequence_expr evaluates to true if, and only if, the property
strong( )
sequence_expr evaluates to true.
strong(first_match( ))
Similarly, a property of the form sequence_expr evaluates to true if, and only if, the property
weak( )
sequence_expr evaluates to true. This is because a prefix witnesses inability to
weak(first_match( ))
match sequence_expr if, and only if, it witnesses inability to match sequence_expr .
first_match( )
The following examples illustrate the sequential property forms:
property p3;
b ##1 c;
endproperty
c1: cover property (@(posedge clk) a #-# p3);
a1: assert property (@(posedge clk) a |-> p3);
The sequential property is interpreted as strong in the cover property . An evaluation attempt of
p3 c1 c1
returns true if, and only if, is true at the tick of at which the attempt begins and both of the
a posedgeclk
following conditions are satisfied:
— is true at the tick of at which the attempt begins.
b posedgeclk
— There exists a subsequent tick of and is true at the first such tick.
posedgeclk c
The sequential property is interpreted as weak in the . An evaluation attempt of
p3 assertpropertya1 a1
returns true if, and only if, either is false at the tick of at which the attempt begins or both of
a posedgeclk
the following conditions are satisfied:
— is true at the tick of at which the attempt begins.
b posedgeclk
— If there exists a subsequent tick of , then is true at the first such tick.
posedgeclk c
16.12.3 Negation property
A property is a negation if it has the form property_expr. For each evaluation attempt of the property,
not
there is an evaluation attempt of property_expr. The keyword states that the evaluation of the property
not
returns the opposite of the evaluation of the underlying property_expr. Thus, if property_expr evaluates to
true, then property_expr evaluates to false; and if property_expr evaluates to false, then
not not
property_expr evaluates to true.
424
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The operator switches the strength of a property. In particular, one should be careful when negating a
not
sequence. For example, consider the following assertion:
a1: assert property (@clk not a ##1 b);
Since the sequential property is used in an assertion, it is weak. This means that if stops
a ##1 b clk
ticking and a holds at the last tick of , the weak sequential property will also hold beginning at
clk a ##1 b
that tick, and so the assertion will fail. In this case it is more reasonable to use:
a1
a2: assert property (@clk not strong(a ##1 b));
16.12.4 Disjunction property
A property is a disjunction if it has the following form:
property_expr property_expr
or
The property evaluates to true if, and only if, at least one of property_expr1 and property_expr2 evaluates to
true.
16.12.5 Conjunction property
A property is a conjunction if it has the following form:
property_expr property_expr
and
The property evaluates to true if, and only if, both property_expr1 and property_expr2 evaluate to true.
16.12.6 If-else property
A property is an if–else if it has either the following form:
expression_or_dist property_expr
if ( )
or the following form:
expression_or_dist property_expr property_expr
if ( ) else
A property of the first form evaluates to true if, and only if, either expression_or_dist evaluates to false or
property_expr evaluates to true. A property of the second form evaluates to true if, and only if, either
expression_or_dist evaluates to true and property_expr1 evaluates to true or expression_or_dist evaluates to
false and property_expr2 evaluates to true.
16.12.7 Implication
The implication construct specifies that the checking of a property is performed conditionally on the match
of a sequential antecedent (see Syntax16-17).
property_expr ::= // from A.2.10
...
| sequence_expr property_expr
|->
| sequence_expr property_expr
|=>
Syntax16-17—Implication syntax (excerpt from AnnexA)
425
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
This construct is used to precondition monitoring of a property expression and is allowed at the property
level. The result of the implication is either true or false. The left-hand operand sequence_expr is called the
antecedent, while the right-hand operand property_expr is called the consequent.
The following points should be noted for implication:
|->
— From a given start point, the antecedent sequence_expr can have zero, one, or more than one
successful match.
— If there is no match of the antecedent sequence_expr from a given start point, then evaluation of the
implication from that start point succeeds and returns true.
— For each successful match of the antecedent sequence_expr, the consequent property_expr is
separately evaluated. The end point of the match of the antecedent sequence_expr is the start point
of the evaluation of the consequent property_expr.
— From a given start point, evaluation of the implication succeeds and returns true if, and only if, for
every match of the antecedent sequence_expr beginning at the start point, the evaluation of the
consequent property_expr beginning at the end point of the match succeeds and returns true.
Two forms of implication are provided: overlapped using operator and nonoverlapped using operator
|->
. For overlapped implication, if there is a match for the antecedent sequence_expr, then the end point of
|=>
the match is the start point of the evaluation of the consequent property_expr. For nonoverlapped
implication, the evaluation of the consequent is described by two cases, depending on whether the
implication is triggered by a nonempty match or by an empty match:
— If triggered by a nonempty match, the start point of the evaluation of the consequent property_expr
is the clock tick after the end point of the match.
— If triggered by an empty match, the start point of the evaluation of the consequent property_expr is
its nearest clock tick, starting from the tick when evaluation of the sequence_expr begins. For a
singly clocked property, this coincides with the current clock tick.
Therefore,
sequence_expr |=> property_expr
is equivalent to the following:
sequence_expr ##1 `true |-> property_expr
The use of implication when multiclock sequences and properties are involved is explained in 16.13.
The following example illustrates a bus operation for data transfer from a master to a target device. When
the bus enters a data transfer phase, multiple data phases can occur to transfer a block of data. During the
data transfer phase, a data phase completes on any rising clock edge on which is asserted and either
irdy
or is asserted. In this example, an asserted signal implies a value of low. The requirement for the
trdy stop
end of a data phase can be expressed as follows:
let ready_exp = (irdy == 0) && ($fell(trdy) || $fell(stop));
property data_end;
@(posedge mclk)
$rose(data_phase) |-> ##[1:5] ready_exp;
endproperty
a1: assert property(data_end);
Each time the sequence matches, an evaluation of the consequent property begins. In
$rose(data_phase)
Figure16-14, a match for occurs at clock tick 2. This begins the evaluation of the
$rose(data_phase)
426
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
consequent property. Then, at clock tick 6, the assertion attempt evaluates to true because
$fell(stop)
and both evaluate to true.
irdy==0
In another example, is used to verify that is deasserted (value high) within two clock
data_end_exp frame
ticks after occurs. Further, it is also required that is deasserted (value high) one clock
data_end_exp irdy
tick after is deasserted.
frame
mclk 1 2 3 4 5 6 7 8 9 10 11 12 13 14
data_phase
irdy
trdy
stop
data_end
Figure16-14—Conditional sequence matching
A property written to express this condition is as follows:
let data_end_exp = data_phase && ready_exp;
property data_end_rule1;
@(posedge mclk)
data_end_exp |-> ##[1:2] $rose(frame) ##1 $rose(irdy);
endproperty
a2: assert property(data_end_rule1);
Property first evaluates at every clock tick to test if its value is true. If
data_end_rule1 data_end_exp
the value is false, then that particular attempt to evaluate is considered true. Otherwise,
data_end_rule1
the following sequence is evaluated:
##[1:2] $rose(frame) ##1 $rose(irdy)
that specifies looking for the rising edge of within two clock ticks in the future. After toggles
frame frame
high, must also toggle high after one clock tick. This is illustrated in Figure16-15 for the evaluation
irdy
attempt at clock tick 6. is acknowledged at clock tick 6. Next, toggles high at clock
data_end_exp frame
tick 7. Because this falls within the timing constraint imposed by , it satisfies the sequence and
[1:2]
continues to evaluate further. At clock tick 8, is evaluated. Signal transitions to high at clock tick
irdy irdy
8, matching the sequence specification completely for the attempt that began at clock tick 6.
Generally, assertions are associated with preconditions so that the checking is performed only under certain
specified conditions. As seen from the previous example, the operator provides this capability to specify
|->
preconditions with sequences that must be satisfied before evaluating their consequent properties. The next
example modifies the preceding example to see the effect on the results of the assertion by removing the
precondition for the consequent. This is shown below and illustrated in Figure16-16.
427
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
property data_end_rule2;
@(posedge mclk) ##[1:2] $rose(frame) ##1 $rose(irdy);
endproperty
a3: assert property(data_end_rule2);
mclk 1 2 3 4 5 6 7 8 9 10 11 12 13 14
data_phase
irdy
trdy (high)
stop
frame
data_end_exp
data_end_rule1
Figure16-15—Conditional sequences
mclk 1 2 3 4 5 6 7 8 9 10 11 12 13 14
data_phase
irdy
trdy (high)
stop
frame
[1:2]
data_end_rule2
Figure16-16—Results without the condition
The property is evaluated at every clock tick. For the evaluation at clock tick 1, the rising edge of signal
does not occur at clock tick 2 or 3; therefore, the property fails at clock tick 1. Similarly, there is a
frame
failure at clock ticks 2, 3, and 4. For attempts starting at clock ticks 5 and 6, the rising edge of signal
frame
at clock tick 7 allows checking further. At clock tick 8, the sequences complete according to the
specification, resulting in a match for attempts starting at clock ticks 5 and 6. All later attempts to match the
sequence fail because does not occur again.
$rose(frame)
428
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Figure16-16 shows that removing the precondition of checking from the assertion causes
data_end_exp
failures that are not relevant to the verification objective. It is important from the validation standpoint to
determine these preconditions and use them to filter out inappropriate or extraneous situations.
An example of implication where the antecedent is a sequence follows:
(a ##1 b ##1 c) |-> (d ##1 e)
If the sequence matches, then the sequence must also match. On the other
(a ##1 b ##1 c) (d ##1 e)
hand, if the sequence does not match, then the result is true.
(a ##1 b ##1 c)
Another example of implication is as follows:
property write_to_addr;
(write_en & data_valid) ##0
(write_en && (retire_address[0:4]==addr)) [*2] |->
##[3:8] write_en && !data_valid &&(write_address[0:4]==addr);
endproperty
This property can be coded alternatively as a nested implication:
property write_to_addr_nested;
(write_en & data_valid) |->
(write_en && (retire_address[0:4]==addr)) [*2] |->
##[3:8] write_en && !data_valid && (write_address[0:4]==addr);
endproperty
16.12.8 Implies and iff properties
A property is an implies if it has the following form:
property_expr1 property_expr2
implies
A property of this form evaluates to true if, and only if, either property_expr1 evaluates to false or
property_expr2 evaluates to true.
A property is an iff if it has the following form:
property_expr1 property_expr2
iff
A property of this form evaluates to true if, and only if, either both property_expr1 evaluates to false and
property_expr2 evaluates to false or both property_expr1 evaluates to true and property_expr2 evaluates to
true.
16.12.9 Followed-by property
A property is a followed-by if it has one of the following forms that use the followed-by operators shown in
Syntax16-18.
property_expr ::= // from A.2.10
...
| sequence_expr property_expr
#-#
| sequence_expr property_expr
#=#
Syntax16-18—Followed-by syntax (excerpt from AnnexA)
429
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
This clause is used to trigger monitoring of a property expression and is allowed at the property level.
The result of the followed-by is either true or false. The left-hand operand sequence_expr is called the
antecedent, while the right-hand operand property_expr is called the consequent. For the followed-by
property to succeed, the following must hold:
— From a given start point sequence_expr shall have at least one successful match.
— property_expr shall be successfully evaluated starting from one of the match points of the
sequence_expr.
From a given start point, evaluation of the followed-by succeeds and returns true if, and only if, there exists
a match of the antecedent sequence_expr beginning at the start point, and the evaluation of the consequent
property_expr beginning at the tick specified by the rules in the next paragraph succeeds and returns true.
Two forms of followed-by are provided: overlapped using operator and nonoverlapped using operator
#-#
. For overlapped followed-by, there shall be a match for the antecedent sequence_expr, where the end
#=#
point of this match is the start point of the evaluation of the consequent property_expr. For nonoverlapped
followed-by, the evaluation of the consequent is described by two cases, depending on whether the
antecedent sequence_expr attains a nonempty match or an empty match:
— If a nonempty match, the start point of the evaluation of the consequent property_expr is the clock
tick after the end point of the match.
— If an empty match, the start point of the evaluation of the consequent property_expr is its nearest
clock tick, starting from the tick when evaluation of the sequence_expr begins. For a singly clocked
property, this coincides with the current clock tick.
The followed-by operators are the duals of the implication operators. Therefore, sequence_expr
#-#
property_expr is equivalent to the following:
sequence_expr property_expr
not ( |-> not )
and sequence_expr property_expr is equivalent to the following:
#=#
sequence_expr property_expr
not ( |=> not )
Examples:
property p1;
##[0:5] done #-# always !rst;
endproperty
property p2;
##[0:5] done #=# always !rst;
endproperty
Property says that shall be asserted at some clock tick during the first 6 clock ticks, and starting
p1 done
from one of the clock ticks when is asserted, shall always be low. Property says that
done rst p2 done
shall be asserted at some clock tick during the first 6 clock ticks, and starting the clock tick after one of the
clock ticks when is asserted, shall always be low.
done rst
sequence_expr sequence_expr1 is semantically equivalent to sequence_expr
#-# strong( ) strong( ##0
sequence_expr1 , and sequence_expr sequence_expr1 is semantically equivalent to
) #=# strong( )
sequence_expr sequence_expr1 .
strong( ##1 )
A followed-by operator is especially convenient for specifying a directive over a
cover property
sequence followed by a property.
430
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
16.12.10 Nexttime property
A property is a nexttime if it has one of the following forms that use the nexttime operators:
— Weak nexttime
property_expr
nexttime
The weak nexttime property property_expr evaluates to true if, and only if, either the
nexttime
property_expr evaluates to true beginning at the next clock tick or there is no further clock tick.
— Indexed form of weak nexttime
constant_expression property_expr
nexttime[ ]
The indexed weak nexttime property constant_expression property_expr evaluates to
nexttime[ ]
true if, and only if, either there are not constant_expression clock ticks or property_expr evaluates to
true beginning at the last of the next constant_expression clock ticks.
— Strong nexttime
property_expr
s_nexttime
The strong nexttime property property_expr evaluates to true if, and only if, there
s_nexttime
exists a next clock tick and property_expr evaluates to true beginning at that clock tick.
— Indexed form of strong nexttime
constant_expression property_expr
s_nexttime[ ]
The indexed strong nexttime property constant_expression property_expr
s_nexttime[ ]
evaluates to true if, and only if, there exist constant_expression clock ticks and property_expr
evaluates to true beginning at the last of the next constant_expression clock ticks.
The number of clock ticks given by constant_expression shall be a non-negative integer constant expression.
The preceding explanations refer to the case where the nexttime property is evaluated in a time step that is a
tick of the clock of the nexttime property. When the nexttime property is evaluated in a time step that is not
a tick of the clock of the nexttime property, an alignment to the tick of the clock of the nexttime property
should be applied before the preceding description. Thus, it is more precise to say that
s_nexttime[n]
property_expr evaluates to true if, and only if, there exist ticks of the clock of the nexttime property,
n+1
including the current time step, and property_expr evaluates to true on the clock tick, where counting
n+1
starts at the current time step. In particular and act as alignment operators.
nexttime[0] s_nexttime[0]
The comments in the following examples describe the conditions for the properties to be evaluated to true:
// if the clock ticks once more, then a shall be true at the next clock tick
property p1;
nexttime a;
endproperty
// the clock shall tick once more and a shall be true at the next clock tick.
property p2;
s_nexttime a;
endproperty
// as long as the clock ticks, a shall be true at each future clock tick
// starting from the next clock tick
property p3;
nexttime always a;
431
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
endproperty
// the clock shall tick at least once more and as long as it ticks, a shall
// be true at every clock tick starting from the next one
property p4;
s_nexttime always a;
endproperty
// if the clock ticks at least once more, it shall tick enough times for a to
// be true at some point in the future starting from the next clock tick
property p5;
nexttime s_eventually a;
endproperty
// a shall be true sometime in the strict future
property p6;
s_nexttime s_eventually a;
endproperty
// if there are at least two more clock ticks, a shall be true at the second
// future clock tick
property p7;
nexttime[2] a;
endproperty
// there shall be at least two more clock ticks, and a shall be true at the
// second future clock tick
property p8;
s_nexttime[2] a;
endproperty
16.12.11 Always property
A property is an always if it has one of the following forms that use the always operators:
— Weak always
property_expr
always
A property property_expr evaluates to true if, and only if, property_expr holds at every
always
current or future clock tick.
— Ranged form of weak always
cycle_delay_const_range_expression property_expr
always[ ]
A property cycle_delay_const_range_expression property_expr evaluates to true if, and
always[ ]
only if, property_expr holds at every current or future clock tick that is within the range of clock
ticks specified by cycle_delay_const_range_expression. It is not required that all clock ticks within
this range exist. The range for a weak always may be unbounded.
— Ranged form of strong always
constant_range property_expr
s_always[ ]
A property constant_range property_expr evaluates to true if, and only if, all current
s_always [ ]
or future clock ticks specified by constant_range exist and property_expr holds at each of these
clock ticks. The range for a strong always shall be bounded.
The range of clock ticks given by constant_range shall adhere to the following restrictions. The minimum
number of clock ticks is defined by a non-negative integer constant expression; and the maximum number of
432
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
clock ticks either is defined by a non-negative integer constant expression or is $, indicating a finite, but
unbounded, maximum. If both the minimum and maximum numbers of clock ticks are defined by non-
negative integer constant expressions (see 11.2.1), then the minimum number shall be less than or equal to
the maximum number.
The preceding explanations refer to the case where the always property is evaluated in a time step that is a
tick of the clock of the always property. When the always property is evaluated in a time step that is not a
tick of the clock of the always property, an alignment to the tick of the clock of the always property should
be applied before the preceding description. Thus, it is more precise to say that
s_always[n:m]
property_expr evaluates to true if, and only if, there exist ticks of the clock of the always property,
m+1
including the current time step, and property_expr evaluates to true beginning in all of the to clock
n+1 m+1
ticks, where counting starts at the current time step.
There is also the implicit always that is associated with concurrent assertions (see 16.5). A verification
statement that is not placed inside an initial block specifies that an evaluation attempt of its top-level
property shall begin at each occurrence of its leading clocking event. In the following two examples, there is
a one-to-one correspondence between the evaluation attempts of specified by the implicit always from the
p
verification statement and the evaluation attempts of specified by the explicit
implicit_always p always
operator in :
explicit_always
Implicit form:
implicit_always: assert property(p);
Explicit form:
initial explicit_always: assert property(always p);
This is not shown as a practical example, but only for illustration of the meaning of .
always
Examples:
initial a1: assume property( @(posedge clk) reset[*5] #=# always !reset);
property p1;
a ##1 b |=> always c;
endproperty
property p2;
always [2:5] a;
endproperty
property p3;
s_always [2:5] a;
endproperty
property p4;
always [2:$] a;
endproperty
property p5;
s_always [2:$] a; // Illegal
endproperty
The assertion says that shall be true for the first 5 clock ticks and then remain 0 for the rest of the
a1 reset
computation. The assumption is being evaluated once starting at the first clock tick. The property
p1
433
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
evaluates to true provided that if is true at the first clock tick and is true at the second clock tick, then
a b c
shall be true at every clock tick that follows the second. The properties and evaluate to true provided
p2 p3
that is true at each of the second through fifth clock ticks after the starting clock tick of the evaluation
a
attempt. Property evaluates to true provided that these clock ticks exist, while property does not
p3 p2
require that. The property evaluates to true if, and only if, is true at every clock tick that is at least two
p4 a
clock ticks after the starting clock tick of the evaluation attempt. These clock ticks are not required to exist.
The property is illegal since specifying an unbounded range is not permitted with the strong form of an
p5
always property.
16.12.12 Until property
A property is an until if it has one of the following forms that use the until operators:
— Weak non-overlapping form
property_expr1 property_expr2
until
— Strong non-overlapping form
property_expr1 property_expr2
s_until
— Weak overlapping form
property_expr1 property_expr2
until_with
— Strong overlapping form
property_expr1 property_expr2
s_until_with
An until property of the non-overlapping form evaluates to true if property_expr1 evaluates to true at every
clock tick beginning with the starting clock tick of the evaluation attempt and continuing until at least one
tick before a clock tick where property_expr2 evaluates to true. An until property of one of the overlapping
forms evaluates to true if property_expr1 evaluates to true at every clock tick beginning with the starting
clock tick of the evaluation attempt and continuing until and including a clock tick at which property_expr2
evaluates to true. An until property of one of the strong forms requires a current or future clock tick exist at
which property_expr2 evaluates to true, while an until property of one of the weak forms does not make this
requirement. An until property of one of the weak forms evaluates to true if property_expr1 evaluates to true
at each clock tick, even if property_expr2 never holds.
Examples:
property p1;
a until b;
endproperty
property p2;
a s_until b;
endproperty
property p3;
a until_with b;
endproperty
property p4;
a s_until_with b;
endproperty
Property evaluates to true if, and only if, is true at every clock tick beginning with the starting clock
p1 a
tick of the evaluation attempt and continuing until, but not necessarily including, a clock tick at which is
b
434
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
true. If there is no current or future clock tick at which is true, than shall be true at every current or future
b a
clock tick. If is true at the starting clock tick of the evaluation attempt, then need not be true at that clock
b a
tick. The property evaluates to true provided that there exists a current or future clock tick at which is
p2 b
true and that is true at every clock tick beginning with the starting clock tick of the evaluation attempt and
a
continuing until, but not necessarily including, the clock tick at which is true. If is true at the starting
b b
clock tick of the evaluation attempt, then need not be true at that clock tick. The property evaluates to
a p3
true provided that is true at every clock tick beginning with the starting clock tick of the evaluation attempt
a
and continuing until and including a clock tick at which is true. If there is no current or future clock tick at
b
which is true, than shall be true at every current or future clock tick. The property evaluates to true
b a p4
provided there exists a current or future clock tick at which is true and that is true at every clock tick
b a
beginning with the starting clock tick of the evaluation attempt and continuing until and including the clock
tick at which is true. The property is equivalent to (here and are
b p4 strong(a[*1:$] ##0 b) a b
Boolean expressions).
16.12.13 Eventually property
A property is an eventually if it has one of the following forms that use the eventually operators:
— Strong eventually
property_expr
s_eventually
A property s_eventuallyproperty_expr evaluates to true if, and only if, there exists a current or
future clock tick at which property_expr evaluates to true.
— Ranged form of weak eventually
constant_range property_expr
eventually[ ]
A property eventually[constant_range]property_expr evaluates to true if, and only if, either there
exists a current or future clock tick within the range specified by constant_range at which
property_expr evaluates to true or not all the current or future clock ticks within the range specified
by constant_range exist. The range for a weak eventually shall be bounded.
— Ranged form of strong eventually
cycle_delay_const_range_expression property_expr
s_eventually[ ]
A property s_eventually[cycle_delay_const_range_expression]property_expr evaluates to true if,
and only if, there exists a current or future clock tick within the range specified by
cycle_delay_const_range_expression at which property_expr evaluates to true. The range for a
strong eventually may be unbounded.
In the following examples, and are Boolean expressions:
a b
property p1;
s_eventually a;
endproperty
property p2;
s_eventually always a;
endproperty
property p3;
always s_eventually a;
endproperty
property p4;
eventually [2:5] a;
endproperty
435
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
property p5;
s_eventually [2:5] a;
endproperty
property p6;
eventually [2:$] a; // Illegal
endproperty
property p7;
s_eventually [2:$] a;
endproperty
The property evaluates to true if, and only if, there exists a current or future clock tick at which is true.
p1 a
It is equivalent to . The property evaluates to true if, and only if, there exists a
strong(##[*0:$] a) p2
current or future clock tick such that is true both at that clock tick and also at every subsequent clock tick.
a
On a computation with infinitely many clock ticks, the property evaluates to true if, and only if, is true
p3 a
at infinitely many of those clock ticks. On a computation with finitely many clock ticks, the property
p3
evaluates to true provided that if there is at least one clock tick, then holds at the last clock tick. The
a
property evaluates to true provided that if the second through fifth clock ticks from the starting clock tick
p4
of the evaluation attempt all exist, then is true at one of these clock ticks. is equivalent to
a p4
. The property evaluates to true if, and only if, there exists a clock tick at which is
weak(##[2:5] a) p5 a
true and that it is between the second and fifth clock ticks, inclusive, from the starting clock tick of the
evaluation attempt. is equivalent to . The property evaluates to true if, and only
p5 strong(##[2:5] a) p7
if, there exists a clock tick at which is true and that it is no earlier than the second clock tick after the
a
starting clock tick of the evaluation attempt.
The preceding explanations refer to the case where the eventually property is evaluated in a time step that is
a tick of the clock of the eventually property. When the eventually property is evaluated in a time step that is
not a tick of the clock of the eventually property, an alignment to the tick of the clock of the eventually
property should be applied before the preceding description. Thus, it is more precise to say that
property_expr evaluates to true if, and only if, there exist at least ticks of the
s_eventually[n:m] n+1
clock of the eventually property, including the current time step, and property_expr evaluates to true
beginning in one of the to clock ticks, where counting starts at the current time step.
n+1 m+1
16.12.14 Abort properties
A property is an abort if it has one of the following forms:
expression_or_dist property_expr
accept_on( )
expression_or_dist property_expr
reject_on( )
expression_or_dist property_expr
sync_accept_on( )
expression_or_dist property_expr
sync_reject_on( )
where the expression_or_dist is called the abort condition. The properties and are
accept_on reject_on
called asynchronous abort properties, and the properties and are
sync_accept_on sync_reject_on
called synchronous abort properties.
For an evaluation of expression_or_dist property_expr and of
accept_on( )
expression_or_dist property_expr, there is an evaluation of the underlying
sync_accept_on( )
property_expr. If during the evaluation, the abort condition becomes true, then the overall evaluation of the
property results in true. Otherwise, the overall evaluation of the property is equal to the evaluation of the
property_expr.
436
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For an evaluation of expression_or_dist property_expr and of
reject_on( )
expression_or_dist property_expr, there is an evaluation of the underlying
sync_reject_on( )
property_expr. If during the evaluation, the abort condition becomes true, then the overall evaluation of the
property results in false. Otherwise, the overall evaluation of the property is equal to the evaluation of the
property_expr.
The operators and are evaluated at the granularity of the simulation time step like
accept_on reject_on
, but their abort condition is evaluated using sampled value as a regular Boolean expression in
disable iff
assertions. The operators and represent asynchronous resets.
accept_on reject_on
The operators and are evaluated at the simulation time step when the
sync_accept_on sync_reject_on
clocking event happens, unlike , , and . Their abort condition is
disableiff accept_on reject_on
evaluated using sampled value as for and . The operators and
accept_on reject_on sync_accept_on
represent synchronous resets.
sync_reject_on
The semantics of is similar to , except for the following differences:
accept_on disable iff
— operates at the property level rather than the concurrent assertion level.
accept_on
— uses sampled values.
accept_on
— While a disable condition of a in a property_spec may cause an evaluation of the
disable iff
property_spec to be disabled, an abort condition of in a property_expr may cause the
accept_on
evaluation of the property_expr to be true.
The semantics of (expression_or_dist) property_expr is the same as
reject_on
expression_or_dist property_expr .
not(accept_on( ) not( ))
The semantics of is similar to , except that it evaluates only at the time steps
sync_accept_on accept_on
when the clocking event happens.
The semantics of (expression_or_dist)property_expr is the same as
sync_reject_on
expression_or_dist property_expr .
not(sync_accept_on( ) not( ))
Any nesting of abort operators , , , and is
accept_on reject_on sync_accept_on sync_reject_on
allowed.
For example, whenever is high, followed by two occurrences of being high, then cannot be
go get stop
high until after is asserted twice (not necessarily consecutive).
put
assert property (@(clk) go ##1 get[*2] |-> reject_on(stop) put[->2]);
In this example the is an asynchronous abort, its value is checked even between ticks of . The
stop clk
following is the synchronous version of the same example:
assert property (@(clk) go ##1 get[*2] |-> sync_reject_on(stop) put[->2]);
Here is checked only at the ticks. The latter assertion can also be written as follows:
stop clk
assert property (@(clk) go ##1 get[*2] |-> !stop throughout put[->2]);
When the abort condition occurs at the same time step where the evaluation of the property_expr ends, the
abort condition takes precedence. For example:
property p; (accept_on(a) p1) and (reject_on(b) p2); endproperty
437
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If becomes true during the evaluation of , the first term is ignored in deciding the truth of . On the other
a p1 p
hand, if becomes true during the evaluation of then evaluates to false.
b p2 p
property p; (accept_on(a) p1) or (reject_on(b) p2); endproperty
If becomes true during the evaluation of then evaluates to true. On the other hand, if becomes true
a p1 p b
during the evaluation of , then the second term is ignored in deciding the truth of .
p2 p
property p; not (accept_on(a) p1); endproperty
inverts the effect of the abort operator. Therefore, if becomes true while evaluating , property
not a p1 p
evaluates to false.
Nested , , , and operators are evaluated in the
accept_on reject_on sync_accept_on sync_reject_on
lexical order (left to right). Therefore, if two nested operator conditions become true in the same time step
during the evaluation of the argument property, then the outermost operator takes precedence. For example:
property p; accept_on(a) reject_on(b) p1; endproperty
If becomes true in the same time step as and during the evaluation of , then succeeds in that time
a b p1 p
step. If becomes true before and during the evaluation of , then fails.
b a p1 p
The abort conditions may contain sampled value functions (see 16.9.3). When sampled value functions other
than are used in the abort condition, the clock argument shall be explicitly specified. Abort
$sampled
conditions shall not contain any reference to local variables and the sequence methods and
triggered
.
matched
16.12.15 Weak and strong operators
The property operators , , , , , and
s_nexttime s_always s_eventually s_until s_until_with
sequence operator are strong: they require that some terminating condition happen in the future, and
strong
this includes the requirement that the property clock ticks enough time to enable the condition to happen.
The property operators , , , , , and sequence operator
nexttime always until eventually until_with
are weak: they do not impose any requirement on the terminating condition, and do not require the
weak
clock to tick.
The concept of weak and strong operators is closely related to an important notion of safety properties.
Safety properties have the characteristic that all their failures happen at a finite time. For example, the
property is a safety property since it is violated only if after finitely many clock ticks there is a
alwaysa
clock tick at which is false, even if there are infinitely many clock ticks in the computation. To the
a
contrary, a failure of the property on a computation with infinitely many clock ticks
s_eventuallya
cannot be identified at a finite time; if it is violated, the value of must be false at each of the infinitely
a
many clock ticks.
16.12.16 Case
The case property statement is a multiway decision that tests whether a Boolean expression matches one of
a number of other Boolean expressions and branches accordingly (see Syntax16-19).
property_expr ::= // from A.2.10
...
| expression_or_dist property_case_item { property_case_item }
case( ) endcase
438
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
...
property_case_item ::=
expression_or_dist { expression_or_dist } property_expr
, : ;
| [ ] property_expr
default : ;
Syntax16-19—Property statement case syntax (excerpt from AnnexA)
The default statement shall be optional. Use of multiple default statements in one property case statement
shall be illegal.
A simple example of the use of the case property statement is the decoding of variable delay to produce a
delay between the check of two signals as follows:
property p_delay(logic [1:0] delay);
case (delay)
2'd0 : a && b;
2'd1 : a ##2 b;
2'd2 : a ##4 b;
2'd3 : a ##8 b;
default: 0; // cause a failure if delay has x or z values
endcase
endproperty
During the linear search, if one of the case item expressions matches the case expression given in
parentheses, then the property statement associated with that case item shall be evaluated, and the linear
search shall terminate. If there is a default case item, it is ignored during this linear search. If all comparisons
fail and the default item is given, then the default item property statement shall be executed. If the default
property statement is not given and all of the comparisons fail, then none of the case item property
statements shall be evaluated and the evaluation of the case property statement from that start point succeeds
and returns true (vacuously).
The rules for comparing the case expression to the case item expressions are described in 12.5.
16.12.17 Recursive properties
SystemVerilog allows recursive properties. A named property is recursive if its declaration involves an
instantiation of itself. Recursion provides a flexible framework for coding properties to serve as ongoing
assumptions, obligations, or coverage monitors.
For example:
property prop_always(p);
p and (1'b1 |=> prop_always(p));
endproperty
is a recursive property that says that the formal argument property must hold at every cycle. This example
p
is useful if the ongoing requirement that property hold applies after a complicated triggering condition
p
encoded in sequence :
s
property p1(s,p);
s |=> prop_always(p);
endproperty
As another example, the recursive property
439
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
property prop_weak_until(p,q);
q or (p and (1'b1 |=> prop_weak_until(p,q)));
endproperty
says that formal argument property must hold at every cycle up to, but not including, the first cycle at
p
which formal argument property holds. Formal argument property is not required ever to hold, however.
q q
This example is useful if must hold at every cycle after a complicated triggering condition encoded in
p
sequence , but the requirement on is lifted by :
s p q
property p2(s,p,q);
s |=> prop_weak_until(p,q);
endproperty
More generally, several properties can be mutually recursive. For example:
property check_phase1;
s1 |-> (phase1_prop and (1'b1 |=> check_phase2));
endproperty
property check_phase2;
s2 |-> (phase2_prop and (1'b1 |=> check_phase1));
endproperty
There are four restrictions on recursive property declarations, as follows:
— Restriction 1: The negation operator and strong operators , ,
not s_nexttime s_eventually
, , and cannot be applied to any property expression that
s_always s_until s_until_with
instantiates a recursive property. In particular, the negation of a recursive property cannot be
asserted or used in defining another property.
The following are examples of illegal property declarations that violate Restriction 1:
property illegal_recursion_1(p);
not prop_always(not p);
endproperty
property illegal_recursion_2(p);
p and (1'b1 |=> not illegal_recursion_2(p));
endproperty
Furthermore, cannot be applied to any property expression that instantiates a property that
not
depends on a recursive property. The precise definition of dependency is given in F.7.
— Restriction 2: The operator cannot be used in the declaration of a recursive property.
disableiff
This restriction is consistent with the restriction that cannot be nested.
disableiff
The following is an example of an illegal property declaration that violates Restriction 2:
property illegal_recursion_3(p);
disable iff (b)
p and (1'b1 |=> illegal_recursion_3(p));
endproperty
The intent of can be written legally as follows:
illegal_recursion_3
property legal_3(p);
disable iff (b) prop_always(p);
endproperty
440
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
because is not a recursive property.
legal_3
— Restriction 3: If is a recursive property, then, in the declaration of , every instance of must
p p p
occur after a positive advance in time. In the case of mutually recursive properties, all recursive
instances must occur after positive advances in time.
The following is an example of an illegal property declaration that violates Restriction 3:
property illegal_recursion_4(p);
p and (1'b1 |-> illegal_recursion_4(p));
endproperty
If this form were legal, the recursion would be stuck in time, checking over and over again at the
p
same cycle.
— Restriction 4: For every recursive instance of property in the declaration of property , each actual
q p
argument expression of the instance satisfies at least one of the following conditions:
e
• is itself a formal argument of .
e p
• No formal argument of appears in .
p e
• is bound to a local variable formal argument of .
e q
For example:
property fibonacci1 (local input int a, b, n, int fib_sig);
(n > 0)
|->
(
(fib_sig == a)
and
(1'b1 |=> fibonacci1(b, a + b, n - 1, fib_sig))
);
endproperty
is a legal declaration, but
property fibonacci2 (int a, b, n, fib_sig);
(n > 0)
|->
(
(fib_sig == a)
and
(1'b1 |=> fibonacci2(b, a + b, n - 1, fib_sig))
);
endproperty
is not legal because, in the recursive instance , the actual
fibonacci2(b, a+b, n-1, fib_sig)
argument expressions , are not themselves formal arguments of , are not bound to
a+b n-1 fibonacci2
local variable formal arguments, and yet formal arguments of appear in these expressions.
fibonacci2
The operators , , , and may be used inside a
accept_on reject_on sync_accept_on sync_reject_on
recursive property. For example, the following uses of and in a property are legal:
accept_on reject_on
property p3(p, bit b, abort);
(p and (1'b1 |=> p4(p, b, abort)));
endproperty
property p4(p, bit b, abort);
441
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
accept_on(b) reject_on(abort) p3(p, b, abort);
endproperty
Recursive properties can represent complicated requirements, such as those associated with varying
numbers of data beats, out-of-order completions, retries, etc. Following is an example of using a recursive
property to check complicated conditions of this kind.
Suppose that write data must be checked according to the following conditions:
— Acknowledgment of a write request is indicated by the signal together with
write_request
. When a write request is acknowledged, it gets a 4-bit tag, indicated by
write_request_ack
signal . The tag is used to distinguish data beats for multiple write
write_reqest_ack_tag
transactions in flight at the same time.
— It is understood that distinct write transactions in flight at the same time must be given distinct tags.
For simplicity, this condition is not a part of what is checked in this example.
— Each write transaction can have between 1 data beat and 16 data beats, and each data beat is 8 bits.
There is a model of the expected write data that is available at acknowledgment of a write request.
The model is a 128-bit vector. The most significant group of 8 bits represents the expected data for
the first beat, the next group of 8 bits represents the expected data for the second beat (if there is a
second beat), and so forth.
— Data transfer for a write transaction occurs after acknowledgment of the write request and, barring
retry, ends with the last data beat. The data beats for a single write transaction occur in order.
— A data beat is indicated by the signal together with the signal to
data_valid data_valid_tag
determine the relevant write transaction. The signal data are valid with and carry the
data_valid
data for that beat. The data for each beat must be correct according to the model of the expected
write data.
— The last data beat is indicated by signal together with and
last_data_valid data_valid
. For simplicity, this example does not represent the number of data beats and
data_valid_tag
does not check that is signaled at the correct beat.
last_data_valid
— At any time after acknowledgment of the write request, but not later than the cycle after the last data
beat, a write transaction can be forced to retry. Retry is indicated by the signal together with
retry
signal to identify the relevant write transaction. If a write transaction is forced to retry,
retry_tag
then its current data transfer is aborted, and the entire data transfer must be repeated. The transaction
does not re-request, and its tag does not change.
— There is no limit on the number of times a write transaction can be forced to retry.
— A write transaction completes the cycle after the last data beat provided it is not forced to retry in
that cycle.
The following is code to check these conditions:
property check_write;
logic [0:127] expected_data; // local variable to sample model data
logic [3:0] tag; // local variable to sample tag
disable iff (reset)
(
write_request && write_request_ack,
expected_data = model_data,
tag = write_request_ack_tag
)
|=>
check_write_data_beat(expected_data, tag, 4'h0);
442
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
endproperty
property check_write_data_beat
(
local input logic [0:127] expected_data,
local input logic [3:0] tag, i
);
(
(data_valid && (data_valid_tag == tag))
||
(retry && (retry_tag == tag))
)[->1]
|->
(
(
(data_valid && (data_valid_tag == tag))
|->
(data == expected_data[i*8+:8])
)
and
(
if (retry && (retry_tag == tag))
(
1'b1 |=> check_write_data_beat(expected_data, tag, 4'h0)
)
else if (!last_data_valid)
(
1'b1 |=> check_write_data_beat(expected_data, tag, i+4'h1)
)
else
(
##1 (retry && (retry_tag == tag))
|=>
check_write_data_beat(expected_data, tag, 4'h0)
)
)
);
endproperty
16.12.18 Typed formal arguments in property declarations
The rules in 16.8.1 for typed formal arguments and their corresponding actual arguments apply to named
properties, except as described next.
If a formal argument of a named property is typed, then the type shall be , , , or
property sequence event
one of the types allowed in 16.6. If the formal argument is of type , then the corresponding actual
property
argument shall be a property_expr, and each reference to the formal argument shall be in a place where a
property_expr may be written.
For example, a Boolean expression or a sequence_expr may be passed as actual argument to a formal
argument of type because each is a property_expr. A formal argument of type may
property property
not be referenced as the antecedent of or (see 16.12.7), regardless of the corresponding actual
|-> |=>
argument, because a property_expr may not be written in that position.
443
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
16.12.19 Local variable formal arguments in property declarations
The rules in 16.8.2 for local variable formal arguments and their corresponding actual arguments apply to
named properties, except as described next.
A local variable formal argument of a named property shall have direction , either specified explicitly
input
or inferred. It shall be illegal to declare a local variable formal argument of a named property with direction
or .
inout output
16.12.20 Property examples
The following examples illustrate the property forms:
property rule1;
@(posedge clk) a |-> b ##1 c ##1 d;
endproperty
property rule2;
@(clkev) disable iff (e) a |-> not(b ##1 c ##1 d);
endproperty
Property negates the sequence in the consequent of the implication
rule2 (b ##1 c ##1 d) . clkev
specifies the clock for the property
.
property rule3;
@(posedge clk) a[*2] |-> ((##[1:3] c) or (d |=> e));
endproperty
Property says that if holds and also held last cycle, then either must hold at some point one to
rule3 a a c
three cycles after the current cycle or, if holds in the current cycle, then must hold one cycle later.
d e
property rule4;
@(posedge clk) a[*2] |-> ((##[1:3] c) and (d |=> e));
endproperty
Property says that if holds and also held last cycle, then must hold at some point one to three
rule4 a a c
cycles after the current cycle and, if holds in the current cycle, then must hold one cycle later.
d e
property rule5;
@(posedge clk)
a ##1 (b || c)[->1] |->
if (b)
(##1 d |-> e)
else // c
f ;
endproperty
Property has followed by the next occurrence of either or as its antecedent. The consequent
rule5 a b c
uses to split cases on which of or is matched first.
if–else b c
property rule6(x,y);
##1 x |-> y;
endproperty
property rule5a;
@(posedge clk)
a ##1 (b || c)[->1] |->
if (b)
444
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
rule6(d,e)
else // c
f ;
endproperty
Property is equivalent to , but it uses an instance of as a property expression.
rule5a rule5 rule6
A property can optionally specify an event control for the clock. The clock derivation and resolution rules
are described in 16.16.
A named property can be instantiated by referencing its name. A hierarchical name can be used, consistent
with the SystemVerilog naming conventions. Like sequence declarations, variables used within a property
that are not formal arguments to the property are resolved hierarchically from the scope in which the
property is declared.
Properties that use more than one clock are described in 16.13.
16.12.21 Finite-length versus infinite-length behavior
The formal semantics in F.5 defines whether a given property holds on a given behavior. How the outcome
of this evaluation relates to the design depends on the behavior that was analyzed. In dynamic verification,
only behaviors that are finite in length are considered. In such a case, SystemVerilog defines the following
four levels of satisfaction of a property:
— Holds strongly
• No bad states have been seen.
• All future obligations have been met.
• The property will hold on any extension of the path.
— Holds (but does not hold strongly)
• No bad states have been seen.
• All future obligations have been met.
• The property may or may not hold on a given extension of the path.
— Pending
• No bad states have been seen.
• Future obligations have not been met.
• The property may or may not hold on a given extension of the path.
— Fails
• A bad state has been seen.
• Future obligations may or may not have been met.
• The property will not hold on any extension of the path.
16.12.22 Nondegeneracy
It is possible to define sequences that can never be matched. For example:
(1'b1) intersect(1'b1 ##1 1'b1)
It is also possible to define sequences that admit only empty matches. For example:
1'b1[*0]
445
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A zero consecutive repetition means that there is no sample taken at any clock tick. Therefore, such a
sequence can only match on an empty trace (as formally defined in F.4.3). A sequence may admit both
empty and nonempty matches, for example, . This sequence admits an empty match and up to two
a[*0:2]
nonempty matches: and .
a a[*2]
A sequence that admits no match or that admits only empty matches is called degenerate. A sequence that
admits at least one nonempty match is called nondegenerate. A more precise definition of nondegeneracy is
given in F.5.2 and F.5.5.
The following restrictions apply:
a) Any sequence that is used as a property shall be nondegenerate and shall not admit any empty
match.
b) Any sequence that is used as the antecedent of an overlapping implication ( ) shall be
|->
nondegenerate.
c) Any sequence that is used as the antecedent of a nonoverlapping implication ( ) shall admit at
|=>
least one match. Such a sequence can admit only empty matches.
The reason for these restrictions is because the use of degenerate sequences in forbidden ways results in
counterintuitive property semantics, especially when the property is combined with a clause.
disableiff
16.13 Multiclock support
Multiclock sequences and properties can be specified as described in the following subclauses.
16.13.1 Multiclocked sequences
Multiclocked sequences are built by concatenating singly clocked subsequences using the single-delay
concatenation operator ##1 or the zero-delay concatenation operator ##0. The single delay indicated by ##1
is understood to be from the end point of the first sequence, which occurs at a tick of the first clock, to the
nearest strictly subsequent tick of the second clock, where the second sequence begins. The zero delay
indicated by ##0 is understood to be from the end point of the first sequence, which occurs at a tick of the
first clock, to the nearest possibly overlapping tick of the second clock, where the second sequence begins.
Example 1:
@(posedge clk0) sig0 ##1 @(posedge clk1) sig1
A match of this sequence starts with a match of at . Then ##1 moves the time to the
sig0 posedge clk0
nearest strictly subsequent , and the match of the sequence ends at that point with a match of
posedgeclk1
. If and are not identical, then the clocking event for the sequence changes after ##1. If
sig1 clk0 clk1
and are identical, then the clocking event does not change after ##1, and the preceding sequence
clk0 clk1
is equivalent to the singly clocked sequence
@(posedge clk0) sig0 ##1 sig1
Example 2:
@(posedge clk0) sig0 ##0 @(posedge clk1) sig1
A match of this sequence starts with a match of at . Then ##0 moves the time to the
sig0 posedgeclk0
nearest possibly overlapping , and the match of the sequence ends at that point with a match
posedgeclk1
of : if and happen simultaneously then the time does not move at ##0,
sig1 posedgeclk0 posedgeclk1
otherwise, it behaves as ##1. If and are not identical, then the clocking event for the sequence
clk0 clk1
446
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
changes after ##0. If and are identical, then the clocking event does not change after ##0, and the
clk0 clk1
preceding sequence is equivalent to the following singly clocked sequence:
@(posedge clk0) sig0 ##0 sig1
which is equivalent to the following:
@(posedge clk0) sig0 && sig1
When concatenating differently clocked sequences, the maximal singly clocked subsequences are required
to admit only nonempty matches. The term maximal singly clocked subsequence refers to the largest singly
clocked sequence appearing in a multiclock sequence resulting from the application of the rewriting
algorithm in F.4.1. Such a sequence cannot be enlarged by absorbing any surrounding operators and their
arguments without changing the singly clocked sequence into a multiclock sequence or to a property.
Thus, if , are sequence expressions with no clocking events, then the multiclocked sequence
s1 s2
@(posedge clk1) s1 ##1 @(posedge clk2) s2
is legal only if neither nor can match the empty word. The clocking event applies
s1 s2 @(posedge clk1)
throughout the match of , while the clocking event applies throughout the match of
s1 @(posedge clk2)
. Because the match of is nonempty, there is an end point of this match at . The ##1
s2 s1 posedge clk1
synchronizes between this end point and the first occurrence of strictly after it. That
posedge clk2
occurrence of is the start point of the match of .
posedgeclk2 s2
A multiclocked sequence has well-defined starting and ending clocking events and well-defined clock
changes because of the restriction that maximal singly clocked subsequences not match the empty word. If
and are not identical, then the sequence
clk1 clk2
@(posedge clk0) sig0 ##1 @(posedge clk1) sig1[*0:1]
is illegal because of the possibility of an empty match of , which would make ambiguous
sig1[*0:1]
whether the ending clocking event is or .
@(posedge clk0) @(posedge clk1)
Differently clocked or multiclocked sequence operands cannot be combined with any sequence operators
other than ##1 and ##0. For example, if and are not identical, then the following are illegal:
clk1 clk2
@(posedge clk1) s1 ##2 @(posedge clk2) s2
@(posedge clk1) s1 intersect @(posedge clk2) s2
16.13.2 Multiclocked properties
A clock may be explicitly specified with any property. The property is multiclocked if some of its
subproperties have a clock different from the property clock, or some of its subproperties are multiclocked
sequences.
As in the case of singly clocked properties, the result of evaluating a multiclocked property is either true or
false. Multiclocked sequences are themselves multiclocked properties. For example:
@(posedge clk0) sig0 ##1 @(posedge clk1) sig1
is a multiclocked property. If a multiclocked sequence is evaluated as a property starting at some point, the
evaluation returns true if, and only if, there is a match of the multiclocked sequence beginning at that point.
447
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The following example shows how to form a multiclocked property using Boolean property operators:
(@(posedge clk0) sig0) and (@(posedge clk1) sig1)
This is a multiclocked property, but it is not a multiclocked sequence. This property evaluates to true at a
point if, and only if, the two sequences
@(posedge clk0) sig0
and
@(posedge clk1) sig1
both have matches beginning at the point.
The meaning of multiclocked nonoverlapping implication is similar to that of singly clocked nonoverlapping
implication. For example, if and are sequences with no clocking event, then in
s0 s1
@(posedge clk0) s0 |=> @(posedge clk1) s1
synchronizes between and . Starting at the point at which the implication
|=> posedgeclk0 posedgeclk1
is being evaluated, for each match of clocked by , time is advanced from the end point of the match
s0 clk0
to the nearest strictly future occurrence of , and from that point there must exist a match of
posedgeclk1
clocked by .
s1 clk1
The following example shows a combination of differently clocked properties using both implication and
Boolean property operators:
@(posedge clk0) s0 |=> (@(posedge clk1) s1) and (@(posedge clk2) s2)
The multiclocked overlapping implication has the following meaning: at the end of the antecedent the
|->
nearest tick of the consequent clock is awaited. If the consequent clock happens at the end of the antecedent,
the consequent is started checking immediately. Otherwise, the meaning of the multiclocked overlapping
implication is the same as the meaning of the multiclock nonoverlapping implication.
For example, if and are sequences with no clocking events, then
s0 s1
@(posedge clk0) s0 |-> @(posedge clk1) s1
means the following: at each match of the nearest is awaited. If it happens immediately
s0 posedgeclk1
then is checked without delay, otherwise its check starts at the next as in case with .
s1 posedgeclk1 |=>
In both cases the evaluation of is controlled by .
s1 posedgeclk1
The semantics of multiclocked / - operators is similar to the semantics of the overlapping
ifif else
implication. For example, if and are sequences with no clocking events, then
s1 s2
@(posedge clk0) if (b) @(posedge clk1) s1 else @(posedge clk2) s2
has the following meaning: the condition is checked at . If is true then is checked at
b posedgeclk0 b s1
the nearest, possibly overlapping , else is checked at the nearest non-strictly subsequent
posedgeclk1 s2
.
posedgeclk2
448
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
16.13.3 Clock flow
Throughout this subclause, c and d denote clocking event expressions and v, w, x, y, and z denote sequences
with no clocking events.
Clock flow allows the scope of a clocking event to extend in a natural way through various parts of
multiclocked sequences and properties and reduces the number of places at which the same clocking event
must be specified.
Intuitively, clock flow provides that in a multiclocked sequence or property, the scope of a clocking event
flows left to right across linear operators (e.g., repetition, concatenation, negation, implication, followed-by,
and the , , operators) and distributes to the operands of branching operators
nexttime always eventually
(e.g., conjunction, disjunction, intersection, , and the until operators) until it is replaced by a new
if–else
clocking event.
For example:
c x c y d z
@( ) |=> @( ) ##1 @( )
can be written more simply as
c x y d z
@( ) |=> ##1 @( )
because clock c is understood to flow across .
|=>
Clock flow also makes the adjointness relationships between concatenation and implication clean for
multiclocked properties:
c x y d z
@( ) ##1 |=> @( )
is equivalent to
c x y d z
@( ) |=> |=> @( )
and
c x y d z
@( ) ##0 |=> @( )
is equivalent to
c x y d z
@( ) |-> |=> @( )
The scope of a clocking event flows into parenthesized subexpressions and, if the subexpression is a
sequence, also flows left to right across the parenthesized subexpression. However, the scope of a clocking
event does not flow out of enclosing parentheses.
For example, in the following:
c w x d y z
@( ) ##1 ( ##1 @( ) ) |=>
w, x, and z are clocked at c, and y is clocked at d. Clock c flows across , across the parenthesized
##1
subsequence , and across . Clock c also flows into the parenthesized subsequence, but
(x ##1 @(d) y) |=>
it does not flow through . Clock d does not flow out of its enclosing parentheses.
@(d)
As another example, in the following:
449
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
c v w d x y z
@( ) |=> ( ##1 @( ) ) and ( ##1 )
v, w, y, and z are clocked at c, and x is clocked at d. Clock c flows across , distributes to both operands of
|=>
the (which is a property conjunction due to the multiple clocking), and flows into each of the
and
parenthesized subexpressions. Within , c flows across but does not flow through
(w ##1 @(d) x) ##1
. Clock d does not flow out of its enclosing parentheses. Within , c flows across .
@(d) (y ##1 z) ##1
Similarly, the scope of a clocking event flows into an instance of a named property or sequence, regardless
of whether method or method is applied to the instance of the sequence. The scope of
triggered matched
a clocking event flows left to right across an instance of a property or sequence. A clocking event in the
declaration of a property or sequence does not flow out of an instance of that property or sequence.
The scope of a clocking event does not flow into the disable condition of .
disable iff
Juxtaposing two clocking events nullifies the first of them; therefore, the following two-clocking-event
statement:
d c x
@( ) @( )
is equivalent to the following:
c x
@( )
because the flow of clock d is immediately overridden by clock c.
16.13.4 Examples
The following are examples of multiclock specifications:
sequence s1;
a ##1 b; // unclocked sequence
endsequence
sequence s2;
c ##1 d; // unclocked sequence
endsequence
a) Multiclock sequence
sequence mult_s;
@(posedge clk) a ##1 @(posedge clk1) s1 ##1 @(posedge clk2) s2;
endsequence
b) Property with a multiclock sequence
property mult_p1;
@(posedge clk) a ##1 @(posedge clk1) s1 ##1 @(posedge clk2) s2;
endproperty
c) Property with a named multiclock sequence
property mult_p2;
mult_s;
endproperty
450
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
d) Property with multiclock implication
property mult_p3;
@(posedge clk) a ##1 @(posedge clk1) s1 |=> @(posedge clk2) s2;
endproperty
e) Property with implication, where antecedent and consequent are named multiclocked sequences
property mult_p6;
mult_s |=> mult_s;
endproperty
f) Property using clock flow and overlapped implication
property mult_p7;
@(posedge clk) a ##1 b |-> c ##1 @(posedge clk1) d;
endproperty
Here, , , and are clocked at .
a b c posedgeclk
g) Property using clock flow and
if–else
property mult_p8;
@(posedge clk) a ##1 b |->
if (c)
(1 |=> @(posedge clk1) d)
else
e ##1 @(posedge clk2) f ;
endproperty
Here, , , , , and constant are clocked at .
a b c e 1 posedgeclk
16.13.5 Detecting and using end point of a sequence in multiclock context
Method can be applied to detect the end point of a multiclocked sequence. Method
triggered triggered
can also be applied to detect the end point of a sequence from within a multiclocked sequence. In both cases,
the ending clock of the sequence instance to which is applied shall be the same as the clock in
triggered
the context where the application of method appears.
triggered
To detect the end point of a sequence when the clock of the source sequence is different from the destination
sequence, method on the source sequence is used. The end point of a sequence is reached
matched
whenever there is a match on its expression.
To detect the end point, the method may be applied to a named sequence instance, with or without
matched
arguments, an untyped formal argument, or a formal argument of type , where such is allowed, as
sequence
follows:
sequence_instance.matched
or
formal_argument_sequence.matched
is a method on a sequence that returns true ( ) or false ( ) . Unlike ,
matched 1'b1 1'b0 triggered matched
uses synchronization between the two clocks, by storing the result of the source sequence match until the
arrival of the first destination clock tick after the match. The result of does not depend upon the
matched
starting point of the source sequence.
451
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Like , can be used on sequences that have formal arguments. An example is shown as
triggered matched
follows:
sequence e1(a,b,c);
@(posedge clk) $rose(a) ##1 b ##1 c ;
endsequence
sequence e2;
@(posedge sysclk) reset ##1 inst ##1 e1(ready,proc1,proc2).matched [->1]
##1 branch_back;
endsequence
In this example, source sequence is evaluated at clock , while the destination sequence is
e1 clk e2
evaluated at clock . In , the end point of the instance is tested to
sysclk e2 e1(ready,proc1,proc2)
occur sometime after the occurrence of . Notice that method only tests for the end point of
inst matched
and has no bearing on the starting point of .
e1(ready,proc1,proc2) e1(ready,proc1,proc2)
Local variables can be passed into an instance of a named sequence to which is applied. The same
matched
restrictions apply as in the case of . Values of local variables sampled in an instance of a named
triggered
sequence to which is applied will flow out under the same conditions as for . See
matched triggered
16.10.
As with , a sequence instance to which is applied can have multiple matches in a
triggered matched
single cycle of the destination sequence clock. The multiple matches are treated semantically the same way
as matching both disjuncts of an . In other words, the thread evaluating the destination sequence will fork
or
to account for such distinct local variable valuations.
16.13.6 Sequence methods
Methods and are available to identify the end point of a sequence. The operand
triggered matched
sequence shall be a named sequence instance, with or without arguments, an untyped formal argument, or a
formal argument of type , in the contexts where such arguments are legal. These methods are
sequence
invoked using the following syntax:
sequence_instance.sequence_method
or
formal_argument_sequence.sequence_method
The results of these operations are true ( ) or false ( ) and do not depend upon the starting point of
1'b1 1'b0
the match of their operand sequence. These methods can be invoked on sequences with formal arguments.
The sampled values of these methods are defined as the current values (see 16.5.1).
The value of method evaluates to true ( ) if the operand sequence has reached its end point
triggered 1'b1
at that particular point in time and false ( ) otherwise. The triggered status of the sequence is set in the
1'b0
Observed region and persists through the remainder of the time step. In addition to using this method in
assertion statements, it may be used in statements (see 9.4.4) or Boolean expressions outside a
wait
sequence context. It shall be considered an error to invoke this method outside a sequence context on
sequences that treat their formal arguments as local variables. A sequence treats its formal argument as a
local variable if the formal argument is used as an lvalue in operator_assignment or inc_or_dec_expression
in sequence_match_item. There shall be no circular dependencies between sequences induced by the use of
.
triggered
The method is used to detect the end point of one sequence (the source sequence) referenced in a
matched
multiclocked sequence (the destination sequence). It can only be used in sequence expressions. Unlike
, provides synchronization between two clocks by storing the result of the source
triggered matched
sequence until the arrival of the first clock tick of the destination sequence after the match. The matched
452
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
status of the sequence is set in the Observed region and persists until the Observed region following the
arrival of the first clock tick of the destination sequence after the match.
It shall be considered an error to use the sequence method in sampled value functions (see 16.9.3).
matched
An example of using the previous methods on a sequence is shown as follows:
sequence e1;
@(posedge sysclk) $rose(a) ##1 b ##1 c;
endsequence
sequence e2;
@(posedge sysclk) reset ##1 inst ##1 e1.triggered ##1 branch_back;
endsequence
sequence e3;
@(posedge clk) reset1 ##1 e1.matched ##1 branch_back1;
endsequence
sequence e2_with_arg(sequence subseq);
@(posedge sysclk) reset ##1 inst ##1 subseq.triggered ##1 branch_back;
endsequence
sequence e4;
e2_with_arg(@(posedge sysclk) $rose(a) ##1 b ##1 c);
endsequence
program check;
initial begin
wait (e1.triggered || e2.triggered);
if (e1.triggered)
$display("e1 passed");
if (e2.triggered)
$display("e2 passed");
L2: ...
end
endprogram
In the preceding example, sequence tests for the end point of sequence using method
e2 e1 triggered
because both sequences use the same clock. The sequence tests for the end point of sequence using
e3 e1
method because and use different clocks. The sequence is semantically equivalent to
matched e1 e3 e4 e2
and shows an application of the sequence method on a formal argument of type . The
triggered sequence
procedure in the program waits for the end point of either or . When either or
initial e1 e2 e1 e2
evaluates to true, the wait statement unblocks the initial process. The process then displays the sequence that
caused it to unblock, and then continues to execute at the statement labeled .
L2
The sequence on which a method is applied shall either be clocked or infer the clock from the context where
it is used. The same rules are used to infer the clocking event as specified in 16.9.3 for sampled value
functions.
If the default actual argument is specified for a formal argument of a sequence, and an
$inferred_clock
actual argument is not provided to the sequence instance to which a method is applied, the same rules as
specified in 16.9.3 for sampled value functions are used to determine the inferred clocking event expression
that is bound to that formal argument.
453
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If a sequence with a method is passed as an actual argument to a checker instantiation, it is substituted in
place of the corresponding formal argument. Such a sequence shall be clocked as if it were instantiated
inside the checker.
If a sequence with a method is connected to a port of a module instantiation, it shall be clocked as if it were
instantiated at the place of module instantiation. The same rule shall apply if a sequence with a method is
connected to a port of an interface or program instantiation or passed as an actual argument to a function or
task call.
The preceding rules for inferring the clocking event also apply to a sequence instantiated in an event
expression.
The following examples illustrate how a clock is inferred by a sequence when a method is applied to it.
module mod_sva_checks;
logic a, b, c, d;
logic clk_a, clk_d, clk_e1, clk_e2;
logic clk_c, clk_p;
clocking cb_prog @(posedge clk_p); endclocking
clocking cb_checker @(posedge clk_c); endclocking
default clocking cb @(posedge clk_d); endclocking
sequence e4;
$rose(b) ##1 c;
endsequence
// e4 infers posedge clk_a as per clock flow rules
a1: assert property (@(posedge clk_a) a |=> e4.triggered);
sequence e5;
// e4 will infer posedge clk_e1 as per clock flow rules
// wherever e5 is instantiated (with/without a method)
@(posedge clk_e1) a ##[1:3] e4.triggered ##1 c;
endsequence
// e4, used in e5, infers posedge clk_e1 from e5
a2: assert property (@(posedge clk_a) a |=> e5.matched);
sequence e6(f);
@(posedge clk_e2) f;
endsequence
// e4 infers posedge clk_e2 as per clock flow rules
a3: assert property (@(posedge clk_a) a |=> e6(e4.triggered));
sequence e7;
e4 ##1 e6(d);
endsequence
// Leading clock of e7 is posedge clk_a as per clock flow rules
a4: assert property (@(posedge clk_a) a |=> e7.triggered);
// Illegal use in a disable condition, e4 is not explicitly clocked
a5_illegal: assert property (
@(posedge clk_a) disable iff (e4.triggered) a |=> b);
454
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
always @(posedge clk_a) begin
// e4 infers default clocking cb and not posedge clk_a as there is
// more than one event control in this procedure (16.14.6)
@(e4);
d = a;
end
program prog_e4;
default clocking cb_prog;
initial begin
// e4 infers default clocking cb_prog
wait (e4.triggered);
$display("e4 passed");
end
endprogram : prog_e4
checker check(input in1, input sequence s_f);
default clocking cb_checker;
always @(s_f)
$display("sequence triggered");
a4: assert property (a |=> in1);
endchecker : check
// e4 infers checker's default clocking cb_checker
check c1(e4.triggered, e4);
// e4 connected to port of a module instance infers default clocking cb
mod_adder ai1(e4.triggered);
endmodule : mod_sva_checks
If a sequence admits an empty match, such empty matches shall not activate the or
.triggered .matched
methods (see 16.9.11).
More details about sequence methods can be found in 9.4.4, 16.9.11, and 16.13.5.
16.13.7 Local variable initialization assignments
For singly clocked sequences and properties, a local variable initialization assignment for an evaluation
attempt of an instance of a named sequence or property is performed when the evaluation attempt begins.
Such an evaluation attempt always begins in a time step in which there is a tick of the single governing
clock.
For multiclock sequences and properties, a local variable initialization assignment for an evaluation attempt
of an instance of a named sequence or property with a single semantic leading clock (see 16.16.1) shall be
performed at the earliest tick of the semantic leading clock that is at or after the beginning of the evaluation
attempt. If there are two or more distinct semantic leading clocks for an instance of a named property, then a
separate copy of the local variable shall be created for each semantic leading clock. For each copy of the
local variable, the initialization assignment shall be performed at the earliest tick of the corresponding
semantic leading clock that is at or after the beginning of the evaluation attempt, and that copy of the local
variable shall be used in the evaluation of the subproperty associated with the corresponding semantic
leading clock.
For example, let
455
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
property p;
logic v = e;
(@(posedge clk1) (a == v)[*1:$] |-> b)
and
(@(posedge clk2) c[*1:$] |-> d == v)
;
endproperty
a1: assert property (@(posedge clk) f |=> p);
where is of type . The instance of in assertion has two semantic leading clocks,
f logic p a1 posedgeclk1
and . Separate copies of the local variable are created for the two subproperties governed
posedgeclk2 v
by these clocks. Let be a time step in which occurs and in which the sampled value of is
t0 posedgeclk f
true. According to the structure of , an evaluation attempt of the instance of starts strictly after . Let
a1 p t0
be the earliest time step after in which occurs, and let be the earliest time step after
t1 t0 posedgeclk1 t2
in which occurs. Then a declaration assignment is performed in , and the value
t0 posedgeclk2 v = e t1
is assigned to the copy of associated with . This value is used in the evaluation of the
v posedge clk1
subproperty . Similarly, a declaration assignment is performed in , and
(a == v)[*1:$] |-> b v = e t2
the value is assigned to the copy of associated with . This value is used in the evaluation of
v posedgeclk2
the subproperty .
c[*1:$] |-> d == v
An equivalent declaration of that does not use local variable declaration assignments is as follows:
p
property p;
logic v;
(@(posedge clk1) (1, v = e) ##0 (a == v)[*1:$] |-> b)
and
(@(posedge clk2) (1, v = e) ##0 c[*1:$] |-> d == v)
;
endproperty
16.14 Concurrent assertions
A property on its own is never evaluated for checking an expression. It shall be used within an assertion
statement (see 16.2) for this to occur.
A concurrent assertion statement may be specified in any of the following:
— An always procedure or initial procedure as a statement, wherever these procedures may appear (see
9.2)
— A module
— An interface
— A program
— A generate block
— A checker
concurrent_assertion_item ::= // from A.2.10
[ block_identifier ] concurrent_assertion_statement
:
...
procedural_assertion_statement ::= // from A.6.10
concurrent_assertion_statement
...
concurrent_assertion_statement ::=
assert_property_statement
456
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| assume_property_statement
| cover_property_statement
| cover_sequence_statement
| restrict_property_statement
assert_property_statement::=
property_spec action_block
assertproperty( )
assume_property_statement::=
property_spec action_block
assumeproperty( )
cover_property_statement::=
property_spec statement_or_null
coverproperty( )
cover_sequence_statement::=
[clocking_event ] [ expression_or_dist ]
cover sequence ( disable iff ( )
sequence_expr statement_or_null
)
restrict_property_statement::=
property_spec
restrictproperty( );
Syntax16-20—Concurrent assert construct syntax (excerpt from AnnexA)
The execution of assertion statements can be controlled using assertion control system tasks (see 20.12).
A concurrent assertion statement can be referenced by its optional name. A hierarchical name can be used
consistent with the SystemVerilog naming conventions. When a name is not provided, a tool shall assign a
name to the statement for the purpose of reporting. Unnamed assertions do not create a scope.
16.14.1 Assert statement
The statement is used to enforce a . When the property for the statement is
assert property assert
evaluated to be true, the pass statements of the action block are executed. When the property for the
assert
statement is evaluated to be false, the fail statements of the action_block are executed. When the property for
the statement is evaluated to be disabled, no action_block statement is executed. The execution of
assert
pass and fail statements can be controlled by using assertion action control tasks. The assertion action
control tasks are described in 20.12.
For example:
property abc(a, b, c);
disable iff (a==2) @(posedge clk) not (b ##1 c);
endproperty
env_prop: assert property (abc(rst, in1, in2))
$display("env_prop passed."); else $display("env_prop failed.");
When no action is needed, a null statement (i.e., ) is specified. If no statement is specified for , then
; else
is used as the statement when the assertion fails.
$error
The action_block shall not include any concurrent , , or statement. The action_block,
assert assume cover
however, can contain immediate assertion statements.
The conventions regarding default severity (error) and the use of severity system tasks in concurrent
assertion action blocks shall be the same as those specified for immediate assertions in 16.3.
The pass and fail statements of an assert statement are executed in the Reactive region. The regions of
execution are explained in the scheduling semantics in Clause4.
457
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
16.14.2 Assume statement
The purpose of the statement is to allow properties to be considered as assumptions for formal
assume
analysis as well as for dynamic simulation tools. When a property is assumed, the tools constrain the
environment so that the property holds.
For formal analysis, there is no obligation to verify that the assumed properties hold. An assumed property
can be considered as a hypothesis to prove the asserted properties.
For simulation, the environment must be constrained so that the properties that are assumed shall hold. Like
an asserted property, an assumed property must be checked and reported if it fails to hold. When the
property for the statement is evaluated to be true, the pass statements of the action_block are
assume
executed. If it evaluates to false, the fail statements of the action_block are executed. For example:
property abc(a, b, c);
disable iff (c) @(posedge clk) a |=> b;
endproperty
env_prop:
assume property (abc(req, gnt, rst)) else $error(”Assumption failed.”);
If the property has a disabled evaluation, neither the pass nor fail statements of the action_block are
executed. The execution of pass and fail statements can be controlled by using assertion action control tasks.
The assertion action control tasks are described in 20.12.
Additionally, for random simulation, biasing on the inputs provides a way to make random choices. An
expression can be associated with biasing as follows:
expression dist { dist_list } ; // from A.2.10
Distribution sets and the operator are explained in 18.5.4.
dist
The biasing feature is useful when properties are considered as assumptions to drive random simulation.
When a property with biasing is used within an or assertion statement, the operator is
assert cover dist
equivalent to operator, and the weight specification is ignored. For example:
inside
a1:assume property ( @(posedge clk) req dist {0:=40, 1:=60} ) ;
property proto ;
@(posedge clk) req |-> req[*1:$] ##0 ack;
endproperty
This is equivalent to the following:
a1_assertion:assert property ( @(posedge clk) req inside {0, 1} ) ;
property proto_assertion ;
@(posedge clk) req |-> req[*1:$] ##0 ack;
endproperty
In the preceding example, signal is specified with distribution in assumption and is converted to an
req a1
equivalent assertion .
a1_assertion
It should be noted that the properties that are assumed must hold in the same way with or without biasing.
When using an assume statement for random simulation, the biasing simply provides a means to select
values of free variables, according to the specified weights, when there is a choice of selection at a particular
time.
458
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Consider an example specifying a simple synchronous request and acknowledge protocol, where variable
can be raised at any time and must stay asserted until is asserted. In the next clock cycle, both
req ack req
and must be deasserted.
ack
Properties governing are as follows:
req
property pr1;
@(posedge clk) !reset_n |-> !req; // when reset_n is asserted (0),
// keep req 0
endproperty
property pr2;
@(posedge clk) ack |=> !req; // one cycle after ack, req
// must be deasserted
endproperty
property pr3;
@(posedge clk) req |-> req[*1:$] ##0 ack;// hold req asserted until
// and including ack asserted
endproperty
Properties governing are as follows:
ack
property pa1;
@(posedge clk) !reset_n || !req |-> !ack;
endproperty
property pa2;
@(posedge clk) ack |=> !ack;
endproperty
When verifying the behavior of a protocol controller that has to respond to requests on , assertions
req
and should be proven while assuming that statements , ,
assert_ack1 assert_ack2 a1 assume_req1
, and hold at all times.
assume_req2 assume_req3
a1:assume property (@(posedge clk) req dist {0:=40, 1:=60} );
assume_req1:assume property (pr1);
assume_req2:assume property (pr2);
assume_req3:assume property (pr3);
assert_ack1:assert property (pa1)
else $error("ack asserted while req is still deasserted");
assert_ack2:assert property (pa2)
else $error("ack is extended over more than one cycle");
16.14.3 Cover statement
There exist two categories of cover statements: and . The
coversequence coverproperty
statement specifies sequence coverage, while the statement specifies
coversequence coverproperty
property coverage. Both monitor behavioral aspects of the design for coverage. Tools shall collect coverage
information and report the results at the end of simulation or on demand via an assertion API (refer to
Clause39). The difference between the two categories is that for sequence coverage, all matches per
evaluation attempt are reported, whereas for property coverage the coverage count is incremented at most
once per evaluation attempt. A cover statement may have an optional pass statement. The pass statement
shall not include any concurrent , , or statement.
assert assume cover
For property coverage, the statement appears as follows:
cover property ( property_spec ) statement_or_null
459
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The results of this coverage statement for a property shall contain the following:
— Number of times attempted
— Number of times succeeded (maximum of one per attempt)
— Number of times succeeded because of vacuity
The pass statement specified in statement_or_null shall be executed once for each successful evaluation
attempt of the underlying property_spec. The pass statement shall be executed in the Reactive region of the
time step in which the corresponding evaluation attempt succeeds. The execution of statement_or_null can
be controlled by using assertion action control tasks. The assertion action control tasks are described in
20.12.
The preceding coverage counters for success or vacuous success do not include disabled evaluations. The
attempt counter includes the attempts that result in disabled evaluation. See 40.5.3 for details on obtaining
assertion coverage results.
For sequence coverage, the statement appears as follows:
cover sequence (
[clocking_event ] [ disable iff ( expression_or_dist ) ] sequence_expr )
statement_or_null
Results of coverage for a sequence shall include the following:
— Number of times attempted
— Number of times matched (each attempt can generate multiple matches)
For a given attempt of the statement, all matches of the sequence_expr that complete
coversequence
without the occurrence of the condition shall be counted, with multiplicity, toward the total
disableiff
number of times matched for the attempt. No other match shall be counted towards the total for the attempt.
The pass statement specified in statement_or_null shall be executed, with multiplicity, for each match that is
counted toward the total for the attempt. The pass statement shall be executed in the Reactive region of the
time step in which the corresponding match completes. The execution of statement_or_null can be
controlled by using assertion action control tasks. The assertion action control tasks are described in 20.12.
For a given attempt of the statement, the total number of times matched for the attempt is
coversequence
equal to the number of times is executed in the corresponding attempt of
increment_match_coverage()
assert property (
[clocking_event] [ disable iff ( expression_or_dist ) ]
sequence_expr |-> ( 1'b1, increment_match_coverage() ) );
For each execution of , the pass statement of the cover sequence
increment_match_coverage()
statement is executed in the Reactive region of the same time step.
16.14.4 Restrict statement
In formal verification, for the tool to converge on a proof of a property or to initialize the design to a specific
state, it is often necessary to constrain the state space. For this purpose, the assertion statement
restrict
is introduced. It has the same semantics as , however, in contrast to that
property assume property
statement, the statement is not verified in simulation and has no action block.
restrictproperty
The statement has the following form:
restrict property ( property_spec ) ;
460
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
There is no action block associated with the statement.
Example:
Suppose that when a control bit has a value 0, an ALU performs an addition, and when it is 1, it
ctr
performs a subtraction. It is required to formally verify that some behavior is correct when ALU does an
addition (in another verification session it is possible to do the same for subtraction by changing the
restriction). The behavior can thus be constrained using the statement:
restrict property (@(posedge clk) ctr == '0);
It does not mean that cannot be 1 in any test case in the simulation; that is not an error.
ctr
16.14.5 Using concurrent assertion statements outside procedural code
A concurrent assertion statement can be used outside a procedural context. It can be used within a module,
an interface, or a program. A concurrent assertion statement is an , an , a , or a
assert assume cover
statement. Such a concurrent assertion statement uses the semantics, meaning that it
restrict always
specifies that a new evaluation attempt of the underlying property_spec begins at every occurrence of its
leading clock event.
The following two forms are equivalent:
assert property ( property_spec ) action_block
always assert property ( property_spec ) action_block ;
Similarly, the following two forms are equivalent:
cover property ( property_spec ) statement_or_null
always cover property ( property_spec ) statement_or_null
For example:
module top(input logic clk);
logic a,b,c;
property rule3;
@(posedge clk) a |-> b ##1 c;
endproperty
a1: assert property (rule3);
...
endmodule
is a property declared in module . The assert statement starts checking the property from the
rule3 top a1
beginning to the end of simulation. The property is always checked. Similarly,
module top(input logic clk);
logic a,b,c;
sequence seq3;
@(posedge clk) b ##1 c;
endsequence
c1: cover property (seq3);
...
endmodule
461
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The cover statement starts coverage of the sequence from beginning to the end of simulation. The
c1 seq3
sequence is always monitored for coverage.
16.14.6 Embedding concurrent assertions in procedural code
A concurrent assertion statement can also be embedded in a procedural block. For example:
property rule;
a ##1 b ##1 c;
endproperty
always @(posedge clk) begin
<statements>
assert property (rule);
end
The term procedural concurrent assertion is used to refer to any concurrent assertion statement (see 16.2)
that appears in procedural code. Unlike an immediate assertion, a procedural concurrent assertion is not
immediately evaluated when reached in procedural code. Instead, the assertion and the current values of all
constant and automatic expressions appearing in its assertion arguments (see 16.14.6.1) are placed in a
procedural assertion queue associated with the currently executing process. Each of the entries in this queue
is said to be a pending procedural assertion instance. Since any given statement in a procedure may be
executed multiple times (as in a loop for example), a particular procedural concurrent assertion may result in
many pending procedural assertion instances within a single time step. A concurrent assertion statement that
appears outside procedural code is referred to as a static concurrent assertion statement.
In the Observed region of each simulation time step, each pending procedural assertion instance that is
currently present in a procedural assertion queue shall mature, which means it is confirmed for execution.
When a pending procedural assertion instance matures, if the current time step is one that corresponds to that
assertion instance’s leading clocking event, an evaluation attempt of the assertion begins immediately within
the Observed region. If the assertion’s leading clocking event has not occurred in this time step, the matured
instance shall be placed on the matured assertion queue, which will cause the assertion to begin an
evaluation attempt upon the next clocking event that corresponds to the leading clocking event of the
assertion.
If a procedural assertion flush point (see 16.14.6.2) is reached in a process, its procedural assertion queue is
cleared. Any currently pending procedural assertion instances will not mature, unless again placed on the
queue in the course of procedural execution.
If no clocking event is specified in a procedural concurrent assertion, the leading clocking event of the
assertion shall be inferred from the procedural context, if possible. If no clock can be inferred from the
procedural context, then the clocks shall be inferred from the default clocking (14.12), as if the assertion
were instantiated immediately before the procedure.
A clock shall be inferred for the context of an always or initial procedure that satisfies the following
requirements:
a) There is no blocking timing control in the procedure.
b) There is exactly one event control in the procedure.
c) One and only one event expression within the event control of the procedure satisfies both of the fol-
lowing conditions:
1) The event expression consists solely of an event variable, solely of a clocking block event, or is
of the form edge_identifier expression1 [ expression2 ] and is not a proper subexpression of
iff
an event expression of this form.
2) If the event expression consists solely of an event variable or clocking block event, it does not
appear anywhere else in the body of the procedure other than as a clocking event or within
462
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
assertion statements. If the event expression is of the form edge_identifier expression1 [
iff
expression2 ], no term in expression1 appears anywhere else in the body of the procedure other
than as a clocking event or within assertion statements.
If these requirements are satisfied, then the unique event expression from the third requirement shall be the
clock inferred for the context of the procedure.
For example, in the following code fragment, the clocking event is inferred as the
@(posedge mclk)
clocking event of , while is clocked by as written:
r1_p1 r1_p2 @(posedge scanclk)
property r1;
q != d;
endproperty
always @(posedge mclk) begin
q <= d1;
r1_p1: assert property (r1);
r1_p2: assert property (@(posedge scanclk)r1);
end
The resulting behavior of the preceding assertion depends on the relative frequencies of and
r1_p2 mclk
. For example:
scanclk
— If runs at twice the frequency of , only every other posedge of will result in
scanclk mclk scanclk
an evaluation of . It is only queued when reached during procedural execution, which happens
r1_p2
on a rising edge of .
mclk
— If runs at twice the frequency of , then by every posedge of , two pending
mclk scanclk scanclk
procedural instances of will mature. Thus every posedge of will see
r1_p2 scanclk r1_p2
evaluated and results reported twice.
Also see 17.4 for the context clock inference in checkers, and 17.5 for examples of clock inference in
checker procedures.
Another, more complex example that is legal is as follows:
property r2;
q != d;
endproperty
always_ff @(posedge clock iff reset == 0 or posedge reset) begin
cnt <= reset ? 0 : cnt + 1;
q <= $past(d1);
r2_p: assert property (r2);
end
In the preceding example, the inferred clock is . The inferred clock is
posedge clock iff reset == 0
not because is a proper subexpression of
posedge clock posedge clock posedge clock iff
.
reset == 0
In contrast, no clock is inferred for the context of the in the following:
always_ff
property r3;
q != d;
endproperty
always_ff @(clock iff reset == 0 or posedge reset) begin
cnt <= reset ? 0 : cnt + 1;
463
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
q <= $past(d1); // no inferred clock
r3_p: assert property (r3); // no inferred clock
end
The edge expression cannot be inferred because is referenced within the procedure,
posedgereset reset
and the expression cannot be inferred because it does not have an edge identifier.
clock iff reset == 0
In the absence of default clocking, the code above results in an error.
In the following example, no clock is inferred due to multiple event controls and delays in the always
procedure.
property r4;
q != d;
endproperty
always @(posedge mclk) begin
#10 q <= d1; // delay prevents clock inference
@(negedge mclk) // event control prevents clock inference
#10 q1 <= !d1;
r4_p: assert property (r4); // no inferred clock
end
16.14.6.1 Arguments to procedural concurrent assertions
A procedural concurrent assertion saves the value of its expressions and automatic variables at the
const
time the assertion evaluation attempt is added to the procedural assertion queue. This assertion evaluation
attempt uses these saved values for the evaluation. For example:
// Assume for this example that (posedge clk) will not occur at time 0
always @(posedge clk) begin
int i = 10;
for (i=0; i<10; i++) begin
a1: assert property (foo[i] && bar[i]);
a2: assert property (foo[const'(i)] && bar[i]);
a3: assert property (foo[const'(i)] && bar[const'(i)]);
end
end
In any given clock cycle, each of these assertions will result in 10 queued executions. Every execution of
assertion , however, will be checking the value of , since the sampled value of
a1 (foo[10] && bar[10])
will always be 10, its final value from the previous execution of the procedure. In the case of , its
i a2
executions will be checking , , ...
(foo[0] && bar[10]) (foo[1] && bar[10])
. Assertion , since it has casts on both uses of , will be checking
(foo[9] && bar[10]) a3 const i
, , ... . So the preceding code
(foo[0] && bar[0]) (foo[1] && bar[1]) (foo[9] && bar[9])
fragment is logically equivalent (aside from instance names) to the following:
default clocking @(posedge clk); endclocking
generate for (genvar i=0; i<10; i++) begin
a1: assert property (foo[10] && bar[10]);
a2: assert property (foo[i] && bar[10]);
a3: assert property (foo[i] && bar[i]);
end
endgenerate
Since automatic variables also have their immediate values preserved, in the following example, all three
properties , , and are logically equivalent:
a4 a5 a6
464
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
always @(posedge clk) begin
// variable declared in for statement is automatic (see 12.7.1)
for (int i=0; i<10; i++) begin
a4: assert property (foo[i] && bar[i]);
a5: assert property (foo[const'(i)] && bar[i]);
a6: assert property (foo[const'(i)] && bar[const'(i)]);
end
end
When a procedural concurrent assertion contains temporal expressions and has matured, the execution flow
of the procedure no longer directly affects the matured instance in future time steps. In other words, the
procedural execution only affects the activation of the assertion instance, not the completion of temporal
expressions in the future. However, any constant values that were passed into the assertion instance due to
constant or automatic variables will remain constant for the duration of that instance’s evaluation. The
following example illustrates this behavior:
wire w;
always @(posedge clk) begin : procedural_block_1
if (my_activation_condition == 1) begin
for (int i=0; i<2; i++) begin
a7: assume property (foo[i] |=> bar[i] ##1 (w==1'b1));
end
end
end
During the time step when is 1, two pending instances of will be placed
my_activation_condition a7
on the procedural assertion queue, one for each value of . Assume that they successfully mature, and
i
is true in the current time step. This means that on the next posedge of , regardless of the
foo[0] clk
execution of or the value of , that matured instance
procedural_block_1 my_activation_condition
of will be checking that is true. The constant value of the automatic from when the assertion
a7 bar[0] i
was queued is still in effect, for this and any future clock cycles of this assertion evaluation. Then, one cycle
later, the assertion will also be checking that the sampled value of is .
w 1'b1
The same rules that apply to procedural concurrent assertion arguments also apply to variables appearing in
their action blocks. Thus, constant or automatic values may be used in action blocks as well as the assertion
statements themselves, where they behave as inputs to the action block that shall not be modified. The
following example illustrates this behavior:
// Assume for this example that (posedge clk) will not occur at time 0
always @(posedge clk) begin
int i = 10;
for (i=0; i<10; i++) begin
a8: assert property (foo[const'(i)] && bar[i]) else
$error("a8 failed for const i=%d and i=%d",
const'(i), $sampled(i));
end
end
Upon a failure, any instance of the preceding assertion will show the constant value of (may be from 0 to
i
9) that was used in that instance for “ ”, while the string printed will always end in “ ”, since
const i= i=10
10 will be the sampled value captured from the Preponed region.
When embedding procedural concurrent assertions in code using conditionals, it is important to remember
that the current values of the conditionals in the procedure are used, rather than the sampled values. This
465
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
contrasts with the assertion’s expressions, where sampled values are used (see 16.5.1). The following
example illustrates this situation:
// Assume a, b, c, and en are not automatic
always @(posedge clk) begin
en = ...;
if (en) begin
a9: assert property p1(a,b,c);
end
if ($sampled(en)) begin
a10: assert property p1(a,b,c);
end
end
Assertion is queued on any time step when becomes true, while is queued on any time step when
a9 en a10
the sampled value of was true. Thus, assuming nothing else in the code modifies , checks of will
en en a10
happen a time step later than checks on , even though both use the sampled values of , , and on their
a9 a b c
respective time steps.
NOTE—This is an area of backwards-incompatibility between this standard and 17.13 of IEEE Std 1800-2005. In the
2005 definition, would have been detected as the inferred enabling condition (a definition that no longer exists in this
en
standard) of and always sampled, so and would have identical behavior.
a9 a9 a10
16.14.6.2 Procedural assertion flush points
A process is defined to have reached a procedural assertion flush point if any of the following occur:
— The process, having been suspended earlier due to reaching an event control or statement,
wait
resumes execution.
— The process was declared by an or , and its execution is resumed due
always_comb always_latch
to a transition on one of its dependent signals.
— The outermost scope of the process is disabled by a statement (see 16.14.6.4).
disable
The following example shows how procedural concurrent assertions inherently avoid multiple evaluations
due to transitional combinational values in a single simulation time step:
assign not_a = !a;
default clocking @(posedge clk); endclocking
always_comb begin : b1
// Probably better to not use consts in this example
// ...but using them to illustrate effects of flushing method
a1: assert property (const'(not_a) != const'(a));
end
When changes in a time step during which a positive clock edge occurs, a simulator could evaluate
a
assertion twice—once for the change in and once for the change in after the evaluation of the
a1 a not_a
continuous assignment. The first execution of , which would have ended up reporting a failure, will be
a1
scheduled on the process’s procedural assertion queue. When changes, the procedural assertion
not_a
queue is flushed due to the activation of , and a new pending instance of the procedural concurrent
b1
assertion will now be queued with the correct values, so no failure of will be reported.
a1
The following example illustrates the behavior of procedural concurrent assertions in the presence of time
delays:
default clocking @(posedge clk); endclocking
always @(a or b) begin : b1
a2: assert property (a == b) r.success(0) else r.error(0, a, b);
466
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#1;
a3: assert property (a == b) r.success(1) else r.error(1, a, b);
end
In this case, due to the time delay in the middle of the procedure, an Observed region will always be reached
after the queueing of and before a flush point. Thus will always mature. For , during time steps
a2 a2 a3
where either or changes after it has been queued, the assertion will always be flushed from the queue and
a b
never mature. In general, procedural concurrent assertions must be used carefully when mixed with time
delays.
The following example illustrates a typical use of a procedural concurrent assertion statement with a
cover
rather than an :
assert
assign a = ...;
assign b = ...;
default clocking @(posedge clk); endclocking
always_comb begin : b1
...
c1: cover property (const'(b) != const'(a));
end
In this example, the goal is to make sure some test is covering the case where and have different values
a b
at that point in the procedural code. Due to the arbitrary order of the assignments in the simulator, it might be
the case that in a cycle where there is a positive clock edge and both variables are being assigned the same
value, executes while has been assigned but still holds its previous value. Thus will be queued, but
b1 a b c1
this is actually a glitch, and probably not a useful piece of coverage information. But, when is executed
b1
the next time (after has also been assigned its new value), that coverage point will be flushed, and when
b
the coverage point matures, will correctly not get reported as having been covered during that time step.
c2
16.14.6.3 Procedural concurrent assertions and glitches
One common concern with assertion execution is glitches, where the same assertion executes multiple times
in a time step and reports undesired failures on temporary values that have not yet received their final values
for the step. In general, procedural concurrent assertions are immune to glitches due to order of procedural
execution due to the flushing mechanism, but are still subject to glitches caused by execution loops between
regions.
For example, if code in the Reactive region modifies signals and causes another pass to the Active region to
occur, this may create some glitching behavior, as the new passage in the Active region may requeue
procedural concurrent assertions, and a second evaluation attempt may be added to the matured assertion
queue. The following code illustrates this situation.
always_comb begin : procedural_block_1
if (en)
foo = bar;
end
always_comb begin : procedural_block_2
p1: assert property ( @(posedge clk) (const'(foo) == const'(bar)) );
end
Suppose is assigned a new value elsewhere in the code at the posedge of the clock, and is 1 so the
bar en
assignment in takes place. Block may be executed twice in
procedural_block_1 procedural_block_2
the Active region: once upon the initial change to , and once after the assignment that updates .
bar foo
Upon the first execution of , a pending instance of will be queued and would
procedural_block_2 p1
467
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
result in failure of the assertion if it matured. But this instance will be flushed upon the second execution of
the procedural block before maturing, and thus there will be no glitch.
However, now suppose that in the same example, is 0, and the assignment of the value to
en bar foo
happens through VPI code in the Reactive region. In this case, the Observed region has already occurred, so
has matured and executed, and reported the assertion failure due to and having different values.
p1 foo bar
After the Reactive region, there will be another Active region in which will be
procedural_block_2
executed, and this time a newly queued instance of will pass. But this is too late to prevent the report of
p1
the failure earlier in the time step.
16.14.6.4 Disabling procedural concurrent assertions
The statement shall interact with procedural concurrent assertions as follows:
disable
— A specific procedural concurrent assertion may be disabled. Any pending procedural instances of
that assertion are cleared from the queue. Any pending procedural instances of other assertions
remain in the queue.
— When a is applied to the outermost scope of a procedure that has a pending procedural
disable
assertion queue, in addition to normal disable activities (see 9.6.2), the pending procedural assertion
queue is flushed and all pending assertion instances on the queue are cleared.
Once a procedural concurrent assertion evaluation attempt has matured, it shall not be impacted by any
disable.
Disabling a task or a non-outermost scope of a procedure does not cause flushing of any pending procedural
assertion instances.
The following example illustrates how user code can explicitly flush a pending procedural assertion
instance. In this case, instances of only mature in time steps where does not settle at a value
a1 bad_val_ok
of 1.
default clocking @(posedge clk); endclocking
always @(bad_val or bad_val_ok) begin : b1
a1: assert property (bad_val) else $fatal(1, "Sorry");
if (bad_val_ok) begin
disable a1;
end
end
The following example illustrates how user code can explicitly flush all pending procedural assertion
instances on the procedural assertion queue of process :
b2
default clocking @(posedge clk); endclocking
always @(a or b or c) begin : b2
if (c == 8'hff) begin
a2: assert property (a && b);
end else begin
a3: assert property (a || b);
end
end
always @(clear_b2) begin : b3
disable b2;
end
468
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
16.14.7 Inferred value functions
The following elaboration time system functions are available to query the inferred clocking event
expression and disable expression:
— returns the expression of the inferred clocking event.
$inferred_clock
— returns the inferred disable expression.
$inferred_disable
The inferred clocking event expression is the current resolved event expression that can be used in a
clocking event definition. It is obtained by applying clock flow rules to the point where
$inferred_clock
is called. If there is no current resolved event expression when is encountered then an
$inferred_clock
error shall be issued.
The inferred disable expression is the disable condition from the default disable declaration whose scope
includes the call to (see 16.15). If the call to is not within the
$inferred_disable $inferred_disable
scope of any default disable declaration, then the call to returns (false).
$inferred_disable 1'b0
A call to an inferred expression function may only be used as the entire default value expression for a formal
argument to a property or sequence declaration. A call to an inferred expression function shall not appear
within the body expression of a property or sequence declaration. If a call to an inferred expression function
is used as the entire default value expression for a formal argument to a property or sequence declaration,
then it is replaced by the inferred expression as determined at the point where the property or sequence is
instantiated. Therefore, if the property or sequence instance is the top-level property expression in an
assertion statement, the event expression that is used to replace the default argument is
$inferred_clock
that as determined at the location of the assertion statement. If the property or sequence instance is not the
top-level property expression in the assertion statement, then the event expression determined by clock flow
rules up to the instance location in the property expression is used as the default value of the argument.
Consider the following example:
module m(logic a, b, c, d, rst1, clk1, clk2);
logic rst;
default clocking @(negedge clk1); endclocking
default disable iff rst1;
property p_triggers(start_event, end_event, form, clk = $inferred_clock,
rst = $inferred_disable);
@clk disable iff (rst)
(start_event ##0 end_event[->1]) |=> form;
endproperty
property p_multiclock(clkw, clkx = $inferred_clock, clky, w, x, y, z);
@clkw w ##1 @clkx x |=> @clky y ##1 z;
endproperty
a1: assert property (p_triggers(a, b, c));
a2: assert property (p_triggers(a, b, c, posedge clk1, 1'b0) );
always @(posedge clk2 or posedge rst) begin
if (rst) ... ;
else begin
a3: assert property (p_triggers(a, b, c));
...
end
end
469
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
a4: assert property(p_multiclock(negedge clk2, , posedge clk1,
a, b, c, d) );
endmodule
The preceding code is logically equivalent to the following:
module m(logic a, b, c, d, rst1, clk1, clk2);
logic rst;
a1: assert property (@(negedge clk1) disable iff (rst1)
a ##0 b[->1] |=> c);
a2: assert property (@(posedge clk1) disable iff (1'b0)
a ##0 b[->1] |=> c);
always @(posedge clk2 or posedge rst) begin
if (rst) ... ;
else begin
...
end
end
a3: assert property
(
@(posedge clk2) disable iff (rst1)
(a ##0 b[->1]) |=> c
);
a4: assert property (@(negedge clk2) a ##1 @(negedge clk1) b |=>
@(posedge clk1) c ##1 d);
endmodule
In assertion the clock event is inferred from the default clocking, therefore is
a1 $inferred_clock
for . In assertion the event expression is passed to the formal
negedge clk1 a1 a2 posedge clk1
argument in the instance of property . Therefore, the is not used for
clk p_triggers $inferred_clock
in that instance. In assertion the clocking event is inferred from the event control of the always
clk a3
procedure, therefore is for .
$inferred_clock posedge clk2 a3
In assertion , as the property is instantiated in the statement, is
a4 p_multiclock assert property clkw
replaced by the actual argument ( ), by the default argument value
negedge clk2 clkx
which is the default clocking clock ( ) at the location of the property
$inferred_clock, negedge clk1
instance in the assertion. The third clock, , is replaced by the actual argument ( )
clky posedge clk1
because it is explicitly specified.
The disable condition is inferred for assertions and from the default disable statement. Assertion
rst1 a1 a3
uses explicit reset value in which case the statement could be omitted altogether in
a2 1'b0 disableiff
the equivalent assertion.
16.14.8 Nonvacuous evaluations
An evaluation attempt of a property is either vacuous or nonvacuous. In particular, a vacuous success on all
evaluation attempts may indicate a potential problem either in the design or in the formulation of the
property. For example,
470
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.