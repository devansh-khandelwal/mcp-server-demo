IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— cbAssertionStepSuccess, cbAssertionStepFailure: cb_time is the time when the assertion
attempt step succeeded or failed.
— cbAssertionDisable, cbAssertionEnable, cbAssertionReset, cbAssertionKill cb_time is
:
the time when the assertion attempt was disabled, enabled, reset, or killed.
d) In contrast to cb_time, the content of attemptStartTime is always the start time of the actual attempt
of an assertion. It can be used as a unique identifier that distinguishes the attempts of any given
assertion.
e) See 39.4.2.1 for callbacks for assertions containing global clocking future sampled value functions.
39.4.2.1 Placing callbacks for assertions with global clocking future sampled value
functions
Callback execution for assertions referring to global clocking future sampled value functions (see 16.9.4)
has the following peculiarities:
— The callback is executed at the nearest tick of the global clock strictly following the callback event.
— cb_time contains the time of the callback event.
For example:
a1: assert property(@(posedge clk) $falling_gclk(a) |=> b);
a2: assert property(@(posedge clk) a |=> $falling_gclk(b));
For both assertions and the callback executes at time 12, and not at time 11 when
a1 a2 $assertkill
directive was issued (see Figure39-1). cb_time has the time value of 11—the time when the callback event
actually happened—and attemptStartTime has the time value of 10.
10 1112
$global_clock
clk
a
b
$assertkill
Figure39-1—Assertions with global clocking future sampled value functions
39.5 Control functions
This subclause defines how to obtain assertion system control and assertion control information.
39.5.1 Assertion system control
To control the assertion system, use vpi_control() with one of the following constants and a second handle
argument that is either a for a scope or a of handles for a list of scopes. A
vpiHandle vpiCollection
handle signifies that the control applies to all assertions regardless of scope.
NULL
1116
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Usage example:
vpi_control(vpiAssertionSysReset, handle)
• vpiAssertionSysReset discards all attempts in progress for all assertions and restores the entire
assertion system to its initial state. Any preexisting and
vpiAssertionStepSuccess
callbacks shall be removed; all other assertion callbacks shall
vpiAssertionStepFailure
remain.
— Usage example:
vpi_control(vpiAssertionSysOff, handle)
• vpiAssertionSysOff disables any further assertions from being started. Assertions already
executing are not affected. This control has no effect on preexisting assertion callbacks.
— Usage example:
vpi_control(vpiAssertionSysKill, handle)
• vpiAssertionSysKill discards all attempts in progress and disables any further assertions from
being started. This control has no effect on preexisting assertion callbacks.
— Usage example:
vpi_control(vpiAssertionSysLock, handle)
• vpiAssertionSysLock locks the assertions from being changed. The status of the assertions can
not be changed without unlocking it.
— Usage example:
vpi_control(vpiAssertionSysUnlock, handle)
• vpiAssertionSysUnlock unlocks the assertions. Now, the status of the assertion can be changed.
— Usage example:
vpi_control(vpiAssertionSysOn, handle)
• vpiAssertionSysOn restarts the assertion system after it was stopped or suspended (e.g., due to
vpiAssertionSysOff or vpiAssertionSysKill ). Once started, attempts shall resume on all
assertions. This control has no effect on prior assertion callbacks.
— Usage example:
vpi_control(vpiAssertionSysEnd, handle)
• vpiAssertionSysEnd discards all attempts in progress and disables any further assertions from
starting. All assertion callbacks currently installed shall be removed. Once this control is issued,
no further assertion-related actions shall be permitted.
— Usage example:
vpi_control(vpiAssertionSysDisablePassAction, handle)
• vpiAssertionSysDisablePassAction disables execution of pass action for vacuous and
nonvacuous success of assertions. This has no effect on any existing attempts or if the assertion
pass action is already disabled. By default, all assertion pass actions are enabled.
— Usage example:
vpi_control(vpiAssertionSysEnablePassAction, handle)
• vpiAssertionSysEnablePassAction enables execution of pass action for vacuous and
nonvacuous success of assertions. This has no effect on any existing attempts or if the assertion
pass action is already enabled.
— Usage example:
vpi_control(vpiAssertionSysDisableFailAction, handle)
• vpiAssertionSysDisableFailAction disables execution of fail action for assertions. This has no
effect on any existing attempts or if the assertion fail action is already disabled. By default, all
fail actions are enabled.
— Usage example:
vpi_control(vpiAssertionSysEnableFailAction, handle)
• vpiAssertionSysEnableFailAction enables execution of fail action for assertions. This has no
effect on any existing attempts or if the assertion fail action is already enabled.
— Usage example:
vpi_control(vpiAssertionSysDisableVacuousAction, handle)
• vpiAssertionSysDisableVacuousAction disables execution of pass action on vacuous success
of assertions. This has no effect on any existing attempts or if the execution of pass action on
vacuous success is already disabled. By default, all vacuous actions are enabled.
— Usage example:
vpi_control(vpiAssertionSysEnableNonvacuousAction, handle)
• vpiAssertionSysEnableNonvacuousAction enables execution of pass action on nonvacuous
success of assertions. This has no effect on any existing attempts or if the pass action for
nonvacuous success is already enabled.
1117
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
39.5.2 Assertion control
To obtain assertion control information for assertion statements (e.g., , , ), use
assume assert cover
vpi_control() with one of the operators in this subclause. Only assertion statement handles are valid here,
not sequence or property instances.
For the following operators, the second argument shall be a valid assertion handle:
— Usage example:
vpi_control(vpiAssertionReset, assertionHandle)
• vpiAssertionReset discards all current attempts in progress for this assertion and resets this
assertion to its initial state.
— Usage example:
vpi_control(vpiAssertionLock, assertionHandle)
• vpiAssertionLock locks the status of the assertion from being changed. The status of the
assertion cannot be changed without unlocking it.
— Usage example:
vpi_control(vpiAssertionUnlock, assertionHandle)
• vpiAssertionUnlock unlocks the assertion. Now the status of the assertion can be changed.
— Usage example:
vpi_control(vpiAssertionDisable, assertionHandle)
• vpiAssertionDisable disables the starting of any new attempts for this assertion. This has no
effect on any existing attempts or if the assertion is already disabled. By default, all assertions are
enabled.
— Usage example:
vpi_control(vpiAssertionEnable, assertionHandle)
• vpiAssertionEnable enables starting new attempts for this assertion. This has no effect on any
existing attempts or if the assertion is already enabled.
— Usage example:
vpi_control(vpiAssertionDisablePassAction, assertionHandle)
• vpiAssertionDisablePassAction disables execution of pass action for vacuous and nonvacuous
success of this assertion. This has no effect on any existing attempts or if the assertion pass action
is already disabled. By default, all pass actions are enabled.
— Usage example:
vpi_control(vpiAssertionEnablePassAction, assertionHandle)
• vpiAssertionEnablePassAction enables execution of pass action for vacuous and nonvacuous
success of this assertion. This has no effect on any existing attempts or if the assertion pass action
is already enabled.
— Usage example:
vpi_control(vpiAssertionDisableFailAction, assertionHandle)
• vpiAssertionDisableFailAction disables execution of fail action for this assertion. This has no
effect on any existing attempts or if the assertion fail action is already disabled. By default, all
fail actions are enabled.
— Usage example:
vpi_control(vpiAssertionEnableFailAction, assertionHandle)
• vpiAssertionEnableFailAction enables execution of fail action for this assertion. This has no
effect on any existing attempts or if the assertion fail action is already enabled.
— Usage example:
vpi_control( vpiAssertionDisableVacuousAction,
assertionHandle)
• vpiAssertionDisableVacuousAction disables execution of pass action on vacuous success of
this assertion. This has no effect on any existing attempts or if the execution of pass action on
vacuous success is already disabled. By default, all vacuous actions are enabled.
— Usage example:
vpi_control(vpiAssertionEnableNonvacuousAction,
assertionHandle)
• vpiAssertionEnableNonvacuousAction enables execution of pass action on nonvacuous
success of this assertion. This has no effect on any existing attempts or if the pass action is
already enabled for nonvacuous success of this assertion.
1118
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For the following operators, the second argument shall be a valid assertion handle, and the third argument
shall be an attempt start time (as a pointer to a correctly initialized structure):
s_vpi_time
— Usage example:
vpi_control(vpiAssertionKill, assertionHandle, attemptStartTime)
• vpiAssertionKill discards the given attempt, but leaves the assertion enabled and does not reset
any state used by this assertion (e.g., sampling).
past()
— Usage example:
vpi_control(vpiAssertionDisableStep, assertionHandle, attemptStartTime)
• vpiAssertionDisableStep disables step callbacks for this assertion. This has no effect if stepping
is not enabled or it is already disabled.
For the following operator, the second argument shall be a valid assertion handle, the third argument shall be
an attempt start time (as a pointer to a correctly initialized structure), and the fourth argument
s_vpi_time
shall be a step control constant:
— Usage example:
vpi_control(vpiAssertionEnableStep, assertionHandle, attemptStartTime,
vpiAssertionClockSteps)
• vpiAssertionEnableStep enables step callbacks to occur for this assertion attempt. By default,
stepping is disabled for all assertions. This call has no effect if stepping is already enabled for
this assertion and attempt, other than possibly changing the stepping mode for the attempt if the
attempt has not occurred yet. The stepping mode of any particular attempt cannot be modified
after the assertion attempt in question has started.
• The fine-grained step control constant vpiAssertionClockSteps indicates callbacks on a
per-assertion/clock-tick basis. The assertion clock is the event expression supplied as the
clocking expression to the assertion declaration. This step callback shall occur at every clocking
event, when stepping is enabled, as the assertion “advances” in evaluation.
39.5.3 VPI functions on deferred assertions and procedural concurrent assertions
Deferred assertions (see 16.4) may be in a pending state where the assertion has executed but been placed in
a deferred assertion report queue. Similarly, procedural concurrent assertions (see 16.14.6) may have
pending instances in a procedural assertion queue waiting to mature. For any VPI function, if it discards
current evaluation attempts in progress, that also means it flushes any pending instances that have not yet
matured from these queues. If a VPI function does not interfere with current attempts, that also means it does
not affect or flush these queues.
For example, since vpiAssertionReset discards all current evaluation attempts in progress for the targeted
assertion, if applied to a deferred assertion, it flushes any pending reports for that assertion. However,
vpiAssertionDisable disables the starting of any new attempts without affecting existing attempts, so any
pending reports from a disabled deferred assertion that are already queued may still mature and be reported.
1119
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
40. Code coverage control and API
40.1 General
This clause describes the following:
— SystemVerilog coverage API
— Coverage constants
— Coverage VPI routines
— FSM recognition
— Coverage VPI extensions
40.2 Overview
This clause defines the coverage API in SystemVerilog.
40.2.1 SystemVerilog coverage API
The following criteria are used within this API:
a) This API shall be similar for all coverages. A wide number of coverage types are available, with
possibly different sets offered by different vendors. Maintaining a common interface across all the
different types enhances portability and ease of use.
b) At a minimum, the following types of coverage shall be supported:
1) Statement coverage
2) Toggle coverage
3) Finite state machine (FSM) coverage
i) FSM states
ii) FSM transitions
3) Assertion coverage
c) Coverage APIs shall be extensible in a transparent manner, i.e., adding a new coverage type shall
not break any existing coverage usage.
d) This API shall provide means to obtain coverage information from specific subhierarchies of the
design without requiring the user to enumerate all instances in those hierarchies.
40.2.2 Nomenclature
The following terms are used in this standard:
— assertion coverage: For each assertion, whether it has had at least one success. Implementations
permit querying for further details, such as attempt counts, success counts, failure counts, and failure
coverage.
— finite state machine (FSM) coverage: The number of states in an FSM that this simulation reached.
This standard does not require FSM automatic extraction, but a standard mechanism to force
specific extraction is available via pragmas.
— statement coverage: Whether a statement has been executed. Statement is anything defined as a
statement in the LRM. Covered means it executed at least once. Some implementations also permit
querying the execution count. The granularity of statement coverage can be per-statement or
per-statement block depending on the query (see 40.5.3 for details).
1120
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— toggle coverage: For each bit of every signal (wire and register), whether that bit has both a value
0
and a value. Full coverage means both are seen; otherwise, some implementations can query for
1
partial coverage. Some implementations also permit querying the toggle count of each bit.
These terms define the primitives for each coverage type. Over instances or blocks, the coverage number is
merely the sum of all contained primitives in that instance or block.
40.3 SystemVerilog real-time coverage access
This subclause describes the mechanisms in SystemVerilog through which SystemVerilog code can query
and control coverage information. Coverage information is provided to SystemVerilog by means of a
number of built-in system functions (described in 40.3.2) using a number of predefined constants (described
in 40.3.1) to describe the types of coverage and the control actions to be performed.
40.3.1 Predefined coverage constants in SystemVerilog
The following predefined macros represent basic real-time coverage capabilities accessible
`define
directly from SystemVerilog:
— Coverage control
`define SV_COV_START 0
`define SV_COV_STOP 1
`define SV_COV_RESET 2
`define SV_COV_CHECK 3
— Scope definition (hierarchy traversal/accumulation type)
`define SV_COV_MODULE 10
`define SV_COV_HIER 11
— Coverage type identification
`define SV_COV_ASSERTION 20
`define SV_COV_FSM_STATE 21
`define SV_COV_STATEMENT 22
`define SV_COV_TOGGLE 23
— Status results
`define SV_COV_OVERFLOW -2
`define SV_COV_ERROR -1
`define SV_COV_NOCOV 0
`define SV_COV_OK 1
`define SV_COV_PARTIAL 2
40.3.2 Built-in coverage access system functions
40.3.2.1 $coverage_control
$coverage_control(control_constant,
coverage_type,
scope_def,
modules_or_instance)
1121
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
This function is used to control or query coverage availability in the specified portion of the hierarchy. The
following control options are available:
— , if possible, starts collecting coverage information in the specified hierarchy.
`SV_COV_START
There is no effect if coverage is already being collected. Coverage is automatically started at the
beginning of simulation for all portions of the hierarchy enabled for coverage.
— stops collecting coverage information in the specified hierarchy. There is no effect
`SV_COV_STOP
if coverage is not being collected.
— resets all available coverage information in the specified hierarchy. There is no
`SV_COV_RESET
effect if coverage not available.
— checks whether coverage information can be obtained from the specified
`SV_COV_CHECK
hierarchy. The existence of coverage information does not imply that coverage is being collected, as
the coverage could have been stopped.
The return value is a name, with the value indicating the success of the action.
`define
— , on a check operation, denotes that coverage is fully available in the specified
`SV_COV_OK
hierarchy. For all other operations, it represents successful and complete execution of the desired
operation.
— , on all operations, means that the control operation failed without any effect,
`SV_COV_ERROR
typically due to errors in arguments, such as a nonexisting module.
— , on a check or start operation, denotes that coverage is not available at any point in
`SV_COV_NOCOV
the specified hierarchy.
— , on a check or start operation, denotes that coverage is only partially available
`SV_COV_PARTIAL
in the specified hierarchy.
Table40-1 describes the possible return values for each of the coverage control options.
Table40-1—Coverage control return values
`SV_COV_OK `SV_COV_ERROR `SV_COV_NOCOV `SV_COV_PARTIAL
` Success Bad args No coverage Partial coverage
SV_COV_START
` Success Bad args — —
SV_COV_STOP
` Success Bad args — —
SV_COV_RESET
` Full coverage Bad args No coverage Partial coverage
SV_COV_CHECK
Starting coverage on an instance that has already had coverage started via a prior call to
shall have no effect. Similarly, repeated calls to stop or reset coverage shall have
$coverage_control()
no effect.
The hierarchy(ies) being controlled or queried are specified as follows:
— provides coverage of all instances of the
`SV_MODULE_COV, "unique module def name"
given module (the unique module name is a string), excluding any child instances in the instances of
the given module. The module definition name can use special notation to describe nested module
definitions.
— provides coverage of all instances of the given module,
`SV_COV_HIER, "module name"
including all the hierarchy below.
1122
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— provides coverage of the one named instance. The instance
`SV_MODULE_COV, instance_name
is specified as a normal SystemVerilog hierarchical path.
— provides coverage of the named instance, plus all the hierarchy
`SV_COV_HIER, instance_name
below it.
All the permutations are summarized in Table40-2.
Table40-2—Instance coverage permutations
Control/query Definition name instance.name
` The sum of coverage for all Coverage for just the named
SV_COV_MODULE
instances of the named module, instance, excluding any
excluding any hierarchy below hierarchy in instances below that
those instances. instance.
` The sum of coverage for all Coverage for the named instance
SV_COV_HIER
instances of the named module, and any hierarchy below it.
including all coverage for all
hierarchy below those instances.
NOTE—Definition names are represented as strings, whereas instance names are referenced by
hierarchical paths. A hierarchical path need not include any if the path refers to an instance in the
.
current context (i.e., normal SystemVerilog hierarchical path rules apply).
See Figure40-1 for an example of hierarchical instances.
1123
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
$root
module TestBench
instance tb
module DUT
instance unit1
module component
instance comp
module control
instance ctrl
module DUT
instance unit2
module component
instance comp
module control
instance ctrl
module BusWatcher
instance watch
Figure40-1—Hierarchical instance example
If coverage is enabled on all instances shown in Figure40-1, then
—
$coverage_control(`SV_COV_CHECK, `SV_COV_TOGGLE, `SV_COV_HIER, $root)
checks all instances to verify they have coverage and, in this case, returns .
`SV_COV_OK
—
$coverage_control(`SV_COV_RESET, `SV_COV_TOGGLE, `SV_COV_MODULE, "DUT")
resets coverage collection on both instances of the DUT, specifically, and
$root.tb.unit1
, but leaves coverage unaffected in all other instances.
$root.tb.unit2
—
$coverage_control(`SV_COV_RESET, `SV_COV_TOGGLE, `SV_COV_MODULE,
$root.tb.unit1)
resets coverage of only the instance , leaving all other instances unaffected.
$root.tb.unit1
—
$coverage_control(`SV_COV_STOP, `SV_COV_TOGGLE, `SV_COV_HIER,
$root.tb. unit1)
resets coverage of the instance and also resets coverage for all instances below it,
$root.tb.unit1
specifically and .
$root.tb.unit1.comp $root.tb.unit1.ctrl
—
$coverage_control(`SV_COV_START, `SV_COV_TOGGLE, `SV_COV_HIER, "DUT")
starts coverage on all instances of the module DUT and of all hierarchy(ies) below those instances.
In thisdesign, coverage is started for the instances , ,
$root.tb.unit1 $root.tb.unit1.comp
, , ,
$root.tb.unit1.ctrl $root.tb.unit2 $root.tb.unit2.comp
and .
$root.tb.unit2.ctrl
1124
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
40.3.2.2 $coverage_get_max
$coverage_get_max(coverage_type, scope_def, modules_or_instance)
This function obtains the value representing 100% coverage for the specified coverage type over the
specified portion of the hierarchy. This value shall remain constant across the duration of the simulation.
NOTE—This value is proportional to the design size and structure; therefore, it also needs to be constant through
multiple independent simulations and compilations of the same design, assuming any compilation options do not modify
the coverage support or design structure.
The return value is an integer, with the following meanings:
— . The value exceeds a number that can be represented as an integer.
-2 (`SV_COV_OVERFLOW)
— . An error occurred (typically due to using incorrect arguments).
-1 (`SV_COV_ERROR)
— . No coverage is available for that coverage type on that/those hierarchy(ies).
0 (`SV_COV_NOCOV)
— pos_num. This value is the maximum coverage number (where pos_num > ), which is the sum
+ 0
of all coverable items of that type over the given hierarchy(ies).
The scope of this function is specified per _control() (see 40.3.2.1).
$coverage
40.3.2.3 _get
$coverage
$coverage_get(coverage_type, scope_def, modules_or_instance)
This function obtains the current coverage value for the given coverage type over the given portion of the
hierarchy. This number can be converted to a coverage percentage by use of the following equation:
coverage_get()
coverage% = 100
coverage_get_max()
The return value follows the same pattern as _get_max() (see 40.3.2.2), but with pos_num
$coverage
representing the current coverage level, i.e., the number of the coverable items that have been covered in
this/these hierarchy(ies).
The scope of this function is specified per _control() (see 40.3.2.1).
$coverage
The return value is an integer, with the following meanings:
— . The value exceeds a number that can be represented as an integer.
-2 (`SV_COV_OVERFLOW)
— . An error occurred (typically due to using incorrect arguments).
-1 (`SV_COV_ERROR)
— . No coverage is available for that coverage type on that/those hierarchy(ies).
0 (`SV_COV_NOCOV)
— pos_num. This value is the maximum coverage number (where pos_num > ), which is the sum
+ 0
of all coverable items of that type over the given hierarchy(ies).
40.3.2.4 _merge
$coverage
$coverage_merge(coverage_type, "name")
This function loads and merges coverage data for the specified coverage into the simulator. is an
name
arbitrary string used by the tool, in an implementation-specific way, to locate the appropriate coverage
database, i.e., tools are allowed to store coverage files any place they want with any extension they want as
long as the user can retrieve the information by asking for a specific saved name from that coverage
database. If does not exist or does not correspond to a coverage database from the same design, an
name
1125
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
error shall occur. If an error occurs during loading, the coverage numbers generated by this simulation might
not be meaningful.
The return values from this function are as follows:
— . The coverage data have been found and merged.
`SV_COV_OK
— . The coverage data have been found, but did not contain the coverage type
`SV_COV_NOCOV
requested.
— . The coverage data were not found, or they did not correspond to this design, or
`SV_COV_ERROR
another error occurred.
40.3.2.5 _save
$coverage
$coverage_save(coverage_type, "name")
This function saves the current state of coverage to the tool’s coverage database and associates it with the
given name. This name will be mapped in an implementation-specific way into some file or set of files in the
coverage database. Data saved to the database shall be retrieved later by using _merge() and
$coverage
supplying the same name. Saving coverage shall not have any effect on the state of coverage in this
simulation.
The return values from this function are as follows:
— . The coverage data were successfully saved.
`SV_COV_OK
— . No such coverage is available in this design (nothing was saved).
`SV_COV_NOCOV
— . Some error occurred during the save. If an error occurs, the tool shall
`SV_COV_ERROR
automatically remove the coverage database entry for to preserve the coverage database
name
integrity. It is not an error to overwrite a previously existing .
name
Details:
1) The coverage database format is implementation dependent.
2) Mapping of names to actual directories or files is implementation dependent. There is no
requirement that a coverage name map to any specific set of files or directories.
40.4 FSM recognition
Coverage tools need to have automatic recognition of many of the common FSM coding idioms in
SystemVerilog. This standard does not attempt to describe or require any specific automatic FSM
recognition mechanisms. However, this standard does prescribe a means by which nonautomatic FSM
extraction occurs. The presence of any of these standard FSM description additions shall override the tool’s
default extraction mechanism.
Identification of an FSM consists of identifying the following items:
— The state register (or expression)
— The next state register (this is optional)
— The legal states
40.4.1 Specifying signal that holds current state
Use the following pragma to identify the vector signal that holds the current state of the FSM:
signal_name
/* tool state_vector */
1126
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
where tool and state_vector are required keywords. This pragma needs to be specified inside the module
definition where the signal is declared.
Another pragma is also required that specifies an enumeration name for the FSM. This enumeration name is
also specified for the next state and any possible states, associating them with each other as part of the same
FSM. There are two ways to do this, as follows:
— Use the same pragma as above:
signal_name enumeration_name
/* tool state_vector enum */
— Use a separate pragma in the signal’s declaration:
signal_name
/* tool state_vector */
enumeration_name signal_name
logic [7:0] /* tool enum */ ;
In either case, is a required keyword. If using a separate pragma, is also a required keyword, and
enum tool
the pragma needs to be specified immediately after the bit range of the signal.
40.4.2 Specifying part-select that holds current state
A part-select of a vector signal can be used to hold the current state of the FSM. When a coverage tool
displays or reports FSM coverage data, it names the FSM after the signal that holds the current state. If a
part-select holds the current state in the user’s FSM, the user needs to also specify a name for the FSM for
the coverage tool to use. The FSM name is not the same as the enumeration name.
Specify the part-select by using the following pragma:
signal_name FSM_name enumeration_name
/* tool state_vector [n:n] enum */
40.4.3 Specifying concatenation that holds current state
Like specifying a part-select, a concatenation of signals can be specified to hold the current state (when
including an FSM name and an enumeration name):
signal_name signal_name FSM_name
/* tool state_vector { , , ...} enum
enumeration_name
*/
The concatenation is composed of all the signals specified. Bit-selects or part-selects of signals cannot be
used in the concatenation.
40.4.4 Specifying signal that holds next state
The signal that holds the next state of the FSM can also be specified with the pragma that specifies the
enumeration name:
enumeration_name
logic [7:0] /* tool enum */ signal_name
This pragma can be omitted if, and only if, the FSM does not have a signal for the next state.
40.4.5 Specifying current and next state signals in same declaration
The tool assumes the first signal following the pragma holds the current state and the next signal holds the
next state when a pragma is used for specifying the enumeration name in a declaration of multiple signals.
For example:
1127
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
/* tool state_vector cs */
logic [1:0] /* tool enum myFSM */ cs, ns, nonstate;
In this example, the tool assumes signal holds the current state and signal holds the next state. It
cs ns
assumes nothing about signal .
nonstate
40.4.6 Specifying possible states of FSM
The possible states of the FSM can also be specified with a pragma that includes the following enumeration
name:
enumeration_name
parameter /* tool enum */
S0 = 0,
s1 = 1,
s2 = 2,
s3 = 3;
Put this pragma immediately after the keyword parameter, unless a bit width for the parameters is used, in
which case, specify the pragma immediately after the bit width:
enumeration_name
parameter [1:0] /* tool enum */
S0 = 0,
s1 = 1,
s2 = 2,
s3 = 3;
40.4.7 Pragmas in one-line comments
These pragmas work in both block comments, between the and character strings, and one-line
/* */
comments, following the character string. For example:
//
enumeration_name
parameter [1:0] // tool enum
S0 = 0,
s1 = 1,
s2 = 2,
s3 = 3;
40.4.8 Example
See Figure40-2 for an example of FSM specified with pragmas.
1128
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
module m3;
Signal holds the next state
ns
reg[31:0] cs;
reg[31:0] /* tool enum MY_FSM */ ns;
reg[31:0] clk;
Signal holds the current state
reg[31:0] rst; cs
// tool state_vector cs enum MY_FSM
parameter // tool enum MY_FSM
p1=10,
p2=11,
, , and are possible states of
p3=12; p1 p2 p3
the FSM
endmodule // m3
Figure40-2—FSM specified with pragmas
40.5 VPI coverage extensions
40.5.1 VPI entity/relation diagrams related to coverage
40.5.2 Extensions to VPI enumerations
— Coverage control
vpiCoverageStart
vpiCoverageStop
vpiCoverageReset
vpiCoverageCheck
vpiCoverageMerge
vpiCoverageSave
— VPI properties
• Coverage type properties
vpiAssertCoverage
vpiFsmStateCoverage
vpiStatementCoverage
vpiToggleCoverage
• Coverage status properties
vpiCovered
vpiCoveredMax
vpiCoveredCount
• Assertion-specific coverage status properties
vpiAssertAttemptCovered
vpiAssertSuccessCovered
vpiAssertFailureCovered
vpiAssertVacuousSuccessCovered
vpiAssertDisableCovered
vpiAssertKillCovered
• FSM-specific methods
vpiFsmStates
vpiFsmStateExpression
1129
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— FSM handle types (vpi types)
vpiFsm
vpiFsmHandle
40.5.3 Obtaining coverage information
To obtain coverage information, the vpi_get() function is extended with additional VPI properties that can
be obtained from the following existing handles:
vpi_get(<coverageType>, instance_handle)
returns the number of covered items of the given coverage type in the given instance. Coverage type is one
of the coverage type properties described in 40.5.2. For example, given coverage type
vpiStatement-
, this call would return the number of covered statements in the instance pointed to by
Coverage
.
instance_handle
vpi_get(vpiCovered, assertion_handle)
vpi_get(vpiCovered, statement_handle)
vpi_get(vpiCovered, signal_handle)
vpi_get(vpiCovered, fsm_handle)
vpi_get(vpiCovered, fsm_state_handle)
returns whether the item referenced by the handle has been covered. For handles that can contain multiple
coverable entities, such as statement, FSM, and signal handles, the return value indicates how many of the
entities have been covered.
— For assertion handle, the coverable entities are assertions.
— For statement handle, the entities are statements.
— For signal handle, the entities are individual signal bits.
— For FSM handle, the entities are FSM states.
For assertions, vpiCovered implies that the assertion has been attempted, has succeeded at least once, and
has never failed. More detailed coverage information can be obtained for assertions by the following
queries:
vpi_get(vpiAssertAttemptCovered, assertion_handle)
returns the number of times the assertion has been attempted.
vpi_get(vpiAssertSuccessCovered, assertion_handle)
returns the number of times the assertion has succeeded nonvacuously or, if the assertion handle corresponds
to a cover sequence, the number of times the sequence has been matched. Refer to 16.12.7 and 16.14.8 for
the definition of vacuity.
vpi_get(vpiAssertVacuousSuccessCovered, assertion_handle)
returns the number of times the assertion has succeeded vacuously.
vpi_get(vpiAssertDisableCovered, assertion_handle)
returns the number of times the assertion has reached the disabled state (e.g., as a result of
disable iff
condition becoming true or if an attempt starts when the is true). Refer to 16.12 for the
disable iff
definition of disabled evaluation.
1130
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
vpi_get(vpiAssertKillCovered, assertion_handle)
returns the number of times the assertion has been killed (e.g., as a result of a control action, see 39.5.2).
vpi_get(vpiAssertFailureCovered, assertion_handle)
returns the number of times the assertion has failed. For any assertion, the number of attempts that have not
yet reached any conclusion (success, failure, disabled, or killed) can be derived from the equation:
in progress = attempts - (successes + vacuous success + disabled + killed +
failures)
The equation does not apply to statements as there can be multiple matches
cover sequence
corresponding to a single attempt. The following example illustrates some of these queries:
module covtest;
bit on = 1, off = 0;
logic clk;
initial begin
clk = 0;
forever begin
#10;
clk = ~clk;
end
end
always @(false) begin
anvr: assert(on ##1 on); // assertion will not be attempted
end
always @(posedge clk) begin
aundf: assert (on ##[1:$] off); // assertion will not pass or fail
afail: assert (on ##1 off); // assertion will always fail on 2nd tick
apass: assert (on ##1 on); // assertion will succeed on each attempt
end
endmodule
For this example, the assertions will have the coverage results shown in Table40-3.
Table40-3—Assertion coverage results
vpiAssertAttempt- vpiAssertSuccess- vpiAssertFailure-
vpiCovered
Covered Covered Covered
False False False False
anvr
False True False False
aundf
False True False True
afail
True True True False
apass
The number of times an item has been covered can be obtained by the vpiCoveredCount property.
vpi_get(vpiCoveredCount, assertion_handle)
vpi_get(vpiCoveredCount, statement_handle)
vpi_get(vpiCoveredCount, signal_handle)
1131
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
vpi_get(vpiCoveredCount, fsm_handle)
vpi_get(vpiCoveredCount, fsm_state_handle)
returns the number of times each coverable entity referred by the handle has been covered. The handle
coverage information is only easily interpretable when the handle points to a unique coverable item (such as
an individual statement). When the handle points to an item containing multiple coverable entities (such as a
handle to a block statement containing a number of statements), the result is the sum of coverage counts for
each of the constituent entities.
vpi_get(vpiCoveredMax, assertion_handle)
vpi_get(vpiCoveredMax, statement_handle)
vpi_get(vpiCoveredMax, signal_handle)
vpi_get(vpiCoveredMax, fsm_handle)
vpi_get(vpiCoveredMax, fsm_state_handle)
returns the number of coverable entities pointed by the handle. The number returned shall always be when
1
applied to an assertion or FSM state handle.
vpi_iterate(vpiFsm, instance-handle)
returns an iterator to all FSMs in an instance.
vpi_handle(vpiFsmStateExpression, fsm-handle)
returns the handle to the signal or expression encoding the FSM state.
vpi_iterate(vpiFsmStates, fsm-handle)
returns an iterator to all states of an FSM.
vpi_get_value(fsm_state_handle, state-handle)
returns the value of an FSM state.
40.5.4 Controlling coverage
Control of the collection of coverage shall be through the vpi_control() routine:
vpi_control(<coverageControl>, <coverageType>, instance_handle)
vpi_control(<coverageControl>, <coverageType>, assertion_handle)
Statement, toggle, and FSM coverage are not individually controllable (i.e., they are controllable only at the
instance level and not on a per-statement, signal, or FSM basis). The semantics and behavior are per the
system function (see 40.3.2.1). coverageControl shall be vpiCoverageStart,
$coverage_control()
vpiCoverageStop, vpiCoverageReset, or vpiCoverageCheck, as defined in 40.5.2. coverageType is any
one of the VPI coverage type properties (see 40.5.2)
To save coverage for the current simulation use the following:
vpi_control(coverageSave, <coverageType>, name)
as defined in 40.5.2. The semantics and behavior are specified per the equivalent system function
(see 40.3.2.5).
$coverage_save()
1132
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
To merge coverage for the current simulation use the following:
vpi_control(vpiCoverageMerge, <coverageType>, name)
as defined in 40.5.2. The semantics and behavior are specified per the equivalent system function
(see 40.3.2.4).
$coverage_merge()
1133
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
41. Data read API
This clause has been deprecated. See IEEE Std 1800-2005 for the contents of this clause.
1134
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Part Four:
Annexes
1135
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex A
(normative)
Formal syntax
The formal syntax of SystemVerilog is described using Backus-Naur Form (BNF). The syntax of
SystemVerilog source is derived from the starting symbol source_text. The syntax of a library map file is
derived from the starting symbol library_text. The conventions used are as follows:
— Keywords and punctuation are in text.
bold-red
— Syntactic categories are named in nonbold text.
— A vertical bar (|) separates alternatives.
— Square brackets ([]) enclose optional items.
— Braces ({}) enclose items that can be repeated zero or more times.
The full syntax and semantics of SystemVerilog are not described solely using BNF. The normative text
description contained within the clauses and annexes of this standard provide additional details on the syntax
and semantics described in this BNF.
A qualified term in the syntax is a term such as array_identifier for which the “array” portion represents
some semantic intent and the “identifier” term indicates that the qualified term reduces to the “identifier”
term in the syntax. The syntax does not completely define the semantics of such qualified terms; for exam-
ple, while an identifier that would qualify semantically as an array_identifier is created by a declaration,
such declaration forms are not explicitly described using array_identifier in the syntax.
A.1 Source text
A.1.1 Library source text
library_text ::= { library_description }
library_description ::=
library_declaration
| include_statement
| config_declaration
|
;
library_declaration ::=
library_identifier file_path_spec { file_path_spec }
library ,
[ file_path_spec { file_path_spec } ]
-incdir , ;
include_statement ::= file_path_spec
include ;
A.1.2 SystemVerilog source text
source_text ::= [ timeunits_declaration ] { description }
description ::=
module_declaration
| udp_declaration
| interface_declaration
| program_declaration
1136
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| package_declaration
| { attribute_instance } package_item
| { attribute_instance } bind_directive
| config_declaration
module_nonansi_header ::=
{ attribute_instance } module_keyword [ lifetime ] module_identifier
{ package_import_declaration } [ parameter_port_list ] list_of_ports
;
module_ansi_header ::=
{ attribute_instance } module_keyword [ lifetime ] module_identifier
{ package_import_declaration }1 [ parameter_port_list ] [ list_of_port_declarations ]
;
module_declaration ::=
module_nonansi_header [ timeunits_declaration ] { module_item }
[ module_identifier ]
endmodule :
| module_ansi_header [ timeunits_declaration ] { non_port_module_item }
[ module_identifier ]
endmodule :
| { attribute_instance } module_keyword [ lifetime ] module_identifier
( .* ) ;
[ timeunits_declaration ] { module_item } [ module_identifier ]
endmodule :
| module_nonansi_header
extern
| module_ansi_header
extern
module_keyword ::= |
module macromodule
interface_declaration ::=
interface_nonansi_header [ timeunits_declaration ] { interface_item }
[ interface_identifier ]
endinterface :
| interface_ansi_header [ timeunits_declaration ] { non_port_interface_item }
[ interface_identifier ]
endinterface :
| { attribute_instance } interface_identifier
interface ( .* ) ;
[ timeunits_declaration ] { interface_item }
[ interface_identifier ]
endinterface :
| interface_nonansi_header
extern
| interface_ansi_header
extern
interface_nonansi_header ::=
{ attribute_instance } [ lifetime ] interface_identifier
interface
{ package_import_declaration } [ parameter_port_list ] list_of_ports
;
interface_ansi_header ::=
{attribute_instance } [ lifetime ] interface_identifier
interface
{ package_import_declaration }1 [ parameter_port_list ] [ list_of_port_declarations ]
;
program_declaration ::=
program_nonansi_header [ timeunits_declaration ] { program_item }
[ program_identifier ]
endprogram :
| program_ansi_header [ timeunits_declaration ] { non_port_program_item }
[ program_identifier ]
endprogram :
| { attribute_instance } program_identifier
program ( .* ) ;
[ timeunits_declaration ] { program_item }
[ program_identifier ]
endprogram :
| program_nonansi_header
extern
| program_ansi_header
extern
program_nonansi_header ::=
{ attribute_instance } [ lifetime ] program_identifier
program
{ package_import_declaration } [ parameter_port_list ] list_of_ports
;
program_ansi_header ::=
{attribute_instance } [ lifetime ] program_identifier
program
1137
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
{ package_import_declaration }1 [ parameter_port_list ] [ list_of_port_declarations ]
;
checker_declaration ::=
checker_identifier [ [ checker_port_list ] ]
checker ( ) ;
{ { attribute_instance } checker_or_generate_item }
[ checker_identifier ]
endchecker :
class_declaration ::=
[ ] [ lifetime ] class_identifier [ parameter_port_list ]
virtual class
[ class_type [ list_of_arguments ] ]
extends ( )
[ interface_class_type { interface_class_type } ]
implements , ;
{ class_item }
[ class_identifier]
endclass :
interface_class_type ::= ps_class_identifier [ parameter_value_assignment ]
interface_class_declaration ::=
class_identifier [ parameter_port_list ]
interfaceclass
[ interface_class_type { interface_class_type } ]
extends , ;
{ interface_class_item }
[ class_identifier]
endclass :
interface_class_item ::=
type_declaration
| { attribute_instance } interface_class_method
| local_parameter_declaration
;
| parameter_declaration7
;
|
;
interface_class_method ::=
method_prototype
purevirtual ;
package_declaration ::=
{ attribute_instance } [ lifetime ] package_identifier
package ;
[ timeunits_declaration ] { { attribute_instance } package_item }
[ package_identifier ]
endpackage :
timeunits_declaration ::=
time_literal [ time_literal ]
timeunit / ;
| time_literal
timeprecision ;
| time_literal time_literal
timeunit ;timeprecision ;
| time_literal time_literal
timeprecision ;timeunit ;
A.1.3 Module parameters and ports
parameter_port_list ::=
list_of_param_assignments { parameter_port_declaration }
# ( , )
| parameter_port_declaration { parameter_port_declaration }
# ( , )
|
#( )
parameter_port_declaration ::=
parameter_declaration
| local_parameter_declaration
| data_type list_of_param_assignments
| list_of_type_assignments
type
list_of_ports ::= port { port }
( , )
list_of_port_declarations2 ::=
[ { attribute_instance} ansi_port_declaration { { attribute_instance} ansi_port_declaration } ]
( , )
1138
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
port_declaration ::=
{ attribute_instance } inout_declaration
| { attribute_instance } input_declaration
| { attribute_instance } output_declaration
| { attribute_instance } ref_declaration
| { attribute_instance } interface_port_declaration
port ::=
[ port_expression ]
| port_identifier [ port_expression ]
. ( )
port_expression ::=
port_reference
| port_reference { port_reference }
{ , }
port_reference ::=
port_identifier constant_select
port_direction ::= | | |
input output inout ref
net_port_header ::= [ port_direction ] net_port_type
variable_port_header ::= [ port_direction ] variable_port_type
interface_port_header ::=
interface_identifier [ modport_identifier ]
.
| [ modport_identifier ]
interface .
ansi_port_declaration ::=
[ net_port_header | interface_port_header ] port_identifier { unpacked_dimension }
[ constant_expression ]
=
| [ variable_port_header ] port_identifier { variable_dimension } [ constant_expression ]
=
| [ port_direction ] port_identifier [ expression ]
. ( )
A.1.4 Module items
elaboration_system_task ::=
[ finish_number [ list_of_arguments ] ]
$fatal ( , ) ;
| [ [ list_of_arguments ] ]
$error ( ) ;
| [ [ list_of_arguments ] ]
$warning ( ) ;
| [ [ list_of_arguments ] ]
$info ( ) ;
finish_number ::= | |
0 1 2
module_common_item ::=
module_or_generate_item_declaration
| interface_instantiation
| program_instantiation
| assertion_item
| bind_directive
| continuous_assign
| net_alias
| initial_construct
| final_construct
| always_construct
| loop_generate_construct
| conditional_generate_construct
| elaboration_system_task
module_item ::=
port_declaration
;
1139
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| non_port_module_item
module_or_generate_item ::=
{ attribute_instance } parameter_override
| { attribute_instance } gate_instantiation
| { attribute_instance } udp_instantiation
| { attribute_instance } module_instantiation
| { attribute_instance } module_common_item
module_or_generate_item_declaration ::=
package_or_generate_item_declaration
| genvar_declaration
| clocking_declaration
| clocking_identifier
defaultclocking ;
| expression_or_dist
defaultdisable iff ;
non_port_module_item ::=
generate_region
| module_or_generate_item
| specify_block
| { attribute_instance } specparam_declaration
| program_declaration
| module_declaration
| interface_declaration
| timeunits_declaration3
parameter_override ::= list_of_defparam_assignments
defparam ;
bind_directive4 ::=
bind_target_scope [ bind_target_instance_list] bind_instantiation
bind : ;
| bind_target_instance bind_instantiation
bind ;
bind_target_scope ::=
module_identifier
| interface_identifier
bind_target_instance ::=
hierarchical_identifier constant_bit_select
bind_target_instance_list ::=
bind_target_instance { bind_target_instance }
,
bind_instantiation ::=
program_instantiation
| module_instantiation
| interface_instantiation
| checker_instantiation
A.1.5 Configuration source text
config_declaration ::=
config_identifier
config ;
{ local_parameter_declaration }
;
design_statement
{ config_rule_statement }
[ config_identifier ]
endconfig :
design_statement ::= { [ library_identifier ] cell_identifier }
design . ;
config_rule_statement ::=
default_clause liblist_clause
;
1140
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| inst_clause liblist_clause
;
| inst_clause use_clause
;
| cell_clause liblist_clause
;
| cell_clause use_clause
;
default_clause ::=
default
inst_clause ::= inst_name
instance
inst_name ::= topmodule_identifier { instance_identifier }
.
cell_clause ::= [ library_identifier ] cell_identifier
cell .
liblist_clause ::= {library_identifier}
liblist
use_clause ::= [ library_identifier ] cell_identifier [ ]
use . : config
| named_parameter_assignment { named_parameter_assignment } [ ]
use , :config
| [ library_identifier ] cell_identifier named_parameter_assignment
use .
{ named_parameter_assignment } [ ]
, :config
A.1.6 Interface items
interface_or_generate_item ::=
{ attribute_instance } module_common_item
| { attribute_instance } extern_tf_declaration
extern_tf_declaration ::=
method_prototype
extern ;
| task_prototype
externforkjoin ;
interface_item ::=
port_declaration
;
| non_port_interface_item
non_port_interface_item ::=
generate_region
| interface_or_generate_item
| program_declaration
| modport_declaration
| interface_declaration
| timeunits_declaration3
A.1.7 Program items
program_item ::=
port_declaration
;
| non_port_program_item
non_port_program_item ::=
{ attribute_instance } continuous_assign
| { attribute_instance } module_or_generate_item_declaration
| { attribute_instance } initial_construct
| { attribute_instance } final_construct
| { attribute_instance } concurrent_assertion_item
| timeunits_declaration3
| program_generate_item
program_generate_item5 ::=
loop_generate_construct
| conditional_generate_construct
1141
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| generate_region
| elaboration_system_task
A.1.8 Checker items
checker_port_list ::=
checker_port_item { checker_port_item}
,
checker_port_item ::=
{ attribute_instance } [ checker_port_direction ] property_formal_type formal_port_identifier
{variable_dimension} [ property_actual_arg ]
=
checker_port_direction ::=
|
input output
checker_or_generate_item ::=
checker_or_generate_item_declaration
| initial_construct
| always_construct
| final_construct
| assertion_item
| continuous_assign
| checker_generate_item
checker_or_generate_item_declaration ::=
[ ] data_declaration
rand
| function_declaration
| checker_declaration
| assertion_item_declaration
| covergroup_declaration
| genvar_declaration
| clocking_declaration
| clocking_identifier
defaultclocking ;
| expression_or_dist
defaultdisableiff ;
|
;
checker_generate_item6 ::=
loop_generate_construct
| conditional_generate_construct
| generate_region
| elaboration_system_task
A.1.9 Class items
class_item ::=
{ attribute_instance } class_property
| { attribute_instance } class_method
| { attribute_instance } class_constraint
| { attribute_instance } class_declaration
| { attribute_instance } covergroup_declaration
| local_parameter_declaration
;
| parameter_declaration7
;
|
;
class_property ::=
{ property_qualifier } data_declaration
| { class_item_qualifier } data_type const_identifier [ constant_expression ]
const = ;
1142
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
class_method ::=
{ method_qualifier } task_declaration
| { method_qualifier } function_declaration
| { class_item_qualifier } method_prototype
purevirtual ;
| { method_qualifier } method_prototype
extern ;
| { method_qualifier } class_constructor_declaration
| { method_qualifier } class_constructor_prototype
extern
class_constructor_prototype ::=
[ [ tf_port_list ] ]
function new ( ) ;
class_constraint ::=
constraint_prototype
| constraint_declaration
class_item_qualifier8 ::=
static
|
protected
|
local
property_qualifier8 ::=
random_qualifier
| class_item_qualifier
random_qualifier8 ::=
rand
|
randc
method_qualifier8 ::=
[ ]
pure virtual
| class_item_qualifier
method_prototype ::=
task_prototype
| function_prototype
class_constructor_declaration ::=
[ class_scope ] [ [ tf_port_list ] ]
function new ( ) ;
{ block_item_declaration }
[ [ list_of_arguments ] ]
super . new ( ) ;
{ function_statement_or_null }
[ ]
endfunction : new
A.1.10 Constraints
constraint_declaration ::= [ ] constraint_identifier constraint_block
static constraint
constraint_block ::= { constraint_block_item }
{ }
constraint_block_item ::=
solve_before_list solve_before_list
solve before ;
| constraint_expression
solve_before_list ::= constraint_primary { constraint_primary }
,
constraint_primary ::= [ implicit_class_handle | class_scope ] hierarchical_identifier select
.
constraint_expression ::=
[ ] expression_or_dist
soft ;
| uniqueness_constraint
;
| expression constraint_set
–>
| expression constraint_set [ constraint_set ]
if( ) else
1143
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| ps_or_hierarchical_array_identifier loop_variables constraint_set
foreach ( [ ])
| constraint_primary
disablesoft ;
uniqueness_constraint ::=
open_range_list9
unique{ }
constraint_set ::=
constraint_expression
| { constraint_expression }
{ }
dist_list ::= dist_item { dist_item }
,
dist_item ::= value_range [ dist_weight ]
dist_weight ::=
expression
:=
| expression
:/
constraint_prototype ::= [constraint_prototype_qualifier] [ ] constraint_identifier
static constraint ;
constraint_prototype_qualifier ::= |
extern pure
extern_constraint_declaration ::=
[ ] class_scope constraint_identifier constraint_block
static constraint
identifier_list ::= identifier { identifier }
,
A.1.11 Package items
package_item ::=
package_or_generate_item_declaration
| anonymous_program
| package_export_declaration
| timeunits_declaration3
package_or_generate_item_declaration ::=
net_declaration
| data_declaration
| task_declaration
| function_declaration
| checker_declaration
| dpi_import_export
| extern_constraint_declaration
| class_declaration
| class_constructor_declaration
| local_parameter_declaration
;
| parameter_declaration
;
| covergroup_declaration
| assertion_item_declaration
|
;
anonymous_program ::= { anonymous_program_item }
program ; endprogram
anonymous_program_item ::=
task_declaration
| function_declaration
| class_declaration
| covergroup_declaration
| class_constructor_declaration
|
;
1144
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A.2 Declarations
A.2.1 Declaration types
A.2.1.1 Module parameter declarations
local_parameter_declaration ::=
data_type_or_implicit list_of_param_assignments
localparam
| list_of_type_assignments
localparamtype
parameter_declaration ::=
data_type_or_implicit list_of_param_assignments
parameter
| list_of_type_assignments
parametertype
specparam_declaration ::=
[ packed_dimension ] list_of_specparam_assignments
specparam ;
A.2.1.2 Port declarations
inout_declaration ::=
net_port_type list_of_port_identifiers
inout
input_declaration ::=
net_port_type list_of_port_identifiers
input
| variable_port_type list_of_variable_identifiers
input
output_declaration ::=
net_port_type list_of_port_identifiers
output
| variable_port_type list_of_variable_port_identifiers
output
interface_port_declaration ::=
interface_identifier list_of_interface_identifiers
| interface_identifier modport_identifier list_of_interface_identifiers
.
ref_declaration ::= variable_port_type list_of_variable_identifiers
ref
A.2.1.3 Type declarations
data_declaration ::=
[ ] [ ] [ lifetime ] data_type_or_implicit list_of_variable_decl_assignments 10
const var ;
| type_declaration
| package_import_declaration11
| net_type_declaration
package_import_declaration ::=
package_import_item { package_import_item }
import , ;
package_import_item ::=
package_identifier identifier
::
| package_identifier
:: *
package_export_declaration ::=
export *::* ;
| package_import_item { package_import_item }
export , ;
genvar_declaration ::= list_of_genvar_identifiers
genvar ;
net_declaration12 ::=
net_type [ drive_strength | charge_strength ] [ | ]
vectored scalared
data_type_or_implicit [ delay3 ] list_of_net_decl_assignments
;
| net_type_identifier [ delay_control ]
list_of_net_decl_assignments
;
| implicit_data_type [ delay_value ]
interconnect #
1145
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
net_identifier { unpacked_dimension }
[ net_identifier { unpacked_dimension }]
, ;
type_declaration ::=
data_type type_identifier { variable_dimension }
typedef ;
| interface_instance_identifier constant_bit_select type_identifier type_identifier
typedef . ;
| [ | | | | ] type_identifier
typedef enum struct union class interfaceclass ;
net_type_declaration ::=
data_type net_type_identifier
nettype
[ [ package_scope | class_scope ] tf_identifier ]
with ;
| [ package_scope | class_scope ] net_type_identifier net_type_identifier
nettype ;
lifetime ::= |
static automatic
A.2.2 Declaration data types
A.2.2.1 Net and variable types
casting_type ::= simple_type | constant_primary | signing | |
string const
data_type ::=
integer_vector_type [ signing ] { packed_dimension }
| integer_atom_type [ signing ]
| non_integer_type
| struct_union [ [ signing ] ] struct_union_member { struct_union_member }
packed { }
{ packed_dimension }13
| [ enum_base_type ] enum_name_declaration { enum_name_declaration }
enum { , }
{ packed_dimension }
|
string
|
chandle
| [ ] interface_identifier [ parameter_value_assignment ] [ modport_identifier ]
virtual interface .
| [ class_scope | package_scope ] type_identifier { packed_dimension }
| class_type
|
event
| ps_covergroup_identifier
| type_reference14
data_type_or_implicit ::=
data_type
| implicit_data_type
implicit_data_type ::= [ signing ] { packed_dimension }
enum_base_type ::=
integer_atom_type [ signing ]
| integer_vector_type [ signing ] [ packed_dimension ]
| type_identifier [ packed_dimension ]15
enum_name_declaration ::=
enum_identifier [ integral_number [ integral_number ] ] [ constant_expression ]
[ : ] =
class_scope ::= class_type
::
class_type ::=
ps_class_identifier [ parameter_value_assignment ]
{ class_identifier [ parameter_value_assignment ] }
::
integer_type ::= integer_vector_type | integer_atom_type
integer_atom_type ::= | | | | |
byte shortint int longint integer time
integer_vector_type ::= | |
bit logic reg
1146
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
non_integer_type ::= | |
shortreal real realtime
net_type ::= | | | | | | | | | | |
supply0 supply1 tri triand trior trireg tri0 tri1 uwire wire wand wor
net_port_type ::=
[ net_type ] data_type_or_implicit
| net_type_identifier
| implicit_data_type
interconnect
variable_port_type ::= var_data_type
var_data_type ::= data_type | data_type_or_implicit
var
signing ::= |
signed unsigned
simple_type ::= integer_type | non_integer_type | ps_type_identifier | ps_parameter_identifier
struct_union_member16 ::=
{ attribute_instance } [random_qualifier] data_type_or_void list_of_variable_decl_assignments
;
data_type_or_void ::= data_type |
void
struct_union ::= | [ ]
struct union tagged
type_reference ::=
expression17
type( )
| data_type
type( )
A.2.2.2 Strengths
drive_strength ::=
strength0 , strength1
( )
| strength1 , strength0
( )
| strength0 ,
( highz1)
| strength1 ,
( highz0)
| , strength1
(highz0 )
| , strength0
(highz1 )
strength0 ::= | | |
supply0 strong0 pull0 weak0
strength1 ::= | | |
supply1 strong1 pull1 weak1
charge_strength ::= | |
( small ) ( medium ) ( large )
A.2.2.3 Delays
delay3 ::= delay_value | mintypmax_expression [ mintypmax_expression [
# # ( , ,
mintypmax_expression ] ]
)
delay2 ::= delay_value | mintypmax_expression [ mintypmax_expression ]
# # ( , )
delay_value ::=
unsigned_number
| real_number
| ps_identifier
| time_literal
|
1step
A.2.3 Declaration lists
list_of_defparam_assignments ::= defparam_assignment { defparam_assignment }
,
list_of_genvar_identifiers ::= genvar_identifier { genvar_identifier }
,
list_of_interface_identifiers ::= interface_identifier { unpacked_dimension }
{ interface_identifier { unpacked_dimension } }
,
list_of_net_decl_assignments ::= net_decl_assignment { net_decl_assignment }
,
1147
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
list_of_param_assignments ::= param_assignment { param_assignment }
,
list_of_port_identifiers ::= port_identifier { unpacked_dimension }
{ port_identifier { unpacked_dimension } }
,
list_of_udp_port_identifiers ::= port_identifier { port_identifier }
,
list_of_specparam_assignments ::= specparam_assignment { specparam_assignment }
,
list_of_tf_variable_identifiers ::= port_identifier { variable_dimension } [ expression ]
=
{ port_identifier { variable_dimension } [ expression ] }
, =
list_of_type_assignments ::= type_assignment { type_assignment }
,
list_of_variable_decl_assignments ::= variable_decl_assignment { variable_decl_assignment }
,
list_of_variable_identifiers ::= variable_identifier { variable_dimension }
{ variable_identifier { variable_dimension } }
,
list_of_variable_port_identifiers ::= port_identifier { variable_dimension } [ constant_expression ]
=
{ port_identifier { variable_dimension } [ constant_expression ] }
, =
A.2.4 Declaration assignments
defparam_assignment ::= hierarchical_parameter_identifier constant_mintypmax_expression
=
net_decl_assignment ::= net_identifier { unpacked_dimension } [ expression ]
=
param_assignment ::=
parameter_identifier { unpacked_dimension } [ constant_param_expression ]18
=
specparam_assignment ::=
specparam_identifier constant_mintypmax_expression
=
| pulse_control_specparam
type_assignment ::=
type_identifier [ data_type ]18
=
pulse_control_specparam ::=
reject_limit_value [ error_limit_value ]
PATHPULSE$= ( , )
| specify_input_terminal_descriptor specify_output_terminal_descriptor
PATHPULSE$ $
reject_limit_value [ error_limit_value ]
= ( , )
error_limit_value ::= limit_value
reject_limit_value ::= limit_value
limit_value ::= constant_mintypmax_expression
variable_decl_assignment ::=
variable_identifier { variable_dimension } [ expression ]
=
| dynamic_array_variable_identifier unsized_dimension { variable_dimension }
[ dynamic_array_new ]
=
| class_variable_identifier [ class_new ]
=
class_new19 ::=
[ class_scope ] [ list_of_arguments ]
new ( )
| expression
new
dynamic_array_new ::= expression [ expression ]
new [ ] ( )
A.2.5 Declaration ranges
unpacked_dimension ::=
constant_range
[ ]
| constant_expression
[ ]
1148
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
packed_dimension20 ::=
constant_range
[ ]
| unsized_dimension
associative_dimension ::=
data_type
[ ]
|
[ * ]
variable_dimension ::=
unsized_dimension
| unpacked_dimension
| associative_dimension
| queue_dimension
queue_dimension ::= [ constant_expression ]
[ $ : ]
unsized_dimension ::=
[ ]
A.2.6 Function declarations
function_data_type_or_implicit ::=
data_type_or_void
| implicit_data_type
function_declaration ::= [ lifetime ] function_body_declaration
function
function_body_declaration ::=
function_data_type_or_implicit
[ interface_identifier | class_scope ] function_identifier
. ;
{ tf_item_declaration }
{ function_statement_or_null }
[ function_identifier ]
endfunction :
| function_data_type_or_implicit
[ interface_identifier | class_scope ] function_identifier [ tf_port_list ]
. ( );
{ block_item_declaration }
{ function_statement_or_null }
[ function_identifier ]
endfunction :
function_prototype ::= data_type_or_void function_identifier [ [ tf_port_list ] ]
function ( )
dpi_import_export ::=
dpi_spec_string [ dpi_function_import_property ] [ c_identifier ] dpi_function_proto
import = ;
| dpi_spec_string [ dpi_task_import_property ] [ c_identifier ] dpi_task_proto
import = ;
| dpi_spec_string [ c_identifier ] function_identifier
export = function ;
| dpi_spec_string [ c_identifier ] task_identifier
export = task ;
dpi_spec_string ::= |
"DPI-C" "DPI"
dpi_function_import_property ::= |
context pure
dpi_task_import_property ::=
context
dpi_function_proto21,22 ::= function_prototype
dpi_task_proto22 ::= task_prototype
A.2.7 Task declarations
task_declaration ::= [ lifetime ] task_body_declaration
task
task_body_declaration ::=
[ interface_identifier | class_scope ] task_identifier
. ;
1149
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
{ tf_item_declaration }
{ statement_or_null }
[ task_identifier ]
endtask :
| [ interface_identifier | class_scope ] task_identifier [ tf_port_list ]
. ( ) ;
{ block_item_declaration }
{ statement_or_null }
[ task_identifier ]
endtask :
tf_item_declaration ::=
block_item_declaration
| tf_port_declaration
tf_port_list ::=
tf_port_item { tf_port_item }
,
tf_port_item23 ::=
{ attribute_instance }
[ tf_port_direction ] [ ] data_type_or_implicit
var
[ port_identifier { variable_dimension } [ expression ] ]
=
tf_port_direction ::= port_direction |
constref
tf_port_declaration ::=
{ attribute_instance } tf_port_direction [ ] data_type_or_implicit list_of_tf_variable_identifiers
var ;
task_prototype ::= task_identifier [ [ tf_port_list ] ]
task ( )
A.2.8 Block item declarations
block_item_declaration ::=
{ attribute_instance } data_declaration
| { attribute_instance } local_parameter_declaration
;
| { attribute_instance } parameter_declaration
;
| { attribute_instance } let_declaration
A.2.9 Interface declarations
modport_declaration ::= modport_item { modport_item }
modport , ;
modport_item ::= modport_identifier modport_ports_declaration { modport_ports_declaration }
( , )
modport_ports_declaration ::=
{ attribute_instance } modport_simple_ports_declaration
| { attribute_instance } modport_tf_ports_declaration
| { attribute_instance } modport_clocking_declaration
modport_clocking_declaration ::= clocking_identifier
clocking
modport_simple_ports_declaration ::=
port_direction modport_simple_port { modport_simple_port }
,
modport_simple_port ::=
port_identifier
| port_identifier [ expression ]
. ( )
modport_tf_ports_declaration ::=
import_export modport_tf_port { modport_tf_port }
,
modport_tf_port ::=
method_prototype
| tf_identifier
import_export ::= |
import export
1150
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A.2.10 Assertion declarations
concurrent_assertion_item ::=
[ block_identifier ] concurrent_assertion_statement
:
| checker_instantiation
concurrent_assertion_statement ::=
assert_property_statement
| assume_property_statement
| cover_property_statement
| cover_sequence_statement
| restrict_property_statement
assert_property_statement::=
property_spec action_block
assertproperty( )
assume_property_statement::=
property_spec action_block
assumeproperty( )
cover_property_statement::=
property_spec statement_or_null
coverproperty( )
expect_property_statement ::=
property_spec action_block
expect ( )
cover_sequence_statement::=
[clocking_event ] [ expression_or_dist ]
cover sequence ( disable iff ( )
sequence_expr statement_or_null
)
restrict_property_statement::=
property_spec
restrictproperty( );
property_instance ::=
ps_or_hierarchical_property_identifier [ [ property_list_of_arguments ] ]
( )
property_list_of_arguments ::=
[property_actual_arg] { [property_actual_arg] } { identifier [property_actual_arg] }
, , . ( )
| identifier [property_actual_arg] { identifier [property_actual_arg] }
. ( ) , . ( )
property_actual_arg ::=
property_expr
| sequence_actual_arg
assertion_item_declaration ::=
property_declaration
| sequence_declaration
| let_declaration
property_declaration ::=
property_identifier [ [ property_port_list ] ]
property ( ) ;
{ assertion_variable_declaration }
property_spec [ ]
;
[ property_identifier ]
endproperty :
property_port_list ::=
property_port_item { property_port_item}
,
property_port_item ::=
{ attribute_instance } [ [ property_lvar_port_direction ] ] property_formal_type
local
formal_port_identifier {variable_dimension} [ property_actual_arg ]
=
property_lvar_port_direction ::=
input
property_formal_type ::=
sequence_formal_type
|
property
1151
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
property_spec ::=
[clocking_event ] [ expression_or_dist ] property_expr
disable iff( )
property_expr ::=
sequence_expr
| sequence_expr
strong( )
| sequence_expr
weak( )
| property_expr
( )
| property_expr
not
| property_expr property_expr
or
| property_expr property_expr
and
| sequence_expr property_expr
|->
| sequence_expr property_expr
|=>
| ( expression_or_dist ) property_expr [ property_expr ]
if else
| ( expression_or_dist ) property_case_item { property_case_item }
case endcase
| sequence_expr property_expr
#-#
| sequence_expr property_expr
#=#
| property_expr
nexttime
| constant _expression property_expr
nexttime[ ]
| property_expr
s_nexttime
| constant_expression property_expr
s_nexttime[ ]
| property_expr
always
| cycle_delay_const_range_expression property_expr
always[ ]
| constant_range] property_expr
s_always[
| property_expr
s_eventually
| constant_range property_expr
eventually[ ]
| cycle_delay_const_range_expression property_expr
s_eventually[ ]
| property_expr property_expr
until
| property_expr property_expr
s_until
| property_expr property_expr
until_with
| property_expr property_expr
s_until_with
| property_expr property_expr
implies
| property_expr property_expr
iff
| expression_or_dist property_expr
accept_on( )
| expression_or_dist property_expr
reject_on( )
| expression_or_dist property_expr
sync_accept_on( )
| expression_or_dist property_expr
sync_reject_on( )
| property_instance
| clocking_event property_expr
property_case_item ::=
expression_or_dist { expression_or_dist } property_expr
, : ;
| [ ] property_expr
default : ;
sequence_declaration ::=
sequence_identifier [ [ sequence_port_list ] ]
sequence ( ) ;
{ assertion_variable_declaration }
sequence_expr [ ]
;
[ sequence_identifier ]
endsequence :
sequence_port_list ::=
sequence_port_item { sequence_port_item}
,
sequence_port_item ::=
{ attribute_instance } [ [ sequence_lvar_port_direction ] ] sequence_formal_type
local
formal_port_identifier {variable_dimension} [ sequence_actual_arg ]
=
sequence_lvar_port_direction ::= | |
input inout output
1152
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
sequence_formal_type ::=
data_type_or_implicit
|
sequence
|
untyped
sequence_expr ::=
cycle_delay_range sequence_expr { cycle_delay_range sequence_expr }
| sequence_expr cycle_delay_range sequence_expr { cycle_delay_range sequence_expr }
| expression_or_dist [ boolean_abbrev ]
| sequence_instance [ sequence_abbrev ]
| sequence_expr { sequence_match_item } [ sequence_abbrev ]
( , )
| sequence_expr sequence_expr
and
| sequence_expr sequence_expr
intersect
| sequence_expr sequence_expr
or
| sequence_expr { sequence_match_item}
first_match( , )
| expression_or_dist sequence_expr
throughout
| sequence_expr sequence_expr
within
| clocking_event sequence_expr
cycle_delay_range ::=
constant_primary
##
| cycle_delay_const_range_expression
##[ ]
|
##[*]
|
##[+]
sequence_method_call ::=
sequence_instance method_identifier
.
sequence_match_item ::=
operator_assignment
| inc_or_dec_expression
| subroutine_call
sequence_instance ::=
ps_or_hierarchical_sequence_identifier [ [ sequence_list_of_arguments ] ]
( )
sequence_list_of_arguments ::=
[sequence_actual_arg] { [sequence_actual_arg] } { identifier [sequence_actual_arg] }
, , . ( )
| identifier [sequence_actual_arg] { identifier [sequence_actual_arg] }
. ( ) , . ( )
sequence_actual_arg ::=
event_expression
| sequence_expr
boolean_abbrev ::=
consecutive_repetition
| non_consecutive_repetition
| goto_repetition
sequence_abbrev ::= consecutive_repetition
consecutive_repetition ::=
const_or_range_expression
[* ]
|
[*]
|
[+]
non_consecutive_repetition ::= const_or_range_expression
[= ]
goto_repetition ::= const_or_range_expression
[-> ]
const_or_range_expression ::=
constant_expression
| cycle_delay_const_range_expression
1153
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
cycle_delay_const_range_expression ::=
constant_expression constant_expression
:
| constant_expression
: $
expression_or_dist ::= expression [ dist_list ]
dist{ }
assertion_variable_declaration ::=
var_data_type list_of_variable_decl_assignments
;
A.2.11 Covergroup declarations
covergroup_declaration ::=
covergroup_identifier [ [ tf_port_list ] ] [ coverage_event ]
covergroup ( ) ;
{ coverage_spec_or_option }
[ covergroup_identifier ]
endgroup :
coverage_spec_or_option ::=
{attribute_instance} coverage_spec
| {attribute_instance} coverage_option
;
coverage_option ::=
member_identifier expression
option. =
| member_identifier constant_expression
type_option. =
coverage_spec ::=
cover_point
| cover_cross
coverage_event ::=
clocking_event
| [ tf_port_list ]
withfunctionsample( )
| block_event_expression
@@( )
block_event_expression ::=
block_event_expression block_event_expression
or
| hierarchical_btf_identifier
begin
| hierarchical_btf_identifier
end
hierarchical_btf_identifier ::=
hierarchical_tf_identifier
| hierarchical_block_identifier
| [ hierarchical_identifier | class_scope ] method_identifier
.
cover_point ::=
[ [ data_type_or_implicit ] cover_point_identifier ] expression [ expression ]
: coverpoint iff( )
bins_or_empty
bins_or_empty ::=
{attribute_instance} { bins_or_options }
{ ; }
|
;
bins_or_options ::=
coverage_option
| [ ] bins_keyword bin_identifier [ [ covergroup_expression ] ]
wildcard [ ] =
covergroup_range_list [ with_covergroup_expression ]
{ } with( )
[ expression ]
iff( )
| [ ] bins_keyword bin_identifier [ [ covergroup_expression ] ]
wildcard [ ] =
cover_point_identifier with_covergroup_expression [ expression ]
with( ) iff( )
| [ ] bins_keyword bin_identifier [ [ covergroup_expression ] ]
wildcard [ ] =
set_covergroup_expression [ expression ]
iff( )
| [ ] bins_keyword bin_identifier [ ] trans_list [ expression ]
wildcard [ ] = iff( )
1154
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| bins_keyword bin_identifier [ [ covergroup_expression ] ] [ expression ]
[ ] =default iff( )
| bins_keyword bin_identifier [ expression ]
=defaultsequence iff( )
bins_keyword::= | |
bins illegal_bins ignore_bins
trans_list ::= trans_set { trans_set }
( ) ,( )
trans_set ::= trans_range_list { trans_range_list }
=>
trans_range_list ::=
trans_item
| trans_item repeat_range
[* ]
| trans_item repeat_range
[–> ]
| trans_item repeat_range
[= ]
trans_item ::= covergroup_range_list
repeat_range ::=
covergroup_expression
| covergroup_expression covergroup_expression
:
cover_cross ::=
[ cross_identifier ] list_of_cross_items [ expression ] cross_body
: cross iff( )
list_of_cross_items ::= cross_item cross_item { cross_item }
, ,
cross_item ::=
cover_point_identifier
| variable_identifier
cross_body ::=
{ cross_body_item }
{ ; }
|
;
cross_body_item ::=
function_declaraton
| bins_selection_or_option
;
bins_selection_or_option ::=
{ attribute_instance } coverage_option
| { attribute_instance } bins_selection
bins_selection ::= bins_keyword bin_identifier select_expression [ expression ]
= iff( )
select_expression24 ::=
select_condition
| select_condition
!
| select_expression select_expression
&&
| select_expression select_expression
||
| select_expression
( )
| select_expression with_covergroup_expression [ integer_covergroup_expression ]
with( ) matches
| cross_identifier
| cross_set_expression [ integer_covergroup_expression ]
matches
select_condition ::= bins_expression [ covergroup_range_list ]
binsof ( ) intersect{ }
bins_expression ::=
variable_identifier
| cover_point_identifier [ bin_identifier ]
.
covergroup_range_list ::= covergroup_value_range { covergroup_value_range }
,
covergroup_value_range ::=
covergroup_expression
| covergroup_expression covergroup_expression 25
[ : ]
with_covergroup_expression ::= covergroup_expression26
1155
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
set_covergroup_expression ::= covergroup_expression27
integer_covergroup_expression ::= covergroup_expression
cross_set_expression ::= covergroup_expression
covergroup_expression ::= expression28
A.2.12 Let declarations
let_declaration ::=
let_identifier [ [ let_port_list ] ] expression
let ( ) = ;
let_identifier ::=
identifier
let_port_list ::=
let_port_item { let_port_item}
,
let_port_item ::=
{ attribute_instance } let_formal_type formal_port_identifier { variable_dimension } [ expression ]
=
let_formal_type ::=
data_type_or_implicit
|
untyped
let_expression ::=
[ package_scope ] let_identifier [ [ let_list_of_arguments ] ]
( )
let_list_of_arguments ::=
[ let_actual_arg ] { [ let_actual_arg ] } { identifier [ let_actual_arg ] }
, ,. ( )
| identifier [ let_actual_arg ] { identifier [ let_actual_arg ] }
. ( ) ,. ( )
let_actual_arg ::=
expression
A.3 Primitive instances
A.3.1 Primitive instantiation and instances
gate_instantiation ::=
cmos_switchtype [delay3] cmos_switch_instance { cmos_switch_instance }
, ;
| enable_gatetype [drive_strength] [delay3] enable_gate_instance { enable_gate_instance }
, ;
| mos_switchtype [delay3] mos_switch_instance { mos_switch_instance }
, ;
| n_input_gatetype [drive_strength] [delay2] n_input_gate_instance { n_input_gate_instance }
, ;
| n_output_gatetype [drive_strength] [delay2] n_output_gate_instance
{ n_output_gate_instance }
, ;
| pass_en_switchtype [delay2] pass_enable_switch_instance { pass_enable_switch_instance }
, ;
| pass_switchtype pass_switch_instance { pass_switch_instance }
, ;
| [pulldown_strength] pull_gate_instance { pull_gate_instance }
pulldown , ;
| [pullup_strength] pull_gate_instance { pull_gate_instance }
pullup , ;
cmos_switch_instance ::= [ name_of_instance ] output_terminal input_terminal
( , ,
ncontrol_terminal pcontrol_terminal
, )
enable_gate_instance ::= [ name_of_instance ] output_terminal input_terminal enable_terminal
( , , )
mos_switch_instance ::= [ name_of_instance ] output_terminal input_terminal enable_terminal
( , , )
n_input_gate_instance ::= [ name_of_instance ] output_terminal input_terminal { input_terminal }
( , , )
n_output_gate_instance ::= [ name_of_instance ] output_terminal { output_terminal }
( , ,
1156
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
input_terminal
)
pass_switch_instance ::= [ name_of_instance ] inout_terminal inout_terminal
( , )
pass_enable_switch_instance ::= [ name_of_instance ] inout_terminal inout_terminal
( , ,
enable_terminal
)
pull_gate_instance ::= [ name_of_instance ] output_terminal
( )
A.3.2 Primitive strengths
pulldown_strength ::=
strength0 strength1
( , )
| strength1 strength0
( , )
| strength0
( )
pullup_strength ::=
strength0 strength1
( , )
| strength1 strength0
( , )
| strength1
( )
A.3.3 Primitive terminals
enable_terminal ::= expression
inout_terminal ::= net_lvalue
input_terminal ::= expression
ncontrol_terminal ::= expression
output_terminal ::= net_lvalue
pcontrol_terminal ::= expression
A.3.4 Primitive gate and switch types
cmos_switchtype ::= |
cmos rcmos
enable_gatetype ::= | | |
bufif0 bufif1 notif0 notif1
mos_switchtype ::= | | |
nmos pmos rnmos rpmos
n_input_gatetype ::= | | | | |
and nand or nor xor xnor
n_output_gatetype ::= |
buf not
pass_en_switchtype ::= | | |
tranif0 tranif1 rtranif1 rtranif0
pass_switchtype ::= |
tran rtran
A.4 Instantiations
A.4.1 Instantiation
A.4.1.1 Module instantiation
module_instantiation ::=
module_identifier [ parameter_value_assignment ] hierarchical_instance { hierarchical_instance }
, ;
parameter_value_assignment ::= [ list_of_parameter_assignments ]
# ( )
list_of_parameter_assignments ::=
ordered_parameter_assignment { ordered_parameter_assignment }
,
1157
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| named_parameter_assignment { named_parameter_assignment }
,
ordered_parameter_assignment ::= param_expression
named_parameter_assignment ::= parameter_identifier [ param_expression ]
. ( )
hierarchical_instance ::= name_of_instance [ list_of_port_connections ]
( )
name_of_instance ::= instance_identifier { unpacked_dimension }
list_of_port_connections29 ::=
ordered_port_connection { ordered_port_connection }
,
| named_port_connection { named_port_connection }
,
ordered_port_connection ::= { attribute_instance } [ expression ]
named_port_connection ::=
{ attribute_instance } port_identifier [ [ expression ] ]
. ( )
| { attribute_instance }
.*
A.4.1.2 Interface instantiation
interface_instantiation ::=
interface_identifier [ parameter_value_assignment ] hierarchical_instance { hierarchical_instance }
, ;
A.4.1.3 Program instantiation
program_instantiation ::=
program_identifier [ parameter_value_assignment ] hierarchical_instance { hierarchical_instance }
, ;
A.4.1.4 Checker instantiation
checker_instantiation ::=
ps_checker_identifier name_of_instance [list_of_checker_port_connections]
( );
list_of_checker_port_connections29 ::=
ordered_checker_port_connection { ordered_checker_port_connection }
,
| named_checker_port_connection { named_checker_port_connection }
,
ordered_checker_port_connection ::= { attribute_instance } [ property_actual_arg ]
named_checker_port_connection ::=
{ attribute_instance } formal_port_identifier [ [ property_actual_arg ] ]
. ( )
| { attribute_instance }
.*
A.4.2 Generated instantiation
generate_region ::=
{ generate_item }
generate endgenerate
loop_generate_construct ::=
genvar_initialization genvar_expression genvar_iteration
for( ; ; )
generate_block
genvar_initialization ::=
[ ] genvar_identifier constant_expression
genvar =
genvar_iteration ::=
genvar_identifier assignment_operator genvar_expression
| inc_or_dec_operator genvar_identifier
| genvar_identifier inc_or_dec_operator
conditional_generate_construct ::=
if_generate_construct
| case_generate_construct
1158
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
if_generate_construct ::=
constant_expression generate_block [ generate_block ]
if( ) else
case_generate_construct ::=
constant_expression case_generate_item { case_generate_item }
case( ) endcase
case_generate_item ::=
constant_expression { constant_expression } generate_block
, :
| [ ] generate_block
default :
generate_block ::=
generate_item
| [ generate_block_identifier ] [ generate_block_identifier ]
: begin :
{ generate_item }
[ generate_block_identifier ]
end :
generate_item30 ::=
module_or_generate_item
| interface_or_generate_item
| checker_or_generate_item
A.5 UDP declaration and instantiation
A.5.1 UDP declaration
udp_nonansi_declaration ::=
{ attribute_instance } udp_identifier udp_port_list
primitive ( ) ;
udp_ansi_declaration ::=
{ attribute_instance } udp_identifier udp_declaration_port_list
primitive ( ) ;
udp_declaration ::=
udp_nonansi_declaration udp_port_declaration { udp_port_declaration }
udp_body
[ udp_identifier ]
endprimitive :
| udp_ansi_declaration
udp_body
[ udp_identifier ]
endprimitive :
| udp_nonansi_declaration
extern
| udp_ansi_declaration
extern
| { attribute_instance } udp_identifier
primitive ( .* ) ;
{ udp_port_declaration }
udp_body
[ udp_identifier ]
endprimitive :
A.5.2 UDP ports
udp_port_list ::= output_port_identifier input_port_identifier { input_port_identifier }
, ,
udp_declaration_port_list ::= udp_output_declaration udp_input_declaration { udp_input_declaration }
, ,
udp_port_declaration ::=
udp_output_declaration
;
| udp_input_declaration
;
| udp_reg_declaration
;
udp_output_declaration ::=
{ attribute_instance } port_identifier
output
1159
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| { attribute_instance } port_identifier [ constant_expression ]
outputreg =
udp_input_declaration ::= { attribute_instance } list_of_udp_port_identifiers
input
udp_reg_declaration ::= { attribute_instance } variable_identifier
reg
A.5.3 UDP body
udp_body ::= combinational_body | sequential_body
combinational_body ::= combinational_entry { combinational_entry }
table endtable
combinational_entry ::= level_input_list output_symbol
: ;
sequential_body ::= [ udp_initial_statement ] sequential_entry { sequential_entry }
table endtable
udp_initial_statement ::= output_port_identifier init_val
initial = ;
init_val ::= | | | | | | | | |
1'b0 1'b1 1'bx 1'bX 1'B0 1'B1 1'Bx 1'BX 1 0
sequential_entry ::= seq_input_list current_state next_state
: : ;
seq_input_list ::= level_input_list | edge_input_list
level_input_list ::= level_symbol { level_symbol }
edge_input_list ::= { level_symbol } edge_indicator { level_symbol }
edge_indicator ::= level_symbol level_symbol | edge_symbol
( )
current_state ::= level_symbol
next_state ::= output_symbol |
-
output_symbol ::= | | |
0 1 x X
level_symbol ::= | | | | | |
0 1 x X ? b B
edge_symbol ::= | | | | | | | |
r R f F p P n N *
A.5.4 UDP instantiation
udp_instantiation ::= udp_identifier [ drive_strength ] [ delay2 ] udp_instance { udp_instance }
, ;
udp_instance ::= [ name_of_instance ] output_terminal input_terminal { input_terminal }
( , , )
A.6 Behavioral statements
A.6.1 Continuous assignment and net alias statements
continuous_assign ::=
[ drive_strength ] [ delay3 ] list_of_net_assignments
assign ;
| [ delay_control ] list_of_variable_assignments
assign ;
list_of_net_assignments ::= net_assignment { net_assignment }
,
list_of_variable_assignments ::= variable_assignment { variable_assignment }
,
net_alias ::= net_lvalue net_lvalue { net_lvalue }
alias = = ;
net_assignment ::= net_lvalue expression
=
1160
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A.6.2 Procedural blocks and assignments
initial_construct ::= statement_or_null
initial
always_construct ::= always_keyword statement
always_keyword ::= | | |
always always_comb always_latch always_ff
final_construct ::= function_statement
final
blocking_assignment ::=
variable_lvalue delay_or_event_control expression
=
| nonrange_variable_lvalue dynamic_array_new
=
| [ implicit_class_handle | class_scope | package_scope ] hierarchical_variable_identifier
.
select class_new
=
| operator_assignment
operator_assignment ::= variable_lvalue assignment_operator expression
assignment_operator ::=
| | | | | | | | | | | |
= += -= *= /= %= &= |= ^= <<= >>= <<<= >>>=
nonblocking_assignment ::=
variable_lvalue [ delay_or_event_control ] expression
<=
procedural_continuous_assignment ::=
variable_assignment
assign
| variable_lvalue
deassign
| variable_assignment
force
| net_assignment
force
| variable_lvalue
release
| net_lvalue
release
variable_assignment ::= variable_lvalue expression
=
A.6.3 Parallel and sequential blocks
action_block ::=
statement_or_null
| [ statement ] statement_or_null
else
seq_block ::=
[ block_identifier ] { block_item_declaration } { statement_or_null }
begin :
[ block_identifier ]
end :
par_block ::=
[ block_identifier ] { block_item_declaration } { statement_or_null }
fork :
join_keyword [ block_identifier ]
:
join_keyword ::= | |
join join_any join_none
A.6.4 Statements
statement_or_null ::=
statement
| { attribute_instance }
;
statement ::= [ block_identifier ] { attribute_instance } statement_item
:
statement_item ::=
blocking_assignment
;
| nonblocking_assignment
;
| procedural_continuous_assignment
;
1161
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| case_statement
| conditional_statement
| inc_or_dec_expression
;
| subroutine_call_statement
| disable_statement
| event_trigger
| loop_statement
| jump_statement
| par_block
| procedural_timing_control_statement
| seq_block
| wait_statement
| procedural_assertion_statement
| clocking_drive
;
| randsequence_statement
| randcase_statement
| expect_property_statement
function_statement ::= statement
function_statement_or_null ::=
function_statement
| { attribute_instance }
;
variable_identifier_list ::= variable_identifier { variable_identifier }
,
A.6.5 Timing control statements
procedural_timing_control_statement ::=
procedural_timing_control statement_or_null
delay_or_event_control ::=
delay_control
| event_control
| expression event_control
repeat( )
delay_control ::=
delay_value
#
| mintypmax_expression
# ( )
event_control ::=
hierarchical_event_identifier
@
| event_expression
@ ( )
|
@*
|
@ (*)
| ps_or_hierarchical_sequence_identifier
@
event_expression31 ::=
[ edge_identifier ] expression [ expression ]
iff
| sequence_instance [ expression ]
iff
| event_expression event_expression
or
| event_expression event_expression
,
| event_expression
( )
procedural_timing_control ::=
delay_control
| event_control
| cycle_delay
jump_statement ::=
1162
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
[ expression ]
return ;
|
break ;
|
continue ;
wait_statement ::=
expression statement_or_null
wait ( )
|
wait fork ;
| hierarchical_identifier { hierarchical_identifier } action_block
wait_order( , )
event_trigger ::=
hierarchical_event_identifier
-> ;
| [ delay_or_event_control ] hierarchical_event_identifier
->> ;
disable_statement ::=
hierarchical_task_identifier
disable ;
| hierarchical_block_identifier
disable ;
|
disable fork ;
A.6.6 Conditional statements
conditional_statement ::=
[ unique_priority ] cond_predicate statement_or_null
if( )
{ cond_predicate statement_or_null }
elseif( )
[ statement_or_null ]
else
unique_priority ::= | |
unique unique0 priority
cond_predicate ::=
expression_or_cond_pattern { expression_or_cond_pattern }
&&&
expression_or_cond_pattern ::=
expression | cond_pattern
cond_pattern ::= expression pattern
matches
A.6.7 Case statements
case_statement ::=
[ unique_priority ] case_keyword case_expression
( )
case_item { case_item }
endcase
| [ unique_priority ] case_keyword case_expression
( )matches
case_pattern_item { case_pattern_item }
endcase
| [ unique_priority ] case_expression
case( )inside
case_inside_item { case_inside_item }
endcase
case_keyword ::= | |
case casez casex
case_expression ::= expression
case_item ::=
case_item_expression { case_item_expression } statement_or_null
, :
| [ ] statement_or_null
default :
case_pattern_item ::=
pattern [ expression ] statement_or_null
&&& :
| [ ] statement_or_null
default :
case_inside_item ::=
open_range_list statement_or_null
:
| [ ] statement_or_null
default :
case_item_expression ::= expression
1163
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
randcase_statement ::=
randcase_item { randcase_item }
randcase endcase
randcase_item ::= expression statement_or_null
:
open_range_list ::= open_value_range { open_value_range }
,
open_value_range ::= value_range25
A.6.7.1 Patterns
pattern ::=
variable_identifier
.
|
.*
| constant_expression
| member_identifier [ pattern ]
tagged
| pattern { pattern }
'{ , }
| member_identifier pattern { member_identifier pattern }
'{ : , : }
assignment_pattern ::=
expression { expression }
'{ , }
| structure_pattern_key expression { structure_pattern_key expression }
'{ : , : }
| array_pattern_key expression { array_pattern_key expression }
'{ : , : }
| constant_expression expression { expression }
'{ { , }}
structure_pattern_key ::= member_identifier | assignment_pattern_key
array_pattern_key ::= constant_expression | assignment_pattern_key
assignment_pattern_key ::= simple_type |
default
assignment_pattern_expression ::=
[ assignment_pattern_expression_type ] assignment_pattern
assignment_pattern_expression_type ::=
ps_type_identifier
| ps_parameter_identifier
| integer_atom_type
|type_reference
constant_assignment_pattern_expression32 ::= assignment_pattern_expression
assignment_pattern_net_lvalue ::=
net_lvalue { net_lvalue }
'{ , }
assignment_pattern_variable_lvalue ::=
variable_lvalue { variable_lvalue }
'{ , }
A.6.8 Looping statements
loop_statement ::=
statement_or_null
forever
| expression statement_or_null
repeat( )
| expression statement_or_null
while( )
| [ for_initialization ] [ expression ] [ for_step ]
for ( ; ; )
statement_or_null
| statement_or_null expression
do while( );
| ps_or_hierarchical_array_identifier loop_variables statement
foreach( [ ])
for_initialization ::=
list_of_variable_assignments
| for_variable_declaration { for_variable_declaration }
,
for_variable_declaration ::=
1164
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
[ ] data_type variable_identifier expression { variable_identifier expression }14
var = , =
for_step ::= for_step_assignment { for_step_assignment }
,
for_step_assignment ::=
operator_assignment
| inc_or_dec_expression
| function_subroutine_call
loop_variables ::= [ index_variable_identifier ] { [ index_variable_identifier ] }
,
A.6.9 Subroutine call statements
subroutine_call_statement ::=
subroutine_call
;
| function_subroutine_call
void'( ) ;
A.6.10 Assertion statements
assertion_item ::=
concurrent_assertion_item
| deferred_immediate_assertion_item
deferred_immediate_assertion_item ::= [ block_identifier ] deferred_immediate_assertion_statement
:
procedural_assertion_statement ::=
concurrent_assertion_statement
| immediate_assertion_statement
| checker_instantiation
immediate_assertion_statement ::=
simple_immediate_assertion_statement
| deferred_immediate_assertion_statement
simple_immediate_assertion_statement ::=
simple_immediate_assert_statement
| simple_immediate_assume_statement
| simple_immediate_cover_statement
simple_immediate_assert_statement ::=
expression action_block
assert( )
simple_immediate_assume_statement ::=
expression action_block
assume( )
simple_immediate_cover_statement ::=
expression statement_or_null
cover( )
deferred_immediate_assertion_statement ::=
deferred_immediate_assert_statement
| deferred_immediate_assume_statement
| deferred_immediate_cover_statement
deferred_immediate_assert_statement ::=
expression action_block
assert#0( )
| expression action_block
assertfinal( )
deferred_immediate_assume_statement ::=
expression action_block
assume#0( )
| expression action_block
assumefinal( )
deferred_immediate_cover_statement ::=
expression statement_or_null
cover#0( )
| expression statement_or_null
coverfinal( )
1165
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A.6.11 Clocking block
clocking_declaration ::= [ ] [ clocking_identifier ] clocking_event
default clocking ;
{ clocking_item }
[ clocking_identifier ]
endclocking :
| [ clocking_identifier ] clocking_event [ clocking_identifier ]
globalclocking ;endclocking :
clocking_event ::=
identifier
@
| event_expression
@ ( )
clocking_item ::=
default_skew
default ;
| clocking_direction list_of_clocking_decl_assign
;
| { attribute_instance } assertion_item_declaration
default_skew ::=
clocking_skew
input
| clocking_skew
output
| clocking_skew clocking_skew
input output
clocking_direction ::=
[ clocking_skew ]
input
| [ clocking_skew ]
output
| [ clocking_skew ] [ clocking_skew ]
input output
|
inout
list_of_clocking_decl_assign ::= clocking_decl_assign { clocking_decl_assign }
,
clocking_decl_assign ::= signal_identifier [ expression ]
=
clocking_skew ::=
edge_identifier [ delay_control ]
| delay_control
clocking_drive ::=
clockvar_expression [ cycle_delay ] expression
<=
cycle_delay ::=
integral_number
##
| identifier
##
| expression
## ( )
clockvar ::= hierarchical_identifier
clockvar_expression ::= clockvar select
A.6.12 Randsequence
randsequence_statement ::= [ production_identifier ]
randsequence ( )
production { production }
endsequence
production ::= [ data_type_or_void ] production_identifier [ tf_port_list ] rs_rule { rs_rule }
( ) : | ;
rs_rule ::= rs_production_list [ weight_specification [ rs_code_block ] ]
:=
rs_production_list ::=
rs_prod { rs_prod }
| [ expression ] production_item production_item { production_item }
rand join ( )
weight_specification ::=
integral_number
| ps_identifier
1166
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| expression
( )
rs_code_block ::= { data_declaration } { statement_or_null }
{ }
rs_prod ::=
production_item
| rs_code_block
| rs_if_else
| rs_repeat
| rs_case
production_item ::= production_identifier [ list_of_arguments ]
( )
rs_if_else ::= expression production_item [ production_item ]
if ( ) else
rs_repeat ::= expression production_item
repeat ( )
rs_case ::= case_expression rs_case_item { rs_case_item }
case ( ) endcase
rs_case_item ::=
case_item_expression { case_item_expression } production_item
, : ;
| [ ] production_item
default : ;
A.7 Specify section
A.7.1 Specify block declaration
specify_block ::= { specify_item }
specify endspecify
specify_item ::=
specparam_declaration
| pulsestyle_declaration
| showcancelled_declaration
| path_declaration
| system_timing_check
pulsestyle_declaration ::=
list_of_path_outputs
pulsestyle_onevent ;
| list_of_path_outputs
pulsestyle_ondetect ;
showcancelled_declaration ::=
list_of_path_outputs
showcancelled ;
| list_of_path_outputs
noshowcancelled ;
A.7.2 Specify path declarations
path_declaration ::=
simple_path_declaration
;
| edge_sensitive_path_declaration
;
| state_dependent_path_declaration
;
simple_path_declaration ::=
parallel_path_description path_delay_value
=
| full_path_description path_delay_value
=
parallel_path_description ::=
specify_input_terminal_descriptor [ polarity_operator ] specify_output_terminal_descriptor
( => )
full_path_description ::=
list_of_path_inputs [ polarity_operator ] list_of_path_outputs
( *> )
list_of_path_inputs ::=
1167
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
specify_input_terminal_descriptor { specify_input_terminal_descriptor }
,
list_of_path_outputs ::=
specify_output_terminal_descriptor { specify_output_terminal_descriptor }
,
A.7.3 Specify block terminals
specify_input_terminal_descriptor ::=
input_identifier [ constant_range_expression ]
[ ]
specify_output_terminal_descriptor ::=
output_identifier [ constant_range_expression ]
[ ]
input_identifier ::= input_port_identifier | inout_port_identifier | interface_identifier port_identifier
.
output_identifier ::= output_port_identifier | inout_port_identifier | interface_identifier port_identifier
.
A.7.4 Specify path delays
path_delay_value ::=
list_of_path_delay_expressions
| list_of_path_delay_expressions
( )
list_of_path_delay_expressions ::=
t_path_delay_expression
| trise_path_delay_expression tfall_path_delay_expression
,
| trise_path_delay_expression tfall_path_delay_expression tz_path_delay_expression
, ,
| t01_path_delay_expression t10_path_delay_expression t0z_path_delay_expression
, , ,
tz1_path_delay_expression t1z_path_delay_expression tz0_path_delay_expression
, ,
| t01_path_delay_expression t10_path_delay_expression t0z_path_delay_expression
, , ,
tz1_path_delay_expression t1z_path_delay_expression tz0_path_delay_expression
, , ,
t0x_path_delay_expression tx1_path_delay_expression t1x_path_delay_expression
, , ,
tx0_path_delay_expression txz_path_delay_expression tzx_path_delay_expression
, ,
t_path_delay_expression ::= path_delay_expression
trise_path_delay_expression ::= path_delay_expression
tfall_path_delay_expression ::= path_delay_expression
tz_path_delay_expression ::= path_delay_expression
t01_path_delay_expression ::= path_delay_expression
t10_path_delay_expression ::= path_delay_expression
t0z_path_delay_expression ::= path_delay_expression
tz1_path_delay_expression ::= path_delay_expression
t1z_path_delay_expression ::= path_delay_expression
tz0_path_delay_expression ::= path_delay_expression
t0x_path_delay_expression ::= path_delay_expression
tx1_path_delay_expression ::= path_delay_expression
t1x_path_delay_expression ::= path_delay_expression
tx0_path_delay_expression ::= path_delay_expression
txz_path_delay_expression ::= path_delay_expression
tzx_path_delay_expression ::= path_delay_expression
path_delay_expression ::= constant_mintypmax_expression
edge_sensitive_path_declaration ::=
parallel_edge_sensitive_path_description path_delay_value
=
1168
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| full_edge_sensitive_path_description path_delay_value
=
parallel_edge_sensitive_path_description ::=
[ edge_identifier ] specify_input_terminal_descriptor [ polarity_operator ]
( =>
specify_output_terminal_descriptor [ polarity_operator ] data_source_expression
( : ))
full_edge_sensitive_path_description ::=
[ edge_identifier ] list_of_path_inputs [ polarity_operator ]
( *>
list_of_path_outputs [ polarity_operator ] data_source_expression
( : ))
data_source_expression ::= expression
edge_identifier ::= | |
posedge negedge edge
state_dependent_path_declaration ::=
module_path_expression simple_path_declaration
if( )
| module_path_expression edge_sensitive_path_declaration
if( )
| simple_path_declaration
ifnone
polarity_operator ::= |
+ -
A.7.5 System timing checks
A.7.5.1 System timing check commands
system_timing_check ::=
$setup_timing_check
| $hold_timing_check
| $setuphold_timing_check
| $recovery_timing_check
| $removal_timing_check
| $recrem_timing_check
| $skew_timing_check
| $timeskew_timing_check
| $fullskew_timing_check
| $period_timing_check
| $width_timing_check
| $nochange_timing_check
$setup_timing_check ::=
data_event reference_event timing_check_limit [ [ notifier ] ]
$setup ( , , , ) ;
$hold_timing_check ::=
reference_event data_event timing_check_limit [ [ notifier ] ]
$hold ( , , , ) ;
$setuphold_timing_check ::=
reference_event data_event timing_check_limit timing_check_limit
$setuphold ( , , ,
[ [ notifier ] [ [ timestamp_condition ] [ [ timecheck_condition ]
, , ,
[ [ delayed_reference ] [ [ delayed_data ] ] ] ] ] ]
, , ) ;
$recovery_timing_check ::=
reference_event data_event timing_check_limit [ [ notifier ] ]
$recovery ( , , , ) ;
$removal_timing_check ::=
reference_event data_event timing_check_limit [ [ notifier ] ]
$removal ( , , , ) ;
$recrem_timing_check ::=
reference_event data_event timing_check_limit timing_check_limit
$recrem ( , , ,
[ [ notifier ] [ [ timestamp_condition ] [ [ timecheck_condition ]
, , ,
[ [ delayed_reference ] [ [ delayed_data ] ] ] ] ] ]
, , ) ;
$skew_timing_check ::=
reference_event data_event timing_check_limit [ [ notifier ] ]
$skew ( , , , ) ;
1169
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
$timeskew_timing_check ::=
reference_event data_event timing_check_limit
$timeskew ( , ,
[ [ notifier ] [ [ event_based_flag ] [ [ remain_active_flag ] ] ] ]
, , , ) ;
$fullskew_timing_check ::=
reference_event data_event timing_check_limit timing_check_limit
$fullskew ( , , ,
[ [ notifier ] [ [ event_based_flag ] [ [ remain_active_flag ] ] ] ]
, , , ) ;
$period_timing_check ::=
controlled_reference_event timing_check_limit [ [ notifier ] ]
$period ( , , ) ;
$width_timing_check ::=
controlled_reference_event timing_check_limit threshold [ [ notifier ] ]
$width ( , , , ) ;
$nochange_timing_check ::=
reference_event data_event start_edge_offset end_edge_offset [ [ notifier ] ]
$nochange( , , , , );
A.7.5.2 System timing check command arguments
timecheck_condition ::= mintypmax_expression
controlled_reference_event ::= controlled_timing_check_event
data_event ::= timing_check_event
delayed_data ::=
terminal_identifier
| terminal_identifier constant_mintypmax_expression
[ ]
delayed_reference ::=
terminal_identifier
| terminal_identifier constant_mintypmax_expression
[ ]
end_edge_offset ::= mintypmax_expression
event_based_flag ::= constant_expression
notifier ::= variable_identifier
reference_event ::= timing_check_event
remain_active_flag ::= constant_mintypmax_expression
timestamp_condition ::= mintypmax_expression
start_edge_offset ::= mintypmax_expression
threshold ::= constant_expression
timing_check_limit ::= expression
A.7.5.3 System timing check event definitions
timing_check_event ::=
[timing_check_event_control] specify_terminal_descriptor [ timing_check_condition ]
&&&
controlled_timing_check_event ::=
timing_check_event_control specify_terminal_descriptor [ timing_check_condition ]
&&&
timing_check_event_control ::=
posedge
|
negedge
|
edge
| edge_control_specifier
specify_terminal_descriptor ::=
specify_input_terminal_descriptor
| specify_output_terminal_descriptor
edge_control_specifier ::= edge_descriptor { edge_descriptor }
edge[ , ]
1170
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
edge_descriptor33 ::= | | z_or_x zero_or_one | zero_or_one z_or_x
01 10
zero_or_one ::= |
0 1
z_or_x ::= | | |
x X z Z
timing_check_condition ::=
scalar_timing_check_condition
| scalar_timing_check_condition
( )
scalar_timing_check_condition ::=
expression
| expression
~
| expression scalar_constant
==
| expression scalar_constant
===
| expression scalar_constant
!=
| expression scalar_constant
!==
scalar_constant ::= | | | | | | | | |
1'b0 1'b1 1'B0 1'B1 'b0 'b1 'B0 'B1 1 0
A.8 Expressions
A.8.1 Concatenations
concatenation ::=
expression { expression }
{ , }
constant_concatenation ::=
constant_expression { constant_expression }
{ , }
constant_multiple_concatenation ::= constant_expression constant_concatenation
{ }
module_path_concatenation ::= module_path_expression { module_path_expression }
{ , }
module_path_multiple_concatenation ::= constant_expression module_path_concatenation
{ }
multiple_concatenation ::= expression concatenation 34
{ }
streaming_concatenation ::= stream_operator [ slice_size ] stream_concatenation
{ }
stream_operator ::= |
>> <<
slice_size ::= simple_type | constant_expression
stream_concatenation ::= stream_expression { stream_expression }
{ , }
stream_expression ::= expression [ array_range_expression ]
with[ ]
array_range_expression ::=
expression
| expression expression
:
| expression expression
+:
| expression expression
-:
empty_unpacked_array_concatenation35 ::=
{ }
A.8.2 Subroutine calls
constant_function_call ::= function_subroutine_call36
tf_call37 ::= ps_or_hierarchical_tf_identifier { attribute_instance } [ list_of_arguments ]
( )
system_tf_call ::=
system_tf_identifier [ list_of_arguments ]
( )
1171
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| system_tf_identifier data_type [ expression ]
( , )
| system_tf_identifier expression { [ expression ] } [ [ clocking_event ] ]
( , , )
subroutine_call ::=
tf_call
| system_tf_call
| method_call
| [ ] randomize_call
std ::
function_subroutine_call ::= subroutine_call
list_of_arguments ::=
[ expression ] { [ expression ] } { identifier [ expression ] }
, ,. ( )
| identifier [ expression ] { identifier [ expression ] }
. ( ) ,. ( )
method_call ::= method_call_root method_call_body
.
method_call_body ::=
method_identifier { attribute_instance } [ list_of_arguments ]
( )
| built_in_method_call
built_in_method_call ::=
array_manipulation_call
| randomize_call
array_manipulation_call ::=
array_method_name { attribute_instance }
[ list_of_arguments ]
( )
[ expression ]
with( )
randomize_call ::=
{ attribute_instance }
randomize
[ [ variable_identifier_list | ] ]
( null )
[ [ [ identifier_list ] ] constraint_block ]38
with ( )
method_call_root ::= primary | implicit_class_handle
array_method_name ::=
method_identifier | | | |
unique and or xor
A.8.3 Expressions
inc_or_dec_expression ::=
inc_or_dec_operator { attribute_instance } variable_lvalue
| variable_lvalue { attribute_instance } inc_or_dec_operator
conditional_expression ::= cond_predicate { attribute_instance } expression expression
? :
constant_expression ::=
constant_primary
| unary_operator { attribute_instance } constant_primary
| constant_expression binary_operator { attribute_instance } constant_expression
| constant_expression { attribute_instance } constant_expression constant_expression
? :
constant_mintypmax_expression ::=
constant_expression
| constant_expression constant_expression constant_expression
: :
constant_param_expression ::=
constant_mintypmax_expression | data_type |
$
param_expression ::= mintypmax_expression | data_type |
$
constant_range_expression ::=
constant_expression
1172
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| constant_part_select_range
constant_part_select_range ::=
constant_range
| constant_indexed_range
constant_range ::= constant_expression constant_expression
:
constant_indexed_range ::=
constant_expression constant_expression
+:
| constant_expression constant_expression
-:
expression ::=
primary
| unary_operator { attribute_instance } primary
| inc_or_dec_expression
| operator_assignment
( )
| expression binary_operator { attribute_instance } expression
| conditional_expression
| inside_expression
| tagged_union_expression
tagged_union_expression ::=
member_identifier [ expression ]
tagged
inside_expression ::= expression open_range_list
inside{ }
value_range ::=
expression
| expression expression
[ : ]
mintypmax_expression ::=
expression
| expression expression expression
: :
module_path_conditional_expression ::= module_path_expression { attribute_instance }
?
module_path_expression module_path_expression
:
module_path_expression ::=
module_path_primary
| unary_module_path_operator { attribute_instance } module_path_primary
| module_path_expression binary_module_path_operator { attribute_instance }
module_path_expression
| module_path_conditional_expression
module_path_mintypmax_expression ::=
module_path_expression
| module_path_expression module_path_expression module_path_expression
: :
part_select_range ::= constant_range | indexed_range
indexed_range ::=
expression constant_expression
+:
| expression constant_expression
-:
genvar_expression ::= constant_expression
A.8.4 Primaries
constant_primary ::=
primary_literal
| ps_parameter_identifier constant_select
| specparam_identifier [ constant_range_expression ]
[ ]
1173
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| genvar_identifier39
| formal_port_identifier constant_select
| [ package_scope | class_scope ] enum_identifier
| constant_concatenation [ constant_range_expression ]
[ ]
| constant_multiple_concatenation [ constant_range_expression ]
[ ]
| constant_function_call
| constant_let_expression
| constant_mintypmax_expression
( )
| constant_cast
| constant_assignment_pattern_expression
| type_reference40
|
null
module_path_primary ::=
number
| identifier
| module_path_concatenation
| module_path_multiple_concatenation
| function_subroutine_call
| module_path_mintypmax_expression
( )
primary ::=
primary_literal
| [ class_qualifier | package_scope ] hierarchical_identifier select
| empty_unpacked_array_concatenation
| concatenation [ range_expression ]
[ ]
| multiple_concatenation [ range_expression ]
[ ]
| function_subroutine_call
| let_expression
| mintypmax_expression
( )
| cast
| assignment_pattern_expression
| streaming_concatenation
| sequence_method_call
| 41
this
| 42
$
|
null
class_qualifier := [ 43 ] [ implicit_class_handle | class_scope ]
local:: .
range_expression ::=
expression
| part_select_range
primary_literal ::= number | time_literal | unbased_unsized_literal | string_literal
time_literal44 ::=
unsigned_number time_unit
| fixed_point_number time_unit
time_unit ::= | | | | |
s ms us ns ps fs
implicit_class_handle41 ::= | |
this super this . super
bit_select ::= { expression }
[ ]
select ::=
[ { member_identifier bit_select } member_identifier ] bit_select [ part_select_range ]
. . [ ]
nonrange_select ::=
1174
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
[ { member_identifier bit_select } member_identifier ] bit_select
. .
constant_bit_select ::= { constant_expression }
[ ]
constant_select ::=
[ { member_identifier constant_bit_select } member_identifier ] constant_bit_select
. .
[ constant_part_select_range ]
[ ]
constant_cast ::=
casting_type constant_expression
' ( )
constant_let_expression ::= let_expression45
cast ::=
casting_type expression
' ( )
A.8.5 Expression left-side values
net_lvalue ::=
ps_or_hierarchical_net_identifier constant_select
| net_lvalue { net_lvalue }
{ , }
| [ assignment_pattern_expression_type ] assignment_pattern_net_lvalue
variable_lvalue ::=
[ implicit_class_handle | package_scope ] hierarchical_variable_identifier select46
.
| variable_lvalue { variable_lvalue }
{ , }
| [ assignment_pattern_expression_type ] assignment_pattern_variable_lvalue
| streaming_concatenation47
nonrange_variable_lvalue ::=
[ implicit_class_handle | package_scope ] hierarchical_variable_identifier nonrange_select
.
A.8.6 Operators
unary_operator ::=
| | | | | | | | | |
+ - ! ~ & ~& | ~| ^ ~^ ^~
binary_operator ::=
| | | | | | | | | | | | |
+ - * / % == != === !== ==? !=? && || **
| | | | | | | | | | | | |
< <= > >= & | ^ ^~ ~^ >> << >>> <<<
| |
-> <->
inc_or_dec_operator ::= |
++ --
unary_module_path_operator ::=
| | | | | | | |
! ~ & ~& | ~| ^ ~^ ^~
binary_module_path_operator ::=
| | | | | | | |
== != && || & | ^ ^~ ~^
A.8.7 Numbers
number ::=
integral_number
| real_number
integral_number ::=
decimal_number
| octal_number
| binary_number
1175
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| hex_number
decimal_number ::=
unsigned_number
| [ size ] decimal_base unsigned_number
| [ size ] decimal_base x_digit { }
_
| [ size ] decimal_base z_digit { }
_
binary_number ::= [ size ] binary_base binary_value
octal_number ::= [ size ] octal_base octal_value
hex_number ::= [ size ] hex_base hex_value
sign ::= |
+ -
size ::= non_zero_unsigned_number
non_zero_unsigned_number33 ::= non_zero_decimal_digit { | decimal_digit}
_
real_number33 ::=
fixed_point_number
| unsigned_number [ unsigned_number ] exp [ sign ] unsigned_number
.
fixed_point_number33 ::= unsigned_number unsigned_number
.
exp ::= |
e E
unsigned_number33 ::= decimal_digit { | decimal_digit }
_
binary_value33 ::= binary_digit { | binary_digit }
_
octal_value33 ::= octal_digit { | octal_digit }
_
hex_value33 ::= hex_digit { | hex_digit }
_
decimal_base33 ::= [ | ] | [ | ]
' sS d ' sS D
binary_base33 ::= [ | ] | [ | ]
' sS b ' sS B
octal_base33 ::= [ | ] | [ | ]
' sS o ' sS O
hex_base33 ::= [ | ] | [ | ]
' sS h ' sS H
non_zero_decimal_digit ::= | | | | | | | |
1 2 3 4 5 6 7 8 9
decimal_digit ::= | | | | | | | | |
0 1 2 3 4 5 6 7 8 9
binary_digit ::= x_digit | z_digit | |
0 1
octal_digit ::= x_digit | z_digit | | | | | | | |
0 1 2 3 4 5 6 7
hex_digit ::= x_digit | z_digit | | | | | | | | | | | | | | | | | | | | | |
0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F
x_digit ::= |
x X
z_digit ::= | |
z Z ?
unbased_unsized_literal ::= | | z_or_x 48
'0 '1 '
A.8.8 Strings
string_literal ::= { Any_ASCII_Characters }
" "
1176
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A.9 General
A.9.1 Attributes
attribute_instance ::= attr_spec { attr_spec }
(* , *)
attr_spec ::= attr_name [ constant_expression ]
=
attr_name ::= identifier
A.9.2 Comments
comment ::=
one_line_comment
| block_comment
one_line_comment ::= comment_text \n
//
block_comment ::= comment_text
/* */
comment_text ::= { Any_ASCII_character }
A.9.3 Identifiers
array_identifier ::= identifier
block_identifier ::= identifier
bin_identifier ::= identifier
c_identifier49 ::= [ - - ] { [ - - - ] }
a zA Z_ a zA Z0 9_
cell_identifier ::= identifier
checker_identifier ::= identifier
class_identifier ::= identifier
class_variable_identifier ::= variable_identifier
clocking_identifier ::= identifier
config_identifier ::= identifier
const_identifier ::= identifier
constraint_identifier ::= identifier
covergroup_identifier ::= identifier
covergroup_variable_identifier ::= variable_identifier
cover_point_identifier ::= identifier
cross_identifier ::= identifier
dynamic_array_variable_identifier ::= variable_identifier
enum_identifier ::= identifier
escaped_identifier ::= {any_printable_ASCII_character_except_white_space} white_space
\
formal_identifier ::= identifier
formal_port_identifier ::= identifier
function_identifier ::= identifier
generate_block_identifier ::= identifier
genvar_identifier ::= identifier
hierarchical_array_identifier ::= hierarchical_identifier
1177
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
hierarchical_block_identifier ::= hierarchical_identifier
hierarchical_event_identifier ::= hierarchical_identifier
hierarchical_identifier ::= [ ] { identifier constant_bit_select } identifier
$root. .
hierarchical_net_identifier ::= hierarchical_identifier
hierarchical_parameter_identifier ::= hierarchical_identifier
hierarchical_property_identifier ::= hierarchical_identifier
hierarchical_sequence_identifier ::= hierarchical_identifier
hierarchical_task_identifier ::= hierarchical_identifier
hierarchical_tf_identifier ::= hierarchical_identifier
hierarchical_variable_identifier ::= hierarchical_identifier
identifier ::=
simple_identifier
| escaped_identifier
index_variable_identifier ::= identifier
interface_identifier ::= identifier
interface_instance_identifier ::= identifier
inout_port_identifier ::= identifier
input_port_identifier ::= identifier
instance_identifier ::= identifier
library_identifier ::= identifier
member_identifier ::= identifier
method_identifier ::= identifier
modport_identifier ::= identifier
module_identifier ::= identifier
net_identifier ::= identifier
net_type_identifier ::= identifier
output_port_identifier ::= identifier
package_identifier ::= identifier
package_scope ::=
package_identifier
::
|
$unit ::
parameter_identifier ::= identifier
port_identifier ::= identifier
production_identifier ::= identifier
program_identifier ::= identifier
property_identifier ::= identifier
ps_class_identifier ::= [ package_scope ] class_identifier
ps_covergroup_identifier ::= [ package_scope ] covergroup_identifier
ps_checker_identifier ::= [ package_scope ] checker_identifier
ps_identifier ::= [ package_scope ] identifier
ps_or_hierarchical_array_identifier ::=
[ implicit_class_handle | class_scope | package_scope ] hierarchical_array_identifier
.
ps_or_hierarchical_net_identifier ::= [ package_scope ] net_identifier | hierarchical_net_identifier
ps_or_hierarchical_property_identifier ::=
1178
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
[ package_scope ] property_identifier
| hierarchical_property_identifier
ps_or_hierarchical_sequence_identifier ::=
[ package_scope ] sequence_identifier
| hierarchical_sequence_identifier
ps_or_hierarchical_tf_identifier ::=
[ package_scope ] tf_identifier
| hierarchical_tf_identifier
ps_parameter_identifier ::=
[ package_scope | class_scope ] parameter_identifier
| { generate_block_identifier [ constant_expression ] } parameter_identifier
[ ] .
ps_type_identifier ::= [ 43 | package_scope | class_scope ] type_identifier
local::
sequence_identifier ::= identifier
signal_identifier ::= identifier
simple_identifier49 ::= [ - - ] { [ - - - ] }
a zA Z_ a zA Z0 9_$
specparam_identifier ::= identifier
system_tf_identifier50 ::= [ - - - ]{ [ - - - ] }
$ a zA Z0 9_$ a zA Z0 9_$
task_identifier ::= identifier
tf_identifier ::= identifier
terminal_identifier ::= identifier
topmodule_identifier ::= identifier
type_identifier ::= identifier
udp_identifier ::= identifier
variable_identifier ::= identifier
A.9.4 White space
white_space ::= space | tab | newline | eof
A.10 Footnotes (normative)
1) A package_import_declaration in a module_ansi_header, interface_ansi_header, or program_ansi_header shall be
followed by a parameter_port_list or list_of_port_declarations, or both.
2) The list_of_port_declarations syntax is explained in 23.2.2.2, which also imposes various semantic restrictions,
e.g., a port shall be of a variable type and an port shall not be. It shall be illegal to initialize a port that
ref inout
is not a variable port or to specify a default value for a port that is not an port.
output input
3) A timeunits_declaration shall be legal as a non_port_module_item, non_port_interface_item,
non_port_program_item, or package_item only if it repeats and matches a previous timeunits_declaration within
the same time scope.
4) If the bind_target_scope is an interface_identifier or the bind_target_instance is an interface_instance_identifier,
then the bind_instantiation shall be an interface_instantiation or a checker_instantiation.
5) It shall be illegal for a program_generate_item to include any item that would be illegal in a program_declaration
outside a program_generate_item.
6) It shall be illegal for a checker_generate_item to include any item that would be illegal in a checker_declaration
outside a checker_generate_item.
7) In a parameter_declaration that is a class_item, the keyword shall be a synonym for the
parameter
keyword.
localparam
1179
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
8) In any one declaration, only one of or is allowed, only one of or is allowed,
protected local rand randc
and and/or can appear only once.
static virtual
9) The open_range_list in a uniqueness_constraint shall contain only expressions that denote scalar or array variables,
as described in 18.5.5.
10) In a data_declaration that is not within a procedural context, it shall be illegal to use the keyword. In
automatic
a data_declaration, it shall be illegal to omit the explicit data_type before a list_of_variable_decl_assignments
unless the keyword is used.
var
11) It shall be illegal to have an import statement directly within a class scope.
12) A charge strength shall only be used with the keyword. When the or keyword is
trireg vectored scalared
used, there shall be at least one packed dimension.
13) When a packed dimension is used with the or keyword, the keyword shall also be used.
struct union packed
14) When a type_reference is used in a net declaration, it shall be preceded by a net type keyword; and when it is used
in a variable declaration, it shall be preceded by the keyword.
var
15) A type_identifier shall be legal as an enum_base_type if it denotes an integer_atom_type, with which an additional
packed dimension is not permitted, or an integer_vector_type.
16) It shall be legal to declare a struct_union_member only within tagged unions. It shall be legal to declare a
void
random_qualifier only within unpacked structures.
17) An expression that is used as the argument in a type_reference shall not contain any hierarchical references or
references to elements of dynamic objects.
18) It shall be legal to omit the constant_param_expression from a param_assignment or the data_type from a
type_assignment only within a parameter_port_list. However, it shall not be legal to omit them from localparam
declarations in a parameter_port_list.
19) In a shallow copy, the expression shall evaluate to an object handle.
20) In packed_dimension, unsized_dimension is permitted only as the sole packed dimension in a DPI import
declaration; see dpi_function_proto and dpi_task_proto.
21) dpi_function_proto return types are restricted to small values, per 35.5.5.
22) Formals of dpi_function_proto and dpi_task_proto cannot use pass-by-reference mode, and class types cannot be
passed at all; see 35.5.6 for a description of allowed types for DPI formal arguments.
23) In a tf_port_item, it shall be illegal to omit the explicit port_identifier except within a function_prototype or
task_prototype.
24) The operator shall have higher precedence than the and operators.
matches && ||
25) It shall be legal to use the primary in an open_value_range or covergroup_value_range of the form expression
$ [
or expression .
:$] [$: ]
26) The result of this expression shall be assignment compatible with an integral type.
27) This expression is restricted as described in 19.5.1.2.
28) This expression is restricted as described in 19.5.
29) The token shall appear at most once in a list of port connections.
.*
30) Within an interface_declaration, it shall only be legal for a generate_item to be an interface_or_generate_item.
Within a module_declaration, except when also within an interface_declaration, it shall only be legal for a
generate_item to be a module_or_generate_item. Within a checker_declaration, it shall only be legal for a
generate_item to be a checker_or_generate_item.
31) Parentheses are required when an event expression that contains comma-separated event expressions is passed as an
actual argument using positional binding.
32) In a constant_assignment_pattern_expression, all member expressions shall be constant expressions.
33) Embedded spaces are illegal.
34) In a multiple_concatenation, it shall be illegal for the multiplier not to be a constant_expression unless the type of
the concatenation is .
string
1180
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
35) shall denote an empty unpacked array concatenation, as described in 10.10, and shall not be used in any other
{}
form of concatenation.
36) In a constant_function_call, all arguments shall be constant_expressions.
37) It shall be illegal to omit the parentheses in a tf_call unless the subroutine is a task, void function, or class method.
If the subroutine is a nonvoid class function method, it shall be illegal to omit the parentheses if the call is directly
recursive.
38) In a randomize_call that is not a method call of an object of class type (i.e., a scope randomize), the optional
parenthesized identifier_list after the keyword shall be illegal, and the use of shall be illegal.
with null
39) A genvar_identifier shall be legal in a constant_primary only within a genvar_expression.
40) It shall be legal to use a type_reference constant_primary as the casting_type in a static cast. It shall be illegal for a
type_reference constant_primary to be used with any operators except the equality/inequality and case equality/
inequality operators.
41) implicit_class_handle shall only appear within the scope of a class_declaration or out-of-block method declaration.
42) The primary shall be legal only in a select for a queue variable, in an open_value_range, covergroup_val-
$
ue_range, integer_covergroup_expression, or as an entire sequence_actual_arg or property_actual_arg.
43) The qualifier shall only appear within the scope of an inline constraint block.
local::
44) The unsigned number or fixed-point number in time_literal shall not be followed by white_space.
45) In a constant_let_expression, all arguments shall be constant_expressions and its right-hand side shall be a
constant_expression itself provided that its formal arguments are treated as constant_primary there.
46) In a variable_lvalue that is assigned within a sequence_match_item any select shall also be a constant_select.
47) A streaming_concatenation expression shall not be nested within another variable_lvalue. A
streaming_concatenation shall not be the target of the increment or decrement operator nor the target of any
assignment operator except the simple ( ) or nonblocking assignment ( ) operator.
= <=
48) The apostrophe ( ) in unbased_unsized_literal shall not be followed by white_space.
'
49) A simple_identifier or c_identifier shall start with an alpha or underscore ( ) character, shall have at least one
_
character, and shall not have any spaces.
50) The character in a system_tf_identifier shall not be followed by white_space. A system_tf_identifier shall not be
$
escaped.
End of file.
1181
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex B
(normative)
Keywords
SystemVerilog reserves the keywords listed in TableB.1.
Table B.1—Reserved keywords
accept_on default forkjoin
alias defparam function
always design generate
always_comb disable genvar
always_ff dist global
always_latch do highz0
and edge highz1
assert else if
assign end iff
assume endcase ifnone
automatic endchecker ignore_bins
before endclass illegal_bins
begin endclocking implements
bind endconfig implies
bins endfunction import
binsof endgenerate incdir
bit endgroup include
break endinterface initial
buf endmodule inout
bufif0 endpackage input
bufif1 endprimitive inside
byte endprogram instance
case endproperty int
casex endspecify integer
casez endsequence interconnect
cell endtable interface
chandle endtask intersect
checker enum join
class event join_any
clocking eventually join_none
cmos expect large
config export let
const extends liblist
constraint extern library
context final local
continue first_match localparam
cover for logic
covergroup force longint
coverpoint foreach macromodule
cross forever matches
deassign fork medium
1182
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table B.1—Reserved keywords (continued)
modport reject_on time
module release timeprecision
nand repeat timeunit
negedge restrict tran
nettype return tranif0
new rnmos tranif1
nexttime rpmos tri
nmos rtran tri0
nor rtranif0 tri1
noshowcancelled rtranif1 triand
not s_always trior
notif0 s_eventually trireg
notif1 s_nexttime type
null s_until typedef
or s_until_with union
output scalared unique
package sequence unique0
packed shortint unsigned
parameter shortreal until
pmos showcancelled until_with
posedge signed untyped
primitive small use
priority soft uwire
program solve var
property specify vectored
protected specparam virtual
pull0 static void
pull1 string wait
pulldown strong wait_order
pullup strong0 wand
pulsestyle_ondetect strong1 weak
pulsestyle_onevent struct weak0
pure super weak1
rand supply0 while
randc supply1 wildcard
randcase sync_accept_on wire
randsequence sync_reject_on with
rcmos table within
real tagged wor
realtime task xnor
ref this xor
reg throughout
1183
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex C
(normative)
Deprecation
C.1 General
This annex identifies constructs that either
— have been deprecated from SystemVerilog and no longer appear in this standard, or
— are under consideration for deprecation and might be removed from future versions of this standard.
C.2 Constructs that have been deprecated
C.2.1 PLI TF and ACC routine libraries
IEEE Std 1364-2005 deprecated the Programming Language Interface (PLI) libraries containing the task/
function (TF) and access (ACC) routines that were contained in previous versions of that standard. These
routines were described in Clause 21 through Clause 25, Annex E, and Annex F of IEEE Std 1364-2001.
The text of these deprecated clauses and annexes do not appear in this version of the standard. The text can
be found in IEEE Std 1364-2001.
C.2.2 $sampled with a clocking event argument
IEEE Std 1800-2005 17.7.3 required that an explicit or inferred clocking event argument be provided for the
assertion system function. In this version of the standard, the semantics of have been
$sampled $sampled
changed to a form that does not depend on a clocking event. Therefore the syntax for defining the clocking
event argument to is deprecated and does not appear in this version of the standard.
$sampled
C.2.3 ended sequence method
IEEE Std 1800-2005 17.7.3 required using the sequence method in sequence expressions and the
ended
sequence method in other contexts. Since these two constructs have the same meaning but
triggered
mutually exclusive usage contexts, in this version of the standard, the method is allowed to be
triggered
used in sequence expressions, and the usage of is deprecated and does not appear in this version of
ended
the standard.
C.2.4 vpi_free_object()
The semantics of this VPI routine have been clarified to account for the nature of dynamic data in the
SystemVerilog information model and the concept of handle validity. It has been renamed
vpi_release_handle(), and thus vpi_free_object() has been deprecated.
C.2.5 Data read API
IEEE Std 1800-2009 deprecated the Data Read API that was contained in the previous version of the
standard. These routines were described in Clause 30 and Annex I of IEEE Std 1800-2005. The text of these
1184
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
deprecated clauses and annexes do not appear in this version of the standard. The text can be found in
IEEEStd 1800-2005.
C.2.6 Linked lists
IEEE Std 1800-2009 deprecated the built-in Linked List package that was contained in the previous version
of the standard. This package was described in Annex D of IEEE Std 1800-2005. The text of this deprecated
annex does not appear in this version of the standard. The text can be found in IEEE Std 1800-2005.
C.2.7 always statement in checkers
The procedure in checkers was allowed by IEEE Std 1800-2009, but ,
always always_comb
, and were forbidden. The limitations imposed on the procedure in
always_latch always_ff always
checkers included the limitations imposed on procedures outside checkers. In this version of the
always_ff
standard , , and have been added for checkers. As a result the
always_comb always_latch always_ff
general procedure in checkers would have imposed the same limitations as does.
always always_ff
Therefore the usage of procedures in checkers is deprecated and does not appear in this version of
always
the standard.
C.2.8 Operator overloading
IEEE Std 1800-2017 deprecates the operator overloading construct that was contained in the previous
version of the standard. This construct was described in 11.11 and in the BNF syntax of IEEEStd1800-
2012. The text of this deprecated subclause and its syntax do not appear in this version of the standard. They
can be found in IEEE Std 1800-2012.
C.3 Accellera SystemVerilog 3.1a-compatible access to packed data
The Accellera SystemVerilog 3.1a [B4] semantics for and
svLogicPackedArrRef svBitPackedArrRef
is deprecated. See H.13 for a full description of Accellera SystemVerilog 3.1a versus IEEE 1800 semantics.
C.4 Constructs identified for deprecation
NOTE—Certain SystemVerilog language features can be simulation inefficient, easily abused, and the source of design
problems. These features are being considered for removal from the SystemVerilog language if there is an alternate
method for these features.
The SystemVerilog language features that have been identified in this standard as ones that can be removed from
SystemVerilog are and procedural / .
defparam assigndeassign
C.4.1 Defparam statements
The method of specifying the value of a parameter can be a source of design errors and can be an
defparam
impediment to tool implementation due to its usage of hierarchical paths. The statement does not
defparam
provide a capability that cannot be done by another method that avoids these problems. Therefore, the
statement is on a deprecation list. In other words, a future revision of IEEE Std 1800 might not
defparam
require support for this feature. This current standard still requires tools to support the statement.
defparam
However, users are strongly encouraged to migrate their code to use one of the alternate methods of
parameter redefinition.
1185
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Prior to the acceptance of IEEE Std 1364-2001 (Verilog-2001), it was common practice to change one or
more parameters of instantiated modules using a separate statement. The statements
defparam defparam
can be a source of tool complexity and design problems.
A statement can precede the instance to be modified, can follow the instance to be modified, can
defparam
be at the end of the file that contains the instance to be modified, can be in a separate file from the instance
to be modified, can modify parameters hierarchically that are in turn passed to other statements
defparam
to modify, and can modify the same parameter from two different statements (with undefined
defparam
results). Due to the many ways that a can modify parameters, a SystemVerilog compiler cannot
defparam
resolve the final parameter values for an instance until after all of the design files are compiled.
Prior to IEEE Std 1364-2001, the only other method available to change the values of parameters on
instantiated modules was to use implicit inline parameter redefinition. This method uses
as part of the module instantiation. Implicit inline parameter redefinition syntax
#(parameter_value)
requires that all parameters up to and including the parameter to be changed shall be placed in the correct
order and shall be assigned values.
IEEE Std 1364-2001 introduced explicit inline parameter redefinition, in the form
#(.parameter_
, as part of the module instantiation. This method gives the capability to pass parameters by
name(value))
name in the instantiation, which supplies all of the necessary parameter information to the model in the
instantiation itself.
The practice of using statements is highly discouraged. Engineers are encouraged to take
defparam
advantage of the explicit inline parameter redefinition capability.
See 6.20 for more details on parameters.
C.4.2 Procedural assign and deassign statements
The procedural and statements can be a source of design errors and can be an
assign deassign
impediment to tool implementation. The procedural and statements do not provide a
assign deassign
capability that cannot be done by another method that avoids these problems. Therefore, the procedural
and statements are on a deprecation list. In other words, a future revision of
assign deassign
IEEEStd1800 might not require support for these statements. This current standard still requires tools to
support the procedural and statements. However, users are strongly encouraged to
assign deassign
migrate their code to use one of the alternate methods of procedural or continuous assignments.
SystemVerilog has two forms of the statement, as follows:
assign
— Continuous assignments, placed outside any procedures
— Procedural continuous assignments, placed within a procedure
Continuous assignment statements are a separate process that are active throughout simulation. The
continuous assignment statement accurately represents combinational logic at an RTL level of modeling and
is frequently used.
Procedural continuous assignment statements become active when the statement is executed in the
assign
procedure. The process can be deactivated using a statement. The procedural and
deassign assign
statements are seldom needed to model hardware behavior. In the unusual circumstances where
deassign
the behavior of procedural continuous assignments are required, the same behavior can be modeled using
the procedural and statements.
force release
1186
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Allowing the statement to be used both inside and outside a procedural block causes confusion and
assign
is a source of errors in SystemVerilog models. The practice of using the and statements
assign deassign
inside procedural blocks is highly discouraged.
C.4.3 VPI definitions
Certain object, relationship, and property definitions have been deprecated to implement corrections and
improvements to VPI. Some have been inherited from IEEE Std 1364 (see 36.12.1) and some have been
changed or removed to maintain consistency with related improvements.
1) vpiMemory (as an object type)
The vpiArrayVar (vpiRegArray) object type has been generalized to include vpiMemory and all
other arrays of variables. vpiMemory therefore no longer represents a VPI object type, except under
certain backwards compatibility modes (see 36.12.1). However, it is still in use as a relationship (see
37.20 diagram and detail 1).
2) vpiMemoryWord (as an object type)
This was exclusively used to represent elements of vpiMemory objects in IEEE Std 1364. Since
vpiArrayVar (vpiRegArray) has replaced the definition of vpiMemory, and variable object types
now represent their elements, this is represented by vpiLogicVar (vpiReg) types. Therefore, it no
longer represents a VPI object type, except under certain backwards compatibility modes (see
36.12.1). It is still in use as a relationship, however (see 37.20 diagram and detail 1).
3) vpiArray property
In IEEE Std 1364, variable types vpiIntegerVar, vpiTimeVar, and vpiRealVar could represent
single variable objects or arrays of those objects. The vpiArray property was required to distinguish
those cases (the property returned when they were arrays). Also, the property indicated when
TRUE
vpiReg types represented elements of vpiRegArrays. These two uses became conflicting and
unnecessary when vpiRegArrays and arrays of , , and variables were
integer time real
generalized as vpiArrayVar (vpiRegArray) objects. To distinguish when any variable is an
element of an array, the vpiArrayMember property is now used, thus replacing the original use of
vpiArray for types. The vpiArray property now has only limited use in IEEE 1364 backwards
reg
compatibility modes when vpiIntegerVar, vpiTimeVar, and vpiRealVar could represent arrays
(see 36.12.1).
4) vpiValid property
Significant revisions to VPI have rendered the original vpiValid property inconsistent with its
original purpose, which was to determine the extent to which a transient object represented by a VPI
handle was active or “alive” (see 37.2.4 and 37.3.7). Since the VPI object model no longer supports
maintaining handles to objects whose lifetimes have ended, such “validity” is implicit in their
existence, and their status must be determined by other means (see 38.36.1).
5) vpiInterfaceDecl one-to-many relationship
This relationship was used to return vpiRefObj objects representing virtual interface variables from
any scope. Its definition has been made equivalent to vpiVirtualInterfaceVar, which instead
returns vpiVirtualInterfaceVar object types. This was done to correctly reflect the true
variable-like characteristics of these objects (see 37.30 detail 11).
1187
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex D
(informative)
Optional system tasks and system functions
D.1 General
The system tasks and system functions described in this annex are for informative purposes only and are not
part of this standard.
This annex describes system tasks and system functions, which are companions to the system tasks and
system functions described in Clause20 and Clause21. The system tasks and system functions described in
this annex may not be available in all implementations of SystemVerilog. The following system tasks and
system functions are described in this annex:
[D.2] [D.8]
$countdrivers $reset_count
[D.3] [D.8]
$getpattern $reset_value
[D.9] [D.9]
$incsave $restart
[D.4] [D.9]
$input $save
[D.5] [D.10]
$key $scale
[D.6] [D.11]
$list $scope
[D.7] [D.12]
$log $showscopes
[D.5] [D.13]
$nokey $showvars
[D.7] [D.14]
$nolog $sreadmemb
[D.8] [D.14]
$reset $sreadmemh
D.2 $countdrivers
Syntax:
(net,[ net_is_forced,number_of_01x_drivers, number_of_0_drivers,
$countdrivers
number_of_1_drivers, number_of_x_drivers ] )
;
The system function is provided to count the number of drivers on a specified net so that
$countdrivers
bus contention can be identified.
This system function returns a if there is no more than one driver on the net and returns a otherwise
0 1
(indicating contention). The specified net shall be a scalar or a bit-select of a vector net. The number of
arguments to the system function may vary according to how much information is desired.
If additional arguments are supplied to the function, each argument returns the
$countdrivers
information described in TableD.1.
1188
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table D.1—Argument return value for $countdriver function
Argument Return value
net_is_forced 1 if net is forced.
0 otherwise.
number_of_01x_drivers An integer representing the number of drivers on the net that are in 0, 1, or x
state. This represents the total number of drivers that are not forced.
number_of_0_drivers An integer representing the number of drivers on the net that are in state.
0
number_of_1_drivers An integer representing the number of drivers on the net that are in state.
1
number_of_x_drivers An integer representing the number of drivers on the net that are in state.
x
D.3 $getpattern
Syntax:
( mem_element )
$getpattern ;
The system function provides for fast processing of stimulus patterns that have to be
$getpattern
propagated to a large number of scalar inputs. The function reads stimulus patterns that have been loaded
into a memory using the or system tasks.
$readmemb $readmemh
Use of this function is limited, however, it may only be used in a continuous assignment statement where the
left-hand side is a concatenation of scalar nets and the argument to the system function is a memory element
reference.
The following example shows how stimuli stored in a file can be read into a memory using and
$readmemb
applied to the circuit one pattern at a time using .
$getpattern
The memory is initialized with the stimulus patterns by the task. The integer variable
in_mem $readmemb
selects which pattern is being applied to the circuit. The loop increments the integer variable
index for
periodically to sequence the patterns.
index
module top;
parameter in_width = 10,
patterns = 200,
delay = 20;
logic [1:in_width] in_mem[1:patterns];
integer index;
// declare scalar inputs
wire i1,i2,i3,i4,i5,i6,i7,i8,i9,i10;
// assign patterns to circuit scalar inputs (a new pattern
// is applied to the circuit each time index changes value)
assign {i1,i2,i3,i4,i5,i6,i7,i8,i9,i10} = $getpattern(in_mem[index]);
initial begin
// read stimulus patterns into memory
$readmemb("patt.mem", in_mem);
// step through patterns (each assignment
// to index will drive a new pattern onto the circuit
1189
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
// inputs from the $getpattern system task specified above
for (index = 1; index <= patterns; index = index + 1)
#delay;
end
// instantiate the circuit module - e.g.,
mod1 cct (o1,o2,o3,o4,o5, i1,i2,i3,i4,i5,i6,i7,i8,i9,i10);
endmodule
D.4 $input
Syntax:
( filename )
$input " " ;
The system task allows command input text to come from a named file instead of from the terminal.
$input
At the end of the command file, the input is switched back to the terminal.
D.5 $key and $nokey
Syntax:
[ ( filename ) ]
$key " " ;
$nokey;
A key file is created whenever the interactive mode is entered for the first time during simulation. The key
file contains all of the text that has been typed in from the standard input. The file also contains information
about asynchronous interrupts.
The and system tasks are used to disable and reenable output to the key file. An optional file
$nokey $key
name argument for causes the old key file to be closed, a new file to be created, and output to be
$key
directed to the new file.
D.6 $list
Syntax:
[ ( hierarchical_name ) ]
$list ;
When invoked without an argument, produces a listing of the module, task, function, or named block
$list
that is defined as the current scope setting. If an optional argument is supplied, it shall refer to a specific
module, task, function, or named block, in which case the specified object is listed.
D.7 $log and $nolog
Syntax:
[ ( filename ) ]
$log " " ;
$nolog;
1190
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A log file contains a copy of all the text that is printed to the standard output. The log file may also contain,
at the beginning of the file, the host command that was used to run the tool.
The and system tasks are used to disable and reenable output to the log file. The task
$nolog $log $nolog
disables output to the log file, while the task reenables the output. An optional file name argument for
$log
causes the old file to be closed, a new log file to be created, and output to be directed to the new log
$log
file.
D.8 $reset, $reset_count, and $reset_value
Syntax:
[ ( stop_value [ , reset_value , [ diagnostics_value ] ] ) ]
$reset ;
$reset_count;
$reset_value;
The system task enables a tool to be reset to its “time zero” state so that processing (e.g.,
$reset
simulation) can begin again.
The system function keeps track of the number of times the tool is reset. The
$reset_count
system function returns the value specified by the argument to the
$reset_value reset_value $reset
system task. The system function is used to communicate information from before a reset of
$reset_value
a tool to the time zero state to after the reset.
The following are some of the simulation methods that can be employed with this system task and these
system functions:
— Determine the statements a design needs to operate correctly, reset the simulation to time
force
zero, enter these statements, and start to simulate again.
force
— Reset the simulation to time zero and apply new stimuli.
— Determine that debug system tasks, such as and , are keeping track of the cor-
$monitor $strobe
rect nets or variables, reset the simulation to time zero, and begin simulation again.
The system task tells a tool to return the processing of the design to its logical state at time zero.
$reset
When a tool executes the system task, it takes the following actions to stop the process:
$reset
a) Disables all concurrent activity, initiated in either initial or always procedures in the source
description or through interactive mode (disables, for example, all and statements,
force assign
the current system task, and any other active tasks).
$monitor
b) Cancels all scheduled simulation events.
After a simulation tool executes the system task, the simulation is in the following state:
$reset
— The simulation time is 0.
— All variables and nets contain their initial values.
— The tool begins to execute the first procedural statements in all and procedures.
initial always
The argument indicates if interactive mode or processing is entered immediately after
stop_value
resetting of the tool. A value of or no argument causes interactive mode to be entered after resetting the
0
tool. A nonzero value passed to causes the tool to begin processing immediately.
$reset
The argument is an integer that specifies the value that shall be returned by the
reset_value
system function after the tool is reset. All declared integers return to their initial value after
$reset_value
reset, but entering an integer as this argument allows access to what its value was before the reset with the
1191
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
system function. This argument provides a means of communicating information from
$reset_value
before the reset of a tool to after the reset of the tool.
The specifies the kind of diagnostic messages a tool displays before it resets the
diagnostics_value
simulation to time zero. Increasing integer values results in increased information. A value of zero results in
no diagnostic message.
D.9 $save, $restart, and $incsave
Three system tasks , , and work in conjunction with one another to save the
$save $restart $incsave
complete state of simulation into a permanent file so that the simulation state can be reloaded at a later time
and processing can continue where it left off.
Syntax:
( filename )
$save " " ;
( filename )
$restart " " ;
( incremental_filename )
$incsave " " ;
All three system tasks take a file name as an argument. The file name has to be supplied as a string enclosed
in quotation marks.
The system task saves the complete state into the file specified as an argument.
$save
The system task saves only what has changed since the last invocation of . It is not
$incsave $save
possible to do an incremental save on any file other than the one produced by the last .
$save
The system task restores a previously saved state from a specified file.
$restart
Restarting from an incremental save is similar to restarting from a full save, except that the name of the
incremental save file is specified in the restart command. The full save file on which the incremental save
file was based shall still be present, as it is required for a successful restart. If the full save file has been
changed in any way since the incremental save was performed, errors will result.
The incremental restart is useful for going back in time. If a full save is performed near the beginning of
processing and an incremental save is done at regular intervals, then going back in time is as simple as
restarting from the appropriate file.
For example:
module checkpoint;
initial
#500 $save("save.dat"); // full save
always begin // incremental save every 10000 units,
// files are recycled every 40000 units
#100000 $incsave("inc1.dat");
#100000 $incsave("inc2.dat");
#100000 $incsave("inc3.dat");
#100000 $incsave("inc4.dat");
end
endmodule
1192
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
D.10 $scale
Syntax:
( hierarchical_name )
$scale ;
The function takes a time value from a module with one time unit to be used in a module with a
$scale
different time unit. The time value is converted from the time unit of one module to the time unit of the
module that invokes .
$scale
D.11 $scope
Syntax:
( hierarchical_name )
$scope ;
The system task allows a particular level of hierarchy to be specified as the scope for identifying
$scope
objects. This task accepts a single argument that shall be the complete hierarchical name of a module, task,
function, or named block. The initial setting of the interactive scope is the first top-level module.
D.12 $showscopes
Syntax:
[ ( n ) ]
$showscopes ;
The system task produces a complete list of modules, tasks, functions, and named blocks that
$showscopes
are defined at the current scope level. An optional integer argument can be given to . A
$showscopes
nonzero argument value causes all the modules, tasks, functions, and named blocks in or below the current
hierarchical scope to be listed. No argument or a zero value results in only objects at the current scope level
being listed.
D.13 $showvars
Syntax:
[ ( list_of_variables ) ]
$showvars ;
The system task produces status information for reg and net variables, both scalar and vector.
$showvars
When invoked without arguments, displays the status of all variables in the current scope.
$showvars
When invoked with a list of variables, shows only the status of the specified variables. If the list
$showvars
of variables includes a bit-select or part-select of a vector, then the status information for all the bits of that
vector are displayed.
D.14 $sreadmemb and $sreadmemh
Syntax:
( mem_name , start_address , finish_address , string { , string } )
$sreadmemb ;
( mem_name , start_address , finish_address , string { , string } )
$sreadmemh ;
The system tasks and load data into memory from a character string.
$sreadmemb $sreadmemh mem_name
1193
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The and system tasks take memory data values and addresses as string literal
$sreadmemh $sreadmemb
arguments. The start and finish addresses indicate the bounds for where the data from strings will be stored
in the memory. These strings take the same format as the strings that appear in the input files passed as
arguments to and .
$readmemb $readmemh
1194
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex E
(informative)
Optional compiler directives
E.1 General
The compiler directives described in this annex are for informative purposes only and are not part of this
standard.
This annex describes additional compiler directives as companions to the compiler directives described in
Clause22. The compiler directives described in this annex may not be available in all implementations of
SystemVerilog. The following compiler directives are described in this annex:
[E.2] [E.5]
`default_decay_time `delay_mode_path
[E.3] [E.6]
`default_trireg_strength `delay_mode_unit
[E.4] [E.7]
`delay_mode_distributed `delay_mode_zero
E.2 `default_decay_time
The compiler directive specifies the decay time for the trireg nets that do not have
`default_decay_time
any decay time specified in the declaration. This compiler directive applies to all of the trireg nets in all the
modules that follow it in the source description. An argument specifying the charge decay time shall be used
with this compiler directive.
Syntax:
integer_constant | real_constant |
`default_decay_time infinite
Example 1: The following example shows how the default decay time for all trireg nets can be set to
100time units:
`default_decay_time 100
Example 2: The following example shows how to avoid charge decay on trireg nets:
`default_decay_time infinite
The keyword specifies no charge decay for all the trireg nets that do not have decay time
infinite
specification.
E.3 `default_trireg_strength
The compiler directive specifies the charge strength of nets.
`default_trireg_strength trireg
Syntax:
integer_constant
`default_trireg_strength
1195
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v2e02d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The integer constant shall be between 0 and 250. It indicates the relative strength of the capacitance on the
trireg net.
E.4 `delay_mode_distributed
The compiler directive specifies the distributed delay mode for all modules
`delay_mode_distributed
that follow this directive in the source description.
Syntax:
`delay_mode_distributed
This compiler directive shall be used before the declaration of the module whose delay mode is being
controlled.
E.5 `delay_mode_path
The compiler directive specifies the path delay mode for all modules that follow this
`delay_mode_path
directive in the source description.
Syntax:
`delay_mode_path
This compiler directive shall be used before the declaration of the module whose delay mode is being
controlled.
E.6 `delay_mode_unit
The compiler directive specifies the unit delay mode for all modules that follow this
`delay_mode_unit
directive in the source description.
Syntax:
`delay_mode_unit
This compiler directive shall be used before the declaration of the module whose delay mode is being
controlled.
E.7 `delay_mode_zero
The compiler directive specifies the zero delay mode for all modules that follow this
`delay_mode_zero
directive in the source description.
Syntax:
`delay_mode_zero
This compiler directive shall be used before the declaration of the module whose delay mode is being con-
trolled.
1196
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex F
(normative)
Formal semantics of concurrent assertions
F.1 General
This annex presents a formal semantics for SystemVerilog concurrent assertions. Immediate assertions and
coverage statements are not discussed here.
F.2 Overview
Throughout this annex, “assertion” is used to mean “concurrent assertion” and “iff” is used to mean “if and
only if.” The semantics is defined by a relation that determines when a finite or infinite word (i.e., trace)
satisfies an assertion. Intuitively, such a word represents a sequence of valuations of SystemVerilog
variables sampled at the finest relevant granularity of time (e.g., at the granularity of simulator cycles). The
process by which such words are produced is closely related to the SystemVerilog scheduling semantics and
is not defined here. In this annex, words are assumed to be sequences of elements, each element being either
a set of atomic propositions or one of two special symbols used as placeholders when extending finite
words. The atomic propositions are not further defined. The meaning of satisfaction of a SystemVerilog
Boolean expression by a set of atomic propositions is assumed to be understood.
The semantics in this annex describe each evaluation of a concurrent assertion, but there may be many
evaluations for each assertion implied within SystemVerilog code. This annex does not define the semantics
of queueing an instance of a concurrent assertion in procedural code (16.14.6). Once a pending procedural
assertion instance has matured, the semantics of the resulting property evaluation is defined by this annex. If
multiple evaluation attempts of a particular procedural concurrent assertion all mature, each of those
matured attempts is described separately by the equations in this annex. For a concurrent assertion statement
outside procedural code, which is continuously monitored, an instance of the equations in this annex exists
for each starting clock event of the assertion.
The semantics is based on an abstract syntax for SystemVerilog assertions. There are several advantages to
using the abstract syntax rather than the full SystemVerilog assertions BNF, as follows:
a) The abstract syntax facilitates separation of derived operators from basic operators. The satisfaction
relation is defined explicitly only for assertions built from basic operators.
b) The abstract syntax avoids reliance on operator precedence, associativity, and auxiliary rules for
resolving syntactic and semantic ambiguities.
c) The abstract syntax simplifies the assertion language by modifying or eliminating some features that
tend to encumber the definition of the formal semantics.
1) The abstract syntax modifies local variable declarations so that they are integrated with
sequence and property expressions. This change supports the rewriting algorithm (see F.4.1)
that replaces each instance of a named sequence or property with a flattened sequence or
property expression. The local variable declarations that appeared in the named sequence or
property declaration, including local variable formal arguments, become part of the flattened
expression. The abstract syntax also allows local variable declaration assignments. Local
variable declaration assignments are eliminated by a rewriting procedure after sequence and
property instances have been flattened (see F.4.3). The semantics of local variables does not
explicitly refer to their types.
1197
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
2) The abstract syntax eliminates instantiation of sequences and properties. The semantics of an
assertion with an instance of a named sequence or nonrecursive property is the same as the
semantics of a related assertion obtained by replacing the sequence or nonrecursive property
instance with an explicitly written sequence or property expression. F.4.1 defines a rewriting
algorithm that replaces each instance of a named sequence or nonrecursive property with a
flattened sequence or property expression. The semantics of an assertion that has one or more
instances of recursive properties is defined in F.7. The definition is in terms of an infinite set of
associated assertions, each of which may have instances of sequences and nonrecursive
properties, but has no instances of recursive properties. The semantics of each associated
assertion is obtained, as before, by using the rewriting algorithm.
3) The abstract syntax does not allow implicit clocks. Clocking event controls must be applied
explicitly in the abstract syntax.
In order to use this annex to determine the semantics of a SystemVerilog assertion, the assertion must first
be transformed into an assertion in the abstract syntax. For assertions that do not involve recursive
properties, this transformation involves eliminating sequence and nonrecursive property instances by using
the rewriting algorithm (see F.4.1), eliminating local variable declaration assignments (see F.4.3),
determining implicit or inferred clocking event controls, and eliminating redundant clocking event controls.
For example, the following SystemVerilog assertion:
property P(logic[3:0] a, property q);
(a[1:0] == 2'b10) ##1 (a[3:2] == 2'b01) |=> q;
endproperty
property Q(r, logic[1:2] d);
logic[1:2] v;
(1, v = d) ##1 r |=> d == v;
endproperty
always @(c) assert property ( P(A, Q(R, D)) );
is transformed into the assertion:
always @(c) assert property (
(
item
( (type(logic[3:0])'(A))[1:0] == 2'b10 ) ##1
item
( (type(logic[3:0])'(A))[3:2] == 2'b01 ) |=>
(
logic[1:2] v;
item item
(1, v = (type(logic[1:2])'(D))) ##1 (type(R)'(R)) |=>
item
(type(logic[1:2])'(D)) == v
)
)
);
in the abstract syntax, assuming is not a variable_lvalue.
R
F.3 Abstract syntax
F.3.1 Clock control
In this annex, the clock controls are considered Boolean functions on the input alphabet, and in the
@c
notation, is assumed to be a Boolean. However, in SystemVerilog the notation is commonly used to
c @c
designate a value-change sensitive event control. To describe how value-change sensitive event controls are
1198
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
converted to Boolean, we introduce operator defining rewriting rules from an edge-sensitive clock control
to a level-sensitive clock control. b, b ,… denote a Boolean expression, and e, e ,… denote an event
1 1
expression.
In the following transformation it is assumed that all the clocking events occur at ticks of .
$global_clock
— ( )
$global_clock = 1
— (b) = b , for b , see 14.14.
$changing_gclk( ) = $global_clock
— ( b) = b , see F.3.4.4.
posedge $rising_gclk( )
— ( b) = b , see F.3.4.4.
negedge $falling_gclk( )
— ( b) = ( b) ( b)
edge posedge || negedge
— (e) = b , for a named event e (see 15.5), and for a dummy bit variable b
$future_gclk( )
associated with the event e, such that b has value in the time slots when the event e is triggered,
1
and value in all other time slots.
0
— (e b) = (e) b
iff &&
— (e e ) = (e ) (e )
1or 2 1 || 2
— (e , e ) = (e ) (e )
1 2 1 || 2
For example, the SystemVerilog event control corresponds to
@(posedge clk)
in the formal semantics description.
@($rising_gclk(clk))
F.3.2 Abstract grammars
In the following abstract grammars, b denotes a Boolean expression, t denotes a type, v denotes a local
variable name, and e denotes an expression.
The abstract grammar for unclocked sequences is as follows:
R b
::= // "Boolean expression" form
t v e R
| ( [ = ]; ) // "local variable declaration" form
v e
| ( 1, = ) // "local variable sampling" form
R
| ( ) // "parenthesis" form
R R
| ( ##1 ) // "concatenation" form
R R
| ( ##0 ) // "fusion" form
R R
| ( or ) // "or" form
R R
| ( intersect ) // "intersect" form
R
| first_match ( ) // "first match" form
R
| [* 0 ] // "null repetition" form
R
| [* 1:$ ] // "unbounded repetition" form
The abstract grammar for clocked sequences is as follows:
S b R
::= @( ) // "clock" form
t v e S
| ( [ = ]; ) // "local variable declaration" form
S
| ( ) // "parenthesized" form
S S
| ( ##1 ) // "concatenation" form
The abstract grammar for unclocked properties is as follows:
P R
::= strong ( ) // "strong sequence" form
R
| weak ( ) // "weak sequence" form
t v e P
| ( [ = ]; ) // "local variable declaration" form
P
| ( ) // "parenthesis" form
P
| not // "negation" form
P P
| ( or ) // "or" form
1199
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
P P
| ( and ) // "and" form
R P
| ( |-> ) // "implication" form
P
| nexttime // "nexttime" form
P P
| ( until ) // "until" form
b P
| accept_on ( ) // "abort" form
Each instance of R in this production shall be a nondegenerate unclocked sequence. In the “sequence” form,
R shall not be tightly satisfied by the empty word. See F.5.2 and F.5.5 for the definitions of nondegeneracy
and tight satisfaction.
The abstract grammar for clocked properties is as follows:
Q b P
::= @( ) // "clock" form
S
| strong ( ) // "strong sequence" form
S
| weak ( ) // "weak sequence" form
t v e Q
| ( [ = ]; ) // "local variable declaration" form
Q
| ( ) // "parenthesis" form
Q
| not // "negation" form
Q Q
| ( or ) // "or" form
Q Q
| ( and ) // "and" form
S Q
| ( |-> ) // "implication" form
Q
| nexttime // "nexttime" form
Q Q
| ( until ) // "until" form
b Q
| accept_on ( ) // "abort" form
Each instance of S in this production shall be a nondegenerate clocked sequence. In the “sequence” form, S
shall not be tightly satisfied by the empty word. See F.5.2 and F.5.5 for the definitions of nondegeneracy and
tight satisfaction.
The abstract grammar for unclocked top-level properties is as follows:
T P
::= // plain form
b P
| disable iff ( ) // "disable" form
t v e T
| ( [ = ]; ) // "local variable declaration" form
T
| ( ) // "parenthesis" form
The abstract grammar for clocked top-level properties is as follows:
U Q
::= // plain form
b Q
| disable iff ( ) // "disable" form
t v e U
| ( [ = ]; ) // "local variable declaration" form
U
| ( ) // "parenthesis" form
The abstract grammar for assertions is as follows:
A U
::= always assert property ( ) // "always" form
b T
| always @( ) assert property ( ) // "always with clock" form
U
| initial assert property ( ) // "initial" form
b T
| initial @( ) assert property ( ) // "initial with clock" form
F.3.3 Notations
Except where specified otherwise, the following notational conventions, including subscripted versions of
the notations, will be used throughout the remainder of this annex: b and c denote Boolean expressions; t
denotes a type; vdenotes a local variable name; u denotes a free checker variable name; e denotes an
expression; uppercase R denotes an unclocked sequence; uppercase S denotes a clocked sequence; uppercase
P denotes an unclocked property; uppercase Q denotes a clocked property; uppercase T denotes an
1200
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
unclocked top-level property; uppercase U denotes a clocked top-level property; lowercase r and s denote
sequences, either clocked or unclocked; lowercase p and q denote properties, either clocked or unclocked
and either top-level or not; uppercase A denotes an assertion; i, j, k, m, and n denote non-negative integer
constants.
F.3.4 Derived forms
Internal parentheses are omitted in compositions of the (associative) operators and .
##1 or
F.3.4.1 Derived assertion statements
— .
restrict property assume property
F.3.4.2 Derived sequence operators
F.3.4.2.1 Derived consecutive repetition operators
— Let m > 0. R m R m–1 R .
[* ] ( [* ] ##1 )
— R R R .
[*0:$] ( [*0] or [*1:$])
— R m m R m .
[* : ] [* ]
— Let m < n. R m n R m n–1 R n .
[* : ] ( [* : ]or [* ])
— Let m > 1. R m R m – 1 R .
[* :$] ( [* ] ##1 [*1:$])
— R R R .
[*] ( [*0] or [*1:$])
— R R .
[+] ( [*1:$])
F.3.4.2.2 Derived delay and concatenation operators
Let m < n.
— m n R m n R .
(##[ : ] ) (1[* : ] ##1 )
— m R m R .
(##[ :$] ) (1[* :$] ##1 )
— m R m R .
(## ) (1[* ] ##1 )
— R R .
(##[*] ) (##[0:$] )
— R R .
(##[+] ) (##[1:$] )
— Let m > 0.
(
R1
##[
m
:
n
]
R2
) (
R1
##1 1[*
m – 1
:
n – 1
] ##1
R2
)
.
— Let m > 0.
(
R1
##[
m
:$]
R2
) (
R1
##1 1[*
m – 1
:$] ##1
R2
)
.
— Let m > 1.
(
R1
##
m R2
) (
R1
##1 1[*
m – 1
] ##1
R2
)
.
—
(
R1
##[0:0]
R2
) (
R1
##0
R2
)
.
— Let n > 0.
(
R1
##[0:
n
]
R2
) ((
R1
##0
R2
) or (
R1
##[1:
n
]
R2
))
.
—
(
R1
##[0:$]
R2
) ((
R1
##0
R2
) or (
R1
##[1:$]
R2
))
.
F.3.4.2.3 Derived nonconsecutive repetition operators
Let m < n.
— b m n b * b m n .
[-> : ] (! [ 0:$] ##1 )[* : ]
— b m b * b m .
[-> :$] (! [ 0:$] ##1 )[* :$]
— b m b * b m .
[-> ] (! [ 0:$] ##1 )[* ]
— b m n b m n b .
[= : ] ( [-> : ] ##1 ! [*0:$])
— b m b m b .
[= :$] ( [-> :$] ##1 ! [*0:$])
— b m b m b .
[= ] ( [-> ] ##1 ! [*0:$])
1201
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
F.3.4.2.4 Other derived operators
— R R
( 1 and 2)
(((
R1
##1 1[*0:$]) intersect
R2
) or (
R1
intersect (
R2
##1 1[*0:$])))
.
—
(
R1
within
R2
) ((1[*0:$] ##1
R1
##1 1[*0:$]) intersect
R2
)
.
— b R b R .
( throughout ) (( [*0:$]) intersect )
— R v e R v e .
( , = ) ( ##0 (1, = ))
—
(
R
,
v1
=
e1 ,... ,v
k =
e
k) ((
R, v1
=
e1)
##0 ( 1,
v2
=
e2 ,... , v
k =
e
k ))
for k
> 1
.
F.3.4.3 Derived property operators
F.3.4.3.1 Derived sequential property
— R R when used in a or statement. R R when
strong( ) cover property expect weak( )
used in an or statement.
assertproperty assumeproperty
F.3.4.3.2 Derived Boolean operators
— p p p p .
1implies 2 (not 1or 2)
— p p p p p p .
1iff 2 (( 1implies 2)and( 2implies 1))
F.3.4.3.3 Derived nonoverlapping implication operator
— R P R P .
( |=> ) (( ##1 1) |-> )
— S Q S Q .
( |=> ) (( ##1 @(1) 1) |-> )
F.3.4.3.4 Derived conditional operators
— b P b P .
(if( ) ) ( |-> )
— b P P b P b P .
(if( ) 1 else 2) (( |-> 1) and (weak( ) or 2))
F.3.4.3.5 Derived case operators
Let specify(b) be a function that expands a Boolean expression b and treats it as signed or unsigned
according to the rules mentioned in 12.5 for performing expression comparison while evaluating case
statements.
— b b : P specify(b) specify(b ) P .
(case( ) 1 1endcase) (if( === 1 ) 1)
— b P P .
(case( )default: d endcase) ( d)
— b b : P P specify(b) specify(b ) P P .
(case( ) 1 1default: d endcase) (if( === 1 ) 1else d)
— b b : P … b : P specify(b) specify(b ) P
(case( ) 1 1 n nendcase) (if( === 1 ) 1
specify(b) b : P … b : P .
else case( ) 2 2 n n endcase)
— b b : P … b : P P specify(b) specify(b ) P
(case( ) 1 1 n ndefault: dendcase) (if( === 1 ) 1
specify(b) b : P … b : P P .
else case( ) 2 2 n ndefault: d endcase)
F.3.4.3.6 Derived followed_by operators
— r p r p .
( #-# ) (not( |-> not ))
— r p r p .
( #=# ) (not( |=> not ))
F.3.4.3.7 Derived abort operators
— b P ) b P .
(reject_on( ) (notaccept_on( )not )
— b P b P when the clock context is 1.
(sync_accept_on( ) ) (accept_on( ) )
— b P b P .
(sync_reject_on( ) ) (not(sync_accept_on( )not ))
1202
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
F.3.4.3.8 Derived unbounded temporal operators
— p p .
(always ) ( until 0)
— p p .
(s_eventually ) (not (always(not ))
— p q p q q .
( s_until ) (( until ) and s_eventually )
— p q p p q .
( until_with ) (( until ( and ))
— p q p p q .
( s_until_with ) (( s_until ( and ))
F.3.4.3.9 Derived bounded temporal operators
— p p .
(s_nexttime ) (not nexttime not )
— 0 p 1 p .
(nexttime[ ] ) ( |-> )
— Let m 0. m p m–1 p .
> (nexttime[ ] ) (nexttime(nexttime[ ] ))
— Let m > 0. m p m p .
(s_nexttime[ ] ) (not nexttime[ ] not )
— Let m > 0. m:m p m p ;
(eventually[ ] ) (nexttime[ ] )
— Let m n. m:n p m:n-1 p n p .
< (eventually[ ] ) (eventually[ ] or nexttime[ ] )
— Let m > 0. m:m p m p .
(always[ ] ) (nexttime[ ] )
— Let m n. m:n p m:n–1 p n p .
< (always[ ] ) (always[ ] and nexttime[ ] )
— Let m > 0. m: p m p .
(always[ $] (nexttime[ ] always )
— Let m < n. m:n p m:n p .
(s_eventually[ ] ) (not always[ ] not )
— Let m > 0. m: p m p .
(s_eventually[ $] ) (s_nexttime[ ] s_eventually )
— Let m < n. m:n p m:n p .
(s_always[ ] ) (not eventually[ ] not )
F.3.4.4 Derived sampled value functions
— e e.
$sampled( )
— e c b c b , where b is the LSB of e.
$rose( , ) $past( ,1,1, ) !== 1 && === 1
— e c b c b , where b is the LSB of e.
$fell( , ) $past( ,1,1, ) !== 0 && === 0
— e c e c e.
$stable( , ) $past( ,1,1, ) ===
— e c e c e.
$changed( , ) $past( ,1,1, ) !==
— e b b , where b is the LSB of e.
$rose_gclk( ) $past_gclk( ) !== 1 && === 1
— e b b , where b is the LSB of e.
$fell_gclk( ) $past_gclk( ) !== 0 && === 0
— e e e.
$stable_gclk( ) $past_gclk( ) ===
— e e e.
$changed_gclk( ) $past_gclk( ) !==
— e b b , where b is the LSB of e.
$rising_gclk( ) !== 1 && $future_gclk( ) === 1
— e b b , where b is the LSB of e.
$falling_gclk( ) !== 0 && $future_gclk( ) === 0
— e e e .
$steady_gclk( ) === $future_gclk( )
— e e e .
$changing_gclk( ) !== $future_gclk( )
F.3.4.5 Other derived operators
— ( t1 v1 [ = e 1 ] ;... ; t k v k [ = e k ] ; X ) ( t1 v1 [ = e 1 ] ; ( t2 v2 [ = e 2 ] ;... ; t k v k [ = e k ] ; X ) )
for k > 1 and X any of P, Q, R, S, T, U .
F.3.4.6 Free checker variable assignment
— t u = e u e .
rand initialassumeproperty(@1 === )
— u c
always_ff @c u <= e always_ff assume property(@1 $future_gclk( ) === ( ?
e u .
: ))
1203
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If the assignment to u is in the scope of one or several conditional statements with a resulting
enabling condition b, then the equivalent assumption shall also be evaluated using the same enabling
condition b (see F.5.3.1).
F.4 Rewriting algorithms
For the rewriting algorithm, an auxiliary function item is defined as follows. The function item may be
applied to any SystemVerilog expression that may appear as an actual argument expression in an instance of
a named sequence, property, checker or let. If e is such an expression, then item(e) behaves like e in all
respects except that operations allowed on a reference to or instance of a named item declared with the same
type as e are also allowed on item(e). Also, any operation that is allowed on an instance of a named sequence
(respectively, property) is allowed on item applied to a sequence (respectively, property, including a top-
level property).
The function item is not a SystemVerilog function, and it is introduced only in the rewriting algorithm. The
rewriting algorithm uses item because operations that are legal on a reference to a formal argument within
the body of a declaration might no longer be legal when an actual argument expression is substituted for the
reference to the formal argument. For example, let and be variables of type , let be a
a b logic[0:1] v
variable of type , and let e be the cast expression . If is a
logic[0:3] type(logic[0:3])'({a,b}) v
formal argument, then the part select expression is legal within the body of the declared item.
v[1:2]
However, if e is an actual argument expression passed to in an instance, then the part select operation
v
cannot be applied when e is substituted for because is illegal.
v (type(logic[0:3])'({a,b}))[1:2]
Using the item function, the form item is legal. For expressions
(type(logic[0:3])'({a,b}))[1:2]
with undefined type, item does not enable additional operations.
F.4.1 Rewriting sequence and property instances
This subclause describes an algorithm for rewriting a sequence or property that contains one or more
instances of named sequences or nonrecursive properties. The result of the algorithm is one flattened
sequence or property without instances. The semantics of a hierarchical sequence or property is defined to
be the semantics of the flattened sequence or property resulting from the rewriting algorithm. The rewriting
algorithm does not itself account for name resolution and assumes that names have been resolved prior to the
substitution of actual arguments for references to the corresponding formal arguments. If the flattened
sequence or property is not legal, then the source is not legal. A property rewritten in the algorithm may be
the top-level property of a concurrent assertion.
F.4.1.1 The rewriting algorithm
Given  a sequence or property, possibly a top-level property:
While there are property instances in  do:
begin
Select an arbitrary property instance p and replace it by flatten_property(p).
end
While there are sequence instances in  do:
begin
1) Select an arbitrary sequence instance r.
2) If either (a) r appears as an event_expression in an event_control or a clocking_event, or (b) r is the
operand in a sequence_method_call, then replace r by item( 'flatten_sequence(r)).
sequence
3) Otherwise, replace r by flatten_sequence(r).
end
1204
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
flatten_property(p)
begin
1) Create a copy p' of the declaration of p.
2) For each formal argument f of p', let a be the corresponding actual argument expression for the
f
instance p. I.e., a is the actual argument expression bound to f in p, or, if no argument is bound to f
f
in p, then a is the default actual argument declared for f in p'.
f
3) For each untyped formal argument f of p', do the following for each reference to f in p':
a) If a is either $ or a variable_lvalue, then replace the reference by a .
f f
b) Otherwise, replace the reference by item a a .
(type( f)'( f))
4) For each typed formal argument f of p' that is not a local variable formal argument and whose type t
does not match (see 6.22.1) , , or , do the following for each reference to
event sequence property
f in p':
a) If t is a casting_type (see 6.24), then replace the reference by item(t'(a )).
f
b) Otherwise, replace the reference by item( (t)' a ).
type ( f)
According to 16.8.1, none of the references so replaced shall be the variable_lvalue in an
operator_assignment or inc_or_dec_expression in a sequence_match_item.
5) For each typed formal argument f of p' whose type t matches (see 6.22.1) , , or
event sequence
(and therefore is not a local variable formal argument), do the following for each
property
reference to f in p':
a) If the reference stands as the operand of a sequence_method_call, then replace the reference by
item(a).
f
b) Otherwise, replace the reference by a . The parentheses around a may be omitted if the
( f) f
reference is itself already enclosed in parentheses.
6) For each local variable formal argument f of p' whose type is t, add to the beginning of the body of p'
the local variable declaration “t f = a ;”. These local variable declarations may be arranged in any
f
order.
7) Return the expression obtained by copying the local variable declarations and body property_spec
from p' and enclosing the result in parentheses.
end
flatten_sequence(r)
begin
1) Create a copy r' of the declaration of r.
2) For each formal argument f of r', let a be the corresponding actual argument expression for the
f
instance r. I.e., a is the actual argument expression bound to f in r, or, if no argument is bound to f in
f
r, then a is the default actual argument declared for f in r'.
f
3) For each untyped formal argument f of r', do the following for each reference to f in r':
a) If a is either $ or a variable_lvalue, then replace the reference by a .
f f
b) Otherwise, replace the reference by item a a .
(type( f)'( f))
4) For each typed formal argument f of r' that is not a local variable formal argument and whose type t
does not match (see 6.22.1) or , do the following for each reference to f in r':
event sequence
a) If t is a casting_type (see 6.24), then replace the reference by item(t' a ).
( f)
Otherwise, replace the reference by item( (t)' a ).
type ( f)
According to 16.8.1, none of the references so replaced shall be the variable_lvalue in an
operator_assignment or inc_or_dec_expression in a sequence_match_item.
5) For each typed formal argument f of r' whose type t matches (see 6.22.1) or (and
event sequence
therefore is not a local variable formal argument), do the following for each reference to f in r':
1205
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
a) If the reference stands as the operand of a sequence_method_call, then replace the reference by
item(a).
f
b) Otherwise, replace the reference by a . The parentheses around a may be omitted if the
( f) f
reference is itself already enclosed in parentheses.
6)
a) For each input local variable formal argument f of r' whose type is t, add to the beginning of the
body of r' the local variable declaration “t f = a ;”.
f
b) For each inout local variable formal argument f of r' whose type is t, add to the beginning of the
body of r' the local variable declaration “t f = a ;” and include the assignment “a = f” in a list of
f f
match items attached to the end of the body sequence_expr of r'.
c) For each output local variable formal argument f of r' whose type is t, add to the beginning of the
body of r' the local variable declaration “t f ;” and include the assignment “a = f” in a list of
f
match items attached to the end of the body sequence_expr of r'.
The local variable declarations added to the beginning of the body of r' may be arranged in any
order.
7) Return the expression obtained by copying the local variable declarations and body sequence_expr
from r' and enclosing the result in parentheses.
end
According to 16.8.2, if f, f' are distinct local variable formal arguments of direction or , then a
inout input f
a'. Therefore, the overall result of the assignments to the actual arguments in 6(b) and 6(c) does not
= f
depend on the order of these assignments.
F.4.2 Rewriting checkers
This subclause describes an algorithm for rewriting a checker that contains one or more instances of other
checkers. The result of the algorithm is one flattened checker without instances. The rewriting algorithm
does not itself account for name resolution and assumes that names have been resolved prior to the
substitution of actual arguments for references to the corresponding formal input arguments. The checker
formal arguments that have output direction shall be treated differently (see 17.2), and this algorithm does
not apply to them. If the flattened checker is not legal, then the source is not legal. A checker rewritten in the
algorithm may be a nested checker instance or a top-level checker instance.
F.4.2.1 The rewriting algorithm
Given  a checker, possibly a top-level checker:
While there are checker instances in  do:
begin
Select an arbitrary checker instance c and replace it by flatten_checker(c).
end
flatten_checker(c)
begin
1) Create a copy c' of the declaration of c.
2) For each formal input argument f of c', let a be the corresponding actual argument expression for the
f
instance c. I.e., a is the actual argument expression bound to f in c, or, if no argument is bound to f in
f
c, then a is the default actual argument declared for f in c'.
f
3) For each untyped formal input argument f of c', do the following for each reference to f in c':
a) If a is either $ or a variable_lvalue, then replace the reference by a .
f f
1206
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
b) Otherwise, replace the reference by item a a .
(type( f)'( f))
4) For each typed formal input argument f of c' whose type t does not match (see 6.22.1) ,
event
, or , do the following for each reference to f in c':
sequence property
a) If t is a casting_type (see 6.24), then replace the reference by item(t'(a )).
f
b) Otherwise, replace the reference by item( (t)' a ).
type ( f)
None of the references so replaced shall be a variable_lvalue anywhere in the checker.
5) For each typed formal input argument f of c' whose type t matches (see 6.22.1) , ,
event sequence
or , do the following for each reference to f in c':
property
a) If the reference stands as the operand of a sequence_method_call, then replace the reference by
item(a).
f
b) Otherwise, replace the reference by a . The parentheses around a may be omitted if the
( f) f
reference is itself already enclosed in parentheses.
6) Return the checker body.
end
F.4.3 Rewriting local variable declaration assignments
After replacing instances of named sequences and properties as described in F.4.1, local variable declaration
assignments are eliminated from the resulting sequences and properties. Corresponding local variable
assignments are added within the sequences and properties using the following procedure. Only after this
step is completed are the clock rewrite rules used.
At several points, the procedure for rewriting local variable declaration assignments queries whether a
sequence admits an empty match. The queries allow splitting of cases in order to avoid changing the empty
match behavior. Formally, a sequence admits an empty match if, and only if, it is tightly satisfied by the
empty word. The tight satisfaction relation is defined in F.5.2 and F.5.5, where it is assumed that the clock
rewrite rules have already been applied to eliminate clocking operators. The current procedure requires that
the clocking operators remain in the syntax. Therefore, an independent definition of admission of an empty
match is given below by the function admits_empty, which maps sequences to {0, 1}. It can be proved that
for a sequence r, admits_empty(r) = 1 if, and only if, the empty word tightly satisfies r', where r' is the
sequence that results from r by eliminating local variable declaration assignments and by applying the clock
rewrite rules.
— admits_empty(b) = 0.
— admits_empty( t v e r ) = admits_empty(r).
( [= ]; )
— admits_empty( v e ) = 0.
(1, = )
— admits_empty( r ) = admits_empty(r).
( )
— admits_empty( r r ) = admits_empty(r ) admits_empty(r ).
( 1 ##1 2) 1 && 2
— admits_empty( r r ) = 0.
( 1 ##0 2)
— admits_empty( r r ) = admits_empty(r ) admits_empty(r ).
( 1 or 2) 1 || 2
— admits_empty( r r ) = admits_empty(r ) admits_empty(r ).
( 1 intersect 2) 1 && 2
— admits_empty( r ) = admits_empty(r).
first_match( )
— admits_empty(r ) = 1.
[*0]
— admits_empty(r ) = admits_empty(r).
[*1:$]
— admits_empty( c r) = admits_empty(r).
@( )
Let r be a sequence, and let c be the unique semantic leading clock of r (semantic leading clocks are defined
in 16.16.1). If c = inherited, then let (r) be the empty string. Otherwise, let (r) = (c).
@
1207
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The procedure first eliminates all local variable declaration assignments that are attached to sequences. In
general, ( t v = e; r ) is replaced by
( t v; (r) v e r r
( ((1, = ) ##0 ( )) or (( ) intersect 1[*0])) )
If admits_empty(r) = 0, then the replacement may be simplified to
( t v; (r) v e r
( ((1, = ) ##0 ( )) )
If admits_empty(r) = 1, then the replacement may be simplified to
( t v; (r) v e r
( ((1, = ) ##0 ( )) or 1[*0]) )
After this step, local variable declaration assignments remain only attached to properties. So that the
declaration assignments are executed after advancing to the alignment points with the appropriate semantic
leading clocks, the procedure next pushes these assignments down in the syntax using the function push
defined as follows. push takes a list of local variable declaration assignments as its first argument and a
property as its second argument. The property may be a top-level property. For clarity of notation,
concatenations of lists are enclosed in angle brackets (<, >), and the empty list is denoted by <>.
The procedure finishes by applying the function push with <> as first argument to each top-level property
and descending recursively.
Let E denote an ordered list of local variable assignments. Other notations are as in F.3.3.
— push(E, t v ; p ) = t v ; push(E, p) .
( ) ( )
— push(E, t v = e ; p ) = t v ; push(<E, v = e>, p) .
( ) ( )
— push(<>, r ) = r. If E is nonempty, then
push(E, r) = (r) E r
(1, ) ##0 ( )
In this case, r is a sequence used as a property. According to 16.12.22, admits_empty(r) = 0.
— push(<>, r p) = r push(<>, p). If E is nonempty, then
|-> |->
push(E, r p) = (r) E r push(<>, p)
|-> (1, ) ##0 ( )|->
— push(<>, r p) = r push(<>, p). If E is nonempty and admits_empty(r) = 0, then
|=> |=>
push(E, r p) = (r) E r push(<>, p)
|=> (1, ) ##0 ( )|=>
If E is nonempty and admits_empty(r) = 1, then
push(E, r p) = (r) E r push(<>, p) push(E, p)
|=> ( (1, ) ##0 ( )|=> )and )
— push(<>, b p [ q ] ) = b push(<>, p) [ push(<>, q) ]. If E is nonempty, then
if( ) else if( ) else
push(E, b p [ q ] ) = E b push(<>, p) [ push(<>, q) ].
if( ) else (1, ) |-> if( ) else
— push(E, (b) p) = (b) push(E, p).
disableiff disableiff
— push(E, c p) = c push(E, p).
@( ) @( )
— push(E, p ) = push(E, p) .
( ) ( )
— push(E, p) = push(E, p).
not not
— push(E, p q) = push(E, p) push(E, q).
or or
— push(E, p q) = push(E, p) push(E, q).
and and
F.5 Semantics
Let P be the set of atomic propositions.
The semantics of assertions and properties is defined via a relation of satisfaction by empty, finite, and
infinite words over the alphabet  = 2P U {T, }. Such a word is an empty, finite, or infinite sequence of
elements of . The number of elements in the sequence is called the length of the word, and the length of
word w is denoted |w|, where |w| is either a non-negative integer or infinity.
1208
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The sequence elements of a word are called its letters and are assumed to be indexed consecutively
beginning at zero. If |w| > 0, then the first letter of w is denoted w 0; if |w| > 1, then the second letter of w is
denoted w 1; and so forth. w i.. denotes the word obtained from w by deleting its first i letters. If i <
|w|, then w i.. = w iw i+1.... If i > |w|, then w i.. is empty.
If i < j, then w i, j denotes the finite word obtained from w by deleting its first i letters and also deleting all
letters after its ( j + 1)st. If i < j < |w|, then w i, j = w iw i+1...w j.
If w is a word over , define w to be the word obtained from w by interchanging T with . More precisely,
wi= T if w i = ; w i =  if w i = T; and w i = w i if w i is an element in 2P.
The semantics of clocked sequences and properties is defined in terms of the semantics of unclocked
sequences and properties. See F.5.1.
It is assumed that the satisfaction relation  b is defined for elements in 2P and Boolean expressions b.
For any Boolean expression b, define
T b and  b
F.5.1 Rewrite rules for clocks
The semantics of clocked sequences and properties is defined in terms of the semantics of unclocked
sequences and properties. The following rewrite rules define the transformation of a clocked sequence or
property into an unclocked version that is equivalent for the purposes of defining the satisfaction relation. In
this transformation, it is required that the conditions in event controls not be dependent upon any local
variables.
F.5.1.1 Rewrite rules for sequences
The transformation T s (S, c) recursively defined as follows produces a sequence R from a sequence S and a
clock c:
— T s (b, c) ( c c b).
= ! [*0:$] ##1 &
— T s ( v e , ) (T s ( , c) v e ).
(1, = ) c = 1 ##0 (1, = )
— T s ( (@( c 2) r ) , c 1 ) = ( T s (r, c 2 ) ) .
— T s ( ( r 1 ##1 r 2) , c) = ( T s (r 1 , c) ##1 T s (r 2 , c) ) .
— T s ( ( r 1 ##0 r 2) , c) = ( T s (r 1 , c) ##0 T s (r 2 , c) ) .
— T s ( ( r 1 or r 2) , c) = ( T s (r 1 , c) or T s (r 2 , c) ) .
— T s ( ( r 1 intersect r 2) , c) = ( T s (r 1 , c) intersect T s (r 2 , c) ) .
— T s ( r , c) T s (r, c) .
(first_match ( )) = (first_match ( ))
— T s ( r , c) T s (r, c) .
( [*0]) = ( [*0])
— T s ( r , c) T s (r, c) .
( [*1:$]) = ( [*1:$])
F.5.1.2 Rewrite rules for properties
The transformation T p (p, c) recursively defined as follows produces a property P from a property p and a
clock c:
— T p ( r , c) T s (r, c) .
strong( ) = (strong( ))
— T p ( r , c) T s (r, c) .
weak( ) = (weak( ))
— T p ( (@( c 2) p ) , c 1 ) = T p (p, c 2 ).
— T p ( b p , c) b T p (p, c) .
(disable iff( ) ) = (disable iff( ) )
— T p ( b p , c) b T p (p, c) .
(accept_on( ) ) = (accept_on( ) )
1209
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— T p ( b p , c) b c T p (p, c) .
(sync_accept_on( ) ) = (accept_on( && ) )
— T p ( p , c) T p (p, c) .
(not ) = (not )
— T p ( r p , c) T s (r, c) T p (p, c) .
( |-> ) = ( |-> )
— T p ( ( p 1 or p 2) , c) = ( T p (p 1 , c) or T p (p 2 , c) ) .
— T p ( ( p 1 and p 2) , c) = ( T p (p 1 , c) and T p (p 2 , c) ) .
— T p ( p , c) c c c c T p (p, c) .
(nexttime ) = (! until ( and nexttime (! until ( and ))))
— T p ( ( p 1 until p 2) , c) = ((not ( c and not T p (p 1 , c) )) until ( c and T p (p 2 , c) )) .
F.5.2 Tight satisfaction without local variables
Tight satisfaction is denoted by . For unclocked sequences without local variables, tight satisfaction is
defined as follows: w, x, y, and z denote finite words over .
— w b iff |w| = 1 and w0 b.
— w R iff w R.
( )
— w
(
R1
##1
R2
)
iff there exist x, y so that w = xy and x R1 and y R2 .
— w
(
R1
##0
R2
)
iff there exist x, y, z so that w = xyz and |y| = 1, and xy R1 and yz R2 .
— w
(
R1
or
R2
)
iff either w R1 or w R2 .
— w
(
R1
intersect
R2
)
iff both w R1 and w R2 .
— w R iff both
first_match( )
• w R and
• if there exist x, y so that w = xy and x R, then y is empty.
— w R iff |w| = 0.
[*0]
— w R
[*1:$]
iff there exist words w1 , w2 ,..., w
j
( j > 1) so that w = w1w2 ...w
j
and for every i so that
1< i < j, w R.
i
If S is a clocked sequence, then w S iff w S', where S' is the unclocked sequence that results from S by
applying the rewrite rules.
An unclocked sequence R is nondegenerate iff there exists a nonempty finite word w over  so that w R.
A clocked sequence S is nondegenerate iff the unclocked sequence S' that results from S by applying the
rewrite rules is nondegenerate.
F.5.3 Satisfaction without local variables
F.5.3.1 Neutral satisfaction
w denotes a nonempty finite or infinite word over . Assume that all properties, sequences, and unclocked
property fragments do not involve local variables.
Neutral satisfaction of assertion statements is as follows:
For the definition of neutral satisfaction of assertion statements, b denotes the Boolean expression
representing the enabling condition for the assertion statement. Intuitively, b is derived from the conditions
causing a queued evaluation attempt of a procedural assertion statement (see 16.14.6), while b is for a
1
declarative assertion statement.
— w, b c T iff for every 0 < i < |w| so that w i c and w i b,
always @( ) assert property
either w i.. c T or w i.. d c T.
@( ) @( )
1210
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— w, b U iff for every 0 < i < |w|, if w i b then either
always assert property
w i.. U or w i.. d U.
— w, b c T iff for every 0 < i < |w| so that
initial @( ) assert property
w 0, i !c [*0:$] ##1 c and w i b, either w i.. c T or w i.. d c T.
@( ) @( )
— w, b U iff (if w 0 b then either w U or w d U ).
initial assert property
— w, b c T iff w, b c T.
always @( ) assume property always @( )assert property
— w, b U iff w, b U.
always assume property always assert property
— w, b c T iff w, b c T.
initial @( ) assume property initial @( )assert property
— w, b U iff w, b U.
initial assume property initial assert property
— w, b c T iff there exists 0 < i < |w| so that w i c, w i b, and
always @( ) cover property
wi.. c T.
@( )
— w, b U iff there exists 0 < i < |w| so that w i b and w i.. U.
always cover property
— w, b c T iff there exists 0 < i < |w| so that w 0,i c
initial @( ) cover property ! [*0:$]
c, w i b, and w i.. c T.
##1 @( )
— w, b U iff w 0 b and w U.
initial cover property
The neutral satisfaction of assertion statements previously defined describes the behavior of an assertion
statement on a single word. Given a set of words and a set of assumptions, the following definitions describe
assertion statement satisfaction on the set of words predicated on the set of assumptions:
— A word in the set of words is feasible if every assumption in the set of assumptions is satisfied on the
word.
— An statement is satisfied on a set of words predicated on the set of assumptions
assertproperty
if it is satisfied on each feasible word.
— A statement is satisfied on a set of words predicated on the set of assumptions if it
coverproperty
is satisfied on at least one feasible word.
An assertion statement holds globally on the set of words predicated on the set of assumptions if it is
satisfied on every feasible word.
Neutral satisfaction of top-level properties is defined as follows:
— For T = P, w T iff w P.
— For U = Q, w U iff w Q.
— For T = b P, w T iff either
disable iff( )
• w P and no letter of w satisfies b, or
• Some letter of w satisfies b and w 0, i–1  P for i the least index such that
w i b, 0 < i < |w|.
— For U = b Q, w U iff either
disable iff( )
• w Q and no letter of w satisfies b, or
• Some letter of w satisfies b and w 0, i–1  Q for i the least index such that
w i b, 0 < i < |w|.
— w ( T ) iff w T.
— w ( U ) iff w U.
Disabling of top-level properties is defined as follows:
— For T = P, w d T.
— For U = Q, w d U.
1211
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— For T = b P, w d T iff some letter of w satisfies b and both w 0, i–1 T  P and
disable iff( )
w 0, i–1  P for i the least index such that w i b, 0 < i < |w|.
— For U = b Q, w d U iff some letter of w satisfies b and both w 0, i–1 T  Q
disable iff( )
and w 0, i–1  Q for i the least index such that w i b, 0 < i < |w|.
— w d ( T ) iff w d T.
— w d ( U ) iff w d U.
T is said to pass on w if w T. T is said to be disabled on w if w d T. T is said to fail on w if T neither
passes nor is disabled on w. It can be proved that T cannot both pass and be disabled on w.
Neutral satisfaction of properties is defined as follows:
— w ( P ) iff w P.
— w Q iff w T p (Q, 1).
— w P iff w P.
not
— w R iff there exists 0 < j < |w| so that w 0, j R.
strong( )
— w R iff for every 0 < j < |w|, w 0, j T  R .
weak( ) strong( )
— w R P iff for every 0 < j < |w| so that w 0, j R, w j.. P.
( |-> )
— w P P iff w P or w P .
( 1or 2) 1 2
— w P P iff w P and w P .
( 1and 2) 1 2
— w P iff either |w| 0 or w 1.. P.
(nexttime ) =
— w ( P 1 until P 2) iff either there exists 0 < j < |w| so that w j.. P 2 and for every 0 < i < j,
wi.. P
1
, or for every 0 < i < |w|, wi.. P
1
.
• w b P iff either:
(accept_on( ) )
• w P, or
— For some 0 < i < |w|, w i b and w 0, i–1 T  P.
Here, w 0, –1 denotes the empty word.
Remark: Because w is nonempty, it can be proved that w b iff w b.
not !
F.5.3.2 Weak and strong satisfaction by finite words
This subclause defines weak and strong satisfaction, denoted – and + (respectively) of an assertion A by
a finite (possibly empty) word w over . These relations are defined in terms of the relation of neutral
satisfaction by infinite words as follows:
— w – A iff w T A.
— w + A iff w A.
A tool checking for satisfaction of A by the finite word w should return the following:
— “Holds strongly” if w + A.
— “Fails” if w – A.
— “Holds (but does not hold strongly)” if w A and w + A.
— “Pending” if w – A and w A.
F.5.3.3 Vacuity
non
This subclause defines the relation of non-vacuity, denoted , between a word w and a property P. An
non
evaluation of P on w is nonvacuous provided w P.
1212
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Base:
non
• w R .
strong( )
non
• w R .
weak( )
— Induction:
non non
• w (P) iff w P.
• w non R P iff there exists i > 0 such that w 0..i R and w i.. non P.
|->
non non non
• w P P iff w P or w P .
1and 2 1 2
non non non
• w P P iff w P or w P .
1or 2 1 2
non non non
• w P P iff w P or w P .
1iff 2 1 2
non non non
• w P P iff w P ,w P , and w P .
1implies 2 1 1 2
non non
• w P iff w P.
not
• w non P iff |w| > 0 and wi.. non P.
nextime
non
•
—
w
Eit h
P
e 1 r u w n i t .. inlon
P
P 2
i f
o
f
r
t
w
he
i.
r
.
e
n
e
on
x i
P
sts
a
0
n d
< i < |w| such that the following holds:
1 2
— For all 0 < j < i, wj.. P
1 and not
P
2
.
non
• w
— Eit h
P
e 1 r s w _ i u .. nntoni l P
P
o 2 r
i f
w
f
i
t
..
he
no
re
n P
exi s
a
t
n
s
d
0 < i < |w| such that the following holds:
1 2
— For all 0 < j < i, wj.. P
1 and not
P
2
.
non
• w P iff there exists 0 < i < |w| such that the following holds:
always
— wi.. non P and
— For all 0 < j < i, wj.. P.
non
• w m n P iff there exists m < i < n such that the following holds:
always[ : ]
— wi.. non P and
— For all m < j < i, wj.. P.
non
• w m n P iff there exists m < i < n such that the following holds:
s_always[ : ]
— wi.. non P and
— For all m < j < i, wj.. P.
non
• w P iff there exists 0 < i < |w| such that the following holds:
s_eventually
— wi.. non P and
— For all 0 < j < i, wj.. P.
not
non
• w m n P iff there exists m < i < n such that the following holds:
eventually[ : ]
— wi.. non P and
— For all m < j < i, wj.. P.
not
non
• w m n P iff there exists m < i < n such that the following holds:
s_eventually[ : ]
— wi.. non P and
— For all m < j < i, wj.. P.
not
non non
• w (b) P iff w P and one of the following holds:
disable iff
1) For every 0 < i < |w|, w i b.
2) There exists a prefix x of w, such that for every 0 < i < |x|, x i b, and either x  P or
x T P.
non non
• w (b) P iff w P and one of the following holds:
accept_on
1) For every 0 < i < |w|, w i b.
2) There exists a prefix x of w, such that for every 0 < i < |x|, x i b, and either x  P or
x T P.
1213
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
non non
• w (b) P iff w P and one of the following holds:
reject_on
1) For every 0 < i < |w|, w i b.
2) There exists a prefix x of w, such that for every 0 < i < |x|, x i b, and either x  P or
x T P.
non
A word w satisfies property P nonvacuously iff w P and w P.
non non
The relation is not explicitly defined for all the derived operators. For these operators the relation is
implicitly defined by unrolling their derivation.
F.5.4 Local variable flow
This subclause defines inductively how local variable names flow through unclocked sequences. In the
following, “U” denotes set union, “ ” denotes set intersection, “–” denotes set difference, and “{}” denotes
the empty set.
The function “sample” takes a sequence as input and returns a set of local variable names as output.
Intuitively, this function returns the set of local variable names that are sampled (i.e., assigned) in the
sequence.
The function “block” takes a sequence as input and returns a set of local variable names as output.
Intuitively, this function returns the set of local variable names that are blocked from flowing out of the
sequence.
The function “flow” takes a set X of local variable names and a sequence as input and returns a set of local
variable names as output. Intuitively, this function returns the set of local variable names that flow out of the
sequence given the set X of local variable names that flow into the sequence.
The function “sample” is defined by the following:
— sample (b) = {}.
— sample ( t v R ) = sample (R) – {v}.
( ; )
— sample ( v e ) = {v}.
(1, = )
— sample ( R ) = sample (R).
( )
— sample (
(
R1
##1
R2
)
) = sample (R1 ) U sample (R2 ).
— sample (
(
R1
##0
R2
)
) = sample (R1 ) U sample (R2 ).
— sample (
(
R1
or
R2
)
) = sample (R1 ) U sample (R2 ).
— sample (
(
R1
intersect
R2
)
) = sample (R1 ) U sample (R2 ).
— sample ( R ) = sample (R).
first_match( )
— sample (R ) = {}.
[*0]
— sample (R ) = sample (R).
[*1:$]
The function “block” is defined by the following:
— block (b) = {}.
— block ( t v R ) = block (R) – {v}.
( ; )
— block ( v e ) = {}.
(1, = )
— block ( R ) = block (R).
( )
— block (
(
R1
##1
R2
)
) = (block (R1 ) – flow ({}, R2 )) U block (R2 ).
— block (
(
R1
##0
R2
)
) = (block (R1 ) – flow ({}, R2 )) U block (R2 ).
— block (
(
R1
or
R2
)
) = block (R1 ) U block (R2 ).
1214
Copyright © 2018 IEEE. All rights reserved.

Authorized licensed use limited to: Siemens AG GBS B&S SOL GMS. Downloaded on December 03,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— block (
(
R1
intersect
R2
)
) = block (R1 ) U block (R2 ) U ( sample (R1 ) sample (R2 )).
— block ( R ) = block (R).
first_match( )
— block (R ) = {}.
[*0]
— block (R ) = block (R).
[*1:$]
The function “flow” is defined by the following:
— flow (X, b) = X.
— flow (X , t v R ) = (X {v}) U (flow (X – {v}, R) – {v} ).
( ; )
— flow (X, v e ) = X U {v}.
(1, = )
— flow (X, R ) = flow (X, R).
( )
— flow (X,
(
R1
##1
R2
)
) = flow ( flow (X, R1 ), R2 ).
— flow (X,
(
R1
##0
R2
)
) = flow ( flow (X, R1 ), R2 ).
— flow (X,
(
R1
or
R2
)
) = flow (X, R1 ) flow (X, R2 ).
— flow (X,
(
R1
intersect
R2
)
) = ( flow (X, R1 ) U flow (X, R2 )) – block (
(
R1
intersect
R2
)
).
— flow (X, R ) = flow (X, R).
first_match( )
— flow (X, R ) = X.
[*0]
— flow (X, R ) = flow (X, R).
[*1:$]
Remark: It can be proved that flow (X, R) = (X U flow ({}, R)) – block (R). It follows that flow ({}, R) and
block (R) are disjoint. It can also be proved that flow ({}, R) is a subset of sample (R).
F.5.5 Tight satisfaction with local variables
A local variable context is a function that assigns values to local variable names. If L is a local variable
context, then dom(L) denotes the set of local variable names that are in the domain of L. If D dom(L),
then L| means the local variable context obtained from L by restricting its domain to D. If v is a local
D
variable name, then L\v denotes L| and L[v] denotes L| .
dom(L)-{v} {v}
In the presence of local variables, tight satisfaction is a four-way relation defining when a finite word w over
the alphabet  together with an input local variable context L satisfies an unclocked sequence R and yields
0
an output local variable context L . This relation is denoted as follows:
1
w, L0 , L1 R.
and is defined below. It can be proved that the definition guarantees that w, L , L R implies
0 1
dom(L )=flow (dom(L ), R).
1 0
— w, L0 , L1 ( t v
;
R ) iff there exists L such that w, L0 \v, L R and L1 = L0 [v] U (L\v).
— w, L0 , L1
( 1,
v
=
e
)
iff |w| = 1 and w 0
1
and L1 = {(v, e[L0 , w 0])} U L0 \v), where e[L0 , w 0]
denotes the value obtained from e by evaluating first according to L0 and second according to w 0. In
case w 0 {T, }, e[L0 ,T] and e[L0 , ] can be any constant values of the type of e.
— w, L0 , L1 b iff |w| = 1 and w 0 b[L0 ] and L1 = L0 . Here b[L0 ] denotes the expression obtained from
b by substituting values from L0 .
— w, L0 , L1
(
R
)
iff w, L0 , L1 R.
— w, L0 , L1
(
R1
##1
R2
)
iff there exist x, y, L' so that w = xy and x, L0 , L' R1 and y, L', L1 R2 .
— w, L0 , L1
(
R1
##0
R2
)
iff there exist x, y, z, L' so that w = xyz and |y| = 1, and xy, L0 , L' R1 and
yz, L', L1 R2 .
— w, L0 , L1
(
R1
or
R2
)
iff there exists L' so that both of the following hold:
1215
Copyright © 2018 IEEE. All rights reserved.



  
Authorized licensed use limited to: Siemens AG GBS B&S SOL GMS. Downloaded on December 03,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
• Either w, L0 , L' R1 or w, L0 , L' R2 , and
• L1 = L' |
D
, where D = flow (dom(L0 ),
(
R1
or
R2
)
).
— w, L0 , L1
(
R1
intersect
R2
)
iff there exist L', L" so that w, L0 , L' R1 and w, L0 , L" R2 and
L1 = L' |
D’
U L" |
D’’
, where
D’ = flow (dom(L0 ), R1 ) – (block (
(
R1
intersect
R2
)
) U sample (R2 ))
D’’ = flow (dom(L0 ), R2 ) – (block (
(
R1
intersect
R2
)
) U sample (R1 ))
Remark: It can be proved that if w, L0 , L' R1 and w, L0 , L" R2 , then L' |
D’
U L" |
D’’
is a function.
— w, L0 , L1
first_match (
R
)
iff both
• w, L0 , L1 R and
• If there exist x, y, L' so that w = xy and x, L0 , L' R, then y is empty.
— w, L0 , L1 R [*0] iff |w| = 0 and L 1 = L0 .
— w, L0 , L1 R [*1:$] iff there exist L(0) = L0 , w1 , L(1) , w2 , L(2) ,..., w j , L( j) = L1 ( j > 1) so that
w=w1w2 ...w j and for every i so that 1 < i < j, w i , L(i –1) , L(i) R.
If S is a clocked sequence, then w, L , L S iff w, L , L S', where S' is the unclocked sequence that
0 1 0 1
results from S by applying the rewrite rules.
An unclocked sequence R is nondegenerate iff there exist a nonempty finite word w over  and local
variable contexts L , L so that w, L , L R. A clocked sequence S is nondegenerate iff the unclocked
0 1 0 1
sequence S' that results from S by applying the rewrite rules is nondegenerate.
F.5.6 Satisfaction with local variables
F.5.6.1 Neutral satisfaction
w denotes a nonempty finite or infinite word over . L and L denote local variable contexts.
0 1
The rules defining neutral satisfaction of an assertion are identical to those without local variables, but with
the understanding that the underlying properties can have local variables.
Neutral satisfaction of top-level properties is defined as follows:
— For T = P, w, L T iff w, L P.
0 0
— For U = Q, w, L U iff w, L Q.
0 0
— For T = disable iff ( b ) P, w, L 0 T iff either
• w, L P and no letter of w satisfies b, or
0
• Some letter of w satisfies b and w 0, i–1 , L 0 P for i the least index such that
w i b, 0 < i < |w|.
— For U = disable iff ( b ) Q, w, L 0 U iff either
• w, L Q and no letter of w satisfies b, or
0
• Some letter of w satisfies b and w 0, i–1 , L 0 Q for i the least index such that
w i b, 0 < i < |w|.
— w, L0 ( t v
;
T ) iff w, L0 \v T.
— w, L0 ( t v
;
U ) iff w, L0 \v U.
— w, L0 ( T ) iff w, L0 T.
— w, L0 ( U ) iff w, L0 U.
1216
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Disabling of top-level properties is defined as follows:
— For T = P, w, L0 d T.
— For U = Q, w, L0 d U.
— For T = disable iff ( b ) P, w, L 0 d T iff some letter of w satisfies b and both w 0, i–1 T , L 0 P
and w 0, i–1 , L 0 P for i the least index such that w i b, 0 < i < |w|.
— For U = disable iff ( b ) Q, w, L 0 d U iff some letter of w satisfies b and both w 0, i–1 T , L 0
Q and w 0, i–1 , L 0 Q for i the least index such that w i b, 0 < i < |w|.
— w, L0 d ( t v
;
T ) iff w, L0 \v d T.
— w, L0 d ( t v
;
U ) iff w, L0 \v d U.
— w, L0 d ( T ) iff w, L0 d T.
— w, L0 d ( U ) iff w, L0 d U.
T is said to pass on w, L if w, L T. T is said to be disabled on w, L if w, L d T. T is said to fail on w,
0 0 0 0
L if T neither passes nor is disabled on w, L . It can be proved that T cannot both pass and be disabled on w,
0 0
L .
0
Neutral satisfaction of properties is defined as follows:
— w Q iff w, {} Q.
— w, L0 Q iff w, L0 T p (Q, 1).
— w, L0 ( t v
;
P ) iff w, L0 \v d P.
— w, L0
not
P iff w, L0 P.
— w, L0
strong (
R
)
iff there exist 0 < j < |w| and L1 so that w 0, j, L0 , L1 R.
— w, L0
weak (
R
)
iff for every 0 < j < |w|, w 0, j T , L0
strong (
R
)
.
— w, L0
(
R
|->
P
)
iff for every 0 < j < |w| and L1 so that w 0, j, L0 , L1 R, w j.., L1 P.
— w, L P iff w, L P.
0 ( ) 0
— w, L P P iff w, L P w, L P .
0 ( 1or 2) 0 1or 0 2
— w, L P P iff w, L P w, L P .
0 ( 1and 2) 0 1and 0 2
— w, L
0 ( nexttime
P
)
iff either |w|
=
0 or w 1.., L
0
P.
— w, L 0 ( P 1 until P 2 ) iff either there exists 0 < j < |w| so that w j.., L0 P 2 and for every
0 < i < j, w i.., L0 P 1 , or for every 0 < i < |w|, w i.., L0 P 1 .
— w, L b P iff either:
0 (accept_on( ) )
• w, L P and no letter of w satisfies b, or
0
• For some 0 < i < |w|, w i b and w 0, i–1 T  P. Here, w 0, –1 denotes the empty word.
F.5.6.2 Weak and strong satisfaction by finite words
The definition is identical to that without local variables, but with the understanding that the underlying
properties can have local variables.
F.5.6.3 Vacuity
The definition is identical to that without local variables (see F.5.3.3), but with the understanding that the
non non
underlying properties can have local variables and that w, L0 ( t v
;
P ) iff w, L0 \v P.
1217
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
F.6 Extended expressions
This subclause describes the semantics of several constructs that are used like expressions, but whose
meaning at a point in a word may depend both on the letter at that point and on other letters in the word. By
abuse of notation, the meanings of these extended expressions are defined for letters denoted “w j” even
though they depend also on letters w i for i j. The reason for this abuse is to make clear the way these
=
definitions should be used in combination with those in preceding subclauses.
F.6.1 Extended Booleans
w denotes a nonempty finite or infinite word over , j denotes an integer so that 0 < j < |w|, and T(V) denotes
an instance of a clocked or unclocked sequence that is passed the local variables V as actual arguments.
— w j,L 0 ,L 1 T(V) .triggered iff there exist 0 < i < j and L so that both w i, j, {}, L T(V) and
L =L | U L , where D = dom(L ) – (dom(L) V).
1 0 D V 0
— w j,L 0 ,L 1 @( c )( T(V) .matched) iff there exists 0 < i < j so that w i,L 0 ,L 1 T(V) .triggered and
wi+1, j , {}, {} c .
[->1])
F.6.2 Past
w denotes a nonempty finite or infinite word over , and j denotes an integer so that 0 < j < |w|.
— Let n > 1. If there exist 0 < i < j so that
w i, j , {}, {} ((c && e 2) ##1 (c && e 2[=n-1] ##1 1) ,
then e e wj e wi . Otherwise, e e wj is the result of
$past( 1,n, 2,c)[ ] = 1[ ] $past( 1,n, 2,c)[ ]
evaluating the expression e using the initial values of the variables comprising the expression. The
1
initial value of a static variable is the value assigned in its declaration, or, in the absence of such an
assignment, it is the default (or uninitialized) value of the corresponding type (see 6.8, Table6-7).
The initial value of any other variable or signal is the default value of the corresponding type (see
6.8, Table6-7).
— If j < 0 then e wj e wi–1 . e w 0 is the result of evaluating the
$past_gclk( )[ ] = [ ] $past_gclk( )[ ]
expression e using the initial values of the variables comprising the expression.
NOTE— e is equivalent to e .
$past( ) $past( ,1, 1'b1,1'b1)
F.6.3 Future
w denotes a nonempty finite or infinite word over , and j denotes an integer so that 0 < j < |w| – 1.
e wj e wi+1 . If w is a finite word, e w |w|–1 is undefined.
$future_gclk( )[ ] = [ ] $future_gclk( )[ ]
F.7 Recursive properties
This subclause defines the neutral semantics of properties, including top-level properties, with instances of
recursive properties in terms of the neutral semantics of properties with instances of nonrecursive properties.
The latter can be expanded to properties in the abstract syntax by applying the rewriting algorithm (see
F.4.1); therefore, their semantics is assumed to be understood.
Following are precise versions of the four restrictions given in 16.12.17 and the precise definition of
recursive property. The dependency digraph is the directed graph V, E , where V is the set of all named
properties and an order pair (p, q) is in E if, and only if, an instance of named property q appears in the
declaration of named property p. For example, for the set of properties
1218
Copyright © 2018 IEEE. All rights reserved.

 
Authorized licensed use limited to: Siemens AG GBS B&S SOL GMS. Downloaded on December 03,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
property p1(v);
v |=> p2(p3());
endproperty
property p2(v);
a or (1'b1 |=> v);
endproperty
property p3;
p1(a && b);
endproperty
the dependency digraph is
{p1, p2, p3},{(p1,p2),(p1,p3),(p3,p1)}
A named property is recursive if it is in a nontrivial, strongly connected component of the dependency
digraph. An instance of named property q is recursive if it is in the declaration of a named property p so that
p and q are in the same nontrivial, strongly connected component of the dependency digraph. Here, p and q
need not be distinct properties. Define the weight of an instance of q in the declaration of p as the minimal
number of time steps that are guaranteed from the beginning of the declaration of p until the instance of q. In
the example above, the weights of and of in are both one. Define the weight of an edge
p2(p3()) p3() p1
(p, q) in the dependency digraph as the minimal weight among the weights of instances of q in the
declaration of p.
The following are the restrictions over recursive properties:
— RESTRICTION 1: The negation operator cannot be applied to any property expression that
not
instantiates a property from which a recursive property can be reached in the dependency digraph.
— RESTRICTION 2: The operator cannot be used in the declaration of a recursive
disable iff
property.
— RESTRICTION 3: In every cycle of the dependency digraph, the sum of the weights of the edges
shall be positive.
— RESTRICTION 4: For every recursive instance of property q in the declaration of property p, each
actual argument expression e of the instance satisfies at least one of the following conditions:
• is itself a formal argument of p.
e
• No formal argument of appears in e.
p
• is bound to a local variable formal argument of q.
e
Let p be a named property. For k > 0, the k-fold approximation to p, denoted p[k], is a named property
without instances of recursive properties defined inductively as follows:
— The declaration of p[0] is obtained from the declaration of p by replacing the body property_spec
the literal .
1'b1
— For k > 0, the declaration of p[k] is obtained from the declaration of p by replacing each instance of
a recursive property by the corresponding instance of its (k )-fold approximation and by
-1
replacing each instance of a nonrecursive property by the corresponding instance of its k-fold
approximation.
Let  be a property, possibly the top-level property of a concurrent assertion. The k-fold approximation to ,
denoted [k], is obtained from  by replacing each instance of a named property by the corresponding
instance of its k-fold approximation. The semantics of  is then defined as follows: for any word w over 
and local variable context L, w, L  iff for all k > 0, w, L [k]. Since [k] does not have instances of
recursive properties, its semantics is obtained using the rewriting algorithm (see F.4.1).
1219
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex G
(normative)
Std package
G.1 General
This annex describes the contents of the built-in standard package, including the following:
— The semaphore class
— The mailbox class
— The randomize function
— The process class
G.2 Overview
The standard package contains system types (see 26.7). The following types are provided by the std built-in
package. The descriptions of the semantics of these types are defined in the indicated subclauses.
G.3 Semaphore
The semaphore class is described in 15.3, and its prototype is as follows:
class semaphore;
function new(int keyCount = 0);
function void put(int keyCount = 1);
task get(int keyCount = 1);
function int try_get(int keyCount = 1);
endclass
G.4 Mailbox
The mailbox class is described in 15.4, and its prototype is as follows:
The dynamic_singular_type below represents a special type that enables run-time type checking.
class mailbox #(type T = dynamic_singular_type) ;
function new(int bound = 0);
function int num();
task put( T message);
function int try_put( T message);
task get( ref T message );
function int try_get( ref T message );
task peek( ref T message );
function int try_peek( ref T message );
endclass
1220
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
G.5 Randomize
The randomize function is described in 18.12, and its prototype is as follows:
function int randomize( ... );
The syntax for the randomize function is defined as randomize_call in A.8.2. The specific form applicable to
is summarized here:
std::randomize
{ attribute_instance } [ [ variable_identifier_list ] ]
randomize ( )
[ constraint_block ]
with
G.6 Process
The process class is described in 9.7, and its prototype is as follows:
class process;
enum state { FINISHED, RUNNING, WAITING, SUSPENDED, KILLED };
static function process self();
function state status();
function void kill();
task await();
function void suspend();
function void resume();
endclass
1221
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex H
(normative)
DPI C layer
H.1 General
This annex describes the foreign language side of the direct programming interface (DPI).
H.2 Overview
The SystemVerilog DPI allows direct inter-language function calls between SystemVerilog and any foreign
programming language with a C function call protocol and linking model, as follows:
— Functions implemented in C and given import declarations in SystemVerilog can be called from
SystemVerilog; such functions are referred to as imported functions.
— Functions implemented in SystemVerilog and specified in export declarations can be called from C;
such functions are referred to as exported functions.
— Tasks implemented in SystemVerilog and specified in export declarations can be called from C;
such functions are referred to as exported tasks.
— Functions implemented in C that can be called from SystemVerilog and can in turn call exported
tasks; such functions are referred to as imported tasks.
The SystemVerilog DPI supports only SystemVerilog data types, which are the sole data types that can cross
the boundary between SystemVerilog and a foreign language in either direction. On the other hand, the data
types used in C code shall be C types; hence, the duality of types.
A value that is passed through the DPI is specified in SystemVerilog code as a value of SystemVerilog type,
while the same value shall be specified in C code as a value of C type. Therefore, a pair of matching type
definitions is required to pass a value through DPI: the SystemVerilog definition and the C definition.
It is the user’s responsibility to provide these matching definitions. A tool (such as a SystemVerilog
compiler) can facilitate this by generating C type definitions for the SystemVerilog definitions used in DPI
for imported and exported functions.
Some SystemVerilog types are directly compatible with C types; defining a matching C type for them is
straightforward. There are, however, SystemVerilog-specific types, namely packed types (arrays, structures,
and unions), 2-state or 4-state, which have no natural correspondence in C. DPI defines a canonical
representation of 4-state types that is exactly the same as the representation used by the VPI’s avalue/bvalue
representation of 4-state vectors. DPI defines a 2-state representation model that is consistent with the VPI
4-state model. DPI defines library functions to assist users in working with the canonical data representation.
The DPI C interface includes deprecated functions and definitions related to implementation-specific
representation of packed array arguments. These functions are enabled by using the specification
"DPI"
string in import and export declarations (see 35.5). Refer to H.13 for details on the deprecated functionality.
Formal arguments in SystemVerilog can be specified as open arrays solely in import declarations; exported
SystemVerilog subroutines cannot have formal arguments specified as open arrays. A formal argument is an
open array when a range of one or more of its dimensions is unspecified (denoted in SystemVerilog by using
1222
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
empty square brackets, ). This corresponds to a relaxation of the DPI argument-matching rules (see
[]
35.5.6.1). Actual arguments’ packed dimensions shall collectively match a solitary, unsized formal packed
dimension. Similarly, any actual unpacked dimension shall match a corresponding formal argument
dimension that is unsized. This facilitates writing generalized C code that can handle SystemVerilog arrays
of different sizes.
The C layer of DPI typically uses normalized ranges. The term normalized ranges means indexing
[n-1:0]
for the packed part (which may involve linearizing multiple packed dimensions) and means
[0:n-1]
indexing for an unpacked dimension. Normalized ranges are used for the canonical representation of packed
arrays in C and for SystemVerilog arrays passed as actual arguments to C. Standard open array query
functions (see H.12.2) return the original, SystemVerilog ranges for unpacked dimensions and return a
linearized, normalized range for the packed dimension.
Function arguments are generally passed by some form of reference or by value. All formal arguments,
except open arrays, are passed by direct reference or value, and, therefore, are directly accessible in C code.
Only small values of SystemVerilog input arguments (see H.8.7) are passed by value. Formal arguments
declared in SystemVerilog as open arrays are passed by a handle (type ) and are
svOpenArrayHandle
accessible via library functions. Array-querying functions are provided for open arrays.
The C layer of DPI defines a portable binary interface. Once DPI C code is compiled into object code, the
resulting object code shall work without recompilation in any compliant SystemVerilog implementation.
One normative include file, , is provided as part of the DPI C layer. This file defines all basic types,
svdpi.h
the canonical 2-state and 4-state data representation, and all interface functions.
H.3 Naming conventions
All names introduced by this interface shall conform to the following conventions:
— All names defined in this interface are prefixed with or .
sv SV_
— Function and type names start with , followed by initially capitalized words with no separators,
sv
e.g., .
svLogicVecVal
— Names of symbolic constants start with _, e.g., .
sv sv_x
— Names of macro definitions start with , followed by all uppercase words separated by a
SV_
underscore (_), e.g., .
SV_GET_UNSIGNED_BITS
H.4 Portability
DPI applications are always portable at the binary level. When compiled on a given platform, DPI object
code shall work with every SystemVerilog simulator on that platform.
H.5 svdpi.h include file
The C layer of the DPI defines include file .
svdpi.h
Applications that use the DPI with C code usually need this main include file. The include file
svdpi.h
defines the types for canonical representation of 2-state ( ) and 4-state ( ) values and passing
bit logic
references to SystemVerilog data objects. The file also provides function headers and defines a number of
helper macros and constants.
1223
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The file is fully defined in AnnexI. The content of does not depend on any particular
svdpi.h svdpi.h
implementation; all simulators shall use the same file. For more details on , see H.10.1 and
svdpi.h
AnnexI.
This file may also contain the deprecated functions and data representations described in H.13. H.13 also
describes the deprecated header , which defines the implementation-dependent representation
svdpi_src.h
of packed values.
H.6 Semantic constraints
NOTE—Constraints expressed here merely restate those expressed in 35.5.1.
Formal and actual arguments of both imported subroutines and exported subroutines are bound by the
WYSIWYG principle: What You Specify Is What You Get. This principle is binding both for the caller and
for the callee, in C code and in SystemVerilog code. For the callee, it guarantees the actual arguments are as
specified for the formal ones. For the caller, it means the function call arguments shall conform with the
types of the formal arguments, which might require type-coercion on the caller side.
Another way to state this is that no compiler (either C or SystemVerilog) can make argument coercions
between a caller’s declared formals and the callee’s declared formals. This is because the callee’s formal
arguments are declared in a different language from the caller’s formal arguments; hence there is no visible
relationship between the two sets of formals. Users are expected to understand all argument relationships
and provide properly matched types on both sides of the interface (see H.7.2).
In SystemVerilog code, the compiler can change the formal arguments of a native SystemVerilog subroutine
and modify its code accordingly because of optimizations, compiler pragmas, or command line switches.
The situation is different for imported tasks and functions. A SystemVerilog compiler cannot modify the C
code, perform any coercions, or make any changes whatsoever to the formal arguments of an imported
subroutine.
A SystemVerilog compiler shall provide any necessary coercions for the actual arguments of every imported
subroutine call. For example, a SystemVerilog compiler might truncate or extend bits of a packed array if
the widths of the actual and formal arguments are different.
Similarly, a C compiler can provide coercion for C types based on the relationship of the arguments in an
exported subroutine’s C prototype (formals) and the exported subroutine’s C call site (actuals). However, a
C compiler cannot provide such coercion for SystemVerilog types.
Coercion can be necessary when a SystemVerilog actual argument’s data type is ordinarily accepted by DPI
(H.7.4) and the argument is modified by an optional qualifier (such as ), which has semantics unrelated
rand
to the type’s representation. If a SystemVerilog compiler associates extra bits with such a data type, it shall
coerce an actual argument of that type to match the unqualified SystemVerilog form that lacks such bits.
When such a qualifier is associated with a DPI import function’s formal arguments, the DPI interface shall
not implement the qualifier’s semantics, shall expect the unqualified form of the type from SystemVerilog,
and shall deliver data for that type in the unqualified form back to SystemVerilog without manipulating any
extra bits associated with the qualified form.
For an inter-language function call between SystemVerilog and C in either direction, the compilers expect,
but cannot enforce, that the types on either side are compatible. Each compiler can coerce data to an
expected form for its side of the inter-language boundary. However, the imported or exported function types
must match the types of the corresponding subroutines in the foreign language, ignoring the presence of the
kind of qualifiers previously described.
1224
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.