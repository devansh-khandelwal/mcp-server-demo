IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
is a vpiLogicNet, is its first prefix object (a 2-bit vpiLogicNet vector),
mda[6][8][1][3] mda[6][8][1]
and is its second prefix object (a 22 packed array vpiLogicNet), etc. The
mda[6][8]
object is a vpiLogicNet (a 22 packed array vpiLogicNet), and
spa[9][12].bvec[4]
is its first prefix object (a vpiArrayNet struct member), and is the second
spa[9][12].bvec spa[9][12]
prefix object (the vpiStructNet containing the member), etc.
bvec
For a net object with prefix objects, the vpiParent transition shall return one of the following prefix objects,
whichever comes first in prefix order (rightmost to leftmost):
— Struct or union net
— Struct or union member net
— The largest containing packed array net object
— The largest containing unpacked array net object
If there is no prefix object, or no prefix object meets at least one of the above criteria, vpiParent shall return
NULL.
Using the preceding declarations, the vpiParent of is , the vpiLogicNet
mda[6][8][1][3] mda[6][8]
representing the largest containing packed array prefix; the vpiParent of is , the vpiArrayNet
mda[6][8] mda
representing the largest containing unpacked array net prefix. Likewise, the vpiParent of
is (the largest containing packed array net); the
spa[9][12].bvec[4][0] spa[9][12].bvec[4]
vpiParent of is (struct member), and applying vpiParent again
spa[9][12].bvec[4] spa[9][12].bvec
yields , the struct net for member . The vpiParent of is , the largest
spa[9][12] bvec spa[9][12] spa
containing unpacked array of the struct net; vpiParent of (or ) would return NULL.
spa mda
29) The vpiElement transition shall be used to iterate over the subelements of packed array nets. Unlike vpiNet
iterations for vpiArrayNet objects, vpiElement shall retrieve elements for only one dimension level at a time. This
means that for multidimensioned packed array nets, vpiElement shall retrieve elements that are themselves also
vpiPackedArrayNet objects. vpiElement can then be used to iterate over the subelements of these objects and so
on, until the leaf level struct nets or enum nets are returned. In other words, the data type of each element retrieved
by vpiElement is equivalent to the original vpiPackedArrayNet object’s data type with one leftmost packed range
removed. For example, consider the following vpiPackedArrayNet object:
typedef struct packed { integer i1; logic [1:0][2:3]bvec; } pavartype;
wire pavartype [0:2][6:3] panet1;
The vpiElement transition applied to shall return 3 vpiPackedArrayNet objects: ,
panet1 panet1[0]
, and . The vpiElement transition applied to vpiPackedArrayNet in turn
panet1[1] panet1[2] panet1[0]
shall retrieve vpiStructNet objects , , , and
panet1[0][6] panet1[0][5] panet1[0][4]
, respectively. Also, the vpiParent transition for all the above-mentioned subelements of
panet1[0][3]
shall return (as per detail 28), since is “the largest containing packed array net object.”
panet1 panet1 panet1
30) The vpiStructUnionMember property shall be TRUE for any enum net, integer net, time net, struct net, packed
array net, or array net that is a direct member of a struct net, i.e., whose vpiParent is a struct net (see detail 28).
This property shall be FALSE for any net, array net, or net bit whose vpiParent is not a struct net.
990
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.17 Variables
vpiPortInst
ports ports
vpiLowConn vpiHighConn
expr vpiDriver
variables variable drivers
short real var vpiLoad
variable loads
real var
module
prim term
byte var
instance short int var cont assign
scope int var path term
long int var
tchk term
expr integer var
vpiIndex typespec
time var
vpiParent
vpiParent
variables array var var select
vpiReg
-> array type
int: vpiArrayType
vpiRightRange
vpiParent
expr
packed array var
vpiParent
bit var vpiLeftRange
vpiParent expr
logic var
vpiParent range
struct var
expr vpiParent
vpiParent
union var
vpiIndex vpiParent
enum var
vpiBit
vpiMember
string var
var bit
variables
vpiIndex -> constant selection chandle var
bool: vpiConstantSelect
class var
expr virtual interface var
var bit
-> access by index -> member
vpi_handle_by_index() bool: vpiStructUnionMember
vpi_handle_by_multi_index() -> lifetime ->value
-> array member
bool: vpiAutomatic vpi_get_value()
bool: vpiArray (deprecated) -> memory allocation vpi_put_value()
bool: vpiArrayMember
int: vpiAllocScheme -> scalar
-> name
-> constant variable bool: vpiScalar
str: vpiName
bool: vpiConstantVariable -> visibility
str: vpiFullName
-> determine random availability int: vpiVisibility
-> sign
bool: vpiIsRandomized -> vector
bool: vpiSigned
-> randomization type bool: vpiVector
-> size
int: vpiRandType
int: vpiSize
991
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Details:
1) Any variable declared as an array with one or more unpacked ranges is an array var.
2) The Boolean property vpiArray is deprecated in this standard. The Boolean property vpiArrayMember shall be
if the referenced variable is a member of an array variable. It shall be otherwise.
TRUE FALSE
3) To obtain the members of a union and structure, see the relations in 37.24.
4) For an array var, vpi_iterate(vpiRange, handle) shall return the set of array range declarations beginning with the
leftmost unpacked range and iterating through the rightmost unpacked range. If any dimension of the unpacked
array other than the first dimension is a dynamic array or queue dimension, the iteration shall return an empty range
(see 37.22) for that dimension. The iteration shall also return an empty range for any dimension that is an associa-
tive array dimension. For a packed array, the iteration shall return the set of ranges beginning with the leftmost
packed range and iterating through the rightmost packed range. The ranges returned for a packed array shall not
include the implicit range for packed struct or union var elements themselves, or the range (explicit or implicit) for
the base type of enum var elements.
5) vpi_handle (vpiIndex, var_select_handle) shall return the index of a var select in a one-dimensional array.
vpi_iterate (vpiIndex, var_select_handle) shall return the set of indices for a var select in a multidimensional
array, starting with the index for the var select and working outward.
6) The vpiLeftRange and vpiRightRange relations shall return the bounds of the leftmost packed dimension for a
packed array and of the leftmost unpacked dimension for an unpacked array. If the unpacked array has no mem-
bers,or the leftmost range corresponds to an empty range (see 37.22), vpiLeftRange and vpiRightRange shall
return .
NULL
7) A var select is an element selected from an array var.
8) If the variable has an initialization expression, the expression can be obtained from vpi_handle(vpiExpr,
var_handle).
9) vpiSize for a variable array shall return the number of variables in the array. For variables belonging to an integer
data type (see 6.11), for enum vars, and for packed struct and union variables, vpiSize shall return the size of the
variable in bits. For a string var, it shall return the number of characters that the variable currently contains. For
unpacked structures and unions, the size returned indicates the number of fields in the structure or union. For a var
bit, vpiSize shall return 1. For all other variables, the behavior of the vpiSize property is not defined.
10) vpiSize for a var select shall return the number of bits in the var select. This applies only for packed var select.
11) Variables of type vpiArrayVar, vpiClassVar or vpiVirtualInterfaceVar do not have a value property. Struct var
and union var variables for which the vpiVector property is FALSE do not have a value property.
12) vpiBit iterator applies only for logic, bit, packed struct, packed union, and packed array variables.
13) vpi_handle(vpiIndex, var_bit_handle) shall return the bit index for the variable bit. vpi_iterate(vpiIndex,
var_bit_handle) shall return the set of indices for a multidimensional variable bit select, starting with the index for
the bit and working outwards.
14) cbSizeChange shall be applicable only for dynamic and associative arrays, for queues, and for string vars. If both
value and size change, the size change callback shall be invoked first. This callback fires after the size change
occurs and before any value changes for that variable. The value in the callback is the new size of the array.
15) The property vpiRandType returns the current randomization type for the variable, which can be one of vpiRand,
vpiRandC, or vpiNotRand.
16) vpiIsRandomized is a property to determine whether a random variable is currently active for randomization.
17) When the vpiStructUnionMember property is , it indicates that the variable is a member of a parent struct or
TRUE
union variable. See also the relations in 37.24 and 37.18 detail 5.
18) If a variable is an element of an array (the vpiArrayMember property is ), the vpiIndex iterator shall return
TRUE
the indexing expressions that select that specific variable out of the array. See 37.18 (and detail 6) for similar
functionality available for elements of packed array vars.
19) In the preceding diagram:
logic var == reg
var bit == reg bit
array var == reg array
vpiVarBit is #defined the same as vpiRegBit for backward compatibility. However, a vpiVarBit can be an
992
Authorized licensed use limited to: Siemens AG GBS CBo&pSy SrigOhLt G©M 2S0.1 D8o IwEnEloEa.d Aeldl roignh Dtse creemsebrevre 0d3.,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
element of a vpiBitVar (2-state) or a vpiLogicVar (4-state), whereas vpiRegBit could only be an element of a
vpiReg (4-state).
SystemVerilog treats and variables as equivalent in all respects. To allow for backward compatibility,
reg logic
a call to vpi_get_str(vpiType,<logic_var_handle>) may return either “vpiLogicVar” or “vpiReg”. Similarly,
vpi_get_str(vpiType,<var_bit_handle>) may return either “vpiVarBit” or “vpiRegBit”, while
vpi_get_str(vpiType,<array_var_handle>) may return either “vpiArrayVar” or “vpiRegArray”.
20) A bit var or logic var, without a packed dimension defined, is a scalar and for those objects, the property vpiScalar
shall return , and the property vpiVector shall return . A bit var or logic var, with one or more packed
TRUE FALSE
dimensions defined, is a vector, and the property vpiVector shall return (vpiScalar shall return ). A
TRUE FALSE
packed struct var, a packed union var, and packed array var are vectors, and the property vpiVector shall return
(vpiScalar shall return ). A var bit is a scalar, and the property vpiScalar shall return
TRUE FALSE TRUE
(vpiVector shall return ). The properties vpiScalar and vpiVector when queried on a handle to an enum var
FALSE
shall return the value of the respective property for an object for which the typespec is the same as the base typespec
of the typespec of the enum var. For an integer var, time var, short int var, int var, long int var, and byte var, the
property vpiVector shall return (vpiScalar shall return ). For an array var, the vpiScalar and
TRUE FALSE
vpiVector properties shall return the values of the respective properties for an array element. The vpiScalar and
vpiVector properties shall return for all other var objects.
FALSE
21) vpiArrayType can be one of vpiStaticArray, vpiDynamicArray, vpiAssocArray, or vpiQueue.
22) vpiRandType can be one of vpiRand, vpiRandC, or vpiNotRand.
23) For details on lifetime and memory allocation properties, see 37.3.7.
24) vpiVisibility denotes the visibility ( , , or default) of a variable that is a class member.
local protected
vpiVisibility shall return vpiPublicVis for a class member that is not or , or for a variable that
local protected
is not a class member.
25) A non-static data member of a class var does not have a vpiFullName property. The static data member of a class,
referenced either via a class var or a class defn, has the vpiFullName property. It shall return a full name string
representing the hierarchical path of the static variable through “class defn”. For example:
module top;
class Packet ;
static integer Id ;
....
endclass
Packet p;
c = p.Id;
....
The vpiFullName for is “ ”.
p.Id top.Packet::Id
26) The vpiParent transition shall be allowed on all variable objects. It shall return one of the following types of
objects, representing one of its prefix objects (similar to the field select prefix or indexing select prefix as described
in 11.5.3), or NULL, depending on whether certain criteria are met. For purposes of defining vpiParent, a prefix
object is the object obtained from successively removing the rightmost index or identifier from a compound or
indexed/multidimensional object name (excluding scope identifiers).
Consider the following vpiArrayVar objects:
logic [1:0][2:3] mda [4:6][6:8];
struct { int i1; bit [1:0][2:3]bvec[4:5]; } spa [9:11][12:13];
is a vpiVarBit, is its first prefix object (a 2-bit vpiLogicVar vector), and
mda[6][8][1][3] mda[6][8][1]
is its second prefix object (a 2 x 2 vpiLogicVar packed array), etc. The
mda[6][8] spa[9][12].bvec[4]
object is a vpiBitVar (a 2 x 2 vpiBitVar packed array), and is its first prefix object (a
spa[9][12].bvec
vpiArrayVar struct member), and is the second prefix object (the vpiStructVar containing the
spa[9][12]
member). etc.
bvec
For a variable object with prefix objects, the vpiParent transition shall return one of the following prefix objects,
whichever comes first in prefix order (rightmost to leftmost):
— Struct, union, or class variable
— Struct or union member variable, or class variable data member
— The largest containing packed array object
993
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— The largest containing unpacked array object
If there is no prefix object, or no prefix object meets at least one of the above criteria, vpiParent shall return
NULL.
Using the preceding declarations, the vpiParent of is , the vpiLogicVar
mda[6][8][1][3] mda[6][8]
representing the largest containing packed array prefix; the vpiParent of is , the vpiArrayVar
mda[6][8] mda
representing the largest containing unpacked array prefix. Likewise, the vpiParent of
is (the largest containing packed array); the vpiParent
spa[9][12].bvec[4][0] spa[9][12].bvec[4]
of is (struct member), and applying vpiParent again yields
spa[9][12].bvec[4] spa[9][12].bvec
, the struct variable for member . The vpiParent of is , the largest
spa[9][12] bvec spa[9][12] spa
containing unpacked array of the struct variable; vpiParent of (or ) would return NULL.
spa mda
Class variables (as previously mentioned in the prefix object types) shall be returned as parent objects only when
they are explicitly used to reference corresponding class data members in the design. A VPI handle to a data
member that does not correspond to such an explicit reference in the design (e.g., a VPI handle to a data member
derived from iterations on its vpiClassObj or vpiClassDefn) shall have a NULL parent.
27) The property vpiConstantSelect shall return TRUE for a var bit or other variable if it has a static lifetime and has
no parent (the vpiParent relation returns ) or if both of the following are true of the “select” part of the
NULL
equivalent primary expression (see A.8.4):
— Every index expression in the select is an elaboration time constant expression.
— Every element within the select denotes either a member of a struct or union variable or a member of a packed
or unpacked array with static bounds.
Otherwise, vpiConstantSelect shall return FALSE.
NOTE 1—The final (non-prefix) element of the select may be an unindexed member identifier belonging to any
VPI variable type. It may, for example, be the name of a class variable or dynamic array. However, it must not be a
member of a class variable if the member has an automatic lifetime, and it must not be an element of a dynamically
allocated array.
NOTE 2—If vpiConstantSelect is TRUE, then if the handle refers to a valid underlying simulation object at the
beginning of simulation (or at any point in the simulation), it refers to the same object at all points in the simulation.
Moreover, if any index expression is in or out of bounds at the beginning of simulation, it is in or out of bounds at
all subsequent simulation times as well.
37.18 Packed array variables
enum var
vpiParent struct var vpiIndex
packed array var expr
vpiElement union var
-> packed
packed array var
bool: vpiPacked
-> packed array member
bool: vpiPackedArrayMember
-> constant selection
bool: vpiConstantSelect
Details:
1) vpiPackedArrayVar objects shall represent packed arrays of packed struct var, union var, or enum var objects.
The properties vpiVector and vpiPacked for these objects and their underlying struct var, union var, or enum var
elements shall always be TRUE (see 37.17).
2) For consistency with other variable-width vector objects, the vpiSize property for vpiPackedArrayVar objects
shall be the number of bits in the packed array, not the number of struct, enum, or union var elements. The total
994
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
number of struct var, enum var, or union var elements for a packed array var can be obtained by computing the
product of the vpiSize property for all of its packed ranges.
3) The vpiElement transition shall be used to iterate over the subelements of packed array variables. Unlike
vpiVarSelect or vpiReg transitions for vpiArrayVar objects, vpiElement shall retrieve elements for only one
dimension level at a time. This means that for multi-dimensioned packed arrays, vpiElement shall retrieve
elements that are themselves also vpiPackedArrayVar objects. vpiElement can then be used to iterate over the
subelements of these objects and so on, until the leaf level struct, enum, or union vars are returned. In other words,
the data type of each element retrieved by vpiElement is equivalent to the original vpiPackedArrayVar object’s
data type with the leftmost packed range removed. For example, consider the following vpiPackedArrayVar
object:
typedef struct packed { int i1; bit [1:0][2:3] bvec; } pavartype;
pavartype [0:2][6:3] pavar1;
The vpiElement transition applied to shall return 3 vpiPackedArrayVar objects: ,
pavar1 pavar1[0]
, and . The vpiElement transition applied to vpiPackedArrayVar in turn
pavar1[1] pavar1[2] pavar1[0]
shall retrieve vpiStructVar objects , , , and
pavar1[0][6] pavar1[0][5] pavar1[0][4]
, respectively. Also, the vpiParent transition for all the above-mentioned subelements of
pavar1[0][3]
shall return (as per detail 26 of 37.17, since is “the largest containing packed array
pavar1 pavar1 pavar1
object”).
4) The vpiPackedArrayMember property shall be TRUE for any struct var, union var, enum var, or packed array var
whose vpiParent is a packed array var (see detail 26 of 37.17).
5) The vpiStructUnionMember property shall be TRUE only for packed array vars that are direct members of struct
or union vars, i.e., whose vpiParent is a struct or union var (see detail 26 of 37.17). This property shall be FALSE
for all subelements (as returned by the vpiElement iterator) of such packed array vars.
6) vpi_iterate(vpiIndex, packed_array_var_handle) shall return the set of indices for a subelement of a packed
array variable (relative to its vpiParent), starting with the index for the subelement and working outwards. The
indices retrieved shall be the same as those shown in the example for detail 3 for each of the subelements returned
by vpiElement. The indices will be retrieved in right-to-left order as they appear in the text.
37.19 Variable select
vpiIndex
expr
vpiParent vpiIndex
array var var select expr
-> constant selection
bool: vpiConstantSelect
-> name typespec
str: vpiName
str: vpiFullName
-> size
int: vpiSize
-> value
vpi_get_value()
vpi_put_value()
Details:
1) The property vpiConstantSelect shall return TRUE for a var select if
— every associated index expression is an elaboration time constant expression, and
— the parent of the var select is an unpacked array with static bounds, and
— vpiConstantSelect returns TRUE for the parent of the var select.
Otherwise, vpiConstantSelect shall return FALSE.
995
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
NOTE—If vpiConstantSelect is TRUE, then if the handle refers to a valid underlying simulation object at the
beginning of simulation (or at any point in the simulation), it refers to the same object at all points in the simulation.
Moreover, if an index expression of the var select or of any of its parents is in or out of bounds at the beginning of
simulation, it is in or out of bounds at all subsequent simulation times as well.
37.20 Memory
scope
vpiLeftRange
expr
module
vpiRightRange
expr
vpiMemory
vpiParent
reg array
-> access by index
vpi_handle_by_index()
vpi_handle_by_multi_index()
-> is a memory
bool: vpiIsMemory
vpiLeftRange
vpiMemoryWord expr
expr reg
vpiIndex
vpiRightRange
expr
Details:
1) The objects vpiMemory and vpiMemoryWord have been generalized with the addition of arrays of variables. To
preserve backwards compatibility, they have been converted into methods that will return objects of type
vpiRegArray and vpiReg, respectively. See 37.17 for the definitions of variables and variable arrays.
37.21 Variable drivers and loads
vpiDriver vpiLoad
variable drivers variables variable loads
ports assign stmt
force force
cont assign cont assign
cont assign bit cont assign bit
assign stmt
Details:
1) vpiDrivers/Loads for a structure, union, or class variable shall include the following:
— Driver/Load for the whole variable
996
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Driver/Load for any bit-select or part-select of that variable
— Driver/Load of any member nested inside that variable
2) vpiDrivers/Loads for any variable array should include driver/load for entire array/vector or any portion of an
array/vector to which a handle can be obtained.
37.22 Object Range
vpiLeftRange
expr
range
vpiRightRange
-> size expr
int: vpiSize
Details:
1) An empty range is a range that has no elements. An empty range shall be used to represent:
— any range corresponding to an associative array dimension (see 37.17, detail 4)
— a range corresponding to an empty dynamic array or queue
— any range obtained from a typespec corresponding to a dynamic array, queue, or associative array dimension
For example:
int arr1 [][string];
initial
begin
#1 arr1 = new[2];
#1 arr1[0]["hello"] = 5;
end
All ranges obtained from the typespec handle of are empty. Also, ranges obtained from the object
arr1 arr1
itself at simulation time 0 are all empty, since the array is not sized yet. At times 1 and 2, the first range of is
arr1
and the second is empty since it corresponds to an associative array dimension.
[0:1]
2) For an empty range, vpiSize shall return 0, while the vpiLeftRange and vpiRightRange relations shall each return
.
NULL
997
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.23 Typespec
vpiTypedefAlias
typespec
instance typespec
short real typespec
real typespec
byte typespec
short int typespec
int typespec
long int typespec
integer typespec
class typespec
vpiBaseTypespec
typespec time typespec typespec
enum typespec
enum const
expr
string typespec -> name
str: vpiName
struct typespec
-> value
-> packed
typespec member vpi_get_value()
bool: vpiPacked
-> name
union typespec
str: vpiName
-> tagged
-> randomization type
bool: vpiTagged
int: vpiRandType
vpiElemTypespec
bit typespec bit typespec
range -> vector vpiElemTypespec
bool: vpiVector logic typespec
logic typespec
expr -> vector enum typespec
vpiLeftRange bool: vpiVector
vpiElemTypespec struct typespec
expr packed array typespec
vpiRightRange -> vector union typespec
vpiIndexTypespec bool: vpiVector
packed array typespec
typespec array typespec
-> array type
vpiElemTypespec
range
int: vpiArrayType
typespec
void typespec
sequence typespec
property typespec
event typespec
interface typespec
type parameter
-> name
str: vpiName
998
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Details:
1) If a typespec denotes a type that has a user-defined typedef, the vpiName property shall return the name of that
type; otherwise, except in the case of a class typespec (see 37.30), the vpiName property shall return .
NULL
Consequently the vpiName property returns for any SystemVerilog built-in type. If the typespec denotes a
NULL
type with a typedef that creates an alias of another typedef, then the vpiTypedefAlias of the typespec shall return a
non-null handle, which represents the handle to the aliased typedef. For example:
typedef enum bit [0:2] {red, yellow, blue} primary_colors;
typedef primary_colors colors;
If “ ” is a handle to the typespec , its vpiType shall return vpiEnumTypespec, the vpiName property
h1 colors
shall return “colors,” vpiTypedefAlias shall return a handle “ ” to the typespec “ ” of
h2 primary_colors
vpiType vpiEnumTypespec. The vpiName property for “ ” shall return “ ”, and its
h2 primary_colors
vpiTypedefAlias shall return .
NULL
2) vpiIndexTypespec relation is present only on associative array typespecs and returns the type that is used as the
key into the associative array. For the wildcard index type (see 7.8.1), vpiIndexTypespec shall return .
NULL
3) If the value of the property vpiType of a typespec is vpiStructTypesec or vpiUnionTypespec, then it is possible to
iterate over vpiTypespecMember to obtain the structure of the user-defined type. For each typespec member, the
typespec relation indicates the type of the member.
4) The property vpiName of a typespec member returns the name of the corresponding member, rather than the name
(if any) of the associated typespec.
5) The name of a typedef may be the empty string if the typespec denotes typedef field defined in-line rather than via
a typedef declaration. For example:
typedef struct {
struct
int a;
} B
} C;
The typespec representing the typedef C is a struct typespec; it has a single typespec member named B. The
typespec relation for B returns another struct typespec that has no name and has a single typespec member named
“a”. The typespec relation for “a” returns an int typespec.
6) If a type is defined as an alias of another type, it inherits the vpiType of this other type. For example:
typedef time my_time;
my_time t;
The vpiTypespec of the variable named “ ” shall return a handle to the typespec “ ” whose vpiType
t h1 my_time
shall be a vpiTimeTypespec. The vpiTypedefAlias applied to handle shall return a typespec handle to the
h1 h2
predefined type “time”.
7) The expr associated with a typespec member shall represent the explicit default member value, if any, of the
corresponding member of an unpacked structure data type (See 7.2).
8) The vpiElemTypespec transition shall be used to unwind the typespec of an unpacked array (array typespec) or a
packed array (packed array typespec, or a bit or logic typespec with one or more dimensions), one dimension level
at a time. This means that for a multidimensional array typespec (a typespec with more than one unpacked range),
vpi_handle(vpiElemTypespec, array_typespec_handle) shall initially retrieve a vpiArrayTypespec equivalent
to the original typespec with its leftmost unpacked range removed. Subsequent calls to the vpiElemTypespec
method continue the unwinding until a typespec object is retrieved that has no unpacked ranges remaining.
Similarly, when the vpiElemTypespec is applied to a typespec of a multidimensional packed array object, a
vpiPackedArrayTypespec (or vpiBitTypespec or vpiLogicTypespec) is retrieved that is equivalent to the
original typespec with its leftmost packed range removed, and so on, until a typespec without an explicit packed
range is retrieved. When the vpiElemTypespec relation is applied to a vpiStructTypespec, vpiUnionTypespec,
vpiEnumTypespec, or a vpiBitTypespec or vpiLogicTypespec with no ranges present, it shall return . This
NULL
allows packed or unpacked array typespecs constructed with multiple typedefs to be unwound without losing name
information. Consider the complex array typespec defined below for :
arr
typedef struct packed { int i1; bit bvec; } [1:3] parrtype;
typedef parrtype [2:1] parrtype2;
999
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
typedef parrtype2 unparrtype [6:4];
unparrtype arr [3:0];
The typespec of the object is an unpacked 43 array typespec with a vpiName property. The typespec
arr NULL
retrieved by applying vpiElemTypespec to this is a 3-element unpacked array typespec with a vpiName property
of “ ”. The typespec retrieved by using vpiElemTypespec on this in turn yields a 23 packed array
unparrtype
typespec (of packed struct objects) with a vpiName property of “ ”. Using vpiElemTypespec again in
parrtype2
turn yields another packed array typespec (of 3 packed struct objects) with a vpiName property of “ ”.
parrtype
One more application of vpiElemTypespec to this result yields a struct typespec, a non-array typespec for which
no further array subelements exist (the unwinding is done).
9) If a logic typespec, bit typespec, or packed array typespec has more than one packed dimension, vpiLeftRange and
vpiRightRange shall return the bounds of the leftmost packed dimension. If an array typespec has more than one
unpacked dimension, vpiLeftRange and vpiRightRange shall return the bounds of the leftmost unpacked
dimension, unless that dimension corresponds to an empty range (see 37.22), in which case they shall return NULL.
10) For an array typespec, vpi_iterate(vpiRange, handle) shall return the set of array range declarations beginning
with the leftmost unpacked range and iterating through the rightmost unpacked range. If any dimension of the array
typespec corresponds to a dynamic array, associative array, or queue, the iteration shall return an empty range (see
37.22) for that dimension. For a logic typespec or bit typespec that has an associated range, the iteration shall return
the set of ranges beginning with the leftmost packed range and iterating through the rightmost packed range.
11) In a context (such as a class defn) in which a type parameter has not been resolved, the type parameter itself shall
act as a typespec.
37.24 Structures and unions
struct var vpiParent
variables
union var vpiMember
-> packed
bool: vpiPacked
Details:
1) vpi_get_value()/vpi_put_value() cannot be used to access values of entire unpacked structures and unpacked
unions.
1000
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.25 Named events
vpiTypespec
event typespec
instance
vpiWaitingProcesses
named event thread
-> array member
scope
bool: vpiArray (deprecated)
bool: vpiArrayMember
-> name
module
str: vpiName
str: vpiFullName
-> value
vpi_put_value()
-> lifetime
bool: vpiAutomatic
-> memory allocation
int: vpiAllocScheme
Details:
1) The vpiWaitingProcesses iterator returns all waiting processes, static or dynamic, identified by their thread, for
that named event.
2) vpi_iterate(vpiRange, named_event_array_handle) shall return the set of array range declarations beginning
with the leftmost unpacked range and iterating through the rightmost unpacked range.
3) For details on lifetime and memory allocation properties, see 37.3.7.
vpiTypespec
array typespec
instance
vpiParent
module named event array named event
-> name
range
str: vpiName
vpiIndex
str: vpiFullName
-> access by index expr
vpi_handle_by_index()
vpi_handle_by_multi_index()
-> lifetime
bool: vpiAutomatic
-> memory allocation
int: vpiAllocScheme
Details:
1) vpi_iterate(vpiIndex, named_event_handle) shall return the set of indices for a named event within an array,
starting with the index for the named event and working outward. If the named event is not part of an array, a
NULL
shall be returned.
2) For details on lifetime and memory allocation properties, see 37.3.7.
1001
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.26 Parameter, spec param, def param, param assign
module
vpiParameter
parameters
scope
parameter
type parameter
-> local
bool: vpiLocalParam
-> name
str: vpiName
str: vpiFullName
parameter typespec
-> constant type
expr
int: vpiConstType
-> sign vpiLeftRange
bool: vpiSigned expr
-> size
vpiRightRange
int: vpiSize expr
-> value
vpi_get_value()
type parameter typespec
vpiExpr
typespec
vpiLhs
parameter
module def param
vpiRhs
expr
vpiLhs
parameters
module
param assign
expr
scope -> connection by name vpiRhs
bool: vpiConnByName
typespec
Details:
1) For a value parameter, vpi_get_value() shall return the value that the parameter has at the end of elaboration.
2) The vpiTypespec of a type parameter shall return the typespec that the type parameter has at the end of elaboration,
but without resolving typedef aliases.
1002
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
3) The vpiExpr relation of a value parameter shall return the default expr, while the vpiExpr relation of a type
parameter shall return the default typespec.
4) vpiLhs from a param assign object shall return a handle to the overridden value parameter or type parameter.
5) If a value parameter does not have an explicitly defined range, vpiLeftRange and vpiRightRange shall return a
handle.
NULL
37.27 Virtual interface
vpiTypespec
virtual interface var interface typespec
-> name
str: vpiName interface expr
str: vpiFullName
-> is modport interface
bool: vpiIsModPort
modport
virtual interface var
vpiExpr
ref obj
constant
interface
vpiActual modport
Details:
1) The vpiExpr relation shall return the interface instance assigned to the virtual interface in its declaration, if any;
otherwise, vpiExpr shall return NULL.
2) A ref obj may be an interface expr only if it is a local declaration of an interface or modport passed through a port.
A constant may be an interface expr only if it has a vpiConstType of vpiNullConst.
Example 1: Passing an interface or modport through a port:
interface SBus #(parameter WIDTH=8);
logic req, grant;
logic [WIDTH-1:0] addr, data;
modport phy(input addr, inout data);
endinterface
module top;
parameter SIZE = 4;
virtual SBus#(16) V16;
virtual SBus#(32).phy V32_Array [1:SIZE];
...
endmodule
1003
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In this example, is a virtual interface, while is an array var. The vpiVariables iteration from
V16 V32_Array
module includes both and , while the vpiVirtualInterfaceVar iteration returns
top V16 V32_Array V16
together with the individual elements of , that is, through .
V32_Array V32_Array[1] V32_Array[4]
Example 2: Virtual interface declaration in a class definition:
interface SBus; // A Simple bus interface
logic req, grant;
logic [7:0] addr, data;
endinterface
class SBusTransactor; // SBus transactor class
virtual SBus bus; // virtual interface of type SBus
function new( virtual SBus s );
bus = s; // initialize the virtual interface
endfunction
task request(); // request the bus
bus.req <= 1'b1;
endtask
task wait_for_bus(); // wait for the bus to be granted
@(posedge bus.grant);
endtask
endclass
module devA( SBus s ); ... endmodule // devices that use SBus
module devB( SBus s ); ... endmodule
module top;
SBus s[1:4] (); // instantiate 4 interfaces
devA a1( s[1] ); // instantiate 4 devices
devB b1( s[2] );
devA a2( s[3] );
devB b2( s[4] );
initial begin
SbusTransactor t[1:4]; // create 4 bus-transactors and bind
t[1] = new( s[1] );
t[2] = new( s[2] );
t[3] = new( s[3] );
t[4] = new( s[4] );
end
endmodule
A virtual interface var is returned for the left-hand side expression of the statement “ ” in the constructor
bus = s
of the class definition . The vpiName of the virtual interface var is “ ”, and it has a
SBusTransactor bus
vpiInterfaceTypespec for which the vpiDefName is “ ”. The vpiActual relationship returns the interface
SBus
instance associated with that particular call to after the assignment has executed. For example, if it was
new
“ ”, vpiActual would return the interface . If vpiActual is queried before the assignment is
new(s[1]) s[1]
executed, the method shall return NULL if the virtual interface is uninitialized. In addition, the right-hand side
expression of “ ” returns a virtual interface var for which vpiActual is the interface instance passed to the
bus = s
call to .
new
1004
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.28 Interface typespec
interface typespec
vpiParent
interface typespec param assign
-> name
str: vpiName
-> def name
str: vpiDefName
-> is modport
bool: vpiIsModPort
Details:
1) The vpiDefName of an interface typespec that represents a modport shall be the modport identifier. The
vpiDefName of an interface typespec that represents an interface shall be the identifier of the interface declaration.
2) For an interface typespec that represents a modport, vpiParent shall return an interface typespec of the
corresponding interface. For an interface typespec that represents an interface, vpiParent shall return NULL.
3) In the following example, the first typedef defines an interface typespec corresponding to “
virtual
” whose vpiName is . The vpiDefname of this typespec shall be , and the assigned
SBus#(16) SB16 SBus
parameter value of 16 shall be derived by iterating on vpiParamAssign. The typedef , however, is an array
SBphy
typespec for which the vpiElemTypespec returns an interface typespec corresponding to “
virtual
”.
SBus#(32).phy
The vpiTypedef iteration from the module returns handles to both and interface typespecs.
top SB16 SBphy
interface SBus #(parameter WIDTH=8);
logic req, grant;
logic [WIDTH-1:0] addr, data;
modport phy(input addr, inout data);
endinterface
module top;
parameter SIZE = 4;
typedef virtual SBus#(16) SB16;
typedef virtual SBus#(32).phy SBphy [1:SIZE];
...
endmodule
1005
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.29 Class definition
class typespec
instance
class defn
vpiDerivedClasses scope
variables
extends class defn
vpiMethods
task func
-> name
str: vpiName
constraint
-> virtual
vpiArgument
bool: vpiVirtual
vpiParameter
expr -> declared lifetime parameters
bool: vpiAutomatic
named event
named event array
vpiTypedef
type spec
scope
vpiInternalScope
Details:
1) The iterations over vpiVariables, vpiMethods, vpiNamedEvent, and vpiNamedEventArray shall return both
static and automatic properties or methods. However, the iteration over vpiMethods shall not include built-in
methods for which there is no explicit declaration.
2) vpi_get_value() and vpi_put_value() are not allowed for variable and event handles obtained from class defn
handles.
3) The iterator to constraints returns only normal constraints and not inline constraints.
4) The vpiConstraint iteration shall return the constraints in syntactic declaration order. The position within this
order of a constraint declared as shall be determined by the position of its prototype. To get constraints
extern
inherited from base classes, it is necessary to traverse the extends relation to obtain the base class typespec.
5) The vpiDerivedClasses iterator shall return all the class defns derived from the given class defn.
6) The relation to vpiExtends exists whenever one class is derived from another class (refer to 8.13). The relation
from extends to class typespec provides the base class. The vpiArgument iterator from extends shall provide the
arguments used in constructor chaining (refer to 8.17).
7) The vpiParameter iteration shall return both the parameters declared in the parameter port list of the class
declaration and the parameters declared within the body of the class declaration as class items. The property
vpiLocalParam (see 37.26) shall return TRUE for parameters declared within the body.
8) For details on lifetime and memory allocation properties, see 37.3.7.
1006
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.30 Class typespec
param assign
class typespec
vpiExtends
variables
class defn class typespec
vpiMethods
-> name task func
str: vpiName
-> class type constraint
int: vpiClassType
-> declared lifetime vpiParameter
parameters
bool: vpiAutomatic
virtual interface var
named event
named event array
scope
vpiInternalScope
Details:
1) According to how it is obtained, a class typespec may represent either a lexical construct or a class specialization.
If the class typespec is obtained as part of a class defn, it represents a lexical construct from the SystemVerilog
source code. In particular, it shall represent a lexical construct under the following conditions:
— It is obtained from a class defn via the vpiTypedef iteration. In this case it represents a user-defined typedef.
— It is part of the declaration of a class item (variable or method) obtained from the class defn.
— It is obtained from the extends object associated with the class defn.
A class typespec object that has all parameter values resolved shall represent a class specialization. In particular, it
shall represent a class specialization under the following conditions:
— It is obtained from a class defn by iterating over vpiClassTypespec.
— It is the type of a variable or method for which no containing scope is a class defn. If the variable or method is
declared using the name of a typedef, the class typespec shall be the corresponding class instantiation rather
than the class typespec for the typedef itself.
A class typespec derived from a class defn for which the parameter port list is empty may represent both a lexical
construct and a class specialization.
2) For a class typespec that represents only a lexical construct, the one-to-many relations vpiVariables, vpiMethods,
vpiConstraint, vpiNamedEvent, vpiNamedEventArray, vpiTypedef, and vpiInternalScope are not supported.
3) In the case of a class typespec that represents a lexical construct, if the class type construct includes an explicit
parameter expression or type, the object for that parameter or type shall constitute the vpiRhs part of the
corresponding param assign (see 37.26); otherwise the vpiRhs part shall reference the default expression or type
with which the parameter was declared. However, if the class typespec represents a class specialization, the vpiRhs
of each param assignment may be any object that has the correct value (in the case of a non-type parameter) or type
(in the case of a type parameter).
1007
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
4) A class typespec that represents a class specialization shall have a valid, though tool-dependent, name.
5) From a class typespec that represents a class specialization, the iterations over vpiVariables, vpiMethods,
vpiNamedEvent, and vpiNamedEventArray shall return both static and automatic properties or methods.
However, the iteration over vpiMethods shall not include built-in methods for which there is no explicit
declaration.
6) vpi_get_value() and vpi_put_value() are not allowed for non-static variable and event handles obtained from class
typespec handles.
7) The iterator to constraints returns only normal constraints and not inline constraints.
8) The vpiConstraint iteration shall return the constraints in syntactic declaration order. The position within this
order of a constraint declared as shall be determined by the position of its prototype. To get constraints
extern
inherited from a base class typespec, it is necessary to traverse the extends relation to obtain the base class typespec.
9) The vpiExtends relation shall return the base class typespec, if any, from which a given class typespec is derived.
The base class typespec of a class specialization shall also be a specialization.
10) The vpiClassTypespec iteration from a class defn shall return the class specializations derived directly (and not by
inheritance) from that class defn.
11) The vpiVirtualInterfaceVar iteration (formerly vpiInterfaceDecl—now deprecated in this standard—see C.4.3,
item 5) shall return the virtual interface var declarations in the class specialization (see 37.12 detail 7). If an array of
virtual interfaces is declared, the vpiVirtualInterfaceVar iteration shall return each element of the array
separately. However, the vpiVariables iteration shall return the array declaration as a single vpiArrayVar.
12) The vpiParameter iteration shall return parameters corresponding both to those declared in the parameter port list
of the class declaration and to those declared within the body of the class declaration as class items. The property
vpiLocalParam (see 37.26) shall return TRUE for parameters declared within the body.
13) The vpiClassDefn relation shall return NULL for built-in classes.
14) For details on lifetime and memory allocation properties, see 37.3.7.
1008
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.31 Class variables and class objects
class var class obj variables
-> referenced identity -> my identity
class typespec
int64: vpiObjId int64: vpiObjId
vpiWaitingProcesses
thread
class typespec
vpiMessages
expr
vpiMethods
task func
constraint
vpiParameter
parameters
virtual interface var
named event
named event array
scope
vpiInternalScope
Details:
1) The property vpiObjId is a class object’s identifier. It is a property of a live object and guaranteed to be unique
with respect to all other dynamic objects that support this property for as long as the object is alive. After the object
is destroyed by garbage collection, its particular vpiObjId value may be reused.
2) For a class var, its vpiObjId is the identifier of the object it references or 0, indicating it is not referencing any
object.
3) The vpiWaitingProcesses iterator on a mailbox or semaphore shall return the threads waiting on the class object or
object resource. A waiting process is a static or dynamic process represented by its suspended thread. A process
may be waiting to retrieve a message from a mailbox or waiting for a semaphore resource key.
4) A vpiMessages iteration shall return all the messages in a mailbox.
5) For a class var, vpiClassTypespec shall return the class typespec with which the class var was declared in the
SystemVerilog source text. If the class var has the value of , the vpiClassObj relationship applied to the class
NULL
var shall return a null handle. vpiClassTypespec when applied to a class obj handle shall return the class typespec
with which the class obj was created. The difference between the two usages of vpiClassTypespec can be seen in
the following example:
class Packet;
...
endclass : Packet
class LinkedPacket extends Packet;
...
endclass : LinkedPacket
LinkedPacket l = new;
Packet p = l;
In this example, the vpiClassTypespec of variable p is , but the vpiClassTypespec of the class obj
Packet
associated with variable is “ ”.
p LinkedPacket
NOTE—When a class var is obtained as a data member of a class typespec, the application must use vpiScope (see
37.12) rather than vpiClassTypespec to obtain the enclosing scope.
1009
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
6) From a class obj, the iterations over vpiVariables, vpiMethods, vpiNamedEvent, and vpiNamedEventArray
shall return both static and automatic properties or methods. However, the iteration over vpiMethods shall not
include built-in methods for which there is no explicit declaration.
7) The vpiVirtualInterfaceVar iteration (formerly vpiInterfaceDecl—now deprecated in this standard—see C.4.3,
item 5) shall return the virtual interface var declarations in the class object. If an array of virtual interfaces is
declared, the vpiVirtualInterfaceVar iteration shall return each element of the array separately. However, the
vpiVariables iteration shall return the array declaration as a single vpiArrayVar.
8) The vpiParameter iteration shall return parameters corresponding both to those declared in the parameter port list
of the class declaration and to those declared within the body of the class declaration as class items. The property
vpiLocalParam (see 37.26) shall return TRUE for parameters declared with the body. The value of a parameter
derived from a class obj shall be the same as that of the same parameter derived from the corresponding class
typespec.
9) vpi_handle_by_name() shall accept a full name to a non-static data member, even though it does not have a
vpiFullName property. For example:
module top;
class Packet ;
integer Id ;
....
endclass
Packet p;
c = p.Id;
....
vpi_handle_by_name() accepts “top.p.Id”.
10) For details on class object specific callbacks, see 38.36.1.
1010
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.32 Constraint, constraint ordering, distribution
vpiParent
class obj constraint constraint item
-> virtual
constraint ordering
bool: vpiVirtual
-> lifetime (static/automatic)
bool: vpiAutomatic constraint expr
-> memory allocation
int: vpiAllocScheme
-> access
int: vpiAccessType
-> name
str: vpiName
str: vpiFullName
-> active
bool: vpiIsConstraintEnabled
vpiSolveBefore
expr
constraint ordering
vpiSolveAfter
expr
expr
vpiValueRange
distribution dist item
range
-> distribution type
int: vpiDistType
vpiWeight
expr expr
Details:
1) For a constraint, vpiAutomatic property does not mean lifetime, but reflects the keyword used in the constraint
declaration. vpiAutomatic == 0 implies the constraint was declared static. See 18.5.11 for meaning.
2) For details on memory allocation property, see 37.3.7.
3) Possible return values for the vpiAccessType property (see 37.8) for a constraint are vpiExternAcc or zero,
indicating whether it was declared outside its enclosing class declaration or not (see 18.5.1).
4) The vpiConstraint iteration shall return the constraints in syntactic declaration order. The position within this
order of a constraint declared as shall be determined by the position of its prototype.
extern
5) The vpiConstraintItem iteration shall return the constraint items in the order in which they occur within the
constraint.
1011
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.33 Primitive, prim term
module
expr
primitive array
vpiDelay
expr primitive
prim term
gate -> direction
expr
int: vpiDirection
vpiIndex -> index
switch
vpiTermIndex
-> value
udp defn udp vpi_get_value()
-> array member
bool: vpiArray (deprecated)
bool: vpiArrayMember
-> definition name
str: vpiDefName
-> delay
vpi_get_delays()
vpi_put_delays()
-> name
str: vpiName
str: vpiFullName
-> primitive type
int: vpiPrimType
-> number of inputs
int: vpiSize
-> strength
int: vpiStrength0
int: vpiStrength1
-> value
vpi_get_value()
vpi_put_value()
Details:
1) vpiSize shall return the number of inputs.
2) For primitives, vpi_put_value() shall only be used with sequential UDP primitives.
3) vpiTermIndex can be used to determine the terminal order. The first terminal has a term index of zero.
4) If a primitive is an element within a primitive array, the vpiIndex transition is used to access the index within the
array. If a primitive is not part of a primitive array, this transition shall return NULL.
1012
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.34 UDP
udp
udp defn io decl
-> definition name
str: vpiDefName
-> number of inputs
int: vpiSize table entry
-> protected -> number of symbol entries
bool: vpiProtected int: vpiSize
-> type -> value
int: vpiPrimType vpi_get_value()
initial
Details:
1) Only string (decompilation) and vector (ASCII values) shall be obtained for table entry objects using
vpi_get_value(). Refer to the definition of vpi_get_value() for additional details.
2) vpiPrimType returns vpiSeqPrim for sequential UDPs and vpiCombPrim for combinational UDPs.
37.35 Intermodule path
inter mod path ports
-> delay
vpi_get_delays()
vpi_put_delays()
Details:
1) To get to an intermodule path, vpi_handle_multi(vpiInterModPath, port1, port2) can be used.
1013
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.36 Constraint expression
constraint expr
implication
vpiCondition
expr constr if constraint expr
vpiElseConst
constr if else
constraint expr
constr foreach
distribution
expr
-> soft constraint
bool: vpiSoft
soft disable expr
variables
vpiLoopVars variables
constr foreach
operation
constraint expr
Details:
1) The variable obtained via the vpiVariables relation from a vpiConstrForeach shall represent the array being
indexed.
2) The vpiLoopVars iteration shall return the index variables of the foreach constraint in left-to-right order. If an
index variable is skipped, its place shall be represented as a vpiOperation for which the vpiOpType is vpiNullOp.
3) Each vpiConstraintExpr iteration shall return the expressions in the order in which they occur in the containing
implication, , - , or constraint.
if ifelse foreach
1014
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.37 Module path, path term
vpiCondition
module expr expr
vpiDelay
expr
vpiModDataPathIn
path term
vpiModPathOut
path term
mod path
-> delay
path term
vpi_get_delays() vpiModPathIn
-> direction
vpi_put_delays()
-> path type int: vpiDirection
-> edge
int: vpiPathType
-> polarity int: vpiEdge
int: vpiPolarity
int: vpiDataPolarity
-> hasIfNone interface
bool: vpiModPathHasIfNone
vpiInstance module
Details:
1) Specify blocks can occur in both modules and interfaces. For backwards compatibility the vpiModule relation has
been preserved; however this relation shall return for specify blocks in interfaces. For new code, it is
NULL
recommended that the vpiInstance relation be used instead.
1015
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.38 Timing check
module
vpiExpr expr
tchk term
vpiTchkRefTerm
tchk term
vpiTchkDataTerm
expr tchk tchk term
vpiDelay
-> limit
vpi_get_delays()
vpi_put_delays()
regs
-> tchk type
vpiTchkNotifier
int: vpiTchkType
expr
tchk term
expr
-> edge
vpiCondition
int: vpiEdge
Details:
1) For the timing checks in 31.2 the relationship vpiTchkRefTerm shall denote the reference_event or
controlled_reference_event, while vpiTchkDataTerm shall denote the data_event, if any.
2) When iterating over vpiExpr from a tchk, the handles returned for a reference_event, a controlled_reference_event,
or a data_event shall have the type vpiTchkTerm. All other arguments shall have types matching the expression.
1016
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.39 Task and function declaration
vpiLeftRange
expr
io decl task func
expr
func call function vpiRightRange
-> sign vpiReturn
variables
bool: vpiSigned
-> size
class defn
int: vpiSize
-> type vpiParent
ref obj
int: vpiFuncType
task call task
-> method -> pure DPI
bool: vpiMethod bool: vpiDPIPure
-> access -> context
int: vpiAccessType bool: vpiDPIContext
-> visibility -> DPI qualifier
int: vpiVisibility int: vpiDPICStr
-> virtual -> identifier
bool: vpiVirtual str: vpiDPICIdentifier
-> default lifetime
bool: vpiAutomatic
Details:
1) A SystemVerilog function shall contain an object with the same name, size, and type as the function. This object
shall be used to capture the return value for this function.
2) For a function where the return type is a user-defined type, vpi_handle(vpiReturn, function_handle) shall return
the implicit variable handle representing the return of the function from which the user can get the details of that
user-defined type.
3) vpiReturn shall always return a object, even for simple returns.
var
4) vpiVisibility denotes the visibility (local, protected, or default) of a task or function that is a class member (a
method). vpiVisibility shall return vpiPublicVis for a class member that is not local or protected, or for a task or
function that is not a class member.
5) vpiFullName of a task or function declared inside a package or class defn shall begin with the full name of the
package or class defn followed by “ ” and immediately followed with the name of the task or function.
::
6) vpiAccessType shall return vpiDPIExportAcc for "DPI" and "DPI-C" export functions/tasks, and shall return
vpiDPIImportAcc for "DPI" and "DPI-C" import functions/tasks.
7) vpiDPIPure shall return TRUE for pure "DPI" and "DPI-C" import functions.
8) vpiDPIContext shall return TRUE for context import "DPI" and "DPI-C", functions/tasks.
9) vpiDPICStr shall return vpiDPI for a "DPI" function/task, and vpiDPIC for a "DPI-C" function/task.
10) vpiDPICIdentifier shall return a string corresponding to the C linkage name for the "DPI"/"DPI-C" function/task.
11) For details on lifetime and memory allocation properties, see 37.3.7.
12) If the vpiSize of the vpiReturn variable is defined (see 37.17, detail 9) and can be determined without evaluating
the function, vpiSize for the function shall return the same value as vpiSize for the vpiReturn variable. For a void
function, vpiSize shall return 0. For all other cases the behavior of vpiSize is undefined.
1017
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.40 Task and function call
vpiArgument expr
scope tf call
interface expr
task call
scope
func call
primitive
-> type
named event
int: vpiFuncType
-> value
function named event array
vpi_get_value()
vpiPrefix
task
expr
method func call
-> value vpiWith expr
vpi_get_value()
constraint
method task call
-> is built in
bool: vpiUserDefn
sys func call
-> type
int: vpiFuncType
vpiSysTfCall
-> value user systf
vpi_get_value()
-> systf info
vpi_put_value()
p_vpi_systf_data:
sys task call vpi_get_systf_info()
-> user-defined
bool: vpiUserDefn
-> decompile
str: vpiDecompile
-> name
str: vpiName
Details:
1) The vpiWith relation is only available for randomize methods (see 18.7) and for array locator methods (see 7.12.1).
2) For methods (method func call, method task call), the vpiPrefix relation shall return the object to which the method
is being applied. For example, for the class method invocation
packet.send();
the prefix for the “ ” method is the class var “ ”.
send packet
3) The system task or function that invoked an application shall be accessed with vpi_handle(vpiSysTfCall, ).
NULL
4) vpi_get_value() shall return the current value of the system function.
1018
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
5) If the vpiUserDefn property of a system task or function call is true, then the properties of the corresponding systf
object shall be obtained via vpi_get_systf_info().
6) All user-defined system tasks or functions shall be retrieved using vpi_iterate(), with vpiUserSystf as the type
argument, and a NULL reference argument.
7) The simulator shall not evaluate arguments to system tasks or functions when calling those tasks or functions
(36.4). Effectively, the value of any argument expression, or of any operand or argument of the expression, is not
known until an application asks for it using vpi_get_value() (38.15), a cbValueChange callback (38.36.1), or other
equivalent operation. If no application asks for the value of the argument, it is never evaluated.
8) An empty (omitted) argument (see 21.2.1) shall be represented as an expression with a vpiType of vpiOperation
and a vpiOpType of vpiNullOp. An argument consisting of the special value shall be represented as an
null
expression with a vpiType of vpiConstant and a vpiConstType of vpiNullConst.
Example:
logic my_var;
$my_task(my_var, ””, , null, );
In the call to the user-defined system task , is an ordinary argument of type vpiLogicVar.
$my_task() my_var
The second argument, an empty string (but not an empty argument), is a vpiConstant for which the vpiConstType
is vpiStringConst. The third and fifth arguments are empty arguments, while the fourth argument is a vpiConstant
with a vpiConstType of vpiNullConst. VPI shall represent the third and fifth arguments as vpiOperations with a
vpiOpType of vpiNullOp.
9) The property vpiDecompile shall return a string with a functionally equivalent system task or function call to what
was in the original source code. The arguments shall be decompiled using the same manner as any expression is
decompiled. See 37.57 for a description of expression decompilation.
10) System task and function calls that are protected shall allow iteration over the vpiArgument relationship.
11) For a built-in method func call, vpiFunction shall return , while vpiTask shall return for a built-in
NULL NULL
method task call.
1019
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.41 Frames
scope
task call
func call
method task call
method func call
vpiOrigin
stmt
scope
task call
vpiParent
frame thread
func call
-> active
bool: vpiActive vpiAutomatics
frame
variables
method task call
named event
method func call
named event array
Details:
1) Frames correspond to the set of automatic variables declared in a given task or function.
2) It shall be illegal to place value change callbacks on automatic variables.
3) It shall be illegal to put a value with a delay on automatic variables.
4) There is at most only one active frame at any time in a given thread. To get a handle to the currently active frame,
use vpi_handle(vpiFrame, ). The frame to stmt transition shall return the currently active statement within
NULL
the frame.
5) The frame object model is not backwards compatible with IEEE Std 1364-2005.
6) For details on frame specific callbacks, see 38.36.1.
1020
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.42 Threads
thread
vpiParent
vpiOrigin
stmt
frame thread
-> active
bool: vpiActive
thread
Details:
1) A thread is a SystemVerilog process such as an procedure or a branch of a construct. As a thread
always fork
works its way down a call chain of tasks and/or functions, a new frame is activated as each new task or function is
entered.
2) For details on thread specific callbacks, see 38.36.1.
37.43 Delay terminals
module
vpiInTerm vpiDriver
delay term net drivers
delay device
-> delay type
delay term net loads
int: vpiDelayType vpiOutTerm
vpiLoad
-> delay type
int: vpiDelayType
-> value
vpi_get_value()
Details:
1) The value of the input delay term shall change before the delay associated with the delay device.
2) The value of the output delay term shall not change until after the delay has occurred.
1021
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.44 Net drivers and loads
vpiDriver vpiLoad
net drivers nets net loads
ports delay term
force assign stmt
delay term force
cont assign cont assign
cont assign bit cont assign bit
prim term prim term
ports
Details:
1) Complex expressions on input ports that are not concatenations shall be considered a load for a net. Iterating on
loads for trinet in the following example will cause the fourth port of ram to be a load:
module my_module;
tri trinet;
ram r0 (a, write, read, !trinet);
endmodule
Access to the complex expression shall be available using vpi_handle(vpiHighConn, portH) where portH is the
handle to the port returned when iterating on loads.
1022
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.45 Continuous assignment
vpiDelay expr
expr vpiRhs
expr
vpiLhs
module cont assign
vpiParent
vpiBit
cont assign bit
-> offset from LSB
int: vpiOffset
-> delay
vpi_get_delays()
-> net decl assign
bool: vpiNetDeclAssign
-> strength
int: vpiStrength0
int: vpiStrength1
-> value
vpi_get_value()
Details:
1) The size of a cont assign bit is always scalar.
2) Callbacks for value changes can be placed onto cont assign or a cont assign bit.
3) vpiOffset shall return zero for the LSB.
1023
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.46 Clocking block
vpiInputSkew vpiOutputSkew
delay control delay control
vpiClockingEvent instance
event control clocking block
-> name clocking io decl
str: vpiName
str: vpiFullName property decl
-> edge
int: vpiInputEdge sequence decl
int: vpiOutputEdge
vpiPrefix
virtual interface var
vpiActual
clocking block
vpiInputSkew vpiOutputSkew
delay control expr
nets
vpiExpr
clocking io decl
-> direction variables
int: vpiDirection
-> name ref obj
str: vpiName
-> edge
int: vpiInputEdge
int: vpiOutputEdge
Details:
1) The methods, vpiInputSkew and vpiOutputSkew, and properties vpiInputEdge and vpiOutputEdge, on the
block apply to the default constructs. The same methods and properties on the clocking io decl apply to
clocking
the clocking io decl itself.
2) The vpiPrefix relation shall be non-NULL when the clocking block represents an expression in the SystemVerilog
source code immediately prefixed by a virtual interface.
3) If a prefix of a clocking block is a virtual interface that has no value at the current simulation time, the vpiActual
relation shall return NULL.
4) vpiExpr shall return the expression or ref obj referenced by the clocking io decl. Consider input
. Here, “ ” is represented by a clocking io decl, and the vpiExpr
enable = top.mem1.enable enable
relation returns a handle to “ ”.
top.mem1.enable
1024
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.47 Assertion
assertion
instance clocking block
sequence inst
assert
assume
cover
restrict
property inst
immediate assert
immediate assume
immediate cover
-> location
str: vpiFile
int: vpiStartLine
int: vpiColumn
int: vpiEndLine
int: vpiEndColumn
-> assertion name
str: vpiName
Details:
1) For details on using VPI to obtain static and dynamic assertion information as well as assertion callbacks and
control, see Clause39.
2) For details on using VPI to obtain assertion coverage, see 40.5.3.
1025
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reicgehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.48 Concurrent assertions
vpiClockingEvent
expr concurrent assertions stmt
cover
-> is cover sequence
bool:vpiIsCoverSequence
vpiElseStmt
assert stmt
assume
restrict vpiProperty
property inst
-> name
str: vpiName property spec
str: vpiFullName
-> is clock inferred
bool:vpiIsClockInferred
vpiDisableCondition
expr
distribution
Details:
1) Clocking event is always the actual clocking event on which the assertion is being evaluated, regardless of whether
this is explicit or implicit (inferred).
2) The statement has no pass and no fail action statement. Also, it is not simulated and hence
restrictproperty
generates no run-time information.
1026
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.49 Property declaration
property inst property decl variables
-> name
prop formal decl
str: vpiName property spec
str: vpiFullName
vpiDisableCondition
expr
vpiArgument property expr
property inst
named event
property decl
named event
vpiExpr
prop formal decl
property expr
-> name
str: vpiName
-> direction
typespec
int: vpiDirection
Details:
1) The vpiPropFormalDecl iterator shall return the property declaration arguments in the order that the formals for
the property are declared.
2) The vpiArgument iterator shall return the property instance arguments in the order that the formals for the property
are declared, so that the correspondence between each argument and its respective formal can be made. If a formal
has a default value, that value shall appear as the argument should the instantiation not provide a value for that
argument.
3) The vpiTypespec relation shall return NULL if the formal is untyped.
4) If the formal has an initialization expression, the expression can be obtained using the vpiExpr relation.
5) vpiDirection returns vpiNoDirection if the formal argument is not a local variable argument. Otherwise,
vpiDirection returns vpiInput.
1027
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.50 Property specification
expr property spec property expr
vpiClockingEvent
expr
distribution vpiDisableCondition
property expr
vpiOperand
operation property expr
-> operation type
int: vpiOpType
-> operator strength
bool: vpiOpStrong
sequence expr
multiclock
sequence expr
property inst vpiClockingEvent
expr
clocked property
property expr
vpiCondition
expr
case property
case property item expr
property expr
Details:
1) Variables are declarations of property variables. The value of these variables cannot be accessed.
2) Within the context of a property expr, vpiOpType can be any one of vpiAcceptOnOp, vpiAlwaysOp,
vpiCompAndOp, vpiCompOrOp, vpiEventuallyOp, vpiIfElseOp, vpiIfOp, vpiIffOp, vpiImpliesOp,
vpiNexttimeOp, vpiNonOverlapFollowedByOp, vpiNonOverlapImplyOp, vpiNotOp,
vpiOverlapFollowedByOp, vpiOverlapImplyOp, vpiRejectOnOp, vpiSyncAcceptOnOp,
vpiSyncRejectOnOp, vpiUntilOp, or vpiUntilWithOp.
Operands to these operations shall be provided in the same order as shown in the BNF, with the following
exceptions:
— vpiNexttimeOp: Arguments shall be: property, constant. constant shall only be given if different from 1.
— vpiAlwaysOp and vpiEventuallyOp: Arguments shall be: property, left range, right range.
3) vpiOpStrong is valid only for operations vpiNexttimeOp, vpiAlwaysOp, vpiEventuallyOp, vpiUntilOp,
vpiUntilWithOp, and for sequence expression. vpiOpStrong shall return TRUE to indicate the strong version of
the corresponding operator.
4) The case property item shall group all case conditions that branch to the same property statement.
5) vpi_iterate() shall return NULL for the default case item because there is no expression with the default case.
1028
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.51 Sequence declaration
variables
sequence inst
sequence decl
-> name
str: vpiName
str: vpiFullName vpiExpr sequence expr
seq formal decl
multiclock
sequence expr
named event
vpiExpr
seq formal decl
-> name sequence expr
str: vpiName
-> direction
typespec
int: vpiDirection
Details:
1) The vpiSeqFormalDecl iterator shall return the sequence declaration arguments in the order that the formals for the
sequence are declared.
2) The vpiTypespec relation shall return NULL if the formal is untyped.
3) If the formal has an initialization expression, the expression can be obtained using the vpiExpr relation.
4) vpiDirection returns vpiNoDirection if the formal argument is not a local variable argument. Otherwise,
vpiDirection returns either vpiInput, vpiOutput, or vpiInout.
1029
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.52 Sequence expression
sequence expr
vpiOperand
operation sequence expr
-> operation type
int: vpiOpType
vpiArgument named event
sequence decl sequence inst
sequence expr
distribution
vpiMatchItem assignment
expr
tf call
Details:
1) The vpiArgument iterator shall return the sequence instance arguments in the order that the formals for the
sequence are declared, so that the correspondence between each argument and its respective formal can be made. If
a formal has a default value, that value shall appear as the argument should the instantiation not provide a value for
that argument.
2) Within a sequence expression, vpiOpType can be any one of vpiCompAndOp, vpiIntersectOp, vpiCompOrOp,
vpiFirstMatchOp, vpiThroughoutOp, vpiWithinOp, vpiUnaryCycleDelayOp, vpiCycleDelayOp,
vpiRepeatOp, vpiConsecutiveRepeatOp, or vpiGotoRepeatOp.
3) For operations, the operands shall be provided in the same order as the operands appear in BNF, with the following
exceptions:
— vpiUnaryCycleDelayOp: Arguments shall be: sequence, left range, right range. Right range shall only be
given if different from left range.
— vpiCycleDelayOp: Arguments shall be: left-hand side sequence, right-hand side sequence, left range, right
range. Right range shall only be provided if different than left range.
— All the repeat operators: The first argument shall be the sequence being repeated, and the next argument shall be
the left repeat bound, followed by the right repeat bound. The right repeat bound shall only be provided if
different from left repeat bound.
and, intersect, or,
first_match,
throughout, within,
##,
[*], [=], [->]
1030
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.53 Immediate assertions
stmt
expr immediate assert
vpiElseStmt
-> is deferred
stmt
int: vpiIsDeferred
-> is final
int: vpiIsFinal
stmt
expr immediate assume
vpiElseStmt
-> is deferred
stmt
int: vpiIsDeferred
-> is final
int: vpiIsFinal
expr immediate cover stmt
-> is deferred
int: vpiIsDeferred
-> is final
int: vpiIsFinal
1031
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.54 Multiclock sequence expression
multiclock
clocked seq
sequence expr
vpiClockingEvent
expr
clocked seq
sequence expr
37.55 Let
vpiArgument
let expr expr
let decl expr
-> name
str: vpiName seq formal decl
Details:
1) The vpiArgument iterator shall return the let expression arguments in the order that the formals for the let are
declared, so that the correspondence between each argument and its respective formal can be made. If a formal has
a default value, that value shall appear as the argument should the instantiation not provide a value for that
argument.
1032
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.56 Simple expressions
vpiUse
simple expr
prim term
nets path term
tchk term
variables
delay term
ref obj
ports
parameter
stmt
spec param cont assign
cont assign bit
var select
vpiParent vpiIndex
bit select expr
var select
-> name
integer var str: vpiName
str: vpiFullName
time var -> constant select
bool:
parameter vpiConstantSelect
spec param
Details:
1) For vectors, the vpiUse relationship shall access any use of the vector or of the part-selects or bit-selects of the
vector.
2) For bit-selects, the vpiUse relationship shall access any specific use of that bit, any use of the parent vector, and any
part-select that contains that bit.
3) The property vpiConstantSelect shall return TRUE for a bit-select if
— every associated index expression is an elaboration time constant expression, and
— vpiConstantSelect returns TRUE for the parent of the bit-select.
Otherwise, vpiConstantSelect shall return FALSE.
NOTE—If vpiConstantSelect is TRUE, then if the handle refers to a valid underlying simulation object at the
beginning of simulation (or at any point in the simulation), it refers to the same object at all points in the simulation.
Moreover, if an index expression of the bit-select or of any of its parents is in or out of bounds at the beginning of
simulation, it is in or out of bounds at all subsequent simulation times as well.
1033
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.57 Expressions
expr typespec
vpiBaseExpr
expr
indexed part select
-> constant selection expr
vpiWidthExpr
bool: vpiConstantSelect
-> index part select type
int: vpiIndexedPartSelectType
simple expr
vpiParent
vpiParent
vpiLeftRange
expr
part select vpiRightRange
-> constant selection expr
bool: vpiConstantSelect
vpiOperand
operation
-> operation type expr
int: vpiOpType
interface expr
constant
-> constant type range
int: vpiConstType
pattern
func call
sequence inst
method func call property inst
sys func call
let expr
-> decompile
str: vpiDecompile
-> size
int: vpiSize
-> value
vpi_get_value()
Details:
1) For an operator whose type is vpiMultiConcatOp, the first operand shall be the multiplier expression. The
remaining operands shall be the expressions within the concatenation.
2) The property vpiDecompile shall return a string with a functionally equivalent expression to the original expression
within the source code. Parentheses shall be added only to preserve precedence. Each operand and operator shall be
separated by a single space character. No additional white space shall be added due to parentheses.
1034
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
3) The cast operation, for which vpiOpType returns vpiCastOp, is represented as a unary operation, with its sole
argument being the expression being cast, and the typespec of the cast expression being the type to which the
argument is being cast.
4) The constant type vpiUnboundedConst represents the $ value used in assertion ranges.
5) The one-to-one relation to typespec shall always be available for vpiCastOp operations, for simple expressions,
and for vpiAssignmentPatternOp and vpiMultiAssignmentPatternOp expressions when the curly braces of the
assignment pattern are prefixed by a data type name to form an assignment pattern expression. For other
expressions, it is implementation dependent as to whether or not there is any associated typespec.
6) For an operation of type vpiAssignmentPatternOp, the operand iteration shall return the expressions as if the
assignment pattern were written with the positional notation. Nesting of assignment patterns shall be preserved.
Example 1:
struct {
int A;
struct {
logic B;
real C;
} BC1, BC2;
} ABC = '{BC1: '{1'b1, 1.0}, int: 0, BC2: '{default: 0}};
The assignment pattern that initializes the struct variable uses member, type, and default keys. The
ABC
vpiOperand traversal would represent this assignment pattern expression as:
'{0, '{1'b1, 1.0}, '{0, 0}}
or some other equivalent positional assignment pattern.
Example 2:
logic [2:0] varr [0:3] = '{3: 3'b1, default: 3'b0};
The assignment pattern that initializes the array variable uses index and default keys. The vpiOperand
varr
traversal would represent this assignment pattern as:
'{3'b0, 3'b0, 3'b0, 3'b1}
7) For an operator whose type is vpiMultiAssignmentPatternOp, the first operand shall be the multiplier expression.
The remaining operands shall be the expressions within the assignment pattern.
Example:
bit unpackedbits [1:0];
initial unpackedbits = '{2 {y}} ; // same as '{y, y}
For the assignment pattern , the vpiOpType property shall return vpiMultiAssignmentPatternOp, and
'{2{y}}
the first operand shall be the constant 2. The next operand shall represent the expression .
y
8) Expressions that are protected shall permit access to the vpiSize property.
9) The property vpiConstantSelect shall return TRUE for a part-select or indexed part-select if
— vpiConstantSelect returns TRUE for its parent, and
— the parent is a packed or unpacked array with static bounds, and
— each range expression in the part-select or indexed part-select is an elaboration time constant expression.
Otherwise, vpiConstantSelect shall return FALSE.
NOTE—If vpiConstantSelect is TRUE, then if the handle refers to a valid underlying simulation object at the
beginning of simulation (or at any point in the simulation), it refers to the same object at all points in the simulation.
Moreover, if any index expression of the part-select or indexed part-select or of any of its parents is in or out of
bounds at the beginning of simulation, it is in or out of bounds at all subsequent simulation times as well.
1035
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
10) For a part-select or indexed part-select, the vpiParent object shall correspond to the expression formed by
removing the part-select range from the expression represented by the part-select or indexed part-select itself. For
example, given the declaration
logic [0:3][7:0] r [1:4];
then the parents of various part-selects or indexed part-selects shall be as shown in Table37-1:
Table37-1—Part-select parent expressions
Part-select or indexed
Parent expression
part-select expression
r[4][3][1:0] r[4][3]
r[i+1][3][j+:2] r[i+1][3]
r[0][j-:4] r[0]
r[0:2] r
1036
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.58 Atomic statement
atomic stmt
if
if else
while
repeat
waits
case
for
delay control
event control
event stmt
assignment
assign stmt
deassign
disables
tf call
forever
force
release
do while
expect stmt
foreach stmt
return stmt
break
continue
immediate assert
immediate assume
immediate cover
null stmt
-> label
str: vpiName
1037
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Details:
1) The vpiName property shall provide the statement label if one was given; otherwise, the name is .
NULL
37.59 Dynamic prefixing
simple expr
indexed part select
class var
part select
virtual interface var
named event vpiPrefix
clocking block
named event array
tf call
-> has actual
bool: vpiHasActual
Details:
1) The vpiPrefix relation shall be non-NULL when the object represents an expression or task call in the
SystemVerilog source code prefixed by a virtual interface or a clocking block, or when the object is all or part of a
non-static class property prefix ed by a class var.
2) The memory allocation scheme value for an object for which a class var or virtual interface var vpiPrefix is
non-NULL shall be the same as for the prefix.
3) The property vpiHasActual shall return TRUE:
— whenever the prefix object has a corresponding actual at the current simulation time.
— if the object is all or part of a statically declared object in an elaborated context.
— if the object is part or all of an automatically allocated variable obtained from a frame (see 37.41).
The property vpiHasActual shall return FALSE:
— whenever the prefix object has no corresponding actual at the current simulation time.
— if the object is obtained from a lexical context, such as from a class defn (see 37.29).
— if the object is part or all of a non-static class property variable referenced relative to its class
typespec (see 37.30).
— if the object is part or all of an automatically allocated variable obtained from a task or function
declaration (see 37.39).
1038
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.60 Event statement
event stmt named event
-> blocking
bool: vpiBlocking
37.61 Process
module scope
process stmt
initial scope
final atomic stmt
always
-> always type
int: vpiAlwaysType
Details:
1) vpiAlwaysType can be one of vpiAlways, vpiAlwaysComb, vpiAlwaysFF, or vpiAlwaysLatch.
1039
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.62 Assignment
vpiLhs
delay control
expr
vpiRhs assignment event control
expr
-> operator
int: vpiOpType repeat control
interface expr
-> blocking
bool: vpiBlocking
Details:
1) vpiOpType shall return vpiAssignmentOp for normal assignments (both blocking “=” and nonblocking “<=”).
For assignment operators, vpiOpType shall return a value that corresponds to the operator that is combined with
the assignment as described in 11.4.1.
For example, the assignment
a += 2;
shall return vpiAddOp for the vpiOpType property.
37.63 Event control
vpiCondition
event control “@”
expr
sequence inst
named event
stmt
Details:
1) For event control associated with assignment, the statement shall always be .
NULL
1040
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.64 While, repeat
while
vpiCondition
expr
repeat
stmt
37.65 Waits
waits stmt
vpiCondition
wait
sequence inst
vpiCondition
ordered wait
expr
wait fork vpiElseStmt
stmt
37.66 Delay control
delay control “#” stmt
-> delay
vpi_get_delays() vpiDelay
expr
Details:
1) For delay control associated with assignment, the statement shall always be .
NULL
1041
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.67 Repeat control
repeat control expr
event control
37.68 Forever
forever stmt
37.69 If, if–else
if
vpiCondition
expr
stmt
vpiElseStmt
if else stmt
-> qualifier
int: vpiQualifier
1042
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.70 Case, pattern
vpiCondition
case expr
-> type
int: vpiCaseType vpiExpr pattern
-> qualifier case item
int: vpiQualifier expr
pattern stmt
any pattern
-> name
pattern
str: vpiName
tagged pattern typespec
-> name
str: vpiName
struct pattern pattern
-> name
str: vpiName
expr
Details:
1) The case item shall group all case conditions that branch to the same statement.
2) vpi_iterate() shall return NULL for the default case item because there is no expression with the default case.
1043
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.71 Expect
property spec
expect stmt stmt
vpiElseStmt
stmt
37.72 For
vpiForInitStmt
stmt
for
vpiForIncStmt
stmt
-> has local variables
int: vpiLocalVarDecls vpiForInitStmt
stmt
vpiCondition
expr
vpiForIncStmt
stmt
stmt
37.73 Do-while, foreach
vpiCondition
expr
do while
stmt
variables
vpiLoopVars variables
foreach stmt
operation
stmt
Details:
1) The variable obtained via the vpiVariables relation from a foreach stmt shall represent the packed array, unpacked
array, or string var being indexed.
2) The vpiLoopVars iteration shall return the index variables of the foreach statement in left-to-right order. If an
index variable is skipped, its place shall be represented as a vpiOperation for which the vpiOpType is vpiNullOp.
1044
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.74 Alias statement
vpiLhs
expr
instance alias stmt
vpiRhs
expr
Example:
alias a=b=c=d;
results in 3 aliases:
alias a=d;
alias b=d;
alias c=d;
is the right-hand side for all.
d
37.75 Disables
disables
vpiExpr
disable
task
disable fork
function
named begin
named fork
37.76 Return statement
vpiCondition
return stmt expr
1045
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.77 Assign statement, deassign, force, release
vpiRhs
force expr
vpiLhs
assign stmt expr
deassign
vpiLhs
expr
release
37.78 Callback
prim term callback
-> cb info
expr p_cb_data: vpi_get_cb_info()
time queue
stmt
Details:
1) To get information about the callback object, the routine vpi_get_cb_info() can be used..
2) To get callback objects not related to the above objects, the second argument to vpi_iterate() shall be NULL.
1046
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.79 Time queue
time queue
-> time
vpi_get_time()
Details:
1) The time queue objects shall be returned in increasing order of simulation time.
2) vpi_iterate() shall return NULL if there is nothing left in the simulation time queue.
3) The current time queue shall only be returned as part of the iteration if there are events that precede read only sync.
37.80 Active time format
vpiActiveTimeFormat
tf call
Details:
1) If has not been called, vpi_handle(vpiActiveFormat, NULL) shall return NULL.
$timeformat()
1047
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.81 Attribute
attribute
vpiParent
instances -> name
str: vpiName
port
-> On definition
bool: vpiDefAttribute
net
-> value:
array net vpi_get_value()
-> definition location
variables str: vpiDefFile
int: vpiDefLineNo
named event
prim term
path term
mod path
tchk
param assign
spec param
task func
primitive
table entry
stmt
process
operation
concurrent assertions
sequence decl
property decl
clocking block
class defn
constraint
1048
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.82 Iterator
vpiUse
iterator
instance array
-> type
int: vpiIteratorType scope
udp defn
ports
nets
net array
regs
reg array
variables
named event array
primitive
prim term
mod path
param assign
inter mod path
path term
delay term
tchk
tf call
process
expr
stmt
case item
frame
time queue
Details:
1) vpi_handle(vpiUse, iterator_handle) shall return the reference handle used to create the iterator.
2) It is possible to have a NULL reference handle, in which case vpi_handle(vpiUse, iterator_handle) shall return
NULL.
1049
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.83 Generates
vpiInternalScope
module scope
interface
vpiInstance net
program
array net
module
logic var
array var
gen var vpiMemory
array var
-> name
str: vpiName
variables
str: vpiFullName
named event
gen scope array named event array
-> size
process
int: vpiSize
-> name cont assign
str: vpiName
str: vpiFullName module
-> access by index
vpi_handle_by_index() module array
vpi_handle_by_multi_index()
primitive
primitive array
vpiIndex
expr gen scope
def param
-> array member
bool: vpiArray (deprecated) vpiParameter
parameters
bool: vpiArrayMember
-> name
gen scope array
str: vpiName
str: vpiFullName
program
-> protected
bool: vpiProtected program array
-> is implicitly declared
bool: vpiImplicitDecl assertion
interface
interface array
alias stmt
clocking block
typespec
vpiTypedef
1050
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Details:
1) The size for a gen scope array shall be the number of elements in the array.
2) For an unnamed generate, an implicit scope shall be created. Its vpiImplicitDecl property shall return TRUE.
3) References to gen vars within the gen scope shall be treated as local parameters.
Parameters within the gen scope must be local parameters.
1051
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38. VPI routine definitions
38.1 General
This clause describes the VPI routines and explains their function, syntax, and usage. The routines are listed
in alphabetical order.
The following conventions are used in the definitions of the PLI routines described in this clause:
— Synopsis: A brief description of the PLI routine functionality, intended to be used as a quick
reference when searching for PLI routines to perform specific tasks.
— Syntax: The exact name of the PLI routine and the order of the arguments passed to the routine.
— Returns: The definition of the value returned when the PLI routine is called, along with a brief
description of what the value represents. The return definition contains the following fields:
• Type: The data type of the C value that is returned. The data type is either a standard ANSI C
type or a special type defined within the PLI.
• Description: A brief description of what the value represents.
— Arguments: The definition of the arguments passed with a call to the PLI routine. The argument
definition contains the following fields:
• Type: The data type of the C values that are passed as arguments. The data type is either a
standard ANSI C type or a special type defined within the PLI.
• Name: The name of the argument used in the syntax definition.
• Description: A brief description of what the value represents.
All arguments shall be considered mandatory unless specifically noted in the definition of the PLI
routine.
— Related routines: A list of PLI routines that are typically used with, or provide similar functionality
to, the PLI routine being defined. This list is provided as a convenience to facilitate finding
information in this standard. It is not intended to be all-inclusive, and it does not imply that the
related routines have to be used.
38.2 vpi_chk_error()
vpi_chk_error()
Synopsis: Retrieve information about VPI routine errors.
Syntax:
vpi_chk_error(error_info_p)
Type Description
Returns: PLI_INT32 The error severity level if the previous VPI routine call resulted in an error; 0 (false)
if no error occurred.
Type Name Description
Arguments: p_vpi_error_info error_info_p Pointer to a structure containing error information.
Related
routines:
The VPI routine vpi_chk_error() shall return an integer constant representing an error severity level if the
previous call to a VPI routine resulted in an error. The error constants are shown in Table38-1. If the
previous call to a VPI routine did not result in an error, then vpi_chk_error() shall return 0 (false). The error
1052
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
status shall be reset by any VPI routine call except vpi_chk_error(). Calling vpi_chk_error() shall have no
effect on the error status.
Table38-1—Return error constants for vpi_chk_error()
Error constant Severity level
vpiNotice Lowest severity
vpiWarning
vpiError
vpiSystem
vpiInternal Highest severity
If an error occurred, the structure shall contain information about the error. If the error
s_vpi_error_info
information is not needed, a can be passed to the routine. The structure used by
NULL s_vpi_error_info
vpi_chk_error() is defined in and is listed in Figure38-1.
vpi_user.h
typedef struct t_vpi_error_info
{
PLI_INT32 state; /* vpi[Compile,PLI,Run] */
PLI_INT32 level; /* vpi[Notice,Warning,Error,System,Internal] */
PLI_BYTE8 *message;
PLI_BYTE8 *product;
PLI_BYTE8 *code;
PLI_BYTE8 *file;
PLI_INT32 line;
} s_vpi_error_info, *p_vpi_error_info;
Figure38-1—s_vpi_error_info structure definition
38.3 vpi_compare_objects()
vpi_compare_objects()
Synopsis: Compare two handles to determine whether they reference the same object.
Syntax:
vpi_compare_objects(obj1, obj2)
Type Description
Returns: PLI_INT32 1 (true) if the two handles refer to the same object; 0 (false) otherwise.
Type Name Description
Arguments: vpiHandle obj1 Handle to an object.
vpiHandle obj2 Handle to an object.
Related
routines:
The VPI routine vpi_compare_objects() shall return 1 (TRUE) if the two handles refer to the same
underlying simulation object at the time the function is called, provided that the simulation object exists.
1053
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Otherwise, 0 (FALSE) shall be returned. Object equivalence cannot be determined with a C “ ”
==
comparison.
The following examples illustrate the use of vpi_compare_objects().
Example 1:
struct packed {
int a;
reg [0:7] b;
} ps;
...
initial begin
ps[0] = ...;
ps.b[7] = ...;
end
The expression is another way of referring to bit 7 of , so if a handle refers to and
ps[0] ps.b obj1 ps[0]
a handle refers to , then shall return TRUE.
obj2 ps.b[7] vpi_compare_objects(obj1, obj2)
Example 2:
integer i [0:3];
int j;
...
initial begin
j = 0;
i[j] = ...;
#(1)
j = 1;
i[j] = ...;
end
Let be a handle to an occurrence of the expression , and let be a handle to the object
obj1 i[j] obj2 i[0]
derived by iteration from the integer array . Then
i
vpi_compare_objects(obj1, obj2)
shall return TRUE when has the value 0 and FALSE when has the value 1.
j j
Example 3:
class MyClass;
int a;
endclass
...
MyClass c, d;
...
initial begin
c = null;
d = null;
#(1)
c = new;
c.a = 5;
#(1)
d = c;
d.a = 6;
1054
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#(1)
c = new;
c.a = 7;
end
If represents the expression , while represents , then initially neither object exists, and
obj1 c.a obj2 d.a
shall return FALSE. After one time step, exists, but does
vpi_compare_objects(obj1, obj2) c.a d.a
not, and shall still return FALSE. After the second time step,
vpi_compare_objects(obj1, obj2) c.a
and point to the same data member of the same class object, and
d.a int vpi_compare_objects(obj1,
shall return TRUE. Finally, gets a new class object assigned to it, but does not, and
obj2) c d
shall once again return FALSE.
vpi_compare_objects(obj1, obj2)
38.4 vpi_control()
vpi_control()
Synopsis: Pass information from the application code to the simulator.
Syntax:
vpi_control(operation, varargs)
Type Description
Returns: PLI_INT32 1 (true) if successful; 0 (false) on a failure.
Type Name Description
Arguments: PLI_INT32 operation Select type of operation.
varargs Variable number of operation-specific arguments.
Related
routines:
The VPI routine shall pass information from a user PLI application to a SystemVerilog
vpi_control()
software tool, such as a simulator. The following control constants are defined as part of the VPI standard:
vpiStop Causes the built-in SystemVerilog system task to be executed upon return
$stop
of the application routine. This operation shall be passed one additional integer
argument, which is the same as the diagnostic message level argument passed to
(see 20.2).
$stop
vpiFinish Causes the built-in SystemVerilog system task to be executed upon
$finish
return of the application routine. This operation shall be passed one additional
integer argument, which is the same as the diagnostic message level argument
passed to (see 20.2).
$finish
vpiReset Causes the built-in SystemVerilog system task to be executed upon
$reset
return of the application routine. This operation shall be passed three additional
integer arguments: , , and ,
stop_value reset_value diagnostics_value
which are the same values passed to the system task (see D.8).
$reset
vpiSetInteractiveScope
Causes a tool’s interactive scope to be immediately changed to a new scope. This
operation shall be passed one additional argument, which is a object
vpiHandle
within the vpiScope class.
1055
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.5 vpi_flush()
vpi_flush()
Synopsis: Flushes the data from the simulator output channel and log file output buffers.
Syntax:
vpi_flush()
Type Description
Returns: PLI_INT32 0 if successful; nonzero if unsuccessful.
Type Name Description
Arguments: None
Related Use vpi_printf() to write a finite number of arguments to the simulator output channel and log file.
routines: Use vpi_vprintf() to write a variable number of arguments to the simulator output channel and log file.
Use vpi_mcd_printf() to write one or more opened files.
The routine vpi_flush() shall flush the output buffers for the simulator’s output channel and current log file.
38.6 vpi_get()
vpi_get()
Synopsis: Get the value of an integer or Boolean property of an object.
Syntax:
vpi_get(prop, obj)
Type Description
Returns: PLI_INT32 Value of an integer or Boolean property.
Type Name Description
Arguments: PLI_INT32 prop An integer constant representing the property of an
object for which to obtain a value.
vpiHandle obj Handle to an object.
Related Use vpi_get_str() to get string properties.
routines: Use vpi_get64() to get 64-bit integer properties.
The VPI routine vpi_get() shall return the value of integer and Boolean object properties. These properties
shall be of type . Boolean properties shall have a value of 1 for TRUE and 0 for FALSE. For
PLI_INT32
integer object properties such as vpiSize, any integer shall be returned. For integer object properties that
return a defined value, see AnnexK and AnnexM for the value that shall be returned. For object property
vpiTimeUnit or vpiTimePrecision, if the object is , then the simulation time unit shall be returned.
NULL
Unless otherwise specified, calling vpi_get() for a protected object shall be an error. Should an error occur,
vpi_get() shall return vpiUndefined.
1056
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.7 vpi_get64()
vpi_get64()
Synopsis: Get the value of a 64-bit integer property of an object.
Syntax:
vpi_get64(prop, obj)
Type Description
Returns: PLI_INT64 Value of a 64-bit integer property.
Type Name Description
Arguments: PLI_INT32 prop An integer constant representing the property of an
object for which to obtain a value.
vpiHandle obj Handle to an object.
Related Use vpi_get_str() to get string properties.
routines: Use vpi_get() to get integer or Boolean properties.
The VPI routine vpi_get64() shall return the value of 64-bit integer object properties. These properties shall
be of type . For 64-bit integer object properties that return a defined value, see AnnexK and
PLI_INT64
AnnexM for the value that shall be returned. Unless otherwise specified, calling vpi_get64() for a protected
object shall be an error. Should an error occur, vpi_get64() shall return vpiUndefined.
38.8 vpi_get_cb_info()
vpi_get_cb_info()
Synopsis: Retrieve information about a simulation-related callback.
Syntax:
vpi_get_cb_info(obj, cb_data_p)
Type Description
Returns: void
Type Name Description
Arguments: vpiHandle obj Handle to a simulation-related callback.
p_cb_data cb_data_p Pointer to a structure containing callback information.
Related Use vpi_get_systf_info() to retrieve information about a system task or system function callback.
routines:
The VPI routine vpi_get_cb_info() shall return information about a simulation-related callback in an
structure. The memory for this structure shall be allocated by the application.
s_cb_data
The structure used by vpi_get_cb_info() is defined in and is listed in Figure38-2.
s_cb_data vpi_user.h
1057
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
typedef struct t_cb_data
{
PLI_INT32 reason; /* callback reason */
PLI_INT32 (*cb_rtn)(struct t_cb_data *); /* call routine */
vpiHandle obj; /* trigger object */
p_vpi_time time; /* callback time */
p_vpi_value value; /* trigger object value */
PLI_INT32 index; /* index of the memory word or var select
that changed */
PLI_BYTE8 *user_data;
} s_cb_data, *p_cb_data;
Figure38-2—s_cb_data structure definition
38.9 vpi_get_data()
vpi_get_data()
Synopsis: Get data from an implementation’s save/restart location.
Syntax:
vpi_get_data(id, dataLoc, numOfBytes)
Type Description
Returns: PLI_INT32 The number of bytes retrieved.
Type Name Description
Arguments: PLI_INT32 id A save/restart ID returned from
vpi_get(vpiSaveRestartID, NULL) .
PLI_BYTE8 * dataLoc Address of application-allocated storage.
PLI_INT32 numOfBytes Number of bytes to be retrieved from save/restart
location.
Related Use vpi_put_data() to write saved data.
routines:
The routine shall place numOfBytes of data into the memory location pointed to by dataLoc from a
simulation’s save/restart location. This memory location has to be properly allocated by the application. The
first call for a given id will retrieve the data starting at what was placed into the save/restart location with the
first call to vpi_put_data() for a given id. The return value shall be the number of bytes retrieved. On a
failure, the return value shall be 0. Each subsequent call shall start retrieving data where the last call left off.
It shall be a warning for an application to retrieve more data than were placed into the simulation save/restart
location for a given id. In this case, the dataLoc shall be filled with the data that are left for the given id, and
the remaining bytes shall be filled with “\0”. The return value shall be the actual number of bytes retrieved.
It shall be acceptable for an application to retrieve less data than were stored for a given id with
vpi_put_data(). This routine can only be called from an application routine that has been called for reason
cbStartOfRestart or cbEndOfRestart. The recommended way to get the “id” for vpi_get_data() is to pass
it as the value for user_data when registering for cbStartOfRestart or cbEndOfRestart from the
cbStartOfSave or cbEndOfSave application routine. An application can get the path to the simulation’s
save/restart location by calling vpi_get_str(vpiSaveRestartLocation, NULL) from an application routine
that has been called for reason cbStartOfRestart or cbEndOfRestart.
For an example of vpi_get_data(), see 38.31.
1058
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.10 vpi_get_delays()
vpi_get_delays()
Synopsis: Retrieve the delays or pulse limits of an object.
Syntax:
vpi_get_delays(obj, delay_p)
Type Description
Returns: void
Type Name Description
Arguments: vpiHandle obj Handle to an object.
p_vpi_delay delay_p Pointer to a structure containing delay information.
Related Use vpi_put_delays() to set the delays or timing limits of an object.
routines:
The VPI routine vpi_get_delays() shall retrieve the delays or pulse limits of an object and place them in an
structure that has been allocated by the application. The format of the delay information shall
s_vpi_delay
be controlled by the time_type flag in the structure. This routine shall ignore the value of the
s_vpi_delay
type flag in the structure.
s_vpi_time
The and structures used by both vpi_get_delays() and vpi_put_delays() are
s_vpi_delay s_vpi_time
defined in and are listed in Figure38-3 and Figure38-4.
vpi_user.h
.
typedef struct t_vpi_delay
{
struct t_vpi_time *da; /* pointer to application-allocated
array of delay values */
PLI_INT32 no_of_delays; /* number of delays */
PLI_INT32 time_type; /* [vpiScaledRealTime, vpiSimTime,
or vpiSuppressTime] */
PLI_INT32 mtm_flag; /* true for mtm values */
PLI_INT32 append_flag; /* true for append */
PLI_INT32 pulsere_flag; /* true for pulsere values */
} s_vpi_delay, *p_vpi_delay;
Figure38-3—s_vpi_delay structure definition
typedef struct t_vpi_time
{
PLI_INT32 type; /* [vpiScaledRealTime, vpiSimTime,
vpiSuppressTime] */
PLI_UINT32 high, low; /* for vpiSimTime */
double real; /* for vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;
Figure38-4—s_vpi_time structure definition
The da field of the structure shall be an application-allocated array of
s_vpi_delay s_vpi_time
structures. This array shall store delay values returned by vpi_get_delays(). The number of elements in this
array shall be determined by the following:
1059
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— The number of delays to be retrieved
— The mtm_flag setting
— The pulsere_flag setting
The number of delays to be retrieved shall be set in the no_of_delays field of the structure.
s_vpi_delay
Legal values for the number of delays shall be determined by the type of object, as follows:
— For primitive objects, the no_of_delays value shall be 2 or 3.
— For path delay objects, the no_of_delays value shall be 1, 2, 3, 6, or 12.
— For timing check objects, the no_of_delays value shall match the number of limits existing in the
timing check.
— For intermodule path objects, the no_of_delays value shall be 2 or 3.
The application-allocated array shall contain delays in the same order in which they occur in
s_vpi_delay
the SystemVerilog description. The number of elements for each delay shall be determined by the flags
mtm_flag and pulsere_flag, as shown in Table38-2.
Table38-2—Size of the s_vpi_delay->da array
Number of
Order in which delay elements
Flag values array elements
s_vpi_time shall be filled
required for s_vpi_delay->da
mtm_flag = no_of_delays
FALSE 1st delay: da[0] -> 1st delay
pulsere_flag = FALSE 2nd delay: da[1] -> 2nd delay
...
mtm_flag = 3  no_of_delays
TRUE 1st delay: da[0] -> min delay
pulsere_flag = FALSE da[1] -> typ delay
da[2] -> max delay
2nd delay: ...
mtm_flag = 3  no_of_delays
FALSE 1st delay: da[0] -> delay
pulsere_flag = TRUE da[1] -> reject limit
da[2] -> error limit
2nd delay element: ...
mtm_flag = 9  no_of_delays
TRUE 1st delay: da[0] -> min delay
pulsere_flag = TRUE da[1] -> typ delay
da[2] -> max delay
da[3] -> min reject
da[4] -> typ reject
da[5] -> max reject
da[6] -> min error
da[7] -> typ error
da[8] -> max error
2nd delay: ...
The delay structure has to be allocated before passing a pointer to vpi_get_delays(). In the following
example, a static structure, prim_da, is allocated for use by each call to the vpi_get_delays() function:
display_prim_delays(prim)
vpiHandle prim;
{
static s_vpi_time prim_da[3];
static s_vpi_delay delay_s = {NULL, 3, vpiScaledRealTime};
static p_vpi_delay delay_p = &delay_s;
delay_s.da = prim_da;
vpi_get_delays(prim, delay_p);
vpi_printf("Delays for primitive %s: %6.2f %6.2f %6.2f\n",
1060
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
vpi_get_str(vpiFullName, prim)
delay_p->da[0].real, delay_p->da[1].real, delay_p->da[2].real);
}
38.11 vpi_get_str()
vpi_get_str()
Synopsis: Get the value of a string property of an object.
Syntax:
vpi_get_str(prop, obj)
Type Description
Returns: PLI_BYTE8 * Pointer to a character string containing the property value.
Type Name Description
Arguments: PLI_INT32 prop An integer constant representing the property of an object
for which to obtain a value.
vpiHandle obj Handle to an object.
Related Use vpi_get() to get integer and Boolean properties.
routines: Use vpi_get64() to get 64-bit integer properties.
The VPI routine vpi_get_str() shall return string property values. The string shall be placed in a temporary
buffer that shall be used by every call to this routine. If the string is to be used after a subsequent call, the
string should be copied to another location. A different string buffer shall be used for string values returned
through the structure. Unless otherwise specified, calling vpi_get_str() for a protected object
s_vpi_value
shall be an error.
The following example illustrates the usage of vpi_get_str():
vpiHandle mod = vpi_handle_by_name("top.mod1",NULL);
vpi_printf ("Module top.mod1 is an instance of %s\n",
vpi_get_str(vpiDefName, mod));
1061
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.12 vpi_get_systf_info()
vpi_get_systf_info()
Synopsis: Retrieve information about a user-defined system task or system function callback.
Syntax:
vpi_get_systf_info(obj, systf_data_p)
Type Description
Returns: void
Type Name Description
Arguments: vpiHandle obj Handle to a system task or system function callback.
p_vpi_systf_data systf_data_p Pointer to a structure containing callback information.
Related Use vpi_get_cb_info() to retrieve information about a simulation-related callback.
routines:
The VPI routine vpi_get_systf_info() shall return information about a user-defined system task or system
function callback in an structure. The memory for this structure shall be allocated by
s_vpi_systf_data
the application.
The structure used by vpi_get_systf_info() is defined in and is listed in
s_vpi_systf_data vpi_user.h
Figure38-5.
typedef struct t_vpi_systf_data
{
PLI_INT32 type; /* vpiSysTask, vpiSysFunc */
PLI_INT32 sysfunctype; /* vpiSysTask, vpi[Int,Real,Time,Sized,
SizedSigned]Func */
PLI_BYTE8 *tfname; /* first character must be '$' */
PLI_INT32 (*calltf)(PLI_BYTE8 *);
PLI_INT32 (*compiletf)(PLI_BYTE8 *);
PLI_INT32 (*sizetf)(PLI_BYTE8 *); /* for sized function
callbacks only */
PLI_BYTE8 *user_data;
} s_vpi_systf_data, *p_vpi_systf_data;
Figure38-5—s_vpi_systf_data structure definition
1062
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.13 vpi_get_time()
vpi_get_time()
Synopsis: Retrieve the current simulation time.
Syntax:
vpi_get_time(obj, time_p)
Type Description
Returns: void
Type Name Description
Arguments: vpiHandle obj Handle to an object.
p_vpi_time time_p Pointer to a structure containing time information.
Related
routines:
The VPI routine vpi_get_time() shall retrieve the current simulation time, using the timescale of the object.
If obj is , the simulation time is retrieved using the simulation time unit. If obj is a time queue object,
NULL
the scheduled time of the future event is retrieved using the simulation time unit. The time_p->type field
shall be set to indicate if scaled real or simulation time is desired. The memory for the time_p structure shall
be allocated by the application.
The structure used by vpi_get_time() is defined in and is listed in Figure38-6
s_vpi_time vpi_user.h
[this is the same time structure as used by vpi_put_value()].
typedef struct t_vpi_time
{
PLI_INT32 type; /* [vpiScaledRealTime, vpiSimTime,
vpiSuppressTime] */
PLI_UINT32 high, low; /* for vpiSimTime */
double real; /* for vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;
Figure38-6—s_vpi_time structure definition
1063
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.14 vpi_get_userdata()
vpi_get_userdata()
Synopsis: Get user-data value from an implementation’s system task or system function instance storage location.
Syntax:
vpi_get_userdata(obj)
Type Description
Returns: void * User-data value associated with a system task instance or system function instance.
Type Name Description
Arguments: vpiHandle obj Handle to a system task instance or system function
instance.
Related Use vpi_put_userdata() to write data into the user-data storage area.
routines:
This routine shall return the value of the user data associated with a previous call to vpi_put_userdata() for
a user-defined system task or system function call handle. If no user data had been previously associated
with the object or if the routine fails, the return value shall be NULL.
After a restart or a reset, subsequent calls to vpi_get_userdata() shall return NULL. It is the application’s
responsibility to save the data during a save using vpi_put_data() and to then retrieve them using
vpi_get_data(). The user-data field can be set up again during or after callbacks of type cbEndOfRestart or
cbEndOfReset.
38.15 vpi_get_value()
vpi_get_value()
Synopsis: Retrieve the simulation value of an object.
Syntax:
vpi_get_value(obj, value_p)
Type Description
Returns: void
Type Name Description
Arguments: vpiHandle obj Handle to an expression.
p_vpi_value value_p Pointer to a structure containing value information.
Related Use vpi_put_value() to set the value of an object.
routines:
The VPI routine vpi_get_value() shall retrieve the simulation value of VPI objects. The value shall be
placed in an structure, which has been allocated by the application. The object shall be fully
s_vpi_value
evaluated as if simulated in the context in which it occurs in the SystemVerilog source, including all
expressions with side effects that occur as index expressions or as arguments to function calls embedded in
the object expression.
1064
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For example, applying vpi_get_value() to the expression “ ” shall increment the value of but shall
i++ i
return the unincremented value. Similarly, retrieving the simulation value of “ ” shall
x[my_func(a)]
evaluate in order to determine the value of the index expression.
my_func(a)
The format of the value shall be set by the format field of the structure.
When the format field is vpiObjTypeVal, the routine shall fill in the value and change the format field
based on the object type, as follows:
— For an integer, vpiIntVal
— For a real, vpiRealVal
— For a scalar, either vpiScalar or vpiStrength
— For a time variable, vpiTimeVal with vpiSimTime
— For a vector, vpiVectorVal
The buffer this routine uses for string values shall be different from the buffer that vpi_get_str() shall use.
The string buffer used by vpi_get_value() is overwritten with each call. If the value is needed, it should be
saved by the application.
The , , and structures used by vpi_get_value() are
s_vpi_value s_vpi_vecval s_vpi_strengthval
defined in and are listed in Figure38-7, Figure38-8, and Figure38-9.
vpi_user.h
.
typedef struct t_vpi_value
{
PLI_INT32 format; /* vpi[[Bin,Oct,Dec,Hex]Str,Scalar,Int,Real,String,
Vector,Strength,Suppress,Time,ObjType]Val */
union
{
PLI_BYTE8 *str; /* string value */
PLI_INT32 scalar; /* vpi[0,1,X,Z] */
PLI_INT32 integer; /* integer value */
double real; /* real value */
struct t_vpi_time *time; /* time value */
struct t_vpi_vecval *vector; /* vector value */
struct t_vpi_strengthval *strength; /* strength value */
PLI_BYTE8 *misc; /* ...other */
} value;
} s_vpi_value, *p_vpi_value;
Figure38-7—s_vpi_value structure definition
typedef struct t_vpi_vecval
{
/* following fields are repeated enough times to contain vector */
PLI_UINT32 aval, bval; /* bit encoding: ab: 00=0, 10=1, 11=X, 01=Z */
} s_vpi_vecval, *p_vpi_vecval;
Figure38-8—s_vpi_vecval structure definition
typedef struct t_vpi_strengthval
{
PLI_INT32 logic; /* vpi[0,1,X,Z] */
PLI_INT32 s0, s1; /* refer to strength coding in Annex K */
} s_vpi_strengthval, *p_vpi_strengthval;
Figure38-9—s_vpi_strengthval structure definition
1065
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For vectors, the p_vpi_vecval field shall point to an array of structures. The size of this
s_vpi_vecval
array shall be determined by the size of the vector, where array_size = ((vector_size–1)/32 + 1). The LSB of
the vector shall be represented by the LSB of the 0-indexed element of array. The 33rd bit
s_vpi_vecval
of the vector shall be represented by the LSB of the 1-indexed element of the array, and so on. The memory
for the union members str, time, vector, strength, and misc of the value union in the structure
s_vpi_value
shall be provided by the routine vpi_get_value(). This memory shall only be valid until the next call to
vpi_get_value(). The application shall provide the memory for these members when calling
vpi_put_value(). When a value change callback occurs for a value type of vpiVectorVal, the system shall
create the associated memory (an array of structures) and free the memory upon the return
s_vpi_vecval
of the callback.
Table38-3—Return value field of the s_vpi_value structure union
Format Union member Return description
vpiBinStrVal str String of binary character(s) [1, 0, x, z]
vpiOctStrVal str String of octal character(s) [0–7, x, X, z, Z]
x when all the bits are x
X when some of the bits are x
z when all the bits are z
Z when some of the bits are z
vpiDecStrVal str String of decimal character(s) [0–9]
vpiHexStrVal str String of hex character(s) [0–f, x, X, z, Z]
x when all the bits are x
X when some of the bits are x
z when all the bits are z
Z when some of the bits are z
vpiScalarVal scalar vpi1, vpi0, vpiX, vpiZ, vpiH, vpiL
vpiIntVal integer Integer value of the handle. Any bits x or z in the value
of the object are mapped to a 0
vpiRealVal real Value of the handle as a double
vpiStringVal str A string where each 8-bit group of the value of the
object is assumed to represent an ASCII character
vpiTimeVal time Integer value of the handle using two integers
vpiVectorVal vector aval/bval representation of the value of the object
vpiStrengthVal strength Value plus strength information
vpiObjTypeVal — Return a value in the closest format of the object
If the format field in the s_vpi_value structure is set to vpiStrengthVal, the value.strength pointer shall
point to an array of structures. This array shall have at least as many elements as
s_vpi_strengthval
there are bits in the vector. If the object is a reg or variable, the strength will always be returned as strong.
If the logic value retrieved by vpi_get_value() needs to be preserved for later use, the application shall
allocate storage and copy the value. The following example can be used to copy a value that was retrieved
into an s_vpi_value structure into another structure allocated by the application:
/*
* Copy s_vpi_value structure - must first allocate pointed to fields.
* nvalp must be previously allocated.
* Need to first determine size for vector value.
1066
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
*/
void copy_vpi_value(s_vpi_value *nvalp, s_vpi_value *ovalp,
PLI_INT32 blen, PLI_INT32 nd_alloc)
{
int i;
PLI_INT32 numvals;
nvalp->format = ovalp->format;
switch (nvalp->format) {
/* all string values */
case vpiBinStrVal: case vpiOctStrVal: case vpiDecStrVal:
case vpiHexStrVal: case vpiStringVal:
if (nd_alloc) nvalp->value.str = malloc(strlen(ovalp->value.str)+1);
strcpy(nvalp->value.str, ovalp->value.str);
break;
case vpiScalarVal:
nvalp->value.scalar = ovalp->value.scalar;
break;
case vpiIntVal:
nvalp->value.integer = ovalp->value.integer;
break;
case vpiRealVal:
nvalp->value.real = ovalp->value.real;
break;
case vpiVectorVal:
numvals = (blen + 31) >> 5;
if (nd_alloc)
{
nvalp->value.vector = (p_vpi_vecval)
malloc(numvals*sizeof(s_vpi_vecval));
}
/* t_vpi_vecval is really array of the 2 integer a/b sections */
/* memcpy or bcopy better here */
for (i = 0; i <numvals; i++)
nvalp->value.vector[i] = ovalp->value.vector[i];
break;
case vpiStrengthVal:
if (nd_alloc)
{
nvalp->value.strength = (p_vpi_strengthval)
malloc(sizeof(s_vpi_strengthval));
}
/* assumes C compiler supports struct assign */
*(nvalp->value.strength) = *(ovalp->value.strength);
break;
case vpiTimeVal:
nvalp->value.time = (p_vpi_time) malloc(sizeof(s_vpi_time));
/* assumes C compiler supports struct assign */
*(nvalp->value.time) = *(ovalp->value.time);
break;
/* not sure what to do here? */
case vpiObjTypeVal: case vpiSuppressVal:
vpi_printf(
"**ERR: cannot copy vpiObjTypeVal or vpiSuppressVal formats",
" - not for filled records.\n");
break;
}
}
1067
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
To get the ASCII values of UDP table entries (see Table29-1 in 29.3.6), the p_vpi_vecval field shall point to
an array of structures. The size of this array shall be determined by the size of the table
s_vpi_vecval
entry (number of symbols per table entry), where array_size = ((table_entry_size–1)/4 + 1). Each symbol
shall require two bytes; the ordering of the symbols within shall be the most significant byte
s_vpi_vecval
of abit first, then the least significant byte of abit, then the most significant byte of bbit, and then the least
significant byte of bbit. Each symbol can be either one or two characters; when it is a single character, the
second byte of the pair shall be an ASCII “\0”.
Real valued objects shall be converted to an integer using the rounding defined in 6.12.2 before being
returned in a format other than vpiRealVal and vpiStringVal. If the format specified is vpiStringVal, then
the value shall be returned as a string representation of a floating-point number. The format of this string
shall be in decimal notation with at most 16 digits of precision.
If a constant object’s vpiConstType is vpiStringConst, the value shall be retrieved using a format of either
vpiStringVal or vpiVectorVal.
The misc field in the structure shall provide for alternative value types, which can be
s_vpi_value
implementation specific. If this field is utilized, one or more corresponding format types shall also be
provided.
In the following example, the binary value of each net that is contained in a particular module and whose
name begins with a particular string is displayed. [This function makes use of the facility
strcmp()
normally declared in a C library.]
string.h
void display_certain_net_values(mod, target)
vpiHandle mod;
PLI_BYTE8 *target;
{
static s_vpi_value value_s = {vpiBinStrVal};
static p_vpi_value value_p = &value_s;
vpiHandle net, itr;
itr = vpi_iterate(vpiNet, mod);
while (net = vpi_scan(itr))
{
PLI_BYTE8 *net_name = vpi_get_str(vpiName, net);
if (strcmp(target, net_name) == 0)
{
vpi_get_value(net, value_p);
vpi_printf("Value of net %s: %s\n",
vpi_get_str(vpiFullName, net),value_p->value.str);
}
}
}
The following example illustrates the use of vpi_get_value() to access UDP table entries. Two sample
outputs from this example are provided after the example.
/*
* hUDP must be a handle to a UDP definition
*/
static void dumpUDPTableEntries(vpiHandle hUDP)
{
vpiHandle hEntry, hEntryIter;
s_vpi_value value;
PLI_INT32 numb;
1068
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
PLI_INT32 udpType;
PLI_INT32 item;
PLI_INT32 entryVal;
PLI_INT32 *abItem;
PLI_INT32 cnt, cnt2;
numb = vpi_get(vpiSize, hUDP);
udpType = vpi_get(vpiPrimType, hUDP);
if (udpType == vpiSeqPrim)
numb++; /* There is one more table entry for state */
numb++; /* There is a table entry for the output */
hEntryIter = vpi_iterate(vpiTableEntry, hUDP);
if (!hEntryIter)
return;
value.format = vpiVectorVal;
while(hEntry = vpi_scan(hEntryIter))
{
vpi_printf("\n");
/* Show the entry as a string */
value.format = vpiStringVal;
vpi_get_value(hEntry, &value);
vpi_printf("%s\n", value.value.str);
/* Decode the vector value format */
value.format = vpiVectorVal;
vpi_get_value(hEntry, &value);
abItem = (PLI_INT32 *)value.value.vector;
for(cnt=((numb-1)/2+1);cnt>0;cnt--)
{
entryVal = *abItem;
abItem++;
/* Rip out 4 characters */
for (cnt2=0;cnt2<4;cnt2++)
{
item = entryVal&0xff;
if (item)
vpi_printf("%c", item);
else
vpi_printf("_");
entryVal = entryVal>>8;
}
}
}
vpi_printf("\n");
}
For a UDP table of
1 0 :?:1;
0 (01) :?:-;
(10) 0 :0:1;
the output from the preceding example would be
10:1
_0_1___1
01:0
_1_0___0
00:1
_0_0___1
1069
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For a UDP table entry of
1 0 :?:1;
0 (01) :?:-;
(10) 0 :0:1;
the output from the preceding example would be
10:?:1
_0_1_1_?
0(01):?:-
10_0_-_?
(10)0:0:1
_001_1_0
38.16 vpi_get_value_array()
vpi_get_value_array()
Synopsis: Retrieve simulation values for contiguous elements of a static unpacked array object.
Syntax:
vpi_get_value_array(obj, arrayvalue_p, index_p, num)
Type Description
Returns: void
Type Name Description
Arguments: vpiHandle obj Handle to an unpacked array object.
p_vpi_arrayvalue arrayvalue_p Pointer to a structure containing array value information.
PLI_INT32 * index_p Pointer to an array of index values corresponding to the
start of the section of the object to be retrieved.
PLI_UINT32 num Number of array elements to be retrieved.
Related Use vpi_put_value_array() to set values of contiguous elements of a static unpacked array object
routines:
The VPI routine vpi_get_value_array() shall retrieve simulation values of contiguous elements in static
unpacked variable or net arrays (array objects for which the vpiArrayType property is vpiStaticArray).
Such arrays must also have static lifetimes and not contain dynamic arrays or dynamic elements (e.g., string
vars). For purposes here, the term element corresponds to any indexable member of such an array with all
unpacked indices fully specified. The data type of each element so defined corresponds to the data type of
the array with all unpacked ranges removed. The elements of arrays are not allowed to be of an unpacked
type themselves (e.g., unpacked structs).
The values for the array section shall be placed in an structure defined in
s_vpi_arrayvalue
, as follows:
vpi_user.h
typedef struct t_vpi_arrayvalue
{
PLI_UINT32 format;
PLI_UINT32 flags;
union
1070
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
{
PLI_INT32 *integers;
PLI_INT16 *shortints;
PLI_INT64 *longints;
PLI_BYTE8 *rawvals;
struct t_vpi_vecval *vectors;
struct t_vpi_time *times;
double *reals;
float *shortreals;
} value;
} s_vpi_arrayvalue, *p_vpi_arrayvalue;
The structure shown above shall be allocated by the application. However, the
s_vpi_arrayvalue
application has the flexibility of allocating the actual storage where the array element values are placed (see
the following). The layout of the values retrieved shall be set by the format field in the structure. In addition
to the format types vpiIntVal, vpiTimeVal, vpiVectorVal, and vpiRealVal available with the
vpi_get_value() function (Table38-3 in 38.15), the following format types are available:
vpiRawFourStateVal
Values for each element retrieved will be stored in aval/bval format (similar to 4-
state vectors) using the field of the union above, interleaved
*rawvals
according to the following structure:
struct
{
PLI_BYTE8 avalbits[ngroups];
PLI_BYTE8 bvalbits[ngroups];
}
Each array element occupies bytes stored consecutively as A/B byte
ngroups*2
groups as shown above. For the first indexed array element, the
avalbits
begins at , and the at ,
rawvals[0] bvalbits rawvals[ngroups]
respectively. The second array element’s begin at
avalbits
, and its at , etc.
rawvals[ngroups*2] bvalbits rawvals[ngroups*3]
is computed given the array element size in bits ( ) as
ngroups = elemBits
follows:
int ngroups = (elemBits + 7) / 8;
The total storage required to hold “num” array elements shall be
.
ngroups * num * 2
vpiRawTwoStateVal
Values for each element retrieved shall be stored similarly to
vpiRawFourStateVal above (also using the struct member), except
*rawvals
that the byte group shall be omitted. shall be computed
bvalbits ngroups
similarly also, but the total storage required shall instead be .
ngroups * num
vpiShortIntVal Values retrieved will be stored as an array of “num” short(s), using the
field in the union in this case. This format is appropriate only for
*shortints
arrays of vpiShortIntVar or vpiByteVar elements.
vpiLongIntVal Values retrieved will be stored as an array of “num” long(s), using the
field in the union in this case. This format is appropriate for arrays
*longints
of vpiLongIntVar, vpiShortIntVar or vpiByteVar elements.
vpiShortRealVal Values retrieved will be stored as an array of “num” floats, using the
field in the union in this case. This format is appropriate only
*shortrealvals
for arrays of vpiShortRealVar elements.
1071
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The format types vpiIntVal, vpiTimeVal, vpiVectorVal, and vpiRealVal that are also available with
vpi_get_value() function correspond to similar union member names in (converted to
s_vpi_arrayvalue
pointer values and ending in “ ” to indicate they are arrays). For example, selecting the vpiIntVal format
s
shall cause an array of 32-bit integers to be returned (which should be accessed using the field),
*integers
each representing an indexed element of the array object. The vpiVectorVal format shall cause an array of
consecutive A/B word groups formatted according to the structure (Figure38-8 in 38.15) to
t_vpi_vecval
be retrieved. The field should be used to access them. Given the array element size in bits (
*vectors ==
), the number of words of storage required will be:
elemBits
((elemBits + 31) / 32) * 2 * num
All other formats not mentioned here are unsupported and shall result in an error if requested. Also, formats
requested that are inconsistent with the data type of the array elements (except where explicitly allowed)
shall be considered an error.
The vpiRawFourStateVal and vpiVectorVal formats are appropriate for all 4-state array types (all net
arrays, or variable arrays of vpiLogicVar, vpiIntegerVar, vpiTimeVar, or 4-state packed vpiStructVar or
vpiUnionVar elements). The vpiRawTwoStateVal format is appropriate for all 2-state array types
(variable arrays of vpiBitVar, vpiByteVar, vpiShortInt, vpiInt, vpiLongInt, or 2-state packed
vpiStructVar or vpiUnionVar elements). The vpiRawFourStateVal or vpiVectorVal formats can also be
requested of a 2-state array type, and the vpiRawTwoStateVal format can be requested for a 4-state array
type. The bit values in each array element, whether fixed or variable width, correspond to significance order
in avalbits and bvalbits. That is, the LSB of and indicates the A and B
rawvals[0] rawvals[ngroups]
value of the LSB (0th) bit of the first array element, respectively, and the LSB of and
rawvals[1]
indicates the A and B value of bit 8 of the first array element (if it is of width 9 bits
rawvals[ngroups+1]
or greater), and so on. Similar significance order conventions apply to A/B word groups in the
vpiVectorVal format, as described for vpi_get_value() (38.15).
The argument is an array containing the indices of the starting element to be retrieved in the array
index_p
object. The indices are ordered in this array according to left-to-right order they would appear in an
expression in HDL text. The size of the index array shall be equal to the number of unpacked
index_p
dimensions of , the array object.
obj
The array element values are retrieved consecutively in order of the fastest varying index (rightmost
unpacked range of the array declaration), followed by more slowly varying indices accordingly until the
number of elements ( ) has been retrieved. Index values within each range are ordered from leftmost
num
range value to rightmost. For example, elements of an array with and
a[2:0][3:5] index_p[0] = 1
would be retrieved in the order , , , , ,
index_p[1] = 4 a[1][4] a[1][5] a[0][3] a[0][4] a[0][5]
respectively.
By default, array values shall be returned in memory allocated by VPI (in which case the storage should be
regarded as read-only). In this case, since the same VPI storage area may be overwritten with subsequent
calls to this function, the caller must save this data elsewhere in order to preserve it.
However, if the application sets the vpiUserAllocFlag in the value.flags field, the function will assume the
calling application has set the field to point to a buffer of sufficient size allocated by the application
value
for placing the values. For all formats requested except for vpiRawFourStateVal, vpiVectorVal, and
vpiRawTwoStateVal, the buffer size can be simply computed as:
size = num * sizeof(<union ptr type>);
For example, a buffer sized to hold an array of small integers (of vpiByteVar or vpiShortIntVar elements)
using the vpiShortIntVal format type set would be sized as:
size = num * sizeof(PLI_INT16);
1072
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Buffers allocated to hold the vpiRawFourStateVal and vpiRawTwoStateVal formats shall be sized
according to the instructions in their format description.
If vpi_get_value_array() returns for the value pointer in either case, it shall indicate that a VPI error
NULL
has occurred in the retrieval process. It shall be the application’s responsibility to free memory it has
allocated, even if a VPI error has occurred (when the value field pointer is overwritten to ). The
NULL
application should always save the value of the pointer to memory it allocates so that it can be freed later.
Using the previous example of array , the following code could be used to retrieve the five values shown
a
above starting at (with the application code allocating the storage for them):
a[1][4]
/* Retrieve 5 element values from array "logic a[2:0][3:5]"
* starting at "a[1][4]", given "arrH", a vpiHandle for "a". */
int indexArr[2];
PLI_BYTE8 *valueBuffer; /* Retain local ptr to mem allocated */
s_vpi_arrayvalue arrayVal = { 0, 0, NULL };
vpiHandle elemH, elemI;
int elemWidth, ngroups;
int num = 5;
/* Get array element so we can get size to determine ngroups */
elemI = vpi_iterate(vpiReg, arrH);
elemH = vpi_scan(elemI);
elemWidth = vpi_get(vpiSize, elemH);
ngroups = (elemWidth + 7) / 8;
vpi_release_handle(elemI);
/* Allocate storage and retrieve the values. */
arrayVal.format = vpiRawFourStateVal;
arrayVal.flags |= vpiUserAllocFlag; /* We allocate the memory */
valueBuffer = (PLI_BYTE8 *)malloc(ngroups * 2 * num);
arrayVal.value.rawvals = valueBuffer;
indexArr[0] = 1;
indexArr[1] = 4;
vpi_get_value_array(arrH, &arrayVal, indexArr, num);
/* Check for result status */
if (arrayVal.value.rawvals == NULL) {
/* ... We have an error- check it. ... */
} else {
/* ... Values OK- process them. ... */
}
free(valueBuffer);
1073
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.17 vpi_get_vlog_info()
vpi_get_vlog_info()
Synopsis: Retrieve information about SystemVerilog simulation execution.
Syntax:
vpi_get_vlog_info(vlog_info_p)
Type Description
Returns: PLI_INT32 1 (true) on success; 0 (false) on failure.
Type Name Description
Arguments: p_vpi_vlog_info vlog_info_p Pointer to a structure containing simulation information.
Related
routines:
The VPI routine vpi_get_vlog_info() shall obtain the following information about SystemVerilog tool
execution:
— Number of invocation options (argc)
— Invocation option values (argv)
— Product and version strings
The information shall be contained in an structure. The routine shall return 1 (true) on
s_vpi_vlog_info
success and 0 (false) on failure.
The structure used by vpi_get_vlog_info() is defined in and is listed in
s_vpi_vlog_info vpi_user.h
Figure38-10.
typedef struct t_vpi_vlog_info
{
PLI_INT32 argc;
PLI_BYTE8 **argv;
PLI_BYTE8 *product;
PLI_BYTE8 *version;
} s_vpi_vlog_info, *p_vpi_vlog_info;
Figure38-10—s_vpi_vlog_info structure definition
The format of the argv array is that each pointer in the array shall point to a -terminated character array
NULL
that contains the string located on the tool’s invocation command line. There shall be argc entries in the argv
array. The value in entry zero shall be the tool’s name.
The vendor tool may provide a command-line option to pass a file containing a set of options. In that case,
the argument strings returned by vpi_get_vlog_info() shall contain the vendor option string name followed
by a pointer to a -terminated array of pointers to characters. This new array shall contain the parsed
NULL
contents of the file. The value in entry zero shall contain the name of the file. The remaining entries shall
contain pointers to -terminated character arrays containing the different options in the file. The last
NULL
entry in this array shall be . If one of the options is the vendor file option, then the next pointer shall
NULL
behave the same as previously described.
1074
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.18 vpi_handle()
vpi_handle()
Synopsis: Obtain a handle to an object with a one-to-one relationship.
Syntax:
vpi_handle(type, ref)
Type Description
Returns: vpiHandle Handle to an object.
Type Name Description
Arguments: PLI_INT32 type An integer constant representing the type of object for
which to obtain a handle.
vpiHandle ref Handle to a reference object.
Related Use vpi_iterate() and vpi_scan() to obtain handles to objects with a one-to-many relationship.
routines: Use vpi_handle_multi() to obtain a handle to an object with a many-to-one relationship.
The VPI routine vpi_handle() shall return the object of typetype associated with object ref. Unless
otherwise specified, calling vpi_handle() for a protected object shall be an error. The one-to-one
relationships that are traversed with this routine are indicated as single arrows in the data model diagrams.
The following example application displays each primitive that an input net drives:
void display_driven_primitives(net)
vpiHandle net;
{
vpiHandle load, prim, itr;
vpi_printf("Net %s drives terminals of the primitives: \n",
vpi_get_str(vpiFullName, net));
itr = vpi_iterate(vpiLoad, net);
if (!itr)
return;
while (load = vpi_scan(itr))
{
switch(vpi_get(vpiType, load))
{
case vpiGate:
case vpiSwitch:
case vpiUdp:
prim = vpi_handle(vpiPrimitive, load);
vpi_printf("\t%s\n", vpi_get_str(vpiFullName, prim));
}
}
}
1075
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.19 vpi_handle_by_index()
vpi_handle_by_index()
Synopsis: Get a handle to an object using its index number within a parent object.
Syntax:
vpi_handle_by_index(obj, index)
Type Description
Returns: vpiHandle Handle to an object.
Type Name Description
Arguments: vpiHandle obj Handle to an object.
PLI_INT32 index Index number of the object for which to obtain a handle.
Related
routines:
The VPI routine vpi_handle_by_index() shall return a handle to an object based on the index number of the
object within the reference object obj. The reference object shall be an object that has the access by index
property. Unless otherwise specified, calling vpi_handle_by_index() for a protected object shall be an
error. For example, to access a net bit, obj would be the associated net; to access an element of a reg array,
obj would be the array. If the selection represented by the index number does not lead to the construction of
a legal SystemVerilog index select expression, the routine shall return a handle.
null
38.20 vpi_handle_by_multi_index()
vpi_handle_by_multi_index()
Synopsis: Obtain a handle to a subobject using an array of indices and a reference object.
Syntax:
vpi_handle_by_multi_index(obj, num_index, index_array)
Type Description
Returns: vpiHandle Handle to an object.
Type Name Description
Arguments: vpiHandle obj Handle to an object.
PLI_INT32 num_index Number of indices in the index array.
PLI_INT32 * index_array Array of indices. Leftmost index first.
Related
routines:
The VPI routine vpi_handle_by_multi_index() shall provide access to an index-selected subobject of the
reference handle. The reference object shall be an object that has the access by index property. Unless
otherwise specified, calling vpi_handle_by_multi_index() for a protected object shall be an error. This
routine shall return a handle to a valid SystemVerilog object based on the list of indices provided by the
argument index_array and reference handle denoted by obj. The argument num_index shall contain the
number of indices in the provided array index_array.
1076
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The order of the indices provided shall follow the array dimension declaration from the leftmost range to the
rightmost range of the reference handle; the array indices may be optionally followed by a bit-select index.
If the indices provided do not lead to the construction of a legal SystemVerilog index select expression, the
routine shall return a handle.
null
38.21 vpi_handle_by_name()
vpi_handle_by_name()
Synopsis: Get a handle to an object with a specific name.
Syntax:
vpi_handle_by_name(name, scope)
Type Description
Returns: vpiHandle Handle to an object.
Type Name Description
Arguments: PLI_BYTE8 * name A character string or pointer to a string containing the
name of an object.
vpiHandle scope Handle to a SystemVerilog scope.
Related
routines:
The VPI routine vpi_handle_by_name() shall return a handle to an object with a specific name. This
function can be applied to all objects with a fullname property. The name can be hierarchical or simple. If
scope is , then name shall be searched for from the top level of hierarchy. If a scope object is provided,
NULL
then search within that scope only. Unless otherwise specified, calling vpi_handle_by_name() for a
protected scope object shall be an error. If the name is hierarchical and includes a protected scope, the call
shall be an error.
1077
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.22 vpi_handle_multi()
vpi_handle_multi()
Synopsis: Obtain a handle for an object in a many-to-one relationship.
Syntax:
vpi_handle_multi(type, ref1, ref2, ...)
Type Description
Returns: vpiHandle Handle to an object.
Type Name Description
Arguments: PLI_INT32 type An integer constant representing the type of object for
which to obtain a handle.
vpiHandle ref1, ref2, ... Handles to two or more reference objects.
Related Use vpi_iterate() and vpi_scan() to obtain handles to objects with a one-to-many relationship.
routines: Use vpi_handle() to obtain handles to objects with a one-to-one relationship.
The VPI routine vpi_handle_multi() can be used to return a handle to an object of type vpiInterModPath
associated with a list of output port and input port reference objects. The ports shall be of the same size and
can be at different levels of the hierarchy.
38.23 vpi_iterate()
vpi_iterate()
Synopsis: Obtain an iterator handle to objects with a one-to-many relationship.
Syntax:
vpi_iterate(type, ref)
Type Description
Returns: vpiHandle Handle to an iterator for an object.
Type Name Description
Arguments: PLI_INT32 type An integer constant representing the type of object for
which to obtain iterator handles.
vpiHandle ref Handle to a reference object.
Related Use vpi_scan() to traverse the design hierarchy using the iterator handle returned from vpi_iterate().
routines: Use vpi_handle() to obtain handles to object with a one-to-one relationship.
Use vpi_handle_multi() to obtain a handle to an object with a many-to-one relationship.
The VPI routine vpi_iterate() shall be used to traverse one-to-many relationships, which are indicated as
double arrows in the data model diagrams. Unless otherwise specified, calling vpi_iterate() for a protected
object shall be an error. The vpi_iterate() routine shall return a handle to an iterator, whose type shall be
vpiIterator, which can used by vpi_scan() to traverse all objects of typetype associated with object ref. To
get the reference object from the iterator object, use vpi_handle(vpiUse, iterator_handle). If there are no
objects of typetype associated with the reference handle ref, then the vpi_iterate() routine shall return
.
NULL
The following example application uses vpi_iterate() and vpi_scan() to display each net (including the size
for vectors) declared in the module. The example assumes it shall be passed a valid module handle.
1078
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
void display_nets(mod)
vpiHandle mod;
{
vpiHandle net;
vpiHandle itr;
vpi_printf("Nets declared in module %s\n",
vpi_get_str(vpiFullName, mod));
itr = vpi_iterate(vpiNet, mod);
while (net = vpi_scan(itr))
{
vpi_printf("\t%s", vpi_get_str(vpiName, net));
if (vpi_get(vpiVector, net))
{
vpi_printf(" of size %d\n", vpi_get(vpiSize, net));
}
else vpi_printf("\n");
}
}
38.24 vpi_mcd_close()
vpi_mcd_close()
Synopsis: Close one or more files opened by vpi_mcd_open().
Syntax:
vpi_mcd_close(mcd)
Type Description
Returns: PLI_UINT32 0 if successful; the mcd of unclosed channels if unsuccessful.
Type Name Description
Arguments: PLI_UINT32 mcd A multichannel descriptor representing the files to close.
Related Use vpi_mcd_open() to open a file.
routines: Use vpi_mcd_printf() to write to an opened file.
Use vpi_mcd_vprintf() to write a variable number of arguments to an opened file.
Use vpi_mcd_flush() to flush a file output buffer.
Use vpi_mcd_name() to get the name of a file represented by a channel descriptor.
The VPI routine vpi_mcd_close() shall close the file(s) specified by a multichannel descriptor mcd. Several
channels can be closed simultaneously because channels are represented by discrete bits in the integer mcd.
On success, this routine shall return a 0; on error, it shall return the mcd value of the unclosed channels. This
routine can also be used to close file descriptors that were opened using the system function . See
$fopen
21.3.1 for the functional description of .
$fopen
The following descriptor is predefined and cannot be closed using vpi_mcd_close():
— descriptor 1 is for the output channel of the tool that invoked the PLI application and the current log
file
1079
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.25 vpi_mcd_flush()
vpi_mcd_flush()
Synopsis: Flushes the data from the given mcd output buffers.
Syntax:
vpi_mcd_flush(mcd)
Type Description
Returns: PLI_INT32 0 if successful; nonzero if unsuccessful.
Type Name Description
Arguments: PLI_UINT32 mcd A multichannel descriptor representing the files to which
to write.
Related Use vpi_mcd_printf() to write a finite number of arguments to an opened file.
routines: Use vpi_mcd_vprintf() to write a variable number of arguments to an opened file.
Use vpi_mcd_open() to open a file.
Use vpi_mcd_close() to close a file.
Use vpi_mcd_name() to get the name of a file represented by a channel descriptor.
The routine vpi_mcd_flush() shall flush the output buffers for the file(s) specified by the multichannel
descriptor mcd.
38.26 vpi_mcd_name()
vpi_mcd_name()
Synopsis: Get the name of a file represented by a channel descriptor.
Syntax:
vpi_mcd_name(cd)
Type Description
Returns: PLI_BYTE8 * Pointer to a character string containing the name of a file.
Type Name Description
Arguments: PLI_UINT32 cd A channel descriptor representing a file.
Related Use vpi_mcd_open() to open a file.
routines: Use vpi_mcd_close() to close files.
Use vpi_mcd_printf() to write to an opened file.
Use vpi_mcd_flush() to flush a file output buffer.
Use vpi_mcd_vprintf() to write a variable number of arguments to an opened file.
The VPI routine vpi_mcd_name() shall return the name of a file represented by a single-channel descriptor
cd. On error, the routine shall return . This routine shall overwrite the returned value on subsequent
NULL
calls. If the application needs to retain the string, it should copy it. This routine can be used to get the name
of any file opened using the system function or the VPI routine vpi_mcd_open(). The channel
$fopen
descriptor cd could be an fd file descriptor returned from (indicated by the MSB being set) or an
$fopen
mcd multichannel descriptor returned by either the system function or the VPI routine
$fopen
vpi_mcd_open(). See 21.3.1 for the functional description of .
$fopen
1080
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.27 vpi_mcd_open()
vpi_mcd_open()
Synopsis: Open a file for writing.
Syntax:
vpi_mcd_open(file)
Type Description
Returns: PLI_UINT32 A multichannel descriptor representing the file that was opened.
Type Name Description
Arguments: PLI_BYTE8 * file A character string or pointer to a string containing the file
name to be opened.
Related Use vpi_mcd_close() to close a file.
routines: Use vpi_mcd_printf() to write to an opened file.
Use vpi_mcd_vprintf() to write a variable number of arguments to an opened file.
Use vpi_mcd_flush() to flush a file output buffer.
Use vpi_mcd_name() to get the name of a file represented by a channel descriptor.
The VPI routine vpi_mcd_open() shall open a file for writing and shall return a corresponding multichannel
description number (mcd). The channel descriptor 1 (LSB) is reserved for representing the output channel of
the tool that invoked the PLI application and the log file (if one is currently open). The channel descriptor
32(MSB) is reserved to represent a file descriptor (fd) returned from the SystemVerilog system
$fopen
function.
The mcd descriptor returned by vpi_mcd_open() routine is compatible with the mcd descriptors returned
from the system function. The mcd descriptors returned from vpi_mcd_open() and from
$fopen $fopen
may be shared between the built-in system tasks that use mcd descriptors and the VPI routines that use mcd
descriptors. If the MSB of the return value from is set, then the value is an fd file descriptor, which
$fopen
is not compatible with the mcd descriptor returned by vpi_mcd_open(). See 21.3.1 for the functional
description of .
$fopen
The vpi_mcd_open() routine shall return a 0 on error. If the file has already been opened either by a
previous call to vpi_mcd_open() or using in the SystemVerilog source code, then vpi_mcd_open()
$fopen
shall return the descriptor number.
1081
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.28 vpi_mcd_printf()
vpi_mcd_printf()
Synopsis: Write to one or more files opened with vpi_mcd_open() or $fopen.
Syntax:
vpi_mcd_printf(mcd, format, ...)
Type Description
Returns: PLI_INT32 The number of characters written.
Type Name Description
Arguments: PLI_UINT32 mcd A multichannel descriptor representing the files to which
to write.
PLI_BYTE8 * format A format string using the C fprintf() format.
Related Use vpi_mcd_vprintf() to write a variable number of arguments to an opened file.
routines: Use vpi_mcd_open() to open a file.
Use vpi_mcd_close() to close a file.
Use vpi_mcd_flush() to flush a file output buffer.
Use vpi_mcd_name() to get the name of a file represented by a channel descriptor.
The VPI routine vpi_mcd_printf() shall write to one or more channels (up to 31) determined by the mcd.
An mcd of 1 (bit 0 set) corresponds to the channel 1, an mcd of 2 (bit 1 set) corresponds to channel 2, an mcd
of 4 (bit 2 set) corresponds to channel 3, and so on. Channel 1 is reserved for the output channel of the tool
that invoked the PLI application and the current log file. The MSB of the descriptor is reserved by the tool to
indicate that the descriptor is actually a file descriptor instead of an mcd. vpi_mcd_printf() shall also write
to a file represented by an mcd that was returned from the SystemVerilog system function.
$fopen
vpi_mcd_printf() shall not write to a file represented by an fd file descriptor returned from
$fopen
(indicated by the MSB being set). See 21.3.2 for the functional description of .
$fopen
Several channels can be written to simultaneously because channels are represented by discrete bits in the
integer mcd.
The text written shall be controlled by one or more format strings. The format strings shall use the same
format as the C fprintf() routine. The routine shall return the number of characters printed or return EOF if
an error occurred.
1082
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.29 vpi_mcd_vprintf()
vpi_mcd_vprintf()
Synopsis: Write to one or more files opened with vpi_mcd_open() or $fopen using varargs that are already started.
Syntax:
vpi_mcd_vprintf(mcd, format, ap)
Type Description
Returns: PLI_INT32 The number of characters written.
Type Name Description
Arguments: PLI_UINT32 mcd A multichannel descriptor representing the files to which
to write.
PLI_BYTE8 * format A format string using the C printf() format.
va_list ap An already started varargs list.
Related Use vpi_mcd_printf() to write a finite number of arguments to an opened file.
routines: Use vpi_mcd_open() to open a file.
Use vpi_mcd_close() to close a file.
Use vpi_mcd_flush() to flush a file output buffer.
Use vpi_mcd_name() to get the name of a file represented by a channel descriptor.
This routine performs the same function as vpi_mcd_printf(), except that varargs have already been started.
38.30 vpi_printf()
vpi_printf()
Synopsis: Write to the output channel of the tool that invoked the PLI application and the current tool log file.
Syntax:
vpi_printf(format, ...)
Type Description
Returns: PLI_INT32 The number of characters written.
Type Name Description
Arguments: PLI_BYTE8 * format A format string using the C printf() format.
Related Use vpi_vprintf() to write a variable number of arguments.
routines: Use vpi_mcd_printf() to write to an opened file.
Use vpi_mcd_flush() to flush a file output buffer.
Use vpi_mcd_vprintf() to write a variable number of arguments to an opened file.
The VPI routine vpi_printf() shall write to both the output channel of the tool that invoked the PLI
application and the current tool log file. The format string shall use the same format as the C
printf()
routine. The routine shall return the number of characters printed or return EOF if an error occurred.
1083
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.31 vpi_put_data()
vpi_put_data()
Synopsis: Put data into an implementation’s save/restart location.
Syntax:
vpi_put_data(id, dataLoc, numOfBytes)
Type Description
Returns: PLI_INT32 The number of bytes written.
Type Name Description
Arguments: PLI_INT32 id A save/restart ID returned from
vpi_get(vpiSaveRestartID, NULL).
PLI_BYTE8 * dataLoc Address of application-allocated storage.
PLI_INT32 numOfBytes Number of bytes to be added to save/restart location.
Related Use vpi_get_data() to retrieve saved data.
routines:
This routine shall place numOfBytes, which shall be greater than zero, of data located at dataLoc into an
implementation’s save/restart location. The return value shall be the number of bytes written. A zero shall be
returned if an error is detected. There shall be no restrictions on the following:
— How many times the routine can be called for a given id
— The order applications put data using the different ids
The data from multiple calls to vpi_put_data() with the same id shall be stored by the simulator in such a
way that the opposing routine vpi_get_data() can pull data out of the save/restart location using different
sizes of chunks. This routine can only be called from an application routine that has been called for the
reason cbStartOfSave or cbEndOfSave. An application can get the path to the implementation’s save/
restart location by calling vpi_get_str(vpiSaveRestartLocation, NULL) from an application callback
routine that has been called for reason cbStartOfSave or cbEndOfSave.
The following example illustrates using vpi_put_data() and vpi_get_data():
#include <stdlib.h>
#include <assert.h>
#include "vpi_user.h"
typedef struct myStruct *myStruct_p;
typedef struct myStruct {
PLI_INT32 d1;
PLI_INT32 d2;
myStruct_p next;
} myStruct_s;
static myStruct_p firstWrk = NULL;
PLI_INT32 consumer_restart(p_cb_data data)
{
struct myStruct *wrk;
PLI_INT32 status;
PLI_INT32 cnt, size;
PLI_INT32 id = (PLI_INT32)data->user_data;
1084
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
/* Get the number of structures */
status = vpi_get_data(id,(PLI_BYTE8 *)&cnt,sizeof(PLI_INT32));
assert(status > 0); /* Check returned status */
/* allocate memory for the structures */
size = cnt * sizeof(struct myStruct);
firstWrk = (myStruct_p)malloc(size);
/* retrieve the data structures */
if (cnt != vpi_get_data(id, (PLI_BYTE8 *)firstWrk,cnt))
return(1); /* error */
firstWrk = wrk;
/* Fix the next pointers in the linked list */
for (wrk = firstWrk; cnt > 0; cnt--)
{
wrk->next = wrk + 1;
wrk = wrk->next;
}
wrk->next = NULL;
return(0); /* SUCCESS */
}
PLI_INT32 consumer_save(p_cb_data data)
{
myStruct_p wrk;
s_cb_data cbData;
vpiHandle cbHdl;
PLI_INT32 id = 0;
PLI_INT32 cnt = 0;
/* Get the number of structures */
wrk = firstWrk;
while (wrk)
{
cnt++;
wrk = wrk->next;
}
/* now save the data */
wrk = firstWrk;
id = vpi_get(vpiSaveRestartID, NULL);
/* save the number of data structures */
vpi_put_data(id,(PLI_BYTE8 *)cnt,sizeof(PLI_INT32));
/* Save the different data structures. Note that a pointer
* is being saved. While this is allowed, an application
* must change it to something useful on a restart.
*/
1085
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
while (wrk)
{
vpi_put_data(id,(PLI_BYTE8 *)wrk,sizeof(myStruct_s));
wrk = wrk->next;
}
/* register a call for restart */
/* We need the "id" so that the saved data can be retrieved.
* Using the user_data field of the callback structure is the
* easiest way to pass this information to retrieval operation.
*/
cbData.user_data = (PLI_BYTE8 *)id;
cbData.reason = cbStartOfRestart;
/* See 38.9 vpi_get_data() for a description of how
* the callback routine can be used to retrieve the data.
*/
cbData.cb_rtn = consumer_restart;
cbData.value = NULL;
cbData.time = NULL;
cbHdl = vpi_register_cb(&cbData);
vpi_release_handle(cbHdl);
return(0);
}
38.32 vpi_put_delays()
vpi_put_delays()
Synopsis: Set the delays or timing limits of an object.
Syntax:
vpi_put_delays(obj, delay_p)
Type Description
Returns: void
Type Name Description
Arguments: vpiHandle obj Handle to an object.
p_vpi_delay delay_p Pointer to a structure containing delay information.
Related Use vpi_get_delays() to retrieve delays or timing limits of an object.
routines:
The VPI routine vpi_put_delays() shall set the delays or timing limits of an object as indicated in the
delay_p structure. The same ordering of delays shall be used as described in the vpi_get_delays() function.
If only the delay changes and not the pulse limits, the pulse limits shall retain the values they had before the
delays where altered.
The and structures used by both vpi_get_delays() and vpi_put_delays() are
s_vpi_delay s_vpi_time
defined in and are listed in Figure38-11 and Figure38-12.
vpi_user.h
1086
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLr igGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reicgehmtsb erer s0e3,r2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
typedef struct t_vpi_delay
{
struct t_vpi_time *da; /* pointer to application-allocated
array of delay values*/
PLI_INT32 no_of_delays; /* number of delays */
PLI_INT32 time_type; /* [vpiScaledRealTime,vpiSimTime,
vpiSuppressTime]*/
PLI_INT32 mtm_flag; /* true for mtm values */
PLI_INT32 append_flag; /* true for append */
PLI_INT32 pulsere_flag; /* true for pulsere values */
} s_vpi_delay, *p_vpi_delay;
Figure38-11—s_vpi_delay structure definition
typedef struct t_vpi_time
{
PLI_INT32 type; /* [vpiScaledRealTime, vpiSimTime, vpiSuppressTime] */
PLI_UINT32 high, low; /* for vpiSimTime */
double real; /* for vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;
Figure38-12—s_vpi_time structure definition
The da field of the structure shall be an application-allocated array of
s_vpi_delay s_vpi_time
structures. This array stores the delay values to be written by vpi_put_delays(). The number of elements in
this array is determined by the following:
— The number of delays to be written
— The mtm_flag setting
— The pulsere_flag setting
The number of delays to be set shall be set in the no_of_delays field of the structure. Legal
s_vpi_delay
values for the number of delays shall be determined by the type of object, as follows:
— For primitive objects, the no_of_delays value shall be 2 or 3.
— For path delay objects, the no_of_delays value shall be 1, 2, 3, 6, or 12.
— For timing check objects, the no_of_delays value shall match the number of limits existing in the
timing check.
— For intermodule path objects, the no_of_delays value shall be 2 or 3.
The application-allocated array shall contain delays in the same order in which they occur in
s_vpi_delay
the SystemVerilog source description. The number of elements for each delay shall be determined by the
flags mtm_flag and pulsere_flag, as shown in Table38-4.
Table38-4—Size of the s_vpi_delay->da array
Number of
Order in which delay elements
Flag values array elements
s_vpi_time shall be filled
required for s_vpi_delay da
->
mtm_flag = no_of_delays
FALSE 1st delay: da[0] -> 1st delay
pulsere_flag = FALSE 2nd delay: da[1] -> 2nd delay
...
mtm_flag = 3  no_of_delays
TRUE 1st delay: da[0] -> min delay
pulsere_flag = FALSE da[1] -> typ delay
da[2] -> max delay
2nd delay: ...
1087
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table38-4—Size of the s_vpi_delay->da array (continued)
Number of
Order in which delay elements
Flag values array elements
s_vpi_time shall be filled
required for s_vpi_delay da
->
mtm_flag = 3  no_of_delays
FALSE 1st delay: da[0] -> delay
pulsere_flag = TRUE da[1] -> reject limit
da[2] -> error limit
2nd delay element: ...
mtm_flag = 9  no_of_delays
TRUE 1st delay: da[0] -> min delay
pulsere_flag = TRUE da[1] -> typ delay
da[2] -> max delay
da[3] -> min reject
da[4] -> typ reject
da[5] -> max reject
da[6] -> min error
da[7] -> typ error
da[8] -> max error
2nd delay: ...
The following example application accepts a module path handle, rise and fall delays, and replaces the
delays of the indicated path:
void set_path_rise_fall_delays(path, rise, fall)
vpiHandle path;
double rise, fall;
{
static s_vpi_time path_da[2];
static s_vpi_delay delay_s = {NULL, 2, vpiScaledRealTime};
static p_vpi_delay delay_p = &delay_s;
delay_s.da = path_da;
path_da[0].real = rise;
path_da[1].real = fall;
vpi_put_delays(path, delay_p);
}
1088
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.33 vpi_put_userdata()
vpi_put_userdata()
Synopsis: Put user-data value into an implementation’s system task or system function instance storage location.
Syntax:
vpi_put_userdata(obj, userdata)
Type Description
Returns: PLI_INT32 1 on success; 0 if an error occurs.
Type Name Description
Arguments: vpiHandle obj Handle to a system task instance or system function
instance.
void * userdata User-data value to be associated with the system task
instance or system function instance.
Related Use vpi_get_userdata() to retrieve the user-data value.
routines:
This routine will associate the value of the input userdata with the specified user-defined system task or
system function call handle. The stored value can later be retrieved with the routine vpi_get_userdata().
The routine will return a value of 1 on success or a 0 if it fails.
After a restart or a reset, subsequent calls to vpi_get_userdata() shall return NULL. It is the application’s
responsibility to save the data during a save using vpi_put_data() and to then retrieve it using
vpi_get_data(). The user-data field can be set up again during or after callbacks of type cbEndOfRestart or
cbEndOfReset.
38.34 vpi_put_value()
vpi_put_value()
Synopsis: Set a value on an object.
Syntax:
vpi_put_value(obj, value_p, time_p, flags)
Type Description
Returns: vpiHandle Handle to the scheduled event caused by vpi_put_value().
Type Name Description
Arguments: vpiHandle obj Handle to an object.
p_vpi_value value_p Pointer to a structure with value information.
p_vpi_time time_p Pointer to a structure with delay information.
PLI_INT32 flags Integer constants that set the delay mode.
Related Use vpi_get_value() to retrieve the value of an expression.
routines:
The VPI routine vpi_put_value() shall set simulation logic values on an object. The value to be set shall be
stored in an structure that has been allocated by the calling routine. Any storage referenced
s_vpi_value
1089
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
by the structure shall also be allocated by the calling routine. The legal values that may be
s_vpi_value
specified for each value format are listed in Table38-3 in 38.15. The delay time before the value is set shall
be stored in an structure that has been allocated by the calling routine. The routine can be
s_vpi_time
applied to nets, variables, variable selects, memory words, named events, system function calls, sequential
UDPs, and scheduled events. The flags argument shall be used to direct the routine to use one of the
following delay modes:
vpiInertialDelay All scheduled events on the object shall be removed before this event is
scheduled.
vpiTransportDelay All events on the object scheduled for times later than this event shall be
removed (modified transport delay).
vpiPureTransportDelay
No events on the object shall be removed (transport delay).
vpiNoDelay The object shall be set to the passed value with no delay. Argument time_p shall
be ignored and can be set to .
NULL
vpiForceFlag The object shall be forced to the passed value with no delay (same as the
SystemVerilog procedural force). Argument time_p shall be ignored and can be
set to .
NULL
vpiReleaseFlag The object shall be released from a forced value (same as the SystemVerilog
procedural release). Argument time_p shall be ignored and can be set to .
NULL
The value_p shall be updated with the value of the object after its release. If the
value is a string, time, vector, strength, or miscellaneous value, the data pointed
to by the value_p argument shall be owned by the interface.
vpiCancelEvent A previously scheduled event shall be cancelled. The object passed to
vpi_put_value() shall be a handle to an object of type vpiSchedEvent.
If the flags argument also has the bit mask vpiReturnEvent, vpi_put_value() shall return a handle of type
vpiSchedEvent to the newly scheduled event, provided there is some form of a delay and an event is
scheduled. If the bit mask is not used, or if no delay is used, or if an event is not scheduled, the return value
shall be .
NULL
A scheduled event can be cancelled by calling vpi_put_value() with obj set to the vpiSchedEvent handle
and flags set to vpiCancelEvent. The value_p and time_p arguments to vpi_put_value() are not needed for
cancelling an event and can be set to NULL. It shall not be an error to cancel an event that has already
occurred. The scheduled event can be tested by calling vpi_get() with the flag vpiScheduled. If an event is
cancelled, it shall simply be removed from the event queue. Any effects that were caused by scheduling the
event shall remain in effect (e.g., events that were cancelled due to inertial delay). Cancelling an event shall
also free the handle to that event.
Calling vpi_release_handle() on the handle shall free the handle, but shall not affect the event.
When vpi_put_value() is called for an object of type vpiNet or vpiNetBit, and with modes of
vpiInertialDelay, vpiTransportDelay, vpiPureTransportDelay, or vpiNoDelay, the value supplied
overrides the resolved value of the net. This value shall remain in effect until one of the drivers of the net
changes value. When this occurs, the net shall be reevaluated using the normal resolution algorithms.
It shall be illegal to specify the format of the value as vpiStringVal when putting a value to a real variable or
a system function call of type vpiRealFunc. It shall be illegal to specify the format of the value as
vpiStrengthVal when putting a value to a vector object.
When vpi_put_value() with a vpiForce flag is used, it shall perform a procedural force of a value onto the
same types of objects as supported by a procedural force. A vpiRelease flag shall release the forced value.
1090
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
This shall be the same functionality as the procedural and keywords in SystemVerilog (see
force release
10.6.2).
Sequential UDPs shall be set to the indicated value with no delay regardless of any delay on the primitive
instance. Putting values to UDP instances shall be done using the vpiNoDelay flag. Attempting to use the
other delay modes shall result in an error.
Calling vpi_put_value() on an object of type vpiNamedEvent shall cause the named event to toggle.
Objects of type vpiNamedEvent shall not require an actual value, and the value_p argument may be .
NULL
The vpi_put_value() routine shall also return the value of a system function by passing a handle to the user-
defined system function as the object handle. This should only occur during execution of the calltf routine
for the system function. Attempts to use vpi_put_value() with a handle to the system function when the
calltf routine is not active shall be ignored. Should the calltf routine for a user-defined system function fail to
put a value during its execution, the default value of 0 will be applied. Putting return values to system
functions shall be done using the vpiNoDelay flag.
The vpi_put_value() routine shall only return a system function value in a calltf application when the call to
the system function is active. The action of vpi_put_value() to a system function shall be ignored when the
system function is not active. Putting values to system function shall be done using the vpiNoDelay flag.
The and structures used by vpi_put_value() are defined in and
s_vpi_value s_vpi_time vpi_user.h
are listed in Figure38-13 and Figure38-14.
typedef struct t_vpi_value
{
PLI_INT32 format; /* vpi[[Bin,Oct,Dec,Hex]Str,Scalar,Int,Real,String,
Vector,Strength,Suppress,Time,ObjType]Val */
union
{
PLI_BYTE8 *str; /* string value */
PLI_INT32 scalar; /* vpi[0,1,X,Z] */
PLI_INT32 integer; /* integer value */
double real; /* real value */
struct t_vpi_time *time; /* time value */
struct t_vpi_vecval *vector; /* vector value */
struct t_vpi_strengthval *strength; /* strength value */
PLI_BYTE8 *misc; /* ...other */
} value;
} s_vpi_value, *p_vpi_value;
Figure38-13—s_vpi_value structure definition
typedef struct t_vpi_time
{
PLI_INT32 type; /* [vpiScaledRealTime, vpiSimTime, vpiSuppressTime] */
PLI_UINT32 high, low; /* for vpiSimTime */
double real; /* for vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;
Figure38-14—s_vpi_time structure definition
The and structures found in Figure38-13 are listed in Figure38-15
s_vpi_vecval s_vpi_strengthval
and Figure38-16.
1091
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
typedef struct t_vpi_vecval
{
/* following fields are repeated enough times to contain vector */
PLI_UINT32 aval, bval; /* bit encoding: ab: 00=0, 10=1, 11=X, 01=Z */
} s_vpi_vecval, *p_vpi_vecval;
Figure38-15—s_vpi_vecval structure definition
typedef struct t_vpi_strengthval
{
PLI_INT32 logic; /* vpi[0,1,X,Z] */
PLI_INT32 s0, s1; /* refer to strength coding in Annex K */
} s_vpi_strengthval, *p_vpi_strengthval;
Figure38-16—s_vpi_strengthval structure definition
For vpiScaledRealTime, the indicated time shall be in the timescale associated with the object.
38.35 vpi_put_value_array()
vpi_put_value_array()
Synopsis: Set values for contiguous elements of a static unpacked array object.
Syntax:
vpi_put_value_array(obj, arrayvalue_p, index_p, num)
Type Description
Returns: void
Type Name Description
Arguments: vpiHandle obj Handle to an unpacked array object.
p_vpi_arrayvalue arrayvalue_p Pointer to a structure containing array value information.
PLI_INT32 * index_p Pointer to an array of index values corresponding to the
start of the section of the object to be updated.
PLI_UINT32 num Number of array elements to be updated.
Related Use vpi_get_value_array() to retrieve values of contiguous elements of a static unpacked array object.
routines:
The VPI routine vpi_put_value_array() shall modify simulation values of contiguous elements in static
unpacked variable or net arrays (array objects for which the vpiArrayType property is vpiStaticArray).
Such arrays must also have static lifetimes and not contain dynamic arrays or dynamic elements (e.g., string
vars). For purposes here, the term element corresponds to any indexable member of such an array with all
unpacked indices fully specified. The data type of each element so defined corresponds to the data type of
the array with all unpacked ranges removed. The elements of arrays are not allowed to be of an unpacked
type themselves (e.g., unpacked structs).
The values to be set for the array shall be placed in an structure allocated by the
s_vpi_arrayvalue
calling routine. Any storage referenced by the structure shall also be allocated by the
s_vpi_arrayvalue
calling routine. The structure is defined in , as follows:
s_vpi_arrayvalue vpi_user.h
1092
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
typedef struct t_vpi_arrayvalue
{
PLI_UINT32 format;
PLI_UINT32 flags;
union
{
PLI_INT32 *integers;
PLI_INT16 *shortints;
PLI_INT64 *longints;
PLI_BYTE8 *rawvals;
struct t_vpi_vecval *vectors;
struct t_vpi_time *times;
double *reals;
float *shortreals;
} value;
} s_vpi_arrayvalue, *p_vpi_arrayvalue;
The layout of the values to be set shall be specified by the calling routine by setting the format field in the
structure. In addition to the format types vpiIntVal, vpiVectorVal, vpiTimeVal, and vpiRealVal available
with vpi_get_value() function (Table38-3 in 38.15), the following format types can be used:
vpiRawFourStateVal
Values to be set for each element must be specified in aval/bval format (similar
to 4-state vectors) using the field of the union above, interleaved
*rawvals
according to the following structure:
struct
{
PLI_BYTE8 avalbits[ngroups];
PLI_BYTE8 bvalbits[ngroups];
}
Each array element occupies bytes stored consecutively as A/B byte
ngroups*2
groups as shown above. For the first indexed array element, the must
avalbits
begin at , and the must be at ,
rawvals[0] bvalbits rawvals[ngroups]
respectively. The second array element’s must begin at
avalbits
, and its at , etc.
rawvals[ngroups*2] bvalbits rawvals[ngroups*3]
is computed given the array element size in bits ( ) as
ngroups = elemBits
follows:
int ngroups = (elemBits + 7) / 8;
The total storage required to hold “num” array elements shall be
.
ngroups * num * 2
vpiRawTwoStateVal Values to be set shall be provided similarly to vpiRawFourStateVal above (also
using the struct member), except that the byte group shall
*rawvals bvalbits
be omitted. shall be computed similarly also, but the total storage used
ngroups
shall instead be .
ngroups * num
vpiShortIntVal Values to be set will be provided as an array of “num” short(s), using the
field in the union in this case. This format is appropriate only for
*shortints
arrays of vpiShortIntVar, vpiIntVar, or vpiLongIntVar elements.
vpiLongIntVal Values to be set will be stored as an array of “num” long(s), using the
field in the union in this case. This format is appropriate for arrays
*longints
of vpiLongIntVar elements.
vpiShortRealVal Values to be set will be stored as an array of “num” floats, using the
field in the union in this case. This format is appropriate only
*shortrealvals
for arrays of vpiShortRealVar elements.
1093
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The format types vpiIntVal, vpiTimeVal, vpiVectorVal, and vpiRealVal that are also available with the
vpi_put_value() function correspond to similar union member names in (converted to
s_vpi_arrayvalue
pointer values and ending in “ ” to indicate they are arrays). For example, selecting the vpiIntVal format
s
shall cause an array of 32-bit integer values (set using the field) to be loaded into the specified
*integers
section of the array object. The vpiVectorVal format shall assume that an array of consecutive A/B word
groups formatted according to the structure (Figure38-8 in 38.15) is to be loaded. The
t_vpi_vecval
field should be used to provide these values. Given the array element size in bits (
*vectors ==
), the number of words of storage to provide data for elements will be:
elemBits num
((elemBits + 31) / 32) * 2 * num
All other formats not mentioned here are unsupported and shall result in an error if specified. The
vpiRawFourStateVal format is appropriate for all 4-state array types (all net arrays, or variable arrays of
vpiLogicVar, vpiIntegerVar, vpiTimeVar, or 4-state packed vpiStructVar or vpiUnionVar elements).
The vpiRawTwoStateVal format is appropriate for all 2-state array types (variable arrays of vpiBitVar,
vpiByteVar, vpiShortInt, vpiInt, vpiLongInt, or 2-state packed vpiStructVar or vpiUnionVar elements).
If the vpiRawFourStateVal format is set for a 2-state array type, the shall be ignored. If the
bvalbits
vpiRawTwoStateVal format is specified for a 4-state array type, the shall be assumed to be 0.
bvalbits
The bit values in each array element, whether fixed or variable width, correspond to significance order in
and . That is, the LSB of and indicates the A and
avalbits bvalbits rawvals[0] rawvals[ngroups]
B value of the LSB (0th) bit of the first array element, respectively, and the LSB of and
rawvals[1]
indicates the A and B value of bit 8 of the first array element (if it is of width 9 bits
rawvals[ngroups+1]
or greater), and so on.
The argument is an array containing the indices of the starting element of the array object to be
index_p
retrieved. The indices are ordered in this array according to left-to-right order they would appear in an
expression in HDL text. The size of the index array shall be equal to the number of unpacked
index_p
dimensions of , the array object.
obj
The array element values will be set consecutively in order of the fastest varying index (rightmost unpacked
range of the array declaration), followed by more slowly varying indices accordingly until the number of
elements ( ) has been loaded. Index values within each range are ordered from leftmost range value to
num
rightmost. For example, elements of an with and
array a[2:0][3:5] index_p[0] = 1
would be set in the order , , , , ,
index_p[1] = 4 a[1][4] a[1][5] a[0][3] a[0][4] a[0][5]
respectively.
The field allows the following values to be set to control vpi_put_value_array() behavior:
flags
vpiPropagateOff This flag inhibits notification of the fanouts of the array that one or more values
have changed. This reduces the performance impact of updating large numbers of
array elements. If this is used during active simulation, it may require that at least
one subsequent update event occurs for the array in order to achieve correct
simulation results.
vpiOneValue This flag set causes the function to apply only a single element value to the entire
array section specified. Data for only one element need be provided in the
structure.
s_vpi_arrayvalue
The vpi_put_value_array() function does not allow the delay and event scheduling modes available in the
vpi_put_value() function (38.34). Its behavior is consistent with the vpiNoDelay mode specified there.
Flags other than vpiPropagateOff, vpiOneValue, or vpiNoDelay (the default) specified shall be an error.
When the vpi_put_value_array() function is called for an object of type vpiArrayNet, the values supplied
override the resolved values of the array net elements specified. These values shall remain in effect for each
1094
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
net element until one of the drivers of that element changes. When this occurs, the state of the net elements
shall be reevaluated according to the normal net resolution algorithms.
The following code shows an example of loading 5 elements of array using the vpiRawFourStateVal
a
format. It takes 6 bytes of avalbits and 6 bytes of bvalbits to specify the 42-bit values for each element,
totaling 60 bytes for 5 elements. The argument is set to start the loading at .
index_p a[1][4]
/* Load 5 values into array "logic [41:0] a[2:0][3:5]":
* 1) 00000000000000000000000000000000000000000001
* 2) 00000000000000000000000000000000000100000001
* 3) 00000000000000000000000000010000000100000001
* 4) 00000000000000000001000000010000000100000001
* 5) 000000000001000000010000000100000001xxxxxxxx
* starting at "a[1][4]", given "arrH", a vpiHandle for "a". */
int indexArr[2];
PLI_BYTE8 *valueBuffer; /* Retain local ptr to mem allocated */
s_vpi_arrayvalue arrayVal = { 0, 0, NULL };
vpiHandle elemHdl, elemIter;
int elemWidth, ngroups, offset, bufsiz, elemInd;
int num = 5;
/* Get array element so we can get size to determine ngroups */
elemIter = vpi_iterate(vpiReg, arrH);
elemHdl = vpi_scan(elemIter);
elemWidth = vpi_get(vpiSize, elemHdl);
ngroups = (elemWidth + 7) / 8;
vpi_release_handle(elemIter);
arrayVal.format = vpiRawFourStateVal;
arrayVal.flags |= vpiPropagateOff; /* Disable value prop. */
/* Allocate storage and format the values. */
bufsiz = ngroups * 2 * num; /* Storage total for all values */
valueBuffer = (PLI_BYTE8 *) malloc(bufsiz);
arrayVal.value.rawvals = valueBuffer;
indexArr[0] = 1;
indexArr[1] = 4;
/* Set up the 5 values in valueBuffer */
offset = 0;
memset(valueBuffer, 0, bufsiz); /* Initialize value buffer */
for (elemInd = 1; elemInd <= num; elemInd++) {
for (int i = 0; i < elemInd; i++) {
valueBuffer[offset + i] = 1; /* Set LSB of Abits this byte */
}
offset += (ngroups * 2); /* Skip to beginning of next element */
}
/* Set final abits and bbits for final element 'x' values. */
offset -= (ngroups * 2); /* Back to beginning of last element */
valueBuffer[offset] = 0xff; /* Set avalbits to 1's */
valueBuffer[offset + ngroups] = 0xff; /* Set bvalbits to 1's */
/* Load values into "a" with propagation disabled. */
vpi_put_value_array(arrH, &arrayVal, indexArr, num);
free(valueBuffer);
1095
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.36 vpi_register_cb()
vpi_register_cb()
Synopsis: Register simulation-related callbacks.
Syntax:
vpi_register_cb(cb_data_p)
Type Description
Returns: vpiHandle Handle to the callback object.
Type Name Description
Arguments: p_cb_data cb_data_p Pointer to a structure with data about when callbacks
should occur and the data to be passed.
Related Use vpi_register_systf() to register callbacks for user-defined system tasks and system functions.
routines: Use vpi_remove_cb() to remove callbacks registered with vpi_register_cb().
The VPI routine vpi_register_cb() is used for registration of simulation-related callbacks to a user-provided
application for a variety of reasons during a simulation. The reasons for which a callback can occur are
divided into the following three categories:
— Simulation event
— Simulation time
— Simulation action or feature
How callbacks are registered for each of these categories is explained in this subclause.
The cb_data_p argument shall point to a structure, which is defined in and given
s_cb_data vpi_user.h
in Figure38-17.
typedef struct t_cb_data
{
PLI_INT32 reason; /* callback reason */
PLI_INT32 (*cb_rtn)(struct t_cb_data *); /* call routine */
vpiHandle obj; /* trigger object */
p_vpi_time time; /* callback time */
p_vpi_value value; /* trigger object value */
PLI_INT32 index; /* index of the memory word or var select
that changed */
PLI_BYTE8 *user_data;
} s_cb_data, *p_cb_data;
Figure38-17—s_cb_data structure definition
For all callbacks, the reason field of the structure shall be set to a predefined constant, e.g.,
s_cb_data
cbValueChange, cbAtStartOfSimTime, cbEndOfCompile. The reason constant shall determine when the
application shall be called back. See the file listing in AnnexK and file in
vpi_user.h sv_vpi_user.h
AnnexM for a list of all callback reason constants.
The cb_rtn field of the structure shall be set to the application routine, which shall be invoked
s_cb_data
when the simulator executes the callback. The uses of the remaining fields are detailed in 38.36.1 through
38.36.3.
1096
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The callback routine shall be passed a pointer to an structure. This structure and all structures to
s_cb_data
which it points belong to the simulator. If the application needs any of these data, it must copy the data prior
to returning from the callback routine.
38.36.1 Simulation event callbacks
The vpi_register_cb() callback mechanism can be registered for callbacks to occur for simulation events,
such as value changes on certain objects, lifetime of dynamic data, and execution of a behavioral statement,
function call, or thread. When the cb_data_p->reason field is set to one of the following, the callback shall
occur as follows:
cbValueChange After value change on some variables, any expression, or terminal or after
execution of an event statement. Specifically excluded are class objects, dynamic
arrays, strings, queues, and associative arrays.
cbStmt Before execution of a behavioral statement.
cbForce/cbRelease After a force or release has occurred.
cbAssign/cbDeassign After a procedural assign or deassign statement has been executed.
cbDisable After a named block or task containing a system task or system function has been
disabled.
cbCreateObj After the class constructor call has completed and the internal state of a class
object has been initialized, or for shallow copy, after the copy operation has
completed.
cbReclaimObj Before the class object has been reclaimed by the automatic memory
management, when it has been marked as no longer being used. When control is
returned from this callback, any handles to this class object, its properties or their
subelements, and any associated callbacks should be considered invalid.
cbSizeChange After a dynamic array, associative array, queue, or string has been resized.
cbStartOfFrame Triggers when a frame is activated, i.e., when the associated task or function
begins execution. The frame’s automatic variables have been created and
initialized.
cbEndOfFrame Triggers when a frame’s associated task or function completes execution and
indicates that the frame is about to end. When control is returned from this
callback, any handles to this frame, its automatic variables, or their subelements
should be considered invalid.
cbStartOfThread Triggers whenever any thread is created.
cbEndOfThread Triggers when a particular thread gets deleted. All frames activated with this
thread will have already ended. Any outdated references made by the thread are
subject to deletion. When control is returned from this callback, any handles to
this thread, its out-of-scope references, or their subelements should be considered
invalid.
cbEnterThread Triggers whenever a particular thread resumes execution.
cbEndOfObject Triggers when a particular transient object is going to be deleted as a result of a
simulation event. Depending on the nature of the object, the semantics are
equivalent to cbReclaimObj, cbEndOfFrame, or cbEndOfThread, as
appropriate. In particular, when control is returned from this callback, any
handles to this object or its subelements should be considered invalid.
The following fields shall need to be initialized before passing the structure to
s_cb_data
vpi_register_cb():
cb_data_p->obj This field shall be assigned a handle to an appropriate object, including class
typespec, frame, thread, variable including a class property, expression, terminal,
1097
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
or statement for which the callback shall occur. For cbCreateObj, this field shall
be assigned a handle to a class typespec object. For a cbReclaimObj, this field
shall be assigned either a handle to a class typespec or a class obj. With a class
typespec, any class object of that type shall generate a callback. For force and
release callbacks, if this is set to , every force and release shall generate a
NULL
callback.
cb_data_p->time->type
This field shall be set to either vpiScaledRealTime or vpiSimTime, depending
on what time information the application requires during the callback. If
simulation time information is not needed during the callback, this field can be
set to vpiSuppressTime. For cbReclaimObj and cbEndOfObject, time
information is not passed to the callback routine; therefore, this field shall be
ignored.
cb_data_p->value->format
This field shall be set to one of the value formats indicated in Table38-5. If value
information is not needed during the callback, this field can be set to
vpiSuppressVal. For cbStmt callbacks, value information is not passed to the
callback routine; therefore, this field shall be ignored.
Table38-5—Value format field of cb_data_p->value->format
Format Registers a callback to return
vpiBinStrVal String of binary character(s) [1, 0, x, z]
vpiOctStrVal String of octal character(s) [0–7, x, X, z, Z]
vpiDecStrVal String of decimal character(s) [0–9]
vpiHexStrVal String of hex character(s) [0–f, x, X, z, Z]
vpiScalarVal vpi1, vpi0, vpiX, vpiZ, vpiH, vpiL
vpiIntVal Integer value of the handle
vpiRealVal Value of the handle as a double
vpiStringVal An ASCII string
vpiTimeVal Integer value of the handle using two integers
vpiVectorVal aval/bval representation of the value of the object
vpiStrengthVal Value plus strength information of a scalar object only
vpiObjTypeVal Return a value in the closest format of the object
When a simulation event callback occurs, the application shall be passed a single argument, which is a
pointer to an structure (this is not a pointer to the same structure that was passed to
s_cb_data
vpi_register_cb()). The time and value information shall be set as directed by the time type and value
format fields in the call to vpi_register_cb(). The user_data field shall be equivalent to the user_data field
passed to vpi_register_cb(). The application can use the information in the passed structure and information
retrieved from other VPI routines to perform the desired callback processing.
cbValueChange callbacks can be placed onto event statements. When the event statement is executed, the
callback routine will be called. Because event statements do not have a value, when the callback routine is
called, the value field of the structure will be .
s_cb_data NULL
1098
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For a cbValueChange callback, if the obj has the vpiArrayMember property set to , the value in the
TRUE
structure shall be the value of the array member that changed value. The index field shall
s_cb_data
contain the index of the rightmost range of the array declaration. Use vpi_iterate(vpiIndex,obj) to find all
the indices.
The cbValueChange callback may be placed on a class var and will be called when its value changes, which
indicates that it is referring to a new dynamic object (including a newly constructed one) or no object. Its
value is opaque and cannot be obtained, and the value field of structure will be NULL. Its
s_cb_data
vpiObjId property uniquely identifies what dynamic object, if any, a class var refers to.
If a cbValueChange callback is registered and the format is set to vpiStrengthVal, then the callback shall
occur whenever the object changes strength, including changes that do not result in a value change.
For a cbReclaimObj callback, there is no relationship to simulation time defined when automatic memory
management may occur. The time field of the structure will be NULL. The object field will
s_cb_data
contain a valid handle to the class obj that is about to be reclaimed. The purpose of this callback is to allow
applications to clean up their data structures. All VPI properties of the class obj are accessible. Using this
handle as a reference for purposes of navigation or registering callbacks is undefined.
For cbForce, cbRelease, cbAssign, and cbDeassign callbacks, the object returned in the obj field shall be a
handle to the force, release, assign, or deassign statement. The value field shall contain the resultant value of
the left-hand expression. In the case of a release, the value field shall contain the value after the release has
occurred.
For a cbDisable callback, obj shall be a handle to a system task call, system function call, named begin,
named fork, task, or function.
It is illegal to attempt to place a callback for reason cbForce, cbRelease, or cbDisable on a variable
bit-select.
The following example shows an implementation of a simple monitor functionality for scalar nets, using a
simulation event callback:
setup_monitor(net)
vpiHandle net;
{
static s_vpi_time time_s = {vpiSimTime};
static s_vpi_value value_s = {vpiBinStrVal};
static s_cb_data cb_data_s =
{cbValueChange, my_monitor, NULL, &time_s, &value_s};
PLI_BYTE8 *net_name = vpi_get_str(vpiFullName, net);
cb_data_s.obj = net;
cb_data_s.user_data = malloc(strlen(net_name)+1);
strcpy(cb_data_s.user_data, net_name);
vpi_register_cb(&cb_data_s);
}
my_monitor(cb_data_p)
p_cb_data cb_data_p; {
vpi_printf("%d %d: %s = %s\n",
cb_data_p->time->high, cb_data_p->time->low,
cb_data_p->user_data,
cb_data_p->value->value.str);
}
1099
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.36.1.1 Callbacks on individual statements
When cbStmt is used in the reason field of the structure, the other fields in the structure will be
s_cb_data
defined as follows:
cb_data_p->cb_rtn The function to call before the given statement executes.
cb_data_p->obj A handle to the statement on which to place the callback (the allowable objects
are listed in Table38-6).
cb_data_p->time A pointer to an structure, in which only the type is used, to
s_vpi_time
indicate the type of time that will be returned when the callback is made. This
type can be vpiScaledRealTime, vpiSimTime, or vpiSuppressTime if no time
information is needed by the callback routine.
cb_data_p->value Not used.
cb_data_p->index Not used.
cb_data_p->user_data Data to be passed to the callback function.
Just before the indicated statement executes, the indicated function will be called with a pointer to a new
structure, which will contain the following information:
s_cb_data
cb_data_p->reason cbStmt.
cb_data_p->cb_rtn The same value as passed to vpi_register_cb().
cb_data_p->obj A handle to the statement which is about to execute.
cb_data_p->time A pointer to an structure, which will contain the current
s_vpi_time
simulation time, of the type (vpiScaledRealTime or vpiSimTime) indicated in
the call to vpi_register_cb(). If the value in the call to vpi_register_cb() was
vpiSuppressTime, then the time pointer in the structure will be set
s_cb_data
to NULL.
cb_data_p->value Always NULL.
cb_data_p->index Always set to 0.
cb_data_p->user_data The value passed in as user_data in the call to vpi_register_cb().
Multiple calls to vpi_register_cb() with the same data shall result in multiple callbacks.
Placing callbacks on statements that reside in protected portions of the code shall not be allowed and shall
cause vpi_register_cb() to return a NULL with an appropriate error message printed.
38.36.1.2 Behavior by statement type
Every possible object within the stmt class qualifies for having a cbStmt callback placed on it. Each
possible object is listed in Table38-6, for further clarification.
Table38-6—cbStmt callbacks
Object Description
vpiBegin One callback will occur prior to any of the statements within the block
vpiNamedBegin executing. The handle returned in the obj field will be the handle to the block
vpiFork object.
vpiNamedFork
vpiIf The callback will occur before the condition expression in the if statement is
vpiIfElse evaluated.
vpiWhile A callback will occur prior to the evaluation of the condition expression on
every iteration of the loop.
1100
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table38-6—cbStmt callbacks (continued)
Object Description
vpiRepeat A callback will occur when the repeat statement is first encountered and on
every subsequent iteration of the repeat loop.
vpiFor A callback will occur prior to any of the control expressions being evaluated.
Then on every iteration of the loop, a callback will occur prior to the evaluation
of the incremental statement.
vpiForever A callback will occur when the forever statement is first encountered and on
every subsequent iteration of the forever loop.
vpiWait The callback will occur before the statement executes.
vpiCase
vpiAssignment
vpiAssignStmt
vpiDeassign
vpiDisable
vpiForce
vpiRelease
vpiEventStmt
vpiDelayControl The callback will occur when the delay control is encountered, before the delay
occurs.
vpiEventControl The callback will occur when the event control is encountered, before the event
has occurred.
vpiTaskCall The callback will occur before the given task is executed.
vpiSysTaskCall
38.36.1.3 Registering callbacks on module-wide basis
vpi_register_cb() allows a handle to a module instance in the obj field of the structure. When
s_cb_data
this is done, the effect will be to place a callback on every statement that can have a callback placed on it.
When using vpi_register_cb() on a module object, the call will return a handle to a single callback object
that can be passed to vpi_remove_cb() to remove the callback on every statement in the module instance.
Statements that reside in protected portions of the code shall not have callbacks placed on them.
38.36.2 Simulation time callbacks
The vpi_register_cb() can register callbacks to occur for simulation time reasons, including callbacks at the
beginning or end of the execution of a particular time queue. The following time-related callback reasons are
defined:
cbAtStartOfSimTimeCallback shall occur before execution of events in a specified time queue. A
callback can be set for any time, even if no event is present.
cbNBASynch Callback shall occur immediately before the nonblocking assignment events are
processed.
cbReadWriteSynch Callback shall occur after execution of events for a specified time. This time
may be before or after nonblocking assignment events have been processed.
cbAtEndOfSimTime Callback shall occur after execution of nonblocking events, but before entering
the read-only phase of the time slice.
cbReadOnlySynch Callback shall occur the same as for cbReadWriteSynch, except that writing
values or scheduling events before the next scheduled event is not allowed.
1101
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
cbNextSimTime Callback shall occur before execution of events in the next event queue.
cbAfterDelay Callback shall occur after a specified amount of time, before execution of events
in a specified time queue. A callback can be set for any time, even if no event is
present.
For reason cbNextSimTime, the time field in the time structure is ignored. The following fields shall need
to be set before passing the structure to vpi_register_cb():
s_cb_data
cb_data_p->time->type
This field shall be set to either vpiScaledRealTime or vpiSimTime, depending
on what time information the application requires during the callback.
vpiSuppressTime (or for the field) will result in an
NULL cb_data_p->time
error.
cb_data_p->[time->low,time->high,time->real]
These fields shall contain the requested time of the callback or the delay before
the callback.
The following situations will generate an error, and no callback will be created:
— Attempting to place a cbAtStartOfSimTime callback with a delay of zero when simulation has
progressed into a time slice and the application is not currently within a cbAtStartOfSimTime
callback.
— Attempting to place a cbReadWriteSynch callback with a delay of zero at read-only synch time.
Placing a callback for cbAtStartOfSimTime and a delay of zero during a callback for reason
cbAtStartOfSimTime will result in another cbAtStartOfSimTime callback occurring during the same
time slice.
The value fields are ignored for all reasons with simulation time callbacks.
When the cb_data_p->time->type is set to vpiScaledRealTime, the cb_data_p->obj field shall be used as
the object for determining the time scaling.
When a simulation time callback occurs, the application callback routine shall be passed a single argument,
which is a pointer to an structure [this is not a pointer to the same structure that was passed to
s_cb_data
vpi_register_cb()]. The time structure shall contain the current simulation time. The user_data field shall be
equivalent to the user_data field passed to vpi_register_cb().
The callback application can use the information in the passed structure and information retrieved from
other interface routines to perform the desired callback processing.
38.36.3 Simulator action or feature callbacks
The vpi_register_cb() routine can register callbacks to occur for simulator action reasons or simulator
feature reasons. Simulator action reasons are callbacks such as the end of compilation or end of simulation.
Simulator feature reasons are tool-specific features, such as restarting from a saved simulation state or
entering an interactive mode. Actions are differentiated from features in that actions shall occur in all
VPI-compliant tools, whereas features might not exist in all VPI-compliant tools.
The following action-related callbacks shall be defined:
cbEndOfCompile End of simulation data structure compilation or build
cbStartOfSimulationStart of simulation (beginning of time zero simulation cycle)
cbEndOfSimulation End of simulation (simulation ended because no more events remain in the event
queue or a system task executed)
$finish
1102
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
cbError Simulation run-time error occurred
cbPLIError Simulation run-time error occurred in a PLI function call
cbTchkViolation Timing check error occurred
cbSignal A signal occurred
Examples of possible feature-related callbacks are as follows:
cbStartOfSave Simulation save state command invoked
cbEndOfSave Simulation save state command completed
cbStartOfRestart Simulation restart from saved state command invoked
cbEndOfRestart Simulation restart command completed
cbStartOfReset Start of reset operation as defined by $reset system task
cbEndOfReset End of reset operation as defined by $reset system task.
cbEnterInteractive Simulation entering interactive debug mode (e.g., system task executed)
$stop
cbExitInteractive Simulation exiting interactive mode
cbInteractiveScopeChange
Simulation command to change interactive scope executed
cbUnresolvedSystf Unknown user-defined system task or system function encountered
The only fields in the structure that shall need to be set up for simulation action or feature
s_cb_data
callbacks are the reason, cb_rtn, and user_data (if desired) fields.
vpi_register_cb() can be used to set up a signal handler. To do this, set the reason field to cbSignal, and set
the index field to one of the legal signals specified by the operating system. When this signal occurs, the
simulator will trap the signal, proceed to a safe point (if possible), and then call the callback routine.
When a simulation action or feature callback occurs, the application routine shall be passed a pointer to an
structure. The reason field shall contain the reason for the callback. For cbTchkViolation
s_cb_data
callbacks, the obj field shall be a handle to the timing check. For cbInteractiveScopeChange, obj shall be a
handle to the new scope. For cbUnresolvedSystf, user_data shall point to the name of the unresolved task
or system function. On a cbError callback, the routine vpi_chk_error() can be called to retrieve error
information.
The cbStartOfReset callback shall occur at the start of the system task (see D.8), before the
$reset
simulation time has been reset to 0. The cbEndOfReset callback shall occur after all the activities of the
system task have been completed, and in particular after has reset the simulation time to
$reset $reset
0and has restored the initial values of all variables and nets, but before the tool begins to execute the first
procedural statements in all and always procedures. Both callbacks shall occur whether the
initial
task has been invoked directly or whether it has been invoked indirectly through a call to
$reset
vpi_control(vpiReset, ...).
When an implementation restarts, the only VPI callbacks that shall exist are those for cbStartOfRestart and
cbEndOfRestart.
NOTE—When an application registers for these two callbacks, the user_data field should not be a pointer into memory.
The reason for this is that the executable used to restart an implementation may not be the exact same one used to save
the implementation state. A typical use of the user_data field for these two callbacks would be to store the identifier
returned from a call to vpi_put_data().
With the exception of cbStartOfRestart and cbEndOfRestart callbacks, when a restart occurs all
registered callbacks shall be removed.
1103
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The following example shows a callback application that reports CPU usage at the end of a simulation. If the
application routine is placed in the list, it shall be
setup_report_cpu() vlog_startup_routines
called just after the simulator is invoked.
static PLI_INT32 initial_cputime_g;
void report_cpu()
{
PLI_INT32 total = get_current_cputime() - initial_cputime_g;
vpi_printf("Simulation complete. CPU time used: %d\n", total);
}
void setup_report_cpu()
{
static s_cb_data cb_data_s = {cbEndOfSimulation, report_cpu};
initial_cputime_g = get_current_cputime();
vpi_register_cb(&cb_data_s);
}
38.37 vpi_register_systf()
vpi_register_systf()
Synopsis: Register user-defined system task or system function callbacks.
Syntax:
vpi_register_systf(systf_data_p)
Type Description
Returns: vpiHandle Handle to the callback object.
Type Name Description
Arguments: p_vpi_systf_data systf_data_p Pointer to a structure with data about when callbacks
should occur and the data to be passed.
Related Use vpi_register_cb() to register callbacks for simulation events.
routines:
The VPI routine vpi_register_systf() shall register callbacks for user-defined system tasks or functions.
Callbacks can be registered to occur when a user-defined system task or system function is encountered
during compilation or execution of SystemVerilog source code.
The systf_data_p argument shall point to a structure, which is defined in
s_vpi_systf_data vpi_user.h
and listed in Figure38-18.
1104
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
typedef struct t_vpi_systf_data
{
PLI_INT32 type; /* vpiSysTask, vpiSysFunc */
PLI_INT32 sysfunctype; /* vpiSysTask, vpi[Int,Real,Time,Sized,
SizedSigned]Func */
PLI_BYTE8 *tfname; /* first character must be '$' */
PLI_INT32 (*calltf)(PLI_BYTE8 *);
PLI_INT32 (*compiletf)(PLI_BYTE8 *);
PLI_INT32 (*sizetf)(PLI_BYTE8 *); /* for sized function
callbacks only */
PLI_BYTE8 *user_data;
} s_vpi_systf_data, *p_vpi_systf_data;
Figure38-18—s_vpi_systf_data structure definition
38.37.1 System task and system function callbacks
User-defined SystemVerilog system tasks and system functions that use VPI routines can be registered with
vpi_register_systf(). The following system task and system function callbacks are defined:
The type field of the structure shall register the application to be a system task or a
s_vpi_systf_data
system function. The type field value shall be an integer constant of vpiSysTask or vpiSysFunc.
The sysfunctype field of the structure shall define the type of value that a system
s_vpi_systf_data
function shall return. The sysfunctype field shall be an integer constant of vpiIntFunc, vpiRealFunc,
vpiTimeFunc, vpiSizedFunc, or vpiSizedSignedFunc. This field shall only be used when the type field is
set to vpiSysFunc.
tfname is a character string containing the name of the system task or system function as it will be used in
SystemVerilog source code. The name shall begin with a dollar sign ($) and shall be followed by one or
more ASCII characters that are legal in SystemVerilog simple identifiers. These are the characters A
through Z, a through z, 0 through 9, underscore (_), and the dollar sign ($). The maximum name length shall
be the same as for SystemVerilog identifiers.
The compiletf, calltf, and sizetf fields of the structure shall be pointers to the user-
s_vpi_systf_data
provided applications that are to be invoked by the system task or system function callback mechanism. One
or more of the compiletf, calltf, and sizetf fields can be set to NULL if they are not needed. Callbacks to the
applications pointed to by the compiletf and sizetf fields shall occur when the simulation data structure is
compiled or built (or for the first invocation if the system task or system function is invoked from an
interactive mode). Callbacks to the application pointed to by the calltf routine shall occur each time the
system task or system function is invoked during simulation execution.
The sizetf application shall only be called if the PLI application type is vpiSysFunc and the sysfunctype is
vpiSizedFunc or vpiSizedSignedFunc. If no sizetf is provided, a user-defined system function of type
vpiSizedFunc or vpiSizedSignedFunc shall return 32 bits.
The contents of the user_data field of the structure shall be the only argument passed
s_vpi_systf_data
to the compiletf, sizetf, and calltf routines when they are called. This argument shall be of the type
“ ”.
PLI_BYTE8 *
The following two examples illustrate allocating and filling in the structure and
s_vpi_systf_data
calling the vpi_register_systf() function. These examples show two different C programming methods of
filling in the structure fields. A third method is shown in 38.37.3.
1105
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
/*
* VPI registration data for a $list_nets system task
*/
void listnets_register()
{
s_vpi_systf_data tf_data;
tf_data.type = vpiSysTask;
tf_data.tfname = "$list_nets";
tf_data.calltf = ListCall;
tf_data.compiletf = ListCheck;
vpi_register_systf(&tf_data);
}
/*
* VPI registration data for a $my_random system function
*/
void my_random_init()
{
s_vpi_systf_data func_data;
p_vpi_systf_data func_data_p = &func_data;
PLI_BYTE8 *my_workarea;
my_workarea = malloc(256);
func_data_p->type = vpiSysFunc;
func_data_p->sysfunctype= vpiSizedFunc;
func_data_p->tfname = "$my_random";
func_data_p->calltf = my_random;
func_data_p->compiletf = my_random_compiletf;
func_data_p->sizetf = my_random_sizetf;
func_data_p->user_data = my_workarea;
vpi_register_systf(func_data_p);
}
38.37.2 Initializing VPI system task or system function callbacks
A means of initializing system task and system function callbacks and performing any other desired task just
after the simulator is invoked shall be provided by placing routines in a -terminated static array,
NULL
. A Cfunction using the array definition shall be provided as follows:
vlog_startup_routines
void (*vlog_startup_routines[]) ();
This C function shall be provided with a VPI-compliant tool. Entries in the array shall be added by the user.
The location of vlog_startup_routines and the procedure for linking with a
vlog_startup_routines
tool shall be defined by the tool vendor.
NOTE—Callbacks can also be registered or removed at any time during an application routine, not just at start-up time.
This array of C functions shall be for registering system tasks and system functions. User-defined system
tasks and system functions that appear in a compiled description shall generally be registered by a routine in
this array.
The following example uses to register the system task and system function
vlog_startup_routines
that were defined in the examples in 38.37.1.
A tool vendor shall supply a file that contains the array. The names of the PLI
vlog_startup_routines
application register functions shall be added to this vendor-supplied file.
1106
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
extern void listnets_register();
extern void my_random_init();
void (*vlog_startup_routines[]) () =
{
listnets_register,
my_random_init,
0
}
38.37.3 Registering multiple system tasks and system functions
Multiple system tasks and system functions can be registered at least two different ways, as follows:
— Allocate and define separate structures for each system task and system
s_vpi_systf_data
function, and call once for each structure. This is the method that was
vpi_register_systf()
used by the examples in 38.37.1 and 38.37.2.
— Allocate a static array of structures, and call vpi_register_systf() once for
s_vpi_systf_data
each structure in the array. If the final element in the array is set to 0, then the calls to
vpi_register_systf() can be placed in a loop that terminates when it reaches the 0.
The following example uses a static structure to declare three system tasks and system functions and places
vpi_register_systf() in a loop to register them:
tool
/*In a vendor file which contains vlog_startup_routines ...*/
extern void register_my_systfs();
extern void my_init();
void (*vlog_startup_routines[])() =
{
setup_report_cpu, /* user routine example in 38.36.3 */
register_my_systfs, /* user routine listed below */
0 /* must be last entry in list */
}
/* In a user provided file... */
void register_my_systfs()
{
static s_vpi_systf_data systfTestList[] = {
{vpiSysTask, 0, "$my_task", my_task_calltf, my_task_comptf,0,0},
{vpiSysFunc, vpiIntFunc, "$my_int_func", my_int_func_calltf,
my_int_func_comptf, 0,0},
{vpiSysFunc, vpiSizedFunc, "$my_sized_func",
my_sized_func_calltf, my_sized_func_comptf,
my_sized_func_sizetf,0},
0};
p_vpi_systf_data systf_data_p = &(systfTestList[0]);
while (systf_data_p->type)
vpi_register_systf(systf_data_p++);
}
1107
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.38 vpi_release_handle()
vpi_release_handle()
Synopsis: Release handle and its associated resources allocated by VPI routines.
Syntax:
vpi_release_handle(obj)
Type Description
Returns: PLI_INT32 1 (true) on success; 0 (false) on failure.
Type Name Description
Arguments: vpiHandle obj Handle of an object.
Related
routines:
The VPI routine vpi_release_handle() shall free memory allocated for VPI handles. The SystemVerilog
tool may allocate memory when a handle to an object is obtained, although often all required memory has
been allocated when the underlying object was first created or elaborated. One may safely ignore calling
vpi_release_handle() when a handle is no longer needed, but it is always advisable to do so, provided the
handle is valid and will not automatically become invalid in the future. This avoids logical memory leaks.
vpi_release_handle() shall not be called on an invalid handle.
vpi_release_handle() may be used to free memory created for iterator objects. The iterator object shall
automatically be freed when vpi_scan() returns because it has either completed an object traversal or
NULL
encountered an error condition. If neither of these conditions occurs (which can happen if the code breaks
out of an iteration loop before it has scanned every object), vpi_release_handle() should be called to free
any memory allocated for the iterator.
The routine shall return 1 (true) on success and 0 (false) on failure.
38.39 vpi_remove_cb()
vpi_remove_cb()
Synopsis: Remove a simulation-related callback registered with vpi_register_cb().
Syntax:
vpi_remove_cb(cb_obj)
Type Description
Returns: PLI_INT32 1 (true) if successful; 0 (false) on a failure.
Type Name Description
Arguments: vpiHandle cb_obj Handle to the callback object.
Related Use vpi_register_cb() to register callbacks for simulation events.
routines:
The VPI routine vpi_remove_cb() shall remove callbacks that were registered with vpi_register_cb(). The
argument to this routine shall be a handle to the callback object. The routine shall return a 1 (true) if
successful and a 0 (false) on a failure. After vpi_remove_cb() is called with a handle to the callback, the
handle is no longer valid.
1108
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.40 vpi_scan()
vpi_scan()
Synopsis: Scan the SystemVerilog hierarchy for objects with a one-to-many relationship.
Syntax:
vpi_scan(itr)
Type Description
Returns: vpiHandle Handle to an object.
Type Name Description
Arguments: vpiHandle itr Handle to an iterator object returned from vpi_iterate().
Related Use vpi_iterate() to obtain an iterator handle.
routines: Use vpi_handle() to obtain handles to an object with a one-to-one relationship.
Use vpi_handle_multi() to obtain a handle to an object with a many-to-one relationship.
The VPI routine vpi_scan() shall traverse the instantiated SystemVerilog hierarchy and return handles to
objects as directed by the iterator itr. The iterator handle shall be obtained by calling vpi_iterate() for a
specific object type. Once vpi_scan() returns NULL, the iterator handle is no longer valid and cannot be
used again.
The following example application uses vpi_iterate() and vpi_scan() to display each net (including the size
for vectors) declared in the module. The example assumes it shall be passed a valid module handle.
void display_nets(mod)
vpiHandle mod;
{
vpiHandle net;
vpiHandle itr;
vpi_printf("Nets declared in module %s\n",
vpi_get_str(vpiFullName, mod));
itr = vpi_iterate(vpiNet, mod);
while (net = vpi_scan(itr))
{
vpi_printf("\t%s", vpi_get_str(vpiName, net));
if (vpi_get(vpiVector, net))
{
vpi_printf(" of size %d\n", vpi_get(vpiSize, net));
}
else vpi_printf("\n");
}
}
1109
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
38.41 vpi_vprintf()
vpi_vprintf()
Synopsis: Write to the output channel of the tool that invoked the PLI application and the current tool log file using
varargs that are already started.
Syntax:
vpi_vprintf(format, ap)
Type Description
Returns: PLI_INT32 The number of characters written.
Type Name Description
Arguments: PLI_BYTE8 * format A format string using the C printf() format.
va_list ap An already started varargs list.
Related Use vpi_printf() to write a finite number of arguments.
routines: Use vpi_mcd_printf() to write to an opened file.
Use vpi_mcd_vprintf() to write a variable number of arguments to an opened file.
This routine performs the same function as vpi_printf(), except that varargs have already been started.
1110
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
39. Assertion API
39.1 General
This clause describes the following:
— SystemVerilog assertion API
— Obtaining assertion handles
— Assertions system callbacks
— Assertion control API functions
39.2 Overview
SystemVerilog provides assertion capabilities to enable the following:
— A user’s C code to react to assertion events
— Third-party assertion “waveform” dumping tools to be written
— Third-party assertion coverage tools to be written
— Third-party assertion debug tools to be written
39.3 Static information
This subclause defines how to obtain assertion handles and other static assertion information.
39.3.1 Obtaining assertion handles
SystemVerilog extends the VPI navigation model to encompass assertions, properties, and sequences. It also
enhances the instance iterator model with direct access to assertions, properties, and sequences.
The following steps highlight how to obtain the assertion handles for named assertions through direct
access:
a) Iterate all assertions in the design: use a reference handle (ref) to vpi_iterate(). For example:
NULL
itr = vpi_iterate(vpiAssertion, NULL);
while (assertion = vpi_scan(itr)) {
/* process assertion */
}
b) Iterate all assertions in an instance: pass the appropriate instance handle as a reference handle to
vpi_iterate(). For example:
itr = vpi_iterate(vpiAssertion, instanceHandle);
while (assertion = vpi_scan(itr)) {
/* process assertion */
}
c) Obtain the assertion by name: extend vpi_handle_by_name() to also search for assertion names in
the appropriate scope(s). For example:
vpiHandle = vpi_handle_by_name(assertName, scope)
1111
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
d) To obtain an assertion of a specific type, e.g., concurrent statements, the
cover property
following approach should be used:
vpiHandle assertion;
itr = vpi_iterate(vpiAssertion, NULL);
while (assertion = vpi_scan(itr)) {
if (vpi_get(vpiType, assertion) == vpiCover) {
/* process cover type assertion */
}
}
Details:
— As with all VPI handles, assertion handles are handles to a specific instance of a specific assertion.
— Unnamed assertions cannot be found by name.
39.3.2 Obtaining static assertion information
The following information about an assertion is considered to be static:
— Assertion name
— Instance in which the assertion occurs
— Module definition containing the assertion
— Assertion type
• Sequence instance
• Assert
• Assume
• Cover
• Restrict
• Property instance
• Immediate assert
• Immediate assume
• Immediate cover
— Assertion source information: the file, line, and column where the assertion is defined
— Assertion block/expression
clocking
39.4 Dynamic information
This subclause defines how to place assertion system and assertion callbacks.
39.4.1 Placing assertion system callbacks
To place an assertion system callback, use vpi_register_cb(), setting the element to the function to
cb_rtn
be invoked and the reason element of the structure to one of the following values:
s_cb_data
— cbAssertionSysInitialized. This callback occurs after the system has initialized. No
assertion-specific actions can be performed until this callback completes. The assertion system can
initialize before does or afterwards.
cbStartOfSimulation
— cbAssertionSysLock. This callback occurs when the assertion system is locked, e.g., due to a
system control action.
— cbAssertionSysUnlock. This callback occurs when the assertion system is unlocked, e.g., due to a
system control action.
1112
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— cbAssertionSysOn. The assertion system has become active and starts processing assertion
attempts. This always occurs after cbAssertionSysInitialized. By default, the assertion system is
“started” on simulation startup, but the user can delay this by using assertion system control actions.
— cbAssertionSysOff. The assertion system has been temporarily suspended. While stopped, no new
assertion attempts are processed and no new assertion-related callbacks occur. Assertions already
executing are not affected. The assertion system can be stopped and resumed an arbitrary number of
times during a single simulation run.
— cbAssertionSysKill. The assertion system has been temporarily suspended. While suspended, no
assertion attempts are processed, and no assertion-related callbacks occur. The assertion system can
be suspended and resumed an arbitrary number of times during a single simulation run.
— cbAssertionSysEnd. This callback occurs when all assertions have completed and no new attempts
shall start. Once this callback occurs, no more assertion-related callbacks shall occur, and assertion-
related actions shall have no further effect. This typically occurs after the end of simulation.
— cbAssertionSysReset. This callback occurs when the assertion system is reset, e.g., due to a system
control action.
— cbAssertionSysEnablePassAction. The pass action is enabled for vacuous and nonvacuous success
for the assertion (e.g., as a result of a system control action).
— cbAssertionSysEnableFailAction. The fail action is enabled for vacuous and nonvacuous success
for the assertion (e.g., as a result of a system control action).
— cbAssertionSysDisablePassAction. The pass action is disabled for vacuous and nonvacuous
success for the assertion (e.g., as a result of a system control action).
— cbAssertionSysDisableFailAction. The fail action is disabled for vacuous and nonvacuous success
for the assertion (e.g., as a result of a system control action).
— cbAssertionSysEnableNonvacuousAction. The pass action is enabled for nonvacuous success of
the assertion (e.g., as a result of a system control action).
— cbAssertionSysDisableVacuousAction. The pass action is disabled for vacuous success of the
assertion (e.g., as a result of a system control action).
The callback routine invoked follows the normal VPI callback prototype and is passed an
s_cb_data
containing the callback reason and any user data provided to the vpi_register_cb() call.
39.4.2 Placing assertions callbacks
To place an assertion callback, use vpi_register_assertion_cb(). The prototype is as follows:
/* typedef for vpi_register_assertion_cb callback function */
typedef PLI_INT32 (vpi_assertion_callback_func)(
PLI_INT32 reason, /* callback reason */
p_vpi_time cb_time, /* callback time */
vpiHandle assertion, /* handle to assertion */
p_vpi_attempt_info info, /* attempt related information */
PLI_BYTE8 *user_data /* user data entered upon registration */
);
vpiHandle vpi_register_assertion_cb(
vpiHandle assertion, /* handle to assertion */
PLI_INT32 reason, /* reason for which callbacks needed */
vpi_assertion_callback_func *cb_rtn,
PLI_BYTE8 *user_data /* user data to be supplied to cb */
);
typedef struct t_vpi_assertion_step_info {
PLI_INT32 matched_expression_count;
1113
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
vpiHandle *matched_exprs; /* array of expressions */
PLI_INT32 stateFrom, stateTo;/* identify transition */
} s_vpi_assertion_step_info, *p_vpi_assertion_step_info;
typedef struct t_vpi_attempt_info {
union {
vpiHandle failExpr;
p_vpi_assertion_step_info step;
} detail;
s_vpi_time attemptStartTime; /* Time attempt triggered */
} s_vpi_attempt_info, *p_vpi_attempt_info;
where reason is any of the following.
— cbAssertionStart. An assertion attempt has started. For most assertions, one attempt starts each and
every clock tick. For property and sequence instances the start is the start of evaluation of the
property or sequence instance. A property or sequence instance that is not instantiated in a
verification statement will never start.
— cbAssertionSuccess. An assertion attempt or property instance reaches a success state. For
sequence instances, success is a match.
— cbAssertionVacuousSuccess. An assertion attempt reaches a vacuous success state.
— cbAssertionDisabledEvaluation. An assertion attempt reaches the disabled state (e.g., as a result of
condition becoming true or if an attempt starts when the is true).
disable iff disable iff
— cbAssertionFailure. An assertion attempt or a property fails to reach a success state or a sequence
instance fails to match.
— cbAssertionStepSuccess. Progress one step along an attempt. A step is defined as progress along
the flattened assertion (e.g., rewriting algorithm defined in F.4.1). By default, step callbacks are not
enabled on any assertions; they are enabled on a per-assertion/per-attempt basis (see 39.5.2), rather
than on a per-assertion basis.
— cbAssertionStepFailure. Fail to progress by one step along an attempt. A step is defined as
progress along the flattened assertion (e.g., rewriting algorithm defined in F.4.1). By default, step
callbacks are not enabled on any assertions; they are enabled on a per-assertion/per-attempt basis
(see 39.5.2), rather than on a per-assertion basis.
— cbAssertionLock. The assertion is locked (e.g., as a result of a control action, see 39.5.2).
— cbAssertionUnlock. The assertion is unlocked (e.g., as a result of a control action, see 39.5.2).
— cbAssertionDisable. The assertion is disabled (e.g., as a result of a control action, see 39.5.2).
— cbAssertionEnable. The assertion is enabled (e.g., as a result of a control action, see 39.5.2).
— cbAssertionReset. The assertion is reset (e.g., as a result of a control action, see 39.5.2).
— cbAssertionKill. An attempt is killed (e.g., as a result of a control action, see 39.5.2).
— cbAssertionDisablePassAction. The pass action is disabled for vacuous and nonvacuous success
for the assertion (e.g., as a result of control action, see 39.5.2).
— cbAssertionEnablePassAction. The pass action is enabled for vacuous and nonvacuous success for
the assertion (e.g., as a result of control action, see 39.5.2).
— cbAssertionDisableFailAction. The fail action is disabled for the assertion (e.g., as a result of
control action, see 39.5.2).
— cbAssertionDisableVacuousAction. The pass action is disabled for vacuous success of the
assertion (e.g., as a result of control action, see 39.5.2).
— cbAssertionEnableNonvacuousAction. The pass action is enabled for nonvacuous success of the
assertion (e.g., as a result of control action, see 39.5.2).
— cbAssertionEnableFailAction. The fail action is enabled for the assertion (e.g., as a result of
control action, see 39.5.2).
1114
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Each of these callbacks may be registered on any concurrent or immediate assertion. The cbAssertionStart,
cbAssertionSuccess, and cbAssertionFailure callbacks may also be registered on a sequence instance or a
property instance.
These callbacks are specific to a given assertion; placing such a callback on one assertion does not cause the
callback to trigger on an event occurring on a different assertion. If the callback is successfully placed, a
handle to the callback is returned. This handle can be used to remove the callback via vpi_remove_cb(). If
there were errors on placing the callback, a handle is returned.
NULL
Once the callback is placed, the user-supplied function shall be called each time the specified event occurs
on the given assertion. The callback shall continue to be called whenever the event occurs until the callback
is removed.
The callback function shall be supplied the following arguments:
— The reason for the callback
— A pointer to the time of the callback
— The handle for the assertion
— A pointer to an attempt information structure
— A reference to the user data supplied when the callback was registered
The attempt information structure contains details relevant to the specific event that
t_vpi_attempt_info
occurred.
— On lock, unlock, disable, enable, reset, kill, pass action, fail action, vacuous action, and nonvacuous
action callbacks, the returned info pointer is , and no attempt
p_vpi_attempt_info NULL
information is available.
— On start and success callbacks, only the attemptStartTime field is valid.
— On a cbAssertionFailure callback, the attemptStartTime and detail.failExpr fields are valid.
— On a step callback, the attemptStartTime and detail.step fields are valid.
On a step callback, the describes the set of expressions matched in satisfying a step along the
detail
assertion, along with the corresponding source references. In addition, the also identifies the source
step
and destination “states” needed to uniquely identify the path being taken through the assertion. State ids are
just integers, with identifying the origin state, identifying an accepting state, and any other number
0 1
representing some intermediate point in the assertion. It is possible for the number of expressions in a step to
be , which represents an unconditional transition. In the case of a failing transition, the information
0
provided is just as that for a successful one, but the last expression in the array represents the expression
where the transition failed.
Details:
a) In a failing transition, there shall always be at least one element in the expression array.
b) Placing a step callback results in the same callback function being invoked for both success and
failure steps.
c) The content of the cb_time field depends on the reason identified by the reason field, as follows:
— cbAssertionStart is the time when the assertion attempt has been started.
:cb_time
— cbAssertionSuccess, cbAssertionFailure cb_time is the time when the assertion succeeded
:
nonvacuously or failed.
— cbAssertionVacuousSuccess: cb_time is the time when the assertion succeeded vacuously.
— cbAssertionDisabledEvaluation: cb_time is the time when the assertion reached the disabled
state.
1115
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.