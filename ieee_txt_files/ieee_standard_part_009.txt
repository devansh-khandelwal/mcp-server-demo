IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
initial begin
myteeth = FALSE; // OK: Direct reference to FALSE refers to the
end // FALSE enumeration literal imported from q
endmodule
An explicit import shall be illegal if the imported identifier is declared in the same scope or explicitly
imported from another package. Importing an identifier from the same package multiple times is allowed.
A wildcard import allows all identifiers declared within a package to be imported provided the identifier is
not otherwise defined in the importing scope: A wildcard import is of the following form:
import ComplexPkg::*;
An identifier is potentially locally visible at some point within a scope if there is a wildcard import of a
package before that point within the current scope and the package contains a declaration of that identifier.
An identifier is locally visible at some point within a scope if
a) The identifier denotes a nested scope within the current scope, or
b) The identifier is declared as an identifier prior to that point within the current scope, or
c) The identifier is visible from an explicit import prior to that point within the current scope.
A potentially locally visible identifier from a wildcard import may become locally visible if the resolution of
a reference to an identifier finds no other matching locally visible identifiers.
For a reference to an identifier other than function or task call, the locally visible identifiers defined at the
point of the reference in the current scope shall be searched. If the reference is a function or task call, all of
the locally visible identifiers to the end of the current scope shall be searched. If a match is found, the
reference shall be bound to that locally visible identifier.
If no locally visible identifiers match, then the potentially locally visible identifiers defined prior to the point
of the reference in the current scope shall be searched. If a match is found, that identifier from the package
shall be imported into the current scope, becoming a locally visible identifier within the current scope, and
the reference shall be bound to that identifier.
If the reference is not bound within the current scope, the next outer lexical scope shall be searched; first
from among the locally visible identifiers in that scope and then from among the potentially locally visible
identifiers defined prior to the point of the reference. If a match is found among the potentially locally
visible identifiers, that identifier from the package shall be imported into the outer scope, becoming a locally
visible identifier within the outer scope.
If a wildcard imported symbol is made locally visible in a scope, any later locally visible declaration of the
same name in that scope shall be illegal.
The search algorithm shall be repeated for each outer lexical scope until an identifier is found that matches
the reference or there are no more outer lexical scopes, the compilation unit scope being the final scope
searched. For a reference to an identifier other than function or task call, it shall be illegal if no identifier can
be found that matches the reference. If the reference is a function or task call, the search continues using
upwards hierarchical identifier resolution (see 23.8.1).
It shall be illegal if the wildcard import of more than one package within the same scope defines the same
potentially locally visible identifier and a search for a reference matches that identifier.
778
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 1:
package p;
int x;
endpackage
module top;
import p::*; // line 1
if (1) begin : b
initial x = 1; // line 2
int x; // line 3
initial x = 1; // line 4
end
int x; // line 5
endmodule
The reference in line 2 causes the potentially locally visible from wildcard import to
x p::* ( p::x )
become locally visible in scope , and line 2 initializes . Line 4 initializes . Line 5 is illegal
top p::x top.b.x
since it is a local declaration in scope , which conflicts with the name imported from , which had
top x p
already become a locally visible declaration.
Example 2:
package p;
int x;
endpackage
package p2;
int x;
endpackage
module top;
import p::*; // line 1
if (1) begin : b
initial x = 1; // line 2
import p2::*; // line 3
end
endmodule
Line 2 causes the import of in scope because the wildcard import is in the outer scope
p::x top p::* top
and precedes the occurrence of . The declaration from package becomes locally visible in scope .
x x p top
Example 3:
package p;
function int f();
return 1;
endfunction
endpackage
module top;
int x;
if (1) begin : b
initial x = f(); // line 2
import p::*; // line 3
end
779
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
function int f();
return 1;
endfunction
endmodule
on line 2 binds to and not to since the import is after the function call reference.
f() top.f p::f
Example 4:
package p;
function int f();
return 1;
endfunction
endpackage
package p2;
function int f();
return 1;
endfunction
endpackage
module top;
import p::*;
int x;
if (1) begin : b
initial x = f(); // line 1
end
import p2::*;
endmodule
Since is not found in scope , the rules require inspection of all wildcard imports in the parent scope.
f b
There are two wildcard imports, but only the wildcard import that is lexically preceding the occurrence
p::*
of is considered. In this case, binds to .
f() f p::f
The effect of importing an identifier into a scope makes that identifier visible without requiring access using
the scope resolution operator. Importing does not copy the declaration of that identifier into the importing
scope. The imported identifier shall not be visible outside that importing scope by hierarchical reference into
that scope or by interface port reference into that scope.
It shall be illegal to have an import statement directly within a class scope.
26.4 Using packages in module headers
Package items can be referenced in module, interface or program parameter and port declarations by
importing the package as part of the header to the module, interface, or program declaration. The syntax is
shown in Syntax26-3.
module_nonansi_header ::= // from A.1.2
{ attribute_instance } module_keyword [ lifetime ] module_identifier
{ package_import_declaration } [ parameter_port_list ] list_of_ports
;
module_ansi_header ::=
{ attribute_instance } module_keyword [ lifetime ] module_identifier
{ package_import_declaration }1 [ parameter_port_list ] [ list_of_port_declarations ]
;
780
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
interface_nonansi_header ::=
{ attribute_instance } [ lifetime ] interface_identifier
interface
{ package_import_declaration } [ parameter_port_list ] list_of_ports
;
interface_ansi_header ::=
{attribute_instance } [ lifetime ] interface_identifier
interface
{ package_import_declaration }1 [ parameter_port_list ] [ list_of_port_declarations ]
;
program_nonansi_header ::=
{ attribute_instance } [ lifetime ] program_identifier
program
{ package_import_declaration } [ parameter_port_list ] list_of_ports
;
program_ansi_header ::=
{attribute_instance } [ lifetime ] program_identifier
program
{ package_import_declaration }1 [ parameter_port_list ] [ list_of_port_declarations ]
;
1) A package_import_declaration in a module_ansi_header, interface_ansi_header, or program_ansi_header shall be
followed by a parameter_port_list or list_of_port_declarations, or both.
Syntax26-3—Package import in header syntax (excerpt from AnnexA)
Package items that are imported as part of a module, interface, or program header are visible throughout the
module, interface, or program, including in parameter and port declarations.
For example:
package A;
typedef struct {
bit [ 7:0] opcode;
bit [23:0] addr;
} instruction_t;
endpackage: A
package B;
typedef enum bit {FALSE, TRUE} boolean_t;
endpackage: B
module M import A::instruction_t, B::*;
#(WIDTH = 32)
(input [WIDTH-1:0] data,
input instruction_t a,
output [WIDTH-1:0] result,
output boolean_t OK
);
...
endmodule: M
26.5 Search order rules
Table26-1 describes the search order rules for the declarations imported from a package. For the purposes
of the discussion that follows, consider the following package declarations:
package p;
typedef enum { FALSE, TRUE } BOOL;
const BOOL c = FALSE;
endpackage
781
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
package q;
const int c = 0;
endpackage
Table26-1—Scoping rules for package importation
In a scope In a scope not In a scope In a scope
containing a containing a containing an containing a
Example Description local local explicit import wildcard
declaration of declaration of of c (import import of c
c c q::c) (import q::*)
A qualified OK OK OK OK
u = p::c;
package identi-
y = p::TRUE;
fier is visible in Direct reference Direct reference Direct reference Direct reference
any scope to refers to to is illegal to refers to the to refers to the
c c c c
(without the the locally because it is imported from imported from
c c
need for an declared . undefined. . .
c q q
import clause).
refers to refers to refers to refers to
p::c p::c p::c p::c
the in pack- the in the in package the in package
c c c c
age . package . . .
p p p p
All declara- OK OK OK OK / ERROR
import p::*;
tions inside
package Direct reference Direct reference Direct reference is undefined in
. . . p c
become poten- to refers to to refers to to refers to the the importing
c c c
tially directly the locally the imported imported from scope. Thus, a
y = FALSE; c c
visible in the declared . from package package . direct reference
c q
importing . to is illegal
p c
scope: Direct reference and results in an
– to other identi- error.
c
– fiers (e.g.,
BOOL
– ) refers The import
FALSE FALSE
– to those implic- clause is other-
TRUE
itly imported wise allowed.
from package
.
p
The imported ERROR OK ERROR OK / ERROR
import p::c;
identifier
c
becomes It is illegal to Direct reference It is illegal to The import of
. . .
directly visible import an iden- to refers to import the same makes
c p::c
in the import- tifier defined in the imported identifier from any prior
if( ! c ) ... c
ing scope. the importing from package different reference to
c
scope. . packages. illegal.
p
Otherwise,
direct reference
to refers to the
c
imported from
c
package .
p
When using a wildcard import, a reference to an undefined identifier that is declared within the package
causes that identifier to be imported into the scope of the import statement. However, an error results if the
same identifier is later declared or explicitly imported in the same scope. This is shown in the following
example:
module m;
import q::*;
782
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
wire a = c; // This statement forces the import of q::c;
import p::c; // The conflict with q::c and p::c creates an error.
endmodule
26.6 Exporting imported names from packages
By default, declarations imported into a package are not visible by way of subsequent imports of that
package. Package export declarations allow a package to specify that imported declarations are to be made
visible in subsequent imports. A package export may precede a corresponding package import.
The syntax for package exports is shown in Syntax26-4.
package_export_declaration ::= // from A.2.1.3
export *::* ;
| package_import_item { package_import_item }
export , ;
Syntax26-4—Package export syntax (excerpt from AnnexA)
An export of the form exports all declarations that were actually imported from
package_name::*
within the context of the exporting package. All names from , whether
package_name package_name
imported directly or through wildcard imports, are made available. Symbols that are candidates for import
but not actually imported are not made available. The special wildcard export form, ,
export *::*;
exports all imported declarations from all packages from which imports occur.
An export of the form makes the given declaration available. It shall be an error if
package_name::name
the given declaration is not a candidate for import or if the declaration is not actually imported in the
package. The declaration being exported shall be imported from the same used in the
package_name
export. If the declaration is an unreferenced candidate for import, the export shall be considered to be a
reference and shall import the declaration into the package following the same rules as for a direct import of
the name.
An import of a declaration made visible through an export is equivalent to an import of the original
declaration. Thus direct or wildcard import of a declaration by way of multiple exported paths does not
cause conflicts.
It is valid to specify multiple exports that export the same actual declaration.
Examples:
package p1;
int x, y;
endpackage
package p2;
import p1::x;
export p1::*; // exports p1::x as the name "x";
// p1::x and p2::x are the same declaration
endpackage
package p3;
import p1::*;
import p2::*;
export p2::*;
783
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
int q = x;
// p1::x and q are made available from p3. Although p1::y
// is a candidate for import, it is not actually imported
// since it is not referenced. Since p1::y is not imported,
// it is not made available by the export.
endpackage
package p4;
import p1::*;
export p1::*;
int y = x; // y is available as a direct declaration;
// p1::x is made available by the export
endpackage
package p5;
import p4::*;
import p1::*;
export p1::x;
export p4::x; // p4::x refers to the same declaration
// as p1::x so this is legal.
endpackage
package p6;
import p1::*;
export p1::x;
int x; // Error. export p1::x is considered to
// be a reference to "x" so a subsequent
// declaration of x is illegal.
endpackage
package p7;
int y;
endpackage
package p8;
export *::*; // Exports both p7::y and p1::x.
import p7::y;
import p1::x;
endpackage
module top;
import p2::*;
import p4::*;
int y = x; // x is p1::x
endmodule
26.7 The std built-in package
SystemVerilog provides a built-in package that can contain system types (e.g., classes), variables, tasks, and
functions. Users cannot insert additional declarations into the built-in package.
The contents of the standard built-in package are defined in AnnexG.
784
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The built-in package is implicitly wildcard imported into the compilation-unit scope of every compilation
unit (see 3.12.1). Thus, declarations in the built-in package are directly available in any other scope (like
system tasks and system functions) unless they are redefined by user code.
Declarations in the standard built-in package can also be directly referenced using the syntax shown in
Syntax26-5.
built_in_data_type ::= [ ] data_type_identifier
std ::
built_in_function_call ::= [ ] function_subroutine_call
std ::
Syntax26-5—Std package import syntax (not in AnnexA)
The package name followed by the package scope resolution operator can be used to unambiguously
std ::
access names in the built-in package. For example:
std::sys_task(); // unambiguously call the system provided sys_task
Unlike system tasks and system functions, tasks and functions in the built-in package need not be prefixed
with a to avoid collisions with user-defined identifiers. This mechanism allows functional extensions to
$
the language in a backward compatible manner, without the addition of new keywords or polluting local
name spaces.
785
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
27. Generate constructs
27.1 General
This clause describes the following:
— Loop generate constructs
— Conditional generate constructs
— External names in unnamed generate constructs
27.2 Overview
Generate constructs are used to either conditionally or multiply instantiate generate blocks into a model. A
generate block is a collection of one or more module items. A generate block may not contain port
declarations, specify blocks, or specparam declarations. Parameters declared in generate blocks shall be
treated as localparams (see 6.20.4). All other module items, including other generate constructs, are allowed
in a generate block. Generate constructs provide the ability for parameter values to affect the structure of the
design. They also allow for modules with repetitive structure to be described more concisely, and they make
recursive module instantiation possible.
27.3 Generate construct syntax
There are two kinds of generate constructs: loops and conditionals. Loop generate constructs allow a single
generate block to be instantiated into a model multiple times. Conditional generate constructs, which
include if-generate and case-generate constructs, instantiate at most one generate block from a set of
alternative generate blocks. The term generate scheme refers to the method for determining which or how
many generate blocks are instantiated. It includes the conditional expressions, case alternatives, and loop
control statements that appear in a generate construct.
Generate schemes are evaluated during elaboration of the design. Although generate schemes use syntax that
is similar to behavioral statements, it is important to recognize that they do not execute at simulation time.
They are evaluated at elaboration time, and the result is determined before simulation begins. Therefore, all
expressions in generate schemes shall be constant expressions, deterministic at elaboration time. For more
details on elaboration, see 3.12.
The elaboration of a generate construct results in zero or more instances of a generate block. An instance of
a generate block is similar in some ways to an instance of a module. It creates a new level of hierarchy. It
brings the objects, behavioral constructs, and module instances within the block into existence. These
constructs act the same as they would if they were in a module brought into existence with a module
instantiation, except that object declarations from the enclosing scope can be referenced directly (see 23.9).
Names in instantiated named generate blocks can be referenced hierarchically as described in 23.6.
The keywords and may be used in a module to define a generate region. A
generate endgenerate
generate region is a textual span in the module description where generate constructs may appear. Use of
generate regions is optional. There is no semantic difference in the module when a generate region is used. A
parser may choose to recognize the generate region to produce different error messages for misused generate
construct keywords. Generate regions do not nest, and they may only occur directly within a module. If the
keyword is used, it shall be matched by an keyword.
generate endgenerate
The syntax for generate constructs is given in Syntax27-1.
786
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
generate_region ::= // from A.4.2
{ generate_item }
generate endgenerate
loop_generate_construct ::=
genvar_initialization genvar_expression genvar_iteration
for( ; ; )
generate_block
genvar_initialization ::=
[ ] genvar_identifier constant_expression
genvar =
genvar_iteration ::=
genvar_identifier assignment_operator genvar_expression
| inc_or_dec_operator genvar_identifier
| genvar_identifier inc_or_dec_operator
conditional_generate_construct ::=
if_generate_construct
| case_generate_construct
if_generate_construct ::=
constant_expression generate_block [ generate_block ]
if( ) else
case_generate_construct ::=
constant_expression case_generate_item { case_generate_item }
case( ) endcase
case_generate_item ::=
constant_expression { constant_expression } generate_block
, :
| [ ] generate_block
default :
generate_block ::=
generate_item
| [ generate_block_identifier ] [ generate_block_identifier ]
: begin :
{ generate_item }
[ generate_block_identifier ]
end :
generate_item30 ::=
module_or_generate_item
| interface_or_generate_item
| checker_or_generate_item
module_or_generate_item ::= // from A.1.4
{ attribute_instance } parameter_override
| { attribute_instance } gate_instantiation
| { attribute_instance } udp_instantiation
| { attribute_instance } module_instantiation
| { attribute_instance } module_common_item
module_or_generate_item_declaration ::=
package_or_generate_item_declaration
| genvar_declaration
| clocking_declaration
| clocking_identifier
defaultclocking ;
| expression_or_dist
default disable iff ;
module_common_item ::=
module_or_generate_item_declaration
| interface_instantiation
| program_instantiation
| assertion_item
| bind_directive
| continuous_assign
787
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| net_alias
| initial_construct
| final_construct
| always_construct
| loop_generate_construct
| conditional_generate_construct
interface_or_generate_item ::= // from A.1.6
{ attribute_instance } module_common_item
| { attribute_instance } extern_tf_declaration
package_or_generate_item_declaration ::= // from A.1.11
net_declaration
| data_declaration
| task_declaration
| function_declaration
| checker_declaration
| dpi_import_export
| extern_constraint_declaration
| class_declaration
| class_constructor_declaration
| local_parameter_declaration
;
| parameter_declaration
;
| covergroup_declaration
| assertion_item_declaration
|
;
30) Within an interface_declaration, it shall only be legal for a generate_item to be an interface_or_generate_item.
Within a module_declaration, except when also within an interface_declaration, it shall only be legal for a
generate_item to be a module_or_generate_item. Within a checker_declaration, it shall only be legal for a
generate_item to be a checker_or_generate_item.
Syntax27-1—Syntax for generate constructs (excerpt from AnnexA)
27.4 Loop generate constructs
A loop generate construct permits a generate block to be instantiated multiple times using syntax that is
similar to a for loop statement. The loop index variable shall be declared in a declaration prior to its
genvar
use in a loop generate scheme.
The is used as an integer during elaboration to evaluate the generate loop and create instances of the
genvar
generate block, but it does not exist at simulation time. A shall not be referenced anywhere other
genvar
than in a loop generate scheme.
Both the initialization and iteration assignments in the loop generate scheme shall assign to the same
. The initialization assignment shall not reference the loop index variable on the right-hand side.
genvar
Within the generate block of a loop generate construct, there is an implicit declaration. This is
localparam
an integer parameter that has the same name and type as the loop index variable, and its value within each
instance of the generate block is the value of the index variable at the time the instance was elaborated. This
parameter can be used anywhere within the generate block that a normal parameter with an integer value can
be used. It can be referenced with a hierarchical name.
788
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Because this implicit has the same name as the , any reference to this name inside the
localparam genvar
loop generate block will be a reference to the , not to the . As a consequence, it is not
localparam genvar
possible to have two nested loop generate constructs that use the same .
genvar
Generate blocks in loop generate constructs can be named or unnamed, and they can consist of only one
item, which need not be surrounded by keywords. Even if the keywords are absent,
begin-end begin-end
it is still a generate block, which, like all generate blocks, comprises a separate scope and a new level of
hierarchy when it is instantiated.
If the generate block is named, it is a declaration of an array of generate block instances. The index values in
this array are the values assumed by the during elaboration. This can be a sparse array because the
genvar
values do not have to form a contiguous range of integers. The array is considered to be declared
genvar
even if the loop generate scheme resulted in no instances of the generate block. If the generate block is not
named, the declarations within it cannot be referenced using hierarchical names other than from within the
hierarchy instantiated by the generate block itself.
It shall be an error if the name of a generate block instance array conflicts with any other declaration,
including any other generate block instance array. It shall be an error if the loop generate scheme does not
terminate. It shall be an error if a value is repeated during the evaluation of the loop generate
genvar
scheme. It shall be an if any bit of the is set to or during the evaluation of the loop
error genvar x z
generate scheme.
Example 1: Examples of legal and illegal generate loops
module mod_a;
genvar i;
// "generate", "endgenerate" keywords are not required
for (i=0; i<5; i=i+1) begin:a
for (i=0; i<5; i=i+1) begin:b
... // error -- using "i" as loop index for
... // two nested generate loops
end
end
endmodule
module mod_b;
genvar i;
logic a;
for (i=1; i<0; i=i+1) begin: a
... // error -- "a" conflicts with name of variable "a"
end
endmodule
module mod_c;
genvar i;
for (i=1; i<5; i=i+1) begin: a
...
end
for (i=10; i<15; i=i+1) begin: a
... // error -- "a" conflicts with name of previous
789
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
... // loop even though indices are unique
end
endmodule
Example 2: A parameterized gray-code–to–binary-code converter module using a loop to generate
continuous assignments
module gray2bin1 (bin, gray);
parameter SIZE = 8; // this module is parameterizable
output [SIZE-1:0] bin;
input [SIZE-1:0] gray;
genvar i;
generate
for (i=0; i<SIZE; i=i+1) begin:bitnum
assign bin[i] = ^gray[SIZE-1:i];
// i refers to the implicitly defined localparam whose
// value in each instance of the generate block is
// the value of the genvar when it was elaborated.
end
endgenerate
endmodule
The models in Example 3 and Example 4 are parameterized modules of ripple adders using a loop to
generate SystemVerilog gate primitives. Example 3 uses a two-dimensional net declaration outside the
generate loop to make the connections between the gate primitives while Example 4 makes the net
declaration inside the generate loop to generate the wires needed to connect the gate primitives for each
iteration of the loop.
Example 3: Generated ripple adder with two-dimensional net declaration outside the generate loop
module addergen1 (co, sum, a, b, ci);
parameter SIZE = 4;
output [SIZE-1:0] sum;
output co;
input [SIZE-1:0] a, b;
input ci;
wire [SIZE :0] c;
wire [SIZE-1:0] t [1:3];
genvar i;
assign c[0] = ci;
// Hierarchical gate instance names are:
// xor gates: bitnum[0].g1 bitnum[1].g1 bitnum[2].g1 bitnum[3].g1
// bitnum[0].g2 bitnum[1].g2 bitnum[2].g2 bitnum[3].g2
// and gates: bitnum[0].g3 bitnum[1].g3 bitnum[2].g3 bitnum[3].g3
// bitnum[0].g4 bitnum[1].g4 bitnum[2].g4 bitnum[3].g4
// or gates: bitnum[0].g5 bitnum[1].g5 bitnum[2].g5 bitnum[3].g5
// Generated instances are connected with
// multidimensional nets t[1][3:0] t[2][3:0] t[3][3:0]
// (12 nets total)
for(i=0; i<SIZE; i=i+1) begin:bitnum
xor g1 ( t[1][i], a[i], b[i]);
xor g2 ( sum[i], t[1][i], c[i]);
and g3 ( t[2][i], a[i], b[i]);
and g4 ( t[3][i], t[1][i], c[i]);
790
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
or g5 ( c[i+1], t[2][i], t[3][i]);
end
assign co = c[SIZE];
endmodule
Example 4: Generated ripple adder with net declaration inside the generate loop
module addergen1 (co, sum, a, b, ci);
parameter SIZE = 4;
output [SIZE-1:0] sum;
output co;
input [SIZE-1:0] a, b;
input ci;
wire [SIZE :0] c;
genvar i;
assign c[0] = ci;
// Hierarchical gate instance names are:
// xor gates: bitnum[0].g1 bitnum[1].g1 bitnum[2].g1 bitnum[3].g1
// bitnum[0].g2 bitnum[1].g2 bitnum[2].g2 bitnum[3].g2
// and gates: bitnum[0].g3 bitnum[1].g3 bitnum[2].g3 bitnum[3].g3
// bitnum[0].g4 bitnum[1].g4 bitnum[2].g4 bitnum[3].g4
// or gates: bitnum[0].g5 bitnum[1].g5 bitnum[2].g5 bitnum[3].g5
// Gate instances are connected with nets named:
// bitnum[0].t1 bitnum[1].t1 bitnum[2].t1 bitnum[3].t1
// bitnum[0].t2 bitnum[1].t2 bitnum[2].t2 bitnum[3].t2
// bitnum[0].t3 bitnum[1].t3 bitnum[2].t3 bitnum[3].t3
for(i=0; i<SIZE; i=i+1) begin:bitnum
wire t1, t2, t3;
xor g1 ( t1, a[i], b[i]);
xor g2 ( sum[i], t1, c[i]);
and g3 ( t2, a[i], b[i]);
and g4 ( t3, t1, c[i]);
or g5 ( c[i+1], t2, t3);
end
assign co = c[SIZE];
endmodule
The hierarchical generate block instance names in a multilevel generate loop are shown in Example 5. For
each block instance created by the generate loop, the generate block identifier for the loop is indexed by
adding the “[genvar value]” to the end of the generate block identifier. These names can be used in
hierarchical path names (see 23.6).
Example 5: A multilevel generate loop
parameter SIZE = 2;
genvar i, j, k, m;
generate
for (i=0; i<SIZE; i=i+1) begin:B1 // scope B1[i]
M1 N1(); // instantiates B1[i].N1
for (j=0; j<SIZE; j=j+1) begin:B2 // scope B1[i].B2[j]
M2 N2(); // instantiates B1[i].B2[j].N2
791
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
for (k=0; k<SIZE; k=k+1) begin:B3 // scope B1[i].B2[j].B3[k]
M3 N3(); // instantiates
end // B1[i].B2[j].B3[k].N3
end
if (i>0) begin:B4 // scope B1[i].B4
for (m=0; m<SIZE; m=m+1) begin:B5 // scope B1[i].B4.B5[m]
M4 N4(); // instantiates
end // B1[i].B4.B5[m].N4
end
end
endgenerate
// Some examples of hierarchical names for the module instances:
// B1[0].N1 B1[1].N1
// B1[0].B2[0].N2 B1[0].B2[1].N2
// B1[0].B2[0].B3[0].N3 B1[0].B2[0].B3[1].N3
// B1[0].B2[1].B3[0].N3
// B1[1].B4.B5[0].N4 B1[1].B4.B5[1].N4
27.5 Conditional generate constructs
The conditional generate constructs, if-generate and case-generate, select at most one generate block from a
set of alternative generate blocks based on constant expressions evaluated during elaboration. The selected
generate block, if any, is instantiated into the model.
Generate blocks in conditional generate constructs can be named or unnamed, and they may consist of only
one item, which need not be surrounded by keywords. Even if the keywords are
begin-end begin-end
absent, it is still a generate block, which, like all generate blocks, comprises a separate scope and a new level
of hierarchy when it is instantiated.
Because at most one of the alternative generate blocks is instantiated, it is permissible for there to be more
than one block with the same name within a single conditional generate construct. It is not permissible for
any of the named generate blocks to have the same name as generate blocks in any other conditional or loop
generate construct in the same scope, even if the blocks with the same name are not selected for
instantiation. It is not permissible for any of the named generate blocks to have the same name as any other
declaration in the same scope, even if that block is not selected for instantiation.
If the generate block selected for instantiation is named, then this name declares a generate block instance
and is the name for the scope it creates. Normal rules for hierarchical naming apply. If the generate block
selected for instantiation is not named, it still creates a scope; but the declarations within it cannot be
referenced using hierarchical names other than from within the hierarchy instantiated by the generate block
itself.
If a generate block in a conditional generate construct consists of only one item that is itself a conditional
generate construct and if that item is not surrounded by keywords, then this generate block is
begin-end
not treated as a separate scope. The generate construct within this block is said to be directly nested. The
generate blocks of the directly nested construct are treated as if they belong to the outer construct. Therefore,
they can have the same name as the generate blocks of the outer construct, and they cannot have the same
name as any declaration in the scope enclosing the outer construct (including other generate blocks in other
generate constructs in that scope). This allows complex conditional generate schemes to be expressed
without creating unnecessary levels of generate block hierarchy.
The most common use of this would be to create an generate scheme with any number of
if–else–if
clauses, all of which can have generate blocks with the same name because only one will be
else–if
selected for instantiation. It is permissible to combine if-generate and case-generate constructs in the same
792
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
complex generate scheme. Direct nesting applies only to conditional generate constructs nested in
conditional generate constructs. It does not apply in any way to loop generate constructs.
Example 1:
module test;
parameter p = 0, q = 0;
wire a, b, c;
//---------------------------------------------------------
// Code to either generate a u1.g1 instance or no instance.
// The u1.g1 instance of one of the following gates:
// (and, or, xor, xnor) is generated if
// {p,q} == {1,0}, {1,2}, {2,0}, {2,1}, {2,2}, {2, default}
//---------------------------------------------------------
if (p == 1)
if (q == 0)
begin : u1 // If p==1 and q==0, then instantiate
and g1(a, b, c); // AND with hierarchical name test.u1.g1
end
else if (q == 2)
begin : u1 // If p==1 and q==2, then instantiate
or g1(a, b, c); // OR with hierarchical name test.u1.g1
end
// "else" added to end "if (q == 2)" statement
else ; // If p==1 and q!=0 or 2, then no instantiation
else if (p == 2)
case (q)
0, 1, 2:
begin : u1 // If p==2 and q==0,1, or 2, then instantiate
xor g1(a, b, c); // XOR with hierarchical name test.u1.g1
end
default:
begin : u1 // If p==2 and q!=0,1, or 2, then instantiate
xnor g1(a, b, c); // XNOR with hierarchical name test.u1.g1
end
endcase
endmodule
This generate construct will select at most one of the generate blocks named . The hierarchical name of
u1
the gate instantiation in that block would be . When nesting if-generate constructs, the
test.u1.g1 else
always belongs to the nearest construct.
if
NOTE—As in the preceding example, an with a null generate block can be inserted to make a subsequent
else else
belong to an outer construct. keywords can also be used to disambiguate. However, this would violate
if begin-end
the criteria for direct nesting, and an extra level of generate block hierarchy would be created.
Conditional generate constructs make it possible for a module to contain an instantiation of itself. The same
can be said of loop generate constructs, but it is more easily done with conditional generates. With proper
use of parameters, the resulting recursion can be made to terminate, resulting in a legitimate model
hierarchy. Because of the rules for determining top-level modules, a module containing an instantiation of
itself will not be a top-level module.
Example 2: An implementation of a parameterized multiplier module
module multiplier(a,b,product);
parameter a_width = 8, b_width = 8;
793
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
localparam product_width = a_width+b_width;
// cannot be modified directly with the defparam
// statement or the module instance statement #
input [a_width-1:0] a;
input [b_width-1:0] b;
output [product_width-1:0] product;
generate
if((a_width < 8) || (b_width < 8)) begin: mult
CLA_multiplier #(a_width,b_width) u1(a, b, product);
// instantiate a CLA multiplier
end
else begin: mult
WALLACE_multiplier #(a_width,b_width) u1(a, b, product);
// instantiate a Wallace-tree multiplier
end
endgenerate
// The hierarchical instance name is mult.u1
endmodule
Example 3: Generate with a case to handle widths less than 3
generate
case (WIDTH)
1: begin: adder // 1-bit adder implementation
adder_1bit x1(co, sum, a, b, ci);
end
2: begin: adder // 2-bit adder implementation
adder_2bit x1(co, sum, a, b, ci);
end
default:
begin: adder // others - carry look-ahead adder
adder_cla #(WIDTH) x1(co, sum, a, b, ci);
end
endcase
// The hierarchical instance name is adder.x1
endgenerate
Example 4: A module of memory dimm
module dimm(addr, ba, rasx, casx, csx, wex, cke, clk, dqm, data, dev_id);
parameter [31:0] MEM_WIDTH = 16, MEM_SIZE = 8; // in mbytes
input [10:0] addr;
input ba, rasx, casx, csx, wex, cke, clk;
input [ 7:0] dqm;
inout [63:0] data;
input [ 4:0] dev_id;
genvar i;
case ({MEM_SIZE, MEM_WIDTH})
{32'd8, 32'd16}: // 8Meg x 16 bits wide
begin: memory
for (i=0; i<4; i=i+1) begin:word16
sms_08b216t0 p(.clk(clk), .csb(csx), .cke(cke),.ba(ba),
.addr(addr), .rasb(rasx), .casb(casx),
794
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
.web(wex), .udqm(dqm[2*i+1]), .ldqm(dqm[2*i]),
.dqi(data[15+16*i:16*i]), .dev_id(dev_id));
// The hierarchical instance names are:
// memory.word16[3].p, memory.word16[2].p,
// memory.word16[1].p, memory.word16[0].p,
// and the task memory.read_mem
end
task read_mem;
input [31:0] address;
output [63:0] data;
begin // call read_mem in sms module
word[3].p.read_mem(address, data[63:48]);
word[2].p.read_mem(address, data[47:32]);
word[1].p.read_mem(address, data[31:16]);
word[0].p.read_mem(address, data[15: 0]);
end
endtask
end
{32'd16, 32'd8}: // 16Meg x 8 bits wide
begin: memory
for (i=0; i<8; i=i+1) begin:word8
sms_16b208t0 p(.clk(clk), .csb(csx), .cke(cke),.ba(ba),
.addr(addr), .rasb(rasx), .casb(casx),
.web(wex), .dqm(dqm[i]),
.dqi(data[7+8*i:8*i]), .dev_id(dev_id));
// The hierarchical instance names are
// memory.word8[7].p, memory.word8[6].p,
// ...
// memory.word8[1].p, memory.word8[0].p,
// and the task memory.read_mem
end
task read_mem;
input [31:0] address;
output [63:0] data;
begin // call read_mem in sms module
byte[7].p.read_mem(address, data[63:56]);
byte[6].p.read_mem(address, data[55:48]);
byte[5].p.read_mem(address, data[47:40]);
byte[4].p.read_mem(address, data[39:32]);
byte[3].p.read_mem(address, data[31:24]);
byte[2].p.read_mem(address, data[23:16]);
byte[1].p.read_mem(address, data[15: 8]);
byte[0].p.read_mem(address, data[ 7: 0]);
end
endtask
end
// Other memory cases ...
endcase
endmodule
27.6 External names for unnamed generate blocks
Although an unnamed generate block has no name that can be used in a hierarchical name, it needs to have a
name by which external interfaces can refer to it. A name will be assigned for this purpose to each unnamed
generate block as described in the next paragraph.
795
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Each generate construct in a given scope is assigned a number. The number will be 1 for the construct that
appears textually first in that scope and will increase by 1 for each subsequent generate construct in that
scope. All unnamed generate blocks will be given the name “ ” where is the number
genblk<n> <n>
assigned to its enclosing generate construct. If such a name would conflict with an explicitly declared name,
then leading zeros are added in front of the number until the name does not conflict.
NOTE—Each generate construct is assigned its number as described in the previous paragraph even if it does not
contain any unnamed generate blocks.
For example:
module top;
parameter genblk2 = 0;
genvar i;
// The following generate block is implicitly named genblk1
if (genblk2) logic a; // top.genblk1.a
else logic b; // top.genblk1.b
// The following generate block is implicitly named genblk02
// as genblk2 is already a declared identifier
if (genblk2) logic a; // top.genblk02.a
else logic b; // top.genblk02.b
// The following generate block would have been named genblk3
// but is explicitly named g1
for (i = 0; i < 1; i = i + 1) begin : g1 // block name
// The following generate block is implicitly named genblk1
// as the first nested scope inside g1
if (1) logic a; // top.g1[0].genblk1.a
end
// The following generate block is implicitly named genblk4 since
// it belongs to the fourth generate construct in scope "top".
// The previous generate block would have been
// named genblk3 if it had not been explicitly named g1
for (i = 0; i < 1; i = i + 1)
// The following generate block is implicitly named genblk1
// as the first nested generate block in genblk4
if (1) logic a; // top.genblk4[0].genblk1.a
// The following generate block is implicitly named genblk5
if (1) logic a; // top.genblk5.a
endmodule
796
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
28. Gate-level and switch-level modeling
28.1 General
This clause describes the following:
— Gate and switch primitives
— Logic strength modeling
— Gate and net delays
28.2 Overview
This clause describes the syntax and semantics of the built-in primitives of gate- and switch-level modeling
and how a hardware design can be described using these primitives.
There are 14 logic gates and 12 switches predefined in the SystemVerilog to provide the gate- and
switch-level modeling facility. Modeling with logic gates and switches has the following advantages:
— Gates provide a much closer one-to-one mapping between the actual circuit and the model.
— There is no continuous assignment equivalent to the bidirectional transfer gate.
28.3 Gate and switch declaration syntax
Syntax28-1 shows the gate and switch declaration syntax.
A gate or a switch instance declaration shall have the following specifications:
— The keyword that names the type of gate or switch primitive
— An optional drive strength
— An optional propagation delay
— An optional identifier that names each gate or switch instance
— An optional range for array of instances
— The terminal connection list
Multiple instances of the one type of gate or switch primitive can be declared as a comma-separated list. All
such instances shall have the same drive strength and delay specification.
gate_instantiation ::= // from A.3.1
cmos_switchtype [delay3] cmos_switch_instance { cmos_switch_instance }
, ;
| enable_gatetype [drive_strength] [delay3] enable_gate_instance { enable_gate_instance }
, ;
| mos_switchtype [delay3] mos_switch_instance { mos_switch_instance }
, ;
| n_input_gatetype [drive_strength] [delay2] n_input_gate_instance { n_input_gate_instance }
, ;
| n_output_gatetype [drive_strength] [delay2] n_output_gate_instance
{ n_output_gate_instance }
, ;
| pass_en_switchtype [delay2] pass_enable_switch_instance { pass_enable_switch_instance }
, ;
| pass_switchtype pass_switch_instance { pass_switch_instance }
, ;
| [pulldown_strength] pull_gate_instance { pull_gate_instance }
pulldown , ;
| [pullup_strength] pull_gate_instance { pull_gate_instance }
pullup , ;
cmos_switch_instance ::= [ name_of_instance ] output_terminal input_terminal
( , ,
ncontrol_terminal pcontrol_terminal
, )
797
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
enable_gate_instance ::= [ name_of_instance ] output_terminal input_terminal enable_terminal
( , , )
mos_switch_instance ::= [ name_of_instance ] output_terminal input_terminal enable_terminal
( , , )
n_input_gate_instance ::= [ name_of_instance ] output_terminal input_terminal { input_terminal }
( , , )
n_output_gate_instance ::= [ name_of_instance ] output_terminal { output_terminal }
( , ,
input_terminal
)
pass_switch_instance ::= [ name_of_instance ] inout_terminal inout_terminal
( , )
pass_enable_switch_instance ::= [ name_of_instance ] inout_terminal inout_terminal
( , ,
enable_terminal
)
pull_gate_instance ::= [ name_of_instance ] output_terminal
( )
pulldown_strength ::= // from A.3.2
strength0 strength1
( , )
| strength1 strength0
( , )
| strength0
( )
pullup_strength ::=
strength0 strength1
( , )
| strength1 strength0
( , )
| strength1
( )
enable_terminal ::= expression // from A.3.3
inout_terminal ::= net_lvalue
input_terminal ::= expression
ncontrol_terminal ::= expression
output_terminal ::= net_lvalue
pcontrol_terminal ::= expression
cmos_switchtype ::= | // from A.3.4
cmos rcmos
enable_gatetype ::= | | |
bufif0 bufif1 notif0 notif1
mos_switchtype ::= | | |
nmos pmos rnmos rpmos
n_input_gatetype ::= | | | | |
and nand or nor xor xnor
n_output_gatetype ::= |
buf not
pass_en_switchtype ::= | | |
tranif0 tranif1 rtranif1 rtranif0
pass_switchtype ::= |
tran rtran
name_of_instance ::= instance_identifier { unpacked_dimension } // from A.4.1.1
Syntax28-1—Syntax for gate instantiation (excerpt from AnnexA)
28.3.1 The gate type specification
A gate or switch instance declaration shall begin with the keyword that specifies the gate or switch primitive
being used by the instances that follow in the declaration. Table28-1 lists the keywords that shall begin a
gate or a switch instance declaration.
Explanations of the built-in gates and switches shown in Table28-1 begin in 28.4.
798
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table28-1—Built-in gates and switches
Three-state Bidirectional
n_input gates n_output gates Pull gates MOS switches
gates switches
and buf bufif0 pulldown cmos rtran
nand not bufif1 pullup nmos rtranif0
nor notif0 pmos rtranif1
or notif1 rcmos tran
xnor rnmos tranif0
xor rpmos tranif1
28.3.2 The drive strength specification
An optional drive strength specification shall specify the strength of the logic values on the output terminals
of the gate instance. Only the instances of the gate primitives shown in Table28-2 can have the drive
strength specification.
Table28-2—Valid gate types for strength specifications
and nand buf not pulldown
or nor bufif0 notif0 pullup
—
xor xnor bufif1 notif1
The drive strength specification for a gate instance, with the exception of and , shall have
pullup pulldown
a strength1 specification and a strength0 specification. The strength1 specification shall specify the strength
of signals with a logic value 1, and the strength0 specification shall specify the strength of signals with a
logic value 0. The strength specification shall follow the gate type keyword and precede any delay
specification. The strength0 specification can precede or follow the strength1 specification. The strength1
and strength0 specifications shall be separated by a comma and enclosed within a pair of parentheses.
The gate shall have one of the following: no strength specification, only a strength1 specification,
pullup
or both strength1 and strength0 specifications. The gate shall have one of the following: no
pulldown
strength specification, only a strength0 specification, or both strength1 and strength0 specifications. See
28.10 for more details.
The strength1 specification shall be one of the following keywords:
supply1 strong1 pull1 weak1
The strength0 specification shall be one of the following keywords:
supply0 strong0 pull0 weak0
Specifying as strength1 shall cause the gate or switch to output a logic value in place of a .
highz1 z 1
Specifying shall cause the gate to output a logic value in place of a . The strength specifications
highz0 z 0
and shall be considered invalid.
(highz0, highz1) (highz1, highz0)
799
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In the absence of a strength specification, the instances shall have the default strengths and
strong1
.
strong0
The following example shows a drive strength specification in a declaration of an open collector gate:
nor
nor (highz1,strong0) n1(out1,in1,in2);
In this example, the gate outputs a in place of a .
nor z 1
Logic strength modeling is discussed in more detail in 28.11 through 28.15.
28.3.3 The delay specification
An optional delay specification shall specify the propagation delay through the gates and switches in a
declaration. Gates and switches in declarations with no delay specification shall have no propagation delay.
A delay specification can contain up to three delay values, depending on the gate type. The and
pullup
instance declarations shall not include delay specifications. Delays are discussed in more detail
pulldown
in 28.16.
28.3.4 The primitive instance identifier
An optional name can be given to a gate or switch instance. If multiple instances are declared as an array of
instances, an identifier shall be used to name the instances.
28.3.5 The range specification
There are many situations when repetitive instances are required. These instances shall differ from each
other only by the index of the vector to which they are connected.
In order to specify an array of instances, the instance name shall be followed by the range specification. The
range shall be specified by two constant expressions, left-hand index ( ) and right-hand index ( ),
lhi rhi
separated by a colon and enclosed within a pair of square brackets. A range specification shall
[lhi:rhi]
represent an array of instances. Neither of the two constant expressions are required to be
abs(lhi-rhi)+1
zero, and is not required to be larger than . If both constant expressions are equal, only one instance
lhi rhi
shall be generated.
An array of instances shall have a continuous range. One instance identifier shall be associated with only
one range to declare an array of instances.
The range specification shall be optional. If no range specification is given, a single instance shall be
created.
For example:
The following declaration is illegal:
nand #2 t_nand[0:3] ( ... ), t_nand[4:7] ( ... );
It could be declared correctly as one array of eight instances or as two arrays with unique names of four
elements each, as follows:
nand #2 t_nand[0:7]( ... );
nand #2 x_nand[0:3] ( ... ), y_nand[4:7] ( ... );
800
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
28.3.6 Primitive instance connection list
The terminal list describes how the gate or switch connects to the rest of the model. The gate or switch type
can limit these expressions. The connection list shall be enclosed in a pair of parentheses, and the terminals
shall be separated by commas. The output or bidirectional terminals shall always come first in the terminal
list, followed by the input terminals.
The terminal connections for an array of instances shall follow these rules:
— The bit length of each port expression in the declared instance-array shall be compared with the bit
length of each single-instance port or terminal in the instantiated module or primitive.
— For each port or terminal where the bit length of the instance-array port expression is the same as the
bit length of the single-instance port, the instance-array port expression shall be connected to each
single-instance port.
— If the instance-array port expression is an port or net expression,
interconnect interconnect
the bit-length of the port expression shall be the same as the instance array length.
— If bit lengths are different, each instance shall get a part-select of the port expression, of a bit length
equal to the instance port bit length. The LSB of the port expression shall be connected to the
instance corresponding to the right-hand index of the array range.
— Too many or too few bits to connect to all the instances shall be considered an error.
An individual instance from an array of instances shall be referenced in the same manner as referencing an
element of an array of types.
logic
For example:
Example 1: The following declaration of declares four instances that can be referenced by
nand_array
, , , and , respectively.
nand_array[1] nand_array[2] nand_array[3] nand_array[4]
nand #2 nand_array[1:4]( ... ) ;
Example 2: The two module descriptions that follow are equivalent except for indexed instance names, and
they demonstrate the range specification and connection rules for declaring an array of instances:
module driver (in, out, en);
input [3:0] in;
output [3:0] out;
input en;
bufif0 ar[3:0] (out, in, en); // array of three-state buffers
endmodule
module driver_equiv (in, out, en);
input [3:0] in;
output [3:0] out;
input en;
bufif0 ar3 (out[3], in[3], en); // each buffer declared separately
bufif0 ar2 (out[2], in[2], en);
bufif0 ar1 (out[1], in[1], en);
bufif0 ar0 (out[0], in[0], en);
endmodule
801
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 3: The two module descriptions that follow are equivalent except for indexed instance names, and
they demonstrate how different instances within an array of instances are connected when the port sizes do
not match:
module busdriver (busin, bushigh, buslow, enh, enl);
input [15:0] busin;
output [ 7:0] bushigh, buslow;
input enh, enl;
driver busar3 (busin[15:12], bushigh[7:4], enh);
driver busar2 (busin[11:8], bushigh[3:0], enh);
driver busar1 (busin[7:4], buslow[7:4], enl);
driver busar0 (busin[3:0], buslow[3:0], enl);
endmodule
module busdriver_equiv (busin, bushigh, buslow, enh, enl);
input [15:0] busin;
output [ 7:0] bushigh, buslow;
input enh, enl;
driver busar[3:0] (.out({bushigh, buslow}), .in(busin),
.en({enh, enh, enl, enl}));
endmodule
Example 4: This example demonstrates how a series of modules can be chained together. Figure28-1 shows
an equivalent schematic interconnection of DFF instances.
module dffn (q, d, clk);
parameter bits = 1;
input [bits-1:0] d;
output [bits-1:0] q;
input clk ;
DFF dff[bits-1:0] (q, d, clk); // create a row of D flip-flops
endmodule
module MxN_pipeline (in, out, clk);
parameter M = 3, N = 4; // M=width,N=depth
input [M-1:0] in;
output [M-1:0] out;
input clk;
wire [M*(N-1):1] t;
// #(M) redefines the bits parameter for dffn
// create p[1:N] columns of dffn rows (pipeline)
dffn #(M) p[1:N] ({out, t}, {t, in}, clk);
endmodule
802
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
p[4] p[3] p[2] p[1]
t[3] t[6] t[9] out[2]
in[2]
dff[2] dff[2] dff[2] dff[2]
in[2:0] t[2] t[5] t[8]
out[2:0]
in[1]
dff[1] dff[1] dff[1] dff[1] out[1]
clk
t[1] t[4] t[7]
in[0]
out[0]
dff[0] dff[0] dff[0] dff[0]
Figure28-1—Schematic diagram of interconnections in array of instances
28.4 and, nand, nor, or, xor, and xnor gates
The instance declaration of a multiple input logic gate shall begin with one of the following keywords:
and nand nor or xor xnor
The delay specification shall be zero, one, or two delays. If the specification contains two delays, the first
delay shall determine the output rise delay, the second delay shall determine the output fall delay, and the
smaller of the two delays shall apply to output transitions to . If only one delay is specified, it shall specify
x
both the rise delay and the fall delay. If there is no delay specification, there shall be no propagation delay
through the gate.
These six logic gates shall have one output and one or more inputs. The first terminal in the terminal list
shall connect to the output of the gate and all other terminals connect to its inputs.
The truth tables for these gates, showing the result of two input values, appear in Table28-3.
803
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table28-3—Truth tables for multiple input logic gates
and 0 1 x z or 0 1 x z xor 0 1 x z
0 0 0 0 0 0 0 1 x x 0 0 1 x x
1 0 1 x x 1 1 1 1 1 1 1 0 x x
x 0 x x x x x 1 x x x x x x x
z 0 x x x z x 1 x x z x x x x
nand 0 1 x z nor 0 1 x z xnor 0 1 x z
0 1 1 1 1 0 1 0 x x 0 1 0 x x
1 1 0 x x 1 0 0 0 0 1 0 1 x x
x 1 x x x x x 0 x x x x x x x
z 1 x x x z x 0 x x z x x x x
Versions of these six logic gates having more than two inputs shall have a natural extension, but the number
of inputs shall not alter propagation delays.
The following example declares a two-input gate:
and
and a1 (out, in1, in2);
The inputs are and . The output is . The instance name is .
in1 in2 out a1
28.5 buf and not gates
The instance declaration of a multiple output logic gate shall begin with one of the following keywords:
buf not
The delay specification shall be zero, one, or two delays. If the specification contains two delays, the first
delay shall determine the output rise delay, the second delay shall determine the output fall delay, and the
smaller of the two delays shall apply to output transitions to . If only one delay is specified, it shall specify
x
both the rise delay and the fall delay. If there is no delay specification, there shall be no propagation delay
through the gate.
These two logic gates shall have one input and one or more outputs. The last terminal in the terminal list
shall connect to the input of the logic gate, and the other terminals shall connect to the outputs of the logic
gate.
Truth tables for these logic gates with one input and one output are shown in Table28-4.
804
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table28-4—Truth tables for multiple output logic gates
buf not
input output input output
0 0 0 1
1 1 1 0
x x x x
z x z x
The following example declares a two-output :
buf
buf b1 (out1, out2, in);
The input is The outputs are and . The instance name is .
in. out1 out2 b1
28.6 bufif1, bufif0, notif1, and notif0 gates
The instance declaration of these three-state logic gates shall begin with one of the following keywords:
bufif0 bufif1 notif1 notif0
These four logic gates model three-state drivers. In addition to logic values and , these gates can output .
1 0 z
The delay specification shall be zero, one, two, or three delays. If the delay specification contains three
delays, the first delay shall determine the rise delay, the second delay shall determine the fall delay, the third
delay shall determine the delay of transitions to , and the smallest of the three delays shall determine the
z
delay of transitions to . If the specification contains two delays, the first delay shall determine the output
x
rise delay, the second delay shall determine the output fall delay, and the smaller of the two delays shall
apply to output transitions to and . If only one delay is specified, it shall specify the delay for all output
x z
transitions. If there is no delay specification, there shall be no propagation delay through the gate.
Some combinations of data input values and control input values can cause these gates to output either of
two values, without a preference for either value (see ). The logic tables for these gates include two symbols
representing such unknown results. The symbol shall represent a result that has a value or . The symbol
L 0 z
shall represent a result that has a value or . Delays on transitions to or shall be treated the same as
H 1 z H L
delays on transitions to .
x
These four logic gates shall have one output, one data input, and one control input. The first terminal in the
terminal list shall connect to the output, the second terminal shall connect to the data input, and the third
terminal shall connect to the control input.
Table28-5 presents the logic tables for these gates.
805
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table28-5—Truth tables for three-state logic gates
CONTROL CONTROL
bufif0 bufif1
0 1 x z 0 1 x z
D 0 0 z L L D 0 z 0 L L
A 1 1 z H H A 1 z 1 H H
T x x z x x T x z x x x
A z x z x x A z z x x x
CONTROL CONTROL
notif0 notif1
0 1 x z 0 1 x z
D 0 1 z H H D 0 z 1 H H
A 1 0 z L L A 1 z 0 L L
T x x z x x T x z x x x
A z x z x x A z z x x x
The following example declares an instance of :
bufif1
bufif1 bf1 (outw, inw, controlw);
The output is , the input is , and the control is . The instance name is .
outw inw controlw bf1
28.7 MOS switches
The instance declaration of a metal-oxide semiconductor (MOS) switch shall begin with one of the
following keywords:
cmos nmos pmos rcmos rnmos rpmos
The and switches are described in 28.9.
cmos rcmos
The keyword stands for the P-type metal-oxide semiconductor (PMOS) transistor and the
pmos nmos
keyword stands for the N-type metal-oxide semiconductor (NMOS) transistor. PMOS and NMOS transistors
have relatively low impedance between their sources and drains when they conduct. The keyword
rpmos
stands for resistive PMOS transistor and the keyword stands for resistive NMOS transistor. Resistive
rnmos
PMOS and resistive NMOS transistors have significantly higher impedance between their sources and
drains when they conduct than PMOS and NMOS transistors have. The load devices in static MOS networks
are examples of and transistors. These four switches are unidirectional channels for data
rpmos rnmos
similar to the gates.
bufif
The delay specification shall be zero, one, two, or three delays. If the delay specification contains three
delays, the first delay shall determine the rise delay, the second delay shall determine the fall delay, the third
delay shall determine the delay of transitions to , and the smallest of the three delays shall determine the
z
806
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
delay of transitions to . If the specification contains two delays, the first delay shall determine the output
x
rise delay, the second delay shall determine the output fall delay, and the smaller of the two delays shall
apply to output transitions to and . If only one delay is specified, it shall specify the delay for all output
x z
transitions. If there is no delay specification, there shall be no propagation delay through the switch.
Some combinations of data input values and control input values can cause these switches to output either of
two values, without a preference for either value. The logic tables for these switches include two symbols
representing such unknown results. The symbol represents a result that has a value or . The symbol
L 0 z H
represents a result that has a value or . Delays on transitions to and shall be the same as delays on
1 z H L
transitions to .
x
These four switches shall have one output, one data input, and one control input. The first terminal in the
terminal list shall connect to the output, the second terminal shall connect to the data input, and the third
terminal shall connect to the control input.
The and switches shall pass signals from their inputs and through their outputs with a change in
nmos pmos
the strength of the signal in only one case, as discussed in 28.15.1. The and switches shall
rnmos rpmos
reduce the strength of signals that propagate through them, as discussed in 28.14.
Table28-6 presents the logic tables for these switches.
Table28-6—Truth tables for MOS switches
CONTROL CONTROL
pmos nmos
rpmos rnmos
0 1 x z 0 1 x z
D 0 0 z L L D 0 z 0 L L
A 1 1 z H H A 1 z 1 H H
T x x z x x T x z x x x
A z z z z z A z z z z z
The following example declares a switch:
pmos
pmos p1 (out, data, control);
The output is , the data input is , and the control input is . The instance name is .
out data control p1
28.8 Bidirectional pass switches
The instance declaration of a bidirectional pass switch shall begin with one of the following keywords:
tran tranif1 tranif0
rtran rtranif1 rtranif0
The bidirectional pass switches shall not delay signals propagating through them. When ,
tranif0
, , or devices are turned off, they shall block signals; and when they are
tranif1 rtranif0 rtranif1
turned on, they shall pass signals. The and devices cannot be turned off; they shall always pass
tran rtran
signals.
807
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The delay specifications for , , , and devices shall be zero, one, or
tranif1 tranif0 rtranif1 rtranif0
two delays. If the specification contains two delays, the first delay shall determine the turn-on delay, the
second delay shall determine the turn-off delay, and the smaller of the two delays shall apply to output
transitions to and . If only one delay is specified, it shall specify both the turn-on and the turn-off delays.
x z
If there is no delay specification, there shall be no turn-on or turn-off delay for the bidirectional pass switch.
The bidirectional pass switches and shall not accept delay specification.
tran rtran
The , , , and devices shall have three items in their terminal lists.
tranif1 tranif0 rtranif1 rtranif0
The first two shall be bidirectional terminals that conduct signals to and from the devices, and the third
terminal shall connect to a control input. The and devices shall have terminal lists containing
tran rtran
two bidirectional terminals. Both bidirectional terminals shall unconditionally conduct signals to and from
the devices, allowing signals to pass in either direction through the devices. The bidirectional terminals of all
six devices shall be connected only to scalar nets or bit-selects of vector nets.
The , , and devices shall pass signals with an alteration in their strength in only one
tran tranif0 tranif1
case, as discussed in 28.15.1. The , , and devices shall reduce the strength of the
rtran rtranif0 rtranif1
signals passing through them according to rules discussed in 28.14.
The following example declares an instance of :
tranif1
tranif1 t1 (inout1,inout2,control);
The bidirectional terminals are and . The control input is . The instance name is
inout1 inout2 control
.
t1
28.9 CMOS switches
The instance declaration of a CMOS switch shall begin with one of the following keywords:
cmos rcmos
The delay specification shall be zero, one, two, or three delays. If the delay specification contains three
delays, the first delay shall determine the rise delay, the second delay shall determine the fall delay, the third
delay shall determine the delay of transitions to , and the smallest of the three delays shall determine the
z
delay of transitions to . Delays in transitions to or are the same as delays in transitions to . If the
x H L x
specification contains two delays, the first delay shall determine the output rise delay, the second delay shall
determine the output fall delay, and the smaller of the two delays shall apply to output transitions to and .
x z
If only one delay is specified, it shall specify the delay for all output transitions. If there is no delay
specification, there shall be no propagation delay through the switch.
The and switches shall have a data input, a data output, and two control inputs. In the terminal
cmos rcmos
list, the first terminal shall connect to the data output, the second terminal shall connect to the data input, the
third terminal shall connect to the n-channel control input, and the last terminal shall connect to the
p-channel control input.
The gate shall pass signals with an alteration in their strength in only one case, as discussed in 28.15.1.
cmos
The gate shall reduce the strength of signals passing through it according to rules described in 28.14.
rcmos
The switch shall be treated as the combination of a switch and an switch. The
cmos pmos nmos rcmos
switch shall be treated as the combination of an switch and an switch. The combined switches
rpmos rnmos
in these configurations shall share data input and data output terminals, but they shall have separate control
inputs.
808
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The equivalence of the gate to the pairing of an gate and a gate is shown in the following
cmos nmos pmos
example:
cmos (w, datain, ncontrol, pcontrol);
ncontrol
nmos
is equivalent to:
w datain
pmos
nmos (w, datain, ncontrol);
pmos (w, datain, pcontrol);
pcontrol
28.10 pullup and pulldown sources
The instance declaration of a pullup or a pulldown source shall begin with one of the following keywords:
pullup pulldown
A source shall place a logic value on the nets connected in its terminal list. A source
pullup 1 pulldown
shall place a logic value on the nets connected in its terminal list.
0
The signals that these sources place on nets shall have strength in the absence of a strength
pull
specification. If there is a strength1 specification on a source or a strength0 specification on a
pullup
source, the signals shall have the strength specified. A strength0 specification on a
pulldown pullup
source and a strength1 specification on a source shall be ignored.
pulldown
There shall be no delay specifications for these sources.
The following example declares two instances:
pullup
pullup (strong1) p1 (neta), p2 (netb);
In this example, the instance drives and the instance drives with strength.
p1 neta p2 netb strong
28.11 Logic strength modeling
SystemVerilog provides for accurate modeling of signal contention, bidirectional pass gates, resistive MOS
devices, dynamic MOS, charge sharing, and other technology-dependent network configurations by
allowing scalar net signal values to have a full range of unknown values and different levels of strength or
combinations of levels of strength. This multiple-level logic strength modeling resolves combinations of
signals into known or unknown values to represent the behavior of hardware with improved accuracy.
A strength specification shall have the following two components:
a) The strength of the 0 portion of the net value, called strength0, designated as one of the following:
supply0 strong0 pull0 weak0 highz0
b) The strength of the 1 portion of the net value, called strength1, designated as one of the following:
supply1 strong1 pull1 weak1 highz1
809
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The combinations and shall be considered illegal.
(highz0, highz1) (highz1, highz0)
Despite this division of the strength specification, it is helpful to consider strength as a property occupying
regions of a continuum in order to predict the results of combinations of signals.
Table28-7 demonstrates the continuum of strengths. The left column lists the keywords used in specifying
strengths. The right column gives correlated strength levels.
Table28-7—Strength levels for scalar net signal values
Strength name Strength level
supply0 7
strong0 6
pull0 5
large0 4
weak0 3
medium0 2
small0 1
highz0 0
highz1 0
small1 1
medium1 2
weak1 3
large1 4
pull1 5
strong1 6
supply1 7
In Table28-7, there are four driving strengths:
supply strong pull weak
Signals with driving strengths shall propagate from gate outputs and continuous assignment outputs.
In Table28-7, there are three charge storage strengths:
large medium small
Signals with the charge storage strengths shall originate in the net type.
trireg
It is possible to think of the strengths of signals in Table28-7 as locations on the scale in Figure28-2.
810
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-2—Scale of strengths
Discussions of signal combinations later in this clause employ graphics similar to those used in Figure28-2.
If the signal value of a net is known, all of its strength levels shall be in either the strength0 part of the scale
represented by Figure28-2, or all strength levels shall be in its strength1 part. If the signal value of a net is
unknown, it shall have strength levels in both the strength0 and the strength1 parts. A net with a signal value
shall have a strength level only in one of the 0 subdivisions of the parts of the scale.
z
28.12 Strengths and values of combined signals
In addition to a signal value, a net shall have either a single unambiguous strength level or an ambiguous
strength consisting of more than one level. When signals combine, their strengths and values shall determine
the strength and value of the resulting signal in accordance with the principles in 28.12.1 through 28.12.4.
Nets with user-defined nettypes shall not have strength levels.
Combining signal values for nets with user-defined nettypes shall follow the rules in 6.6.7. Any strength
associated with any drivers of a net with a user-defined shall be ignored.
nettype
28.12.1 Combined signals of unambiguous strength
This subclause deals with combinations of signals in which each signal has a known value and a single
strength level.
If two or more signals of unequal strength combine in a wired net configuration, the stronger signal shall
dominate all the weaker drivers and determine the result. The combination of two or more signals of like
value shall result in the same value with the greater of all the strengths. The combination of signals identical
in strength and value shall result in the same signal.
The combination of signals with unlike values and the same strength can have three possible results. Two of
the results occur in the presence of wired logic, and the third occurs in its absence. Wired logic is discussed
in 28.12.4. The result in the absence of wired logic is the subject of Figure28-4 (in 28.12.2).
In Figure28-3, the numbers in parentheses indicate the relative strengths of the signals. The combination of
a and a results in a , which is the stronger of the two signals.
pull1 strong0 strong0
Pu1(5)
St0(6)
St0(6)
Su1(7)
Su1(7)
La1(4)
Figure28-3—Combining unequal strengths
811
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
28.12.2 Ambiguous strengths: sources and combinations
There are several classifications of signals possessing ambiguous strengths, as follows:
— Signals with known values and multiple strength levels
— Signals with a value , which have strength levels consisting of subdivisions of both the strength1
x
and the strength0 parts of the scale of strengths in Figure28-2
— Signals with a value , which have strength levels that consist of high impedance joined with
L
strength levels in the strength0 part of the scale of strengths in Figure28-2
— Signals with a value , which have strength levels that consist of high impedance joined with
H
strength levels in the strength1 part of the scale of strengths in Figure28-2
Many configurations can produce signals of ambiguous strength. When two signals of equal strength and
opposite value combine, the result shall be a value , along with the strength levels of both signals and all
x
the smaller strength levels.
Figure28-4 shows the combination of a signal with a value and a signal with a value
weak 1 weak
yielding a signal with strength and a value .
0 weak x
We1
WeX
We0
Figure28-4—Combination of signals of equal strength and opposite values
This output signal is described in Figure28-5.
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0 HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-5—Weak x signal strength
An ambiguous signal strength can be a range of possible values. An example is the strength of the output
from the three-state drivers with unknown control inputs as shown in Figure28-6.
812
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
X
bufif1
St1 StH
X
bufif0
We0 StL
Figure28-6—Bufifs with control inputs of x
The output of the in Figure28-6 is a , composed of the range of values described in
bufif1 strong H
Figure28-7.
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-7—Strong H range of values
The output of the in Figure28-6 is a , composed of the range of values described in
bufif0 strong L
Figure28-8.
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-8—Strong L range of values
The combination of two signals of ambiguous strength shall result in a signal of ambiguous strength. The
resulting signal shall have a range of strength levels that includes the strength levels in its component
signals. The combination of outputs from two three-state drivers with unknown control inputs, shown in
Figure28-9, is an example.
813
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
X
PuH
Pu1
X
35X
We0
WeL
Figure28-9—Combined signals of ambiguous strength
In Figure28-9, the combination of signals of ambiguous strengths produces a range that includes the
extremes of the signals and all the strengths between them, as described in Figure28-10.
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-10—Range of strengths for an unknown signal
The result is a value because its range includes the values and . The number , which precedes the ,
x 1 0 35 x
is a concatenation of two digits. The first is the digit 3, which corresponds to the highest strength0 level for
the result. The second digit, 5, corresponds to the highest strength1 level for the result.
Switch networks can produce a ranges of strengths of the same value, such as the signals from the upper and
lower configurations in Figure28-11.
Vcc pullup
logic b = x
Pu1(5)
651
logic a = 1 (6)
logic g = x
56X
Pu0 (5)
530
logic d = 0
and
We0 (3)
logic d = 0
pulldown ground
Figure28-11—Ambiguous strengths from switch networks
814
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In Figure28-11, the upper combination of a type, a gate controlled by a type of unspecified
logic logic
value, and a pullup produces a signal with a value of 1 and a range of strengths ( ) described in
651
Figure28-12.
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0 HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-12—Range of two strengths of a defined value
In Figure28-11, the lower combination of a , a gate controlled by a type of unspecified
pulldown logic
value, and an gate produces a signal with a value and a range of strengths ( ) described in
and 0 530
Figure28-13.
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0 HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-13—Range of three strengths of a defined value
When the signals from the upper and lower configurations in Figure28-11 combine, the result is an
unknown with a range ( ) determined by the extremes of the two signals shown in Figure28-14.
56x
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0 HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-14—Unknown value with a range of strengths
In Figure28-11, replacing the in the lower configuration with a would change the
pulldown supply0
range of the result to the range ( ) described in Figure28-15.
StX
The range in Figure28-15 is because it is unknown and the extremes of both its components are
strongx
. The extreme of the output of the lower configuration is because the lower reduces
strong strong pmos
the strength of the signal. This modeling feature is discussed in 28.15.1.
supply0
815
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0 HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-15—Strong X range
Logic gates produce results with ambiguous strengths as well as three-state drivers. Such a case appears in
Figure28-16. The gate is declared with strength, and is declared with strength.
and N1 highz0 N2 weak0
( , ) N1(a,b);
a=1 StH and strong1 highz0
N1 ( , ) N2(c,d);
and strong1 weak0
b=X
36X
c=0
N2
d=0 We0
Figure28-16—Ambiguous strength from gates
In Figure28-16, type has an unspecified value; therefore, input to the upper gate is .
logic b and strongx
The upper gate has a strength specification including . The signal from the upper gate is a
and highz0 and
composed of the values as described in Figure28-17.
strongH
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0 HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-17—Ambiguous strength signal from a gate
is part of the result because the strength specification for the gate in question specified that strength for
HiZ0
an output with a value . A strength specification other than high impedance for the value output results in
0 0
a gate output value . The output of the lower gate is a as described in Figure28-18.
x and weak0
816
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0 HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-18—Weak 0
When the signals combine, the result is the range ( ) as described in Figure28-19.
36x
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0 HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-19—Ambiguous strength in combined gate signals
Figure28-19 presents the combination of an ambiguous signal and an unambiguous signal. Such
combinations are the topic of 28.12.3.
28.12.3 Ambiguous strength signals and unambiguous signals
The combination of a signal with unambiguous strength and known value with another signal of ambiguous
strength presents several possible cases. To understand a set of rules governing this type of combination, it is
necessary to consider the strength levels of the ambiguous strength signal separately from each other and
relative to the unambiguous strength signal. When a signal of known value and unambiguous strength
combines with a component of a signal of ambiguous strength, the rules shall be as follows:
a) The strength levels of the ambiguous strength signal that are greater than the strength level of the
unambiguous signal shall remain in the result.
b) The strength levels of the ambiguous strength signal that are smaller than or equal to the strength
level of the unambiguous signal shall disappear from the result, subject to rule c).
c) If the operation of rule a) and rule b) results in a gap in strength levels because the signals are of
opposite value, the signals in the gap shall be part of the result.
The following figures show some applications of the rules.
In Figure28-20, the strength levels in the ambiguous strength signal that are smaller than or equal to the
strength level of the unambiguous strength signal disappear from the result, demonstrating rule b).
817
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Combining the two signals above results in the following signal:
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-20—Elimination of strength levels
In Figure28-21, rule a), rule b), and rule c) apply. The strength levels of the ambiguous strength signal that
are of opposite value and lesser strength than the unambiguous strength signal disappear from the result. The
strength levels in the ambiguous strength signal that are less than the strength level of the unambiguous
strength signal, and of the same value, disappear from the result. The strength level of the unambiguous
strength signal and the greater extreme of the ambiguous strength signal define a range in the result.
In Figure28-22, rule a) and rule b) apply. The strength levels in the ambiguous strength signal that are less
than the strength level of the unambiguous strength signal disappear from the result. The strength level of
the unambiguous strength signal and the strength level at the greater extreme of the ambiguous strength
signal define a range in the result.
In Figure28-23, rule a), rule b), and rule c) apply. The greater extreme of the range of strengths for the
ambiguous strength signal is larger than the strength level of the unambiguous strength signal. The result is a
range defined by the greatest strength in the range of the ambiguous strength signal and by the strength level
of the unambiguous strength signal.
818
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Combining the two signals above results in the following signal:
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-21—Result showing a range and the elimination of strength levels of two values
819
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Combining the two signals above results in the following signal:
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-22—Result showing a range and the elimination of strength levels of one value
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Combining the two signals above results in the following signal:
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-23—A range of both values
820
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
28.12.4 Wired logic net types
The net types , , , and shall resolve conflicts when multiple drivers have the same
triand wand trior wor
strength. These net types shall resolve signal values by treating signals as inputs of logic functions.
Consider the combination of two signals of unambiguous strength in Figure28-24.
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
wired AND logic value result: 0
wired OR logic value result: 1
Figure28-24—Wired logic with unambiguous strength signals
The combination of the signals in Figure28-24, using wired and logic, produces a result with the same value
as the result produced by an gate with the value of the two signals as its inputs. The combination of
and
signals using wired or logic produces a result with the same value as the result produced by an gate with
or
the values of the two signals as its inputs. The strength of the result is the same as the strength of the
combined signals in both cases. If the value of the upper signal changes so that both signals in Figure28-24
possess a value , then the results of both types of logic have a value .
1 1
When ambiguous strength signals combine in wired logic, it is necessary to consider the results of all
combinations of each of the strength levels in the first signal with each of the strength levels in the second
signal, as shown in Figure28-25.
821
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Signal 1
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Signal 2
The combinations of strength levels for and logic appear in the following chart:
signal1 signal2 result
strength value strength value strength value
5 0 5 1 5 0
6 0 5 1 6 0
The result is the following signal:
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
The combinations of strength levels for or logic appear in the following chart:
signal1 signal2 result
strength value strength value strength value
5 0 5 1 5 1
6 0 5 1 6 0
The result is the following signal:
strength0 strength1
7 6 5 4 3 2 1 0 0 1 2 3 4 5 6 7
Su0 St0 Pu0 La0 We0 Me0 Sm0 HiZ0HiZ1 Sm1 Me1 We1 La1 Pu1 St1 Su1
Figure28-25—Wired logic and ambiguous strengths
822
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
28.13 Strength reduction by nonresistive devices
The , , and switches shall pass the strength from the data input to the output, except that a
nmos pmos cmos
strength shall be reduced to a strength.
supply strong
The , , and switches shall not affect signal strength across the bidirectional
tran tranif0 tranif1
terminals, except that a strength shall be reduced to a strength.
supply strong
28.14 Strength reduction by resistive devices
The , , , , , and devices shall reduce the strength of signals
rnmos rpmos rcmos rtran rtranif1 rtranif0
that pass through them according to Table28-8.
Table28-8—Strength reduction rules
Inputstrength Reducedstrength
Supplydrive Pulldrive
Strongdrive Pulldrive
Pulldrive Weakdrive
Largecapacitor Mediumcapacitor
Weak drive Mediumcapacitor
Mediumcapacitor Smallcapacitor
Smallcapacitor Smallcapacitor
Highimpedance Highimpedance
28.15 Strengths of net types
The , , , and net types shall generate signals with specific strength levels. The
tri0 tri1 supply0 supply1
declaration can specify either of two signal strength levels other than a default strength level.
trireg
28.15.1 tri0 and tri1 net strengths
The net type models a net connected to a resistive device. In the absence of an overriding
tri0 pulldown
source, such a signal shall have a value and a strength. The net type models a net connected to
0 pull tri1
a resistive device. In the absence of an overriding source, such a signal shall have a value and a
pullup 1
strength.
pull
28.15.2 trireg strength
The net type models charge storage nodes. The strength of the drive resulting from a net
trireg trireg
that is in the charge storage state (that is, a driver charged the net and then went to high impedance) shall be
one of these three strengths: , , or . The specific strength associated with a particular
large medium small
net shall be specified by the user in the net declaration. The default shall be . The syntax of
trireg medium
this specification is described in 6.7.
823
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
28.15.3 supply0 and supply1 net strengths
The net type models ground connections. The net type models connections to power
supply0 supply1
supplies. The and net types shall have driving strengths.
supply0 supply1 supply
28.16 Gate and net delays
Gate and net delays provide a means of more accurately describing delays through a circuit. The gate delays
specify the signal propagation delay from any gate input to the gate output. Up to three values per output
representing rise, fall, and turn-off delays can be specified (see 28.4 through 28.9).
Net delays refer to the time it takes from any driver on the net changing value to the time when the net value
is updated and propagated further. Up to three delay values per net can be specified.
For both gates and nets, the default delay shall be zero when no delay specification is given. When one delay
value is given, then this value shall be used for all propagation delays associated with the gate or the net.
When two delays are given, the first delay shall specify the rise delay, and the second delay shall specify the
fall delay. The delay when the signal changes to high impedance or to unknown shall be the lesser of the two
delay values.
Forathree-delayspecification
— The first delayreferstothetransitiontothe1value(rise delay).
— The second delay refers to the transition to the 0 value (fall delay).
— The third delay refers to the transition to the high-impedance value.
When a value changes to the unknown ( ) value, the delay is the smallest of the three delays. The strength of
x
the input signal shall not affect the propagation delay from an input to an output.
Table28-9 summarizes the from-to propagation delay choice for the two- and three-delay specifications.
Table28-9—Rules for propagation delays
Delayused if there are
Fromvalue: Tovalue:
2delays 3delays
0 1 d1 d1
0 x min(d1, d2) min(d1, d2, d3)
0 z min(d1, d2) d3
1 0 d2 d2
1 x min(d1, d2) min(d1, d2, d3)
1 z min(d1, d2) d3
x 0 d2 d2
x 1 d1 d1
x z min(d1, d2) d3
z 0 d2 d2
824
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table28-9—Rules for propagation delays (continued)
Delayused if there are
Fromvalue: Tovalue:
2delays 3delays
z 1 d1 d1
z x min(d1, d2) min(d1, d2, d3)
Example 1: The following is an example of a delay specification with one, two, and three delays:
and #(10) a1 (out, in1, in2); // only one delay
and #(10,12) a2 (out, in1, in2); // rise and fall delays
bufif0 #(10,12,11) b3 (out, in, ctrl); // rise, fall, and turn-off delays
Example 2: The following example specifies a simple latch module with three-state outputs, where
individual delays are given to the gates. The propagation delay from the inputs to the outputs of the module
will be cumulative, and it depends on the signal path through the network.
module tri_latch (qout, nqout, clock, data, enable);
output qout, nqout;
input clock, data, enable;
tri qout, nqout;
not #5 n1 (ndata, data);
nand #(3,5) n2 (wa, data, clock),
n3 (wb, ndata, clock);
nand #(12,15) n4 (q, nq, wa),
n5 (nq, q, wb);
bufif1 #(3,7,13) q_drive (qout, q, enable),
nq_drive (nqout, nq, enable);
endmodule
28.16.1 min:typ:max delays
The syntax for delays on gate primitives (including UDPs; see Clause29), nets, and continuous assignments
shall allow three values each for the rising, falling, and turn-off delays. The minimum, typical, and
maximum values for each delay shall be specified as expressions separated by colons. There shall be no
required relation (e.g., min  typ  max) between the expressions for minimum, typical, and maximum
delays. These can be any three expressions.
The following example shows values for rising, falling, and turn-off delays:
min:typ:max
module iobuf (io1, io2, dir);
. . .
bufif0 #(5:7:9, 8:10:12, 15:18:21) b1 (io1, io2, dir);
bufif1 #(6:8:10, 5:7:9, 13:17:19) b2 (io2, io1, dir);
. . .
endmodule
The syntax for delay controls in procedural statements (see 9.4) also allows minimum, typical, and
maximum values. These are specified by expressions separated by colons. The following example illustrates
this concept:
825
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
parameter min_hi = 97, typ_hi = 100, max_hi = 107;
logic clk;
always begin
#(95:100:105) clk = 1;
#(min_hi:typ_hi:max_hi) clk = 0;
end
28.16.2 trireg net charge decay
Like all nets, the delay specification in a net declaration can contain up to three delays. The first two
trireg
delays shall specify the delay for transition to the and logic states when the net is driven to these
1 0 trireg
states by a driver. The third delay shall specify the charge decay time instead of the delay in a transition to
the logic state. The charge decay time specifies the delay between when the drivers of a net turn
z trireg
off and when its stored charge can no longer be determined.
A net does not need a turn-off delay specification because a net never makes a transition to
trireg trireg
the logic state. When the drivers of a net make transitions from the , , or logic states to off,
z trireg 1 0 x
the net shall retain the previous , , or logic state that was on its drivers. The value shall not
trireg 1 0 x z
propagate from the drivers of a net to a net. A net can only hold a logic state
trireg trireg trireg z
when is the initial logic state of the net or when the trireg net is forced to the state with a
z trireg z force
statement (see 10.6.2).
A delay specification for charge decay models a charge storage node that is not ideal, i.e., a charge storage
node whose charge leaks out through its surrounding devices and connections.
The charge decay process and the delay specification for charge decay are described in 28.16.2.1 and
28.16.2.2, respectively.
28.16.2.1 Charge decay process
Charge decay is the cause of transition of a 1 or 0 that is stored in a net to an unknown value ( )
trireg x
after a specified delay. The charge decay process shall begin when the drivers of the net turn off and
trireg
the net starts to hold charge. The charge decay process shall end under the following two
trireg
conditions:
a) The delay specified by charge decay time elapses, and the net makes a transition from or
trireg 1
to .
0 x
b) The drivers of net turn on and propagate a , , or into the net.
trireg 1 0 x trireg
28.16.2.2 Delay specification for charge decay time
The third delay in a net declaration shall specify the charge decay time. A three-valued delay
trireg
specification in a net declaration shall have the following form:
trireg
#(d1, d2, d3) // (rise_delay, fall_delay, charge_decay_time)
The charge decay time specification in a net declaration shall be preceded by a rise and a fall delay
trireg
specification.
Example 1: The following example shows a specification of the charge decay time in a net
trireg
declaration:
trireg (large) #(0,0,50) cap1;
826
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
This example declares a net named . This net stores a charge. The delay
trireg cap1 trireg large
specifications for the rise delay is 0, the fall delay is 0, and the charge decay time specification is 50 time
units.
Example 2: The next example presents a source description file that contains a net declaration with
trireg
a charge decay time specification. Figure28-26 shows an equivalent schematic for the source description.
module capacitor;
logic data, gate;
// trireg declaration with a charge decay time of 50 time units
trireg (large) #(0,0,50) cap1;
nmos nmos1 (cap1, data, gate); // nmos that drives the trireg
initial begin
$monitor("%0d data=%v gate=%v cap1=%v", $time, data, gate, cap1);
data = 1;
// Toggle the driver of the control input to the nmos switch
gate = 1;
#10 gate = 0;
#30 gate = 1;
#10 gate = 0;
#100 $finish;
end
endmodule
gate
data
nmos1
trireg
Figure28-26—Trireg net with capacitance
827
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
29. User-defined primitives
29.1 General
This clause describes the following:
— User-defined primitive (UDP) definitions
— Combinational UDPs
— Level-sensitive sequential UDPs
— Edge-sensitive sequential UDPs
— Sequential UDP initialization
— UDP instantiation
29.2 Overview
This clause describes a modeling technique to augment the set of predefined gate primitives by designing
and specifying new primitive elements called UDPs. Instances of these new UDPs can be used in exactly the
same manner as the gate primitives to represent the circuit being modeled.
The following two types of behavior can be represented in a UDP:
a) Combinational—modeled by a combinational UDP
b) Sequential—modeled by a sequential UDP
A combinational UDP uses the value of its inputs to determine the next value of its output. A sequential
UDP uses the value of its inputs and the current value of its output to determine the value of its output.
Sequential UDPs provide a way to model sequential circuits such as flip-flops and latches. A sequential
UDP can model both level-sensitive and edge-sensitive behavior.
Each UDP has exactly one output, which can be in one of three states: , , or . The three-state value is
0 1 x z
not supported. In sequential UDPs, the output always has the same value as the internal state.
The values passed to UDP inputs shall be treated the same as values.
z x
29.3 UDP definition
UDP definitions are independent of modules; they are at the same level as module definitions in the syntax
hierarchy. They can appear anywhere in the source text, either before or after they are instantiated inside a
module. They shall not appear between the keywords ... , ... ,
module endmodule program endprogram
... , or ... .
interface endinterface package endpackage
Implementations may limit the maximum number of UDP definitions in a model, but they shall allow at
least 256.
The formalsyntax of the UDP definition is given in Syntax29-1.
udp_nonansi_declaration ::= // from A.5.1
{ attribute_instance } udp_identifier udp_port_list
primitive ( ) ;
udp_ansi_declaration ::=
{ attribute_instance } udp_identifier udp_declaration_port_list
primitive ( ) ;
828
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
udp_declaration ::=
udp_nonansi_declaration udp_port_declaration { udp_port_declaration }
udp_body
[ udp_identifier ]
endprimitive :
| udp_ansi_declaration
udp_body
[ udp_identifier ]
endprimitive :
| udp_nonansi_declaration
extern
| udp_ansi_declaration
extern
| { attribute_instance } udp_identifier
primitive ( .* ) ;
{ udp_port_declaration }
udp_body
[ udp_identifier ]
endprimitive :
udp_port_list ::= output_port_identifier input_port_identifier { input_port_identifier } // from A.5.2
, ,
udp_declaration_port_list ::= udp_output_declaration udp_input_declaration { udp_input_declaration }
, ,
udp_port_declaration ::=
udp_output_declaration
;
| udp_input_declaration
;
| udp_reg_declaration
;
udp_output_declaration ::=
{ attribute_instance } port_identifier
output
| { attribute_instance } port_identifier [ constant_expression ]
outputreg =
udp_input_declaration ::= { attribute_instance } list_of_udp_port_identifiers
input
udp_reg_declaration ::= { attribute_instance } variable_identifier
reg
udp_body ::= combinational_body | sequential_body // from A.5.3
combinational_body ::= combinational_entry { combinational_entry }
table endtable
combinational_entry ::= level_input_list output_symbol
: ;
sequential_body ::= [ udp_initial_statement ] sequential_entry { sequential_entry }
table endtable
udp_initial_statement ::= output_port_identifier init_val
initial = ;
init_val ::= | | | | | | | | |
1'b0 1'b1 1'bx 1'bX 1'B0 1'B1 1'Bx 1'BX 1 0
sequential_entry ::= seq_input_list current_state next_state
: : ;
seq_input_list ::= level_input_list | edge_input_list
level_input_list ::= level_symbol { level_symbol }
edge_input_list ::= { level_symbol } edge_indicator { level_symbol }
edge_indicator ::= level_symbol level_symbol | edge_symbol
( )
current_state ::= level_symbol
next_state ::= output_symbol |
-
output_symbol ::= | | |
0 1 x X
level_symbol ::= | | | | | |
0 1 x X ? b B
edge_symbol ::= | | | | | | | |
r R f F p P n N *
udp_instantiation ::=
udp_identifier [ drive_strength ] [ delay2 ] udp_instance { udp_instance } // from A.5.4
, ;
udp_instance ::= [ name_of_instance ] output_terminal input_terminal { input_terminal }
( , , )
Syntax29-1—Syntax for UDPs (excerpt from AnnexA)
829
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
29.3.1 UDP header
A UDP definition shall have one of two alternate forms. The first form, udp_nonansi_declaration, shall
begin with the keyword , followed by an identifier, which shall be the name of the UDP. This in
primitive
turn shall be followed by a comma-separated list of port names enclosed in parentheses, which shall be
followed by a semicolon. The UDP definition header shall be followed by port declarations and a state table.
The UDP definition shall be terminated by the keyword .
endprimitive
The second form, udp_ansi_declaration, shall begin with the keyword , followed by an
primitive
identifier, which shall be the name of the UDP. This in turn shall be followed by a comma-separated list of
port declarations enclosed in parentheses, followed by a semicolon. The UDP definition header shall be
followed by a state table. The UDP definition shall be terminated by the keyword .
endprimitive
UDPs have multiple input ports and exactly one output port; bidirectional inout ports are not permitted on
UDPs. All ports of a UDP shall be scalar; vector ports are not permitted.
The output port shall be the first port in the port list.
29.3.2 UDP port declarations
UDPs shall contain input and output port declarations. The output port declaration begins with the keyword
, followed by one output port name. The input port declaration begins with the keyword ,
output input
followed by one or more input port names.
Sequential UDPs shall contain a declaration for the output port, either in addition to the output
reg
declaration, when the UDP is declared using the first form of a UDP header, or as part of the
output_declaration. Combinational UDPs cannot contain a declaration. The initial value of the output
reg
port can be specified in an statement in a sequential UDP (see 29.3.3).
initial
Implementations may limit the maximum number of inputs to a UDP, but they shall allow at least nine
inputs for sequential UDPs and 10 inputs for combinational UDPs.
When UDPs are discussed from the instantiation point of view, UDP ports are referred to as terminals. This
is because they are consistent with terminals of other primitives, rather than module ports. Wherever
primitive terminals are mentioned, the text shall also apply to UDP terminals.
29.3.3 Sequential UDP initial statement
The sequential UDP initial statement specifies the value of the output port when simulation begins. This
statement begins with the keyword . The statement that follows shall be an assignment statement
initial
that assigns a single-bit literal value to the output port.
29.3.4 UDP state table
The state table defines the behavior of a UDP. It begins with the keyword and is terminated with the
table
keyword . Each row of the table is terminated by a semicolon.
endtable
Each row of the table is created using a variety of characters (see Table29-1), which indicate input values
and output state. Three states— , , and —are supported. The state is explicitly excluded from
0 1 x z
consideration in UDPs. A number of special characters are defined to represent certain combinations of state
possibilities. These are described in Table29-1.
The order of the input state fields of each row of the state table is taken directly from the port list in the UDP
definition header. It is not related to the order of the input port declarations.
830
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Combinational UDPs have one field per input and one field for the output. The input fields are separated
from the output field by a colon ( ). Each row defines the output for a particular combination of the input
:
values (see 29.4).
Sequential UDPs have an additional field inserted between the input fields and the output field. This
additional field represents the current state of the UDP and is considered equivalent to the current output
value. It is delimited by colons. Each row defines the output based on the current state, particular
combinations of input values, and at most one input transition (see 29.6). A row such as the following one is
illegal:
(01) (10) 0 : 0 : 1 ;
If all input values are specified as , then the output state shall be specified as .
x x
It is not necessary to explicitly specify every possible input combination. All combinations of input values
that are not explicitly specified result in a default output state of .
x
It shall be illegal to have the same combination of inputs, including edges, specify different output values.
29.3.5 Z values in UDP
The value in a table entry is not supported, and it is considered illegal. The values passed to UDP inputs
z z
shall be treated the same as values.
x
29.3.6 Summary of symbols
To improve the readability and to ease writing of the state table, several special symbols are provided.
Table29-1 summarizes the meaning of all the value symbols that are valid in the table part of a UDP
definition.
Table29-1—UDP table symbols
Symbol Interpretation Comments
Logic —
0 0
Logic —
1 1
Unknown Permitted in the input and output fields of all
x
UDPs and in the current state field of
sequential UDPs.
Iterationof , ,and Not permitted in output field.
? 0 1 x
Iterationof and Permitted in the input fields of all UDPs and
b 0 1
in the current state field of sequential UDPs.
Not permitted in the output field.
Nochange Permitted only in the output field of a
-
sequential UDP.
Valuechange from to and canbeanyoneof , , , ,or ,
(vw) v w v w 0 1 x ? b
and are only permitted in the input field.
Sameas Anyvaluechangeoninput.
* (??)
Sameas Risingedgeoninput.
r (01)
Sameas Fallingedgeoninput.
f (10)
831
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table29-1—UDP table symbols (continued)
Symbol Interpretation Comments
Iterationof , , and Potentialpositiveedgeonthe input.
p (01) (0x) (x1)
Iterationof , , and Potentialnegativeedgeonthe input.
n (10) (1x)
(x0)
29.4 Combinational UDPs
In combinational UDPs, the output state is determined solely as a function of the current input states.
Whenever an input state changes, the UDP is evaluated and the output state is set to the value indicated by
the row in the state table that matches all the input states. All combinations of the inputs that are not
explicitly specified will drive the output state to the unknown value .
x
The following example defines a multiplexer with two data inputs and a control input:
primitive multiplexer (mux, control, dataA, dataB);
output mux;
input control, dataA, dataB;
table
// control dataA dataB mux
0 1 0 : 1 ;
0 1 1 : 1 ;
0 1 x : 1 ;
0 0 0 : 0 ;
0 0 1 : 0 ;
0 0 x : 0 ;
1 0 1 : 1 ;
1 1 1 : 1 ;
1 x 1 : 1 ;
1 0 0 : 0 ;
1 1 0 : 0 ;
1 x 0 : 0 ;
x 0 0 : 0 ;
x 1 1 : 1 ;
endtable
endprimitive
The first entry in this example can be explained as follows: when equals , equals , and
control 0 dataA 1
equals , then output mux equals .
dataB 0 1
The input combination ( , , ) is not specified. If this combination occurs
0xx control=0 dataA=x dataB=x
during simulation, the value of output port will become .
mux x
Using , the description of a multiplexer can be abbreviated as follows:
?
primitive multiplexer (mux, control, dataA, dataB);
output mux;
input control, dataA, dataB;
table
// control dataA dataB mux
0 1 ? : 1 ; // ? = 0 1 x
0 0 ? : 0 ;
1 ? 1 : 1 ;
1 ? 0 : 0 ;
832
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
x 0 0 : 0 ;
x 1 1 : 1 ;
endtable
endprimitive
29.5 Level-sensitive sequential UDPs
Level-sensitive sequential behavior is represented the same way as combinational behavior, except that the
output is declared to be of type and there is an additional field in each table entry. This new field
reg
represents the current state of the UDP. The output field in a sequential UDP represents the next state.
Consider the following example of a latch:
primitive latch (q, ena_, data);
output q; reg q;
input ena_, data;
table
// ena_ data : q : q+
0 1 : ? : 1 ;
0 0 : ? : 0 ;
1 ? : ? : - ; // - = no change
endtable
endprimitive
This description differs from a combinational UDP model in two ways. First, the output identifier has an
q
additional declaration to indicate that there is an internal state . The output value of the UDP is always
reg q
the same as the internal state. Second, a field for the current state, which is separated by colons from the
inputs and the output, has been added.
29.6 Edge-sensitive sequential UDPs
In level-sensitive behavior, the values of the inputs and the current state are sufficient to determine the
output value. Edge-sensitive behavior differs in that changes in the output are triggered by specific
transitions of the inputs. This makes the state table a transition table.
Each table entry can have a transition specification on at most one input. A transition is specified by a pair of
values in parentheses such as or a transition symbol such as . Entries such as the following are illegal:
(01) r
(01)(01)0 : 0 : 1 ;
All transitions that do not affect the output shall be explicitly specified. Otherwise, such transitions cause the
value of the output to change to . All unspecified transitions default to the output value .
x x
If the behavior of the UDP is sensitive to edges of any input, the desired output state shall be specified for all
edges of all inputs.
The following example describes a rising edge D flip-flop:
primitive d_edge_ff (q, clock, data);
output q; reg q;
input clock, data;
table
// clock data q q+
833
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
// obtain output on rising edge of clock
(01) 0 : ? : 0 ;
(01) 1 : ? : 1 ;
(0?) 1 : 1 : 1 ;
(0?) 0 : 0 : 0 ;
// ignore negative edge of clock
(?0) ? : ? : - ;
// ignore data changes on steady clock
? (??) : ? : - ;
endtable
endprimitive
The terms such as represent transitions of the input values. Specifically, represents a transition
(01) (01)
from to . The first line in the table of the preceding UDP definition is interpreted as follows: when clock
0 1
changes value from to and data equals , the output goes to no matter what the current state.
0 1 0 0
The transition of clock from to with equal to and current state equal to will result in the output
0 x data 0 1
going to .
q x
29.7 Sequential UDP initialization
The initial value on the output port of a sequential UDP can be specified with an initial statement that
provides a procedural assignment. The initial statement is optional.
Like initial statements in modules, the initial statement in UDPs begins with the keyword . The
initial
valid contents of initial statements in UDPs and the valid left-hand and right-hand sides of their procedural
assignment statements differ from initial statements in modules. A partial list of differences between these
two types of initial statements is described in Table29-2.
Table29-2—Initial statements in UDPs and modules
Initial statements in UDPs Initial statements in modules
Contents limited to one procedural assignment Contents can be one procedural statement of any type
statement or a block statement that contains more than one
procedural statement
The procedural assignment statement shall assign a Procedural assignment statements in initial statements
value to a whose identifier matches the identifier can assign values to a variable whose identifier does
reg
of the output port not match the identifier of an output port
The procedural assignment statement shall assign one Procedural assignment statements can assign values of
of the following values: , , , , any size, radix, and value
1'b1 1'b0 1'bx 1 0
Example 1: The following example shows a sequential UDP that contains an initial statement.
primitive srff (q, s, r);
output q; reg q;
input s, r;
initial q = 1'b1;
table
// s r q q+
1 0 : ? : 1 ;
f 0 : 1 : - ;
0 r : ? : 0 ;
0 f : 0 : - ;
834
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
1 1 : ? : 0 ;
endtable
endprimitive
The output has an initial value of at the start of the simulation; a delay specification on an instantiated
q 1
UDP does not delay the simulation time of the assignment of this initial value to the output. When
simulation starts, this value is the current state in the state table. Delays are not permitted in a UDP initial
statement.
Example 2: The following example and Figure29-1 show how values are applied in a module that
instantiates a sequential UDP with an initial statement:
primitive dff1 (q, clk, d);
input clk, d;
output q; reg q;
initial q = 1'b1;
table
// clk d q q+
r 0 : ? : 0 ;
r 1 : ? : 1 ;
f ? : ? : - ;
? * : ? : - ;
endtable
endprimitive
module dff (q, qb, clk, d);
input clk, d;
output q, qb;
dff1 g1 (qi, clk, d);
buf #3 g2 (q, qi);
not #5 g3 (qb, qi);
endmodule
The UDP contains an initial statement that sets the initial value of its output to . The module
dff1 1 dff
contains an instance of UDP .
dff1
Figure29-1 shows the schematic of the preceding module and the simulation propagation times of the initial
value of the UDP output.
In Figure29-1, the fanout from the UDP output includes nets and . At simulation time 0, changes
qi q qb qi
value to . That initial value of does not propagate to net until simulation time 3, and it does not
1 qi q
propagate to net until simulation time 5.
qb
835
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
module dff
buf g2
q
d
UDP dff1 g1 #3
qi
not g3
clk qb
#5
1
qi
0
1
q
0
1
qb
0
0 3 5
simulation time
Figure29-1—Module schematic and simulation times of initial value propagation
29.8 UDP instances
The syntax for creating a UDP instance is shown in Syntax29-2.
udp_instantiation ::= // from A.5.4
udp_identifier [ drive_strength ] [ delay2 ] udp_instance { udp_instance }
, ;
udp_instance ::= [ name_of_instance ] output_terminal input_terminal { input_terminal }
( , , )
name_of_instance ::= instance_identifier { unpacked_dimension } // from A.4.1.1
Syntax29-2—Syntax for UDP instances (excerpt from AnnexA)
Instances of UDPs are specified inside modules in the same manner as gates (see 28.3). The instance name is
optional, just as for gates. The terminal connection order is as specified in the UDP definition. Only two
delays may be specified because is not supported for UDPs. An optional range may be specified for an
z
array of UDP instances. The terminal connection rules remain the same as outlined in 28.3.6.
The following example creates an instance of the D-type flip-flop (defined in 29.6).
d_edge_ff
module flip;
reg clock, data;
parameter p1 = 10;
parameter p2 = 33;
836
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
parameter p3 = 12;
d_edge_ff #p3 d_inst (q, clock, data);
initial begin
data = 1;
clock = 1;
#(20 * p1) $finish;
end
always #p1 clock = ~clock;
always #p2 data = ~data;
endmodule
29.9 Mixing level-sensitive and edge-sensitive descriptions
UDP definitions allow a mixing of the level-sensitive and the edge-sensitive constructs in the same table.
When the input changes, the edge-sensitive cases are processed first, followed by level-sensitive cases.
Thus, when level-sensitive and edge-sensitive cases specify different output values, the result is specified by
the level-sensitive case.
For example:
primitive jk_edge_ff (q, clock, j, k, preset, clear);
output q; reg q;
input clock, j, k, preset, clear;
table
// clock jk pc state output/next state
? ?? 01 : ? : 1 ; // preset logic
? ?? *1 : 1 : 1 ;
? ?? 10 : ? : 0 ; // clear logic
? ?? 1* : 0 : 0 ;
r 00 00 : 0 : 1 ; // normal clocking cases
r 00 11 : ? : - ;
r 01 11 : ? : 0 ;
r 10 11 : ? : 1 ;
r 11 11 : 0 : 1 ;
r 11 11 : 1 : 0 ;
f ?? ?? : ? : - ;
b *? ?? : ? : - ; // j and k transition cases
b ?* ?? : ? : - ;
endtable
endprimitive
In this example, the and logic is level-sensitive. Whenever the preset and clear combination
preset clear
is , the output has value . Similarly, whenever the preset and clear combination has value , the output
01 1 10
has value .
0
The remaining logic is sensitive to edges of the clock. In the normal clocking cases, the flip-flop is sensitive
to the rising clock edge, as indicated by an in the clock field in those entries. The insensitivity to the falling
r
edge of clock is indicated by a hyphen ( ) in the output field (see Table29-1) for the entry with an as the
- f
value of clock. Remember that the desired output for this input transition shall be specified to avoid
unwanted values at the output. The last two entries show that the transitions in and inputs do not
x j k
change the output on a steady low or high clock.
837
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
29.10 Level-sensitive dominance
Table29-3 shows level-sensitive and edge-sensitive entries in the example from 29.9, their level-sensitive or
edge-sensitive behavior, and a case of input values that each includes.
Table29-3—Mixing of level-sensitive and edge-sensitive entries
Entry Included case Behavior
Level-sensitive
? ?? 01: ?: 1; 0 00 01: 0: 1;
Edge-sensitive
f ?? ??: ?: -; f 00 01: 0: 0;
The included cases specify opposite next state values for the same input and current state combination. The
level-sensitive included case specifies that when the inputs , , and values are , , and and
clock jk pc 0 00 01
the current state is , the output changes to . The edge-sensitive included case specifies that when
0 1 clock
falls from to , the other inputs and are and , and the current state is , then the output changes
1 0 jk pc 00 01 0
to .
0
When the edge-sensitive case is processed first, followed by the level-sensitive case, the output changes to .
1
838
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
30. Specify blocks
30.1 General
This clause describes the following:
— Module path declarations
— Module path delays
— Mixed path and distributed delays
— Pulse control filtering
30.2 Overview
Two types of constructs are often used to describe delays for structural models such as ASIC cells. They are
as follows:
— Distributed delays, which specify the time it takes events to propagate through gates and nets inside
the module (see 28.16)
— Module path delays, which describe the time it takes an event at a source (input port or inout port) to
propagate to a destination (output port or inout port)
This clause describes how paths are specified in a module and how delays are assigned to these paths.
30.3 Specify block declaration
A block statement called the specify block is the vehicle for describing paths between a source and a
destination and for assigning delays to these paths. The syntax for specify blocks is shown in Syntax30-1.
specify_block ::= { specify_item } // from A.7.1
specify endspecify
specify_item ::=
specparam_declaration
| pulsestyle_declaration
| showcancelled_declaration
| path_declaration
| system_timing_check
Syntax30-1—Syntax for specify block (excerpt from AnnexA)
The specify block shall be bounded by the keywords and , and it shall appear inside a
specify endspecify
module declaration. The specify block can be used to perform the following tasks:
— Describe various paths across the module.
— Assign delays to those paths.
— Perform timing checks to verify that events occurring at the module inputs satisfy the timing
constraints of the device described by the module (see Clause31).
The paths described in the specify block, called module paths, pair a signal source with a signal destination.
The source may be unidirectional (an input port) or bidirectional (an inout port) and is referred to as the
module path source. Similarly, the destination may be unidirectional (an output port) or bidirectional (an
inout port) and is referred to as the module path destination.
839
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For example:
specify
specparam tRise_clk_q = 150, tFall_clk_q = 200;
specparam tSetup = 70;
(clk => q) = (tRise_clk_q, tFall_clk_q);
$setup(d, posedge clk, tSetup);
endspecify
The first two lines following the keyword declare specify parameters, which are discussed in
specify
6.20.5. The line following the declarations of specify parameters describes a module path and assigns delays
to that module path. The specify parameters determine the delay assigned to the module path. Specifying
module paths is presented in 30.4. Assigning delays to module paths is discussed in 30.5. The line preceding
the keyword instantiates one of the system timing checks, which are discussed further in
endspecify
Clause31.
30.4 Module path declarations
There are two steps required to set up module path delays in a specify block:
a) Describe the module paths.
b) Assign delays to those paths (see 30.5).
The syntax of the module path declaration is described in Syntax30-2.
path_declaration ::= // from A.7.2
simple_path_declaration
;
| edge_sensitive_path_declaration
;
| state_dependent_path_declaration
;
Syntax30-2—Syntax for module path declaration (excerpt from AnnexA)
A module path may be described as a simple path, an edge-sensitive path, or a state-dependent path. A
module path shall be defined inside a specify block as a connection between a source signal and a
destination signal. Module paths can connect any combination of vectors and scalars.
Figure30-1 illustrates an example circuit with module path delays. More than one source ( , , , and )
A B C D
may have a module path to the same destination ( ), and different delays may be specified for each input to
Q
output path.
30.4.1 Module path restrictions
Module paths have the following restrictions:
— The module path source shall be a net that is connected to a module input port or inout port.
— The module path destination shall be a net or variable that is connected to a module output port or
inout port.
840
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
10
12
18
n
22
= module path delay
A
MODULE PATHS:
B
from A to Q
Q
from B to Q
C
from C to Q
D from D to Q
Figure30-1—Module path delays
30.4.2 Simple module paths
The syntax for specifying a simple module path is given in Syntax30-3.
simple_path_declaration ::= // from A.7.2
parallel_path_description path_delay_value
=
| full_path_description path_delay_value
=
parallel_path_description ::=
specify_input_terminal_descriptor [ polarity_operator ] specify_output_terminal_descriptor
( => )
full_path_description ::=
list_of_path_inputs [ polarity_operator ] list_of_path_outputs
( *> )
list_of_path_inputs ::=
specify_input_terminal_descriptor { specify_input_terminal_descriptor }
,
list_of_path_outputs ::=
specify_output_terminal_descriptor { specify_output_terminal_descriptor }
,
specify_input_terminal_descriptor ::= // from A.7.3
input_identifier [ constant_range_expression ]
[ ]
specify_output_terminal_descriptor ::=
output_identifier [ constant_range_expression ]
[ ]
input_identifier ::= input_port_identifier | inout_port_identifier | interface_identifier port_identifier
.
output_identifier ::= output_port_identifier | inout_port_identifier | interface_identifier port_identifier
.
polarity_operator ::= | // from A.7.4
+ -
Syntax30-3—Syntax for simple module path (excerpt from AnnexA)
Simple paths can be declared in one of two forms:
— source destination
*>
— source destination
=>
The symbols and each represent a different kind of connection between the module path source and
*> =>
the module path destination. The operator establishes a full connection between source and destination.
*>
841
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The operator establishes a parallel connection between source and destination. See 30.4.5 for a
=>
description of full connection and parallel connection paths.
The following three examples illustrate valid simple module path declarations:
(A => Q) = 10;
(B => Q) = (12);
(C, D *> Q) = 18;
30.4.3 Edge-sensitive paths
When a module path is described using an edge transition at the source, it is called an edge-sensitive path.
The edge-sensitive path construct is used to model the timing of input-to-output delays, which only occur
when a specified edge occurs at the source signal.
The syntax of the edge-sensitive path declaration is shown in Syntax30-4.
edge_sensitive_path_declaration ::= // from A.7.4
parallel_edge_sensitive_path_description path_delay_value
=
| full_edge_sensitive_path_description path_delay_value
=
parallel_edge_sensitive_path_description ::=
[ edge_identifier ] specify_input_terminal_descriptor [ polarity_operator ]
( =>
specify_output_terminal_descriptor [ polarity_operator ] data_source_expression
( : ))
full_edge_sensitive_path_description ::=
[ edge_identifier ] list_of_path_inputs [ polarity_operator ]
( *>
list_of_path_outputs [ polarity_operator ] data_source_expression
( : ))
data_source_expression ::= expression
edge_identifier ::= | |
posedge negedge edge
polarity_operator ::= |
+ -
Syntax30-4—Syntax for edge-sensitive path declaration (excerpt from AnnexA)
The edge identifier may be one of the keywords , , or , associated with an input
posedge negedge edge
terminal descriptor, which may be any input port or inout port. If a vector port is specified as the input
terminal descriptor, the edge transition shall be detected on the LSB. If the edge transition is not specified,
the path shall be considered active on any transition at the input terminal.
An edge-sensitive path may be specified with full connections ( ) or parallel connections ( ). For parallel
*> =>
connections ( ), the destination shall be any scalar output or inout port or the bit-select of a vector output or
=>
inout port. For full connections ( ), the destination shall be a list of one or more of the vector or scalar
*>
output and inout ports, and bit-selects or part-selects of vector output and inout ports. See 30.4.5 for a
description of parallel paths and full connection paths.
The data source expression is an arbitrary expression, which serves as a description of the flow of data to the
path destination. This arbitrary data path description does not affect the actual propagation of data or events
through the model; how an event at the data path source propagates to the destination depends on the internal
logic of the module.
The polarity operator is optional. It describes whether the data path is inverting or noninverting. The polarity
operator has no effect on simulation results. It can be used by timing analysis tools to propagate the timing
of rising or falling edges in the absence of simulation data.
842
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 1: The following example demonstrates an edge-sensitive path declaration with a positive polarity
operator:
( posedge clock => ( out +: in ) ) = (10, 8);
In this example, at the positive edge of , a module path extends from to using a rise delay
clock clock out
of 10 and a fall delay of 8. The data path is from to , and is not inverted as it propagates to .
in out in out
Example 2: The following example demonstrates an edge-sensitive path declaration with a negative polarity
operator:
( negedge clock[0] => ( out -: in ) ) = (10, 8);
In this example, at the negative edge of , a module path extends from to using a
clock[0] clock[0] out
rise delay of 10 and a fall delay of 8. The data path is from to , and is inverted as it propagates to
in out in
.
out
Example 3: The following example demonstrates an edge-sensitive path declaration with no edge identifier:
( clock => ( out : in ) ) = (10, 8);
In this example, at any change in , a module path extends from to .
clock clock out
30.4.4 State-dependent paths
A state-dependent path makes it possible to assign a delay to a module path that affects signal propagation
delay through the path only if specified conditions are true.
A state-dependent path description includes the following items:
— A conditional expression that, when evaluated true, enables the module path
— A module path description
— A delay expression that applies to the module path
The syntax for the state-dependent path declaration is shown in Syntax30-5.
state_dependent_path_declaration ::= // from A.7.4
module_path_expression simple_path_declaration
if( )
| module_path_expression edge_sensitive_path_declaration
if( )
| simple_path_declaration
ifnone
Syntax30-5—Syntax for state-dependent paths (excerpt from AnnexA)
30.4.4.1 Conditional expression
The operands in the conditional expression shall be constructed from the following:
— Scalar or vector module input ports or inout ports or their bit-selects or part-selects
— Locally defined variables or nets or their bit-selects or part-selects
— Compile time constants (constant numbers and specify parameters)
Table30-1 contains a list of valid operators that may be used in conditional expressions.
843
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table30-1—List of valid operators in state-dependent path delay expression
Operator Description Operator Description
~ bitwise negation & reduction AND
& bitwise AND | reduction OR
| bitwise OR ^ reduction XOR
^ bitwise XOR ~& reduction NAND
^~ ~^ bitwise XNOR ~| reduction NOR
== logical equality ^~ ~^ reduction XNOR
!= logical inequality {} concatenation
&& logical AND { {} } replication
|| logical OR ?: conditional
! logical NOT
A conditional expression shall evaluate to true for the state-dependent path to be assigned a delay value.
(1)
If the conditional expression evaluates to or , it shall be treated as true. If the conditional expression
x z
evaluates to multiple bits, the LSB shall represent the result. The conditional expression can have any
number of operands and operators.
30.4.4.2 Simple state-dependent paths
If the path description of a state-dependent path is a simple path, then it is called a simple state-dependent
path. The simple path description is discussed in 30.4.2.
Example 1: The following example uses state-dependent paths to describe the timing of an XOR gate:
module XORgate (a, b, out);
input a, b;
output out;
xor x1 (out, a, b);
specify
specparam noninvrise = 1, noninvfall = 2;
specparam invertrise = 3, invertfall = 4;
if (a) (b => out) = (invertrise, invertfall);
if (b) (a => out) = (invertrise, invertfall);
if (~a)(b => out) = (noninvrise, noninvfall);
if (~b)(a => out) = (noninvrise, noninvfall);
endspecify
endmodule
In this example, the first two state-dependent paths describe a pair of output rise and fall delay times when
the gate inverts a changing input. The last two state-dependent paths describe another pair of
XOR (x1)
output rise and fall delay times when the gate buffers a changing input.
XOR
844
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 2: The following example models a partial ALU. The state-dependent paths specify different
delays for different ALU operations:
module ALU (o1, i1, i2, opcode);
input [7:0] i1, i2;
input [2:1] opcode;
output [7:0] o1;
//functional description omitted
specify
// add operation
if (opcode == 2'b00) (i1,i2 *> o1) = (25.0, 25.0);
// pass-through i1 operation
if (opcode == 2'b01) (i1 => o1) = (5.6, 8.0);
// pass-through i2 operation
if (opcode == 2'b10) (i2 => o1) = (5.6, 8.0);
// delays on opcode changes
(opcode *> o1) = (6.1, 6.5);
endspecify
endmodule
In the preceding example, the first three path declarations declare paths extending from operand inputs
i1
and to the output. The delays on these paths are assigned to operations on the basis of the operation
i2 o1
specified by the inputs on . The last path declaration declares a path from the input to the
opcode opcode o1
output.
30.4.4.3 Edge-sensitive state-dependent paths
If the path description of a state-dependent path describes an edge-sensitive path, then the state-dependent
path is called an edge-sensitive state-dependent path. The edge-sensitive paths are discussed in 30.4.3.
Different delays can be assigned to the same edge-sensitive path as long as the following criteria are met:
— The edge, condition, or both make each declaration unique.
— The port is referenced in the same way in all path declarations (entire port, bit-select, or part-select).
Example 1:
if ( !reset && !clear )
( posedge clock => ( out +: in ) ) = (10, 8) ;
In this example, if the positive edge of occurs when and are low, a module path
clock reset clear
extends from to using a rise delay of 10 and a fall delay of 8.
clock out
Example 2: The following example shows two edge-sensitive path declarations, each of which has a unique
edge:
specify
( posedge clk => ( q[0] : data ) ) = (10, 5);
( negedge clk => ( q[0] : data ) ) = (20, 12);
endspecify
Example 3: The following example shows two edge-sensitive path declarations, each of which has a unique
condition:
specify
if (reset)
845
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
(posedge clk => ( q[0] : data ) ) = (15, 8);
if (!reset && cntrl)
(posedge clk => ( q[0] : data ) ) = (6, 2);
endspecify
Example 4: The following two state-dependent path declarations are not legal because even though they
have different conditions, the destinations are not specified in the same way: the first destination is a part-
select, the second is a bit-select.
specify
if (reset)
(posedge clk => (q[3:0]:data)) = (10,5);
if (!reset)
(posedge clk => (q[0]:data)) = (15,8);
endspecify
30.4.4.4 The ifnone condition
The keyword is used to specify a default state-dependent path delay when all other conditions for
ifnone
the path are false. The condition shall specify the same module path source and destination as the
ifnone
state-dependent module paths. The following rules apply to module paths specified with the
ifnone
condition:
— Only simple module paths may be described with an condition.
ifnone
— The state-dependent paths that correspond to the path may be either simple module paths or
ifnone
edge-sensitive paths.
— If there are no corresponding state-dependent module paths to the module path, then the
ifnone
module path shall be treated the same as an unconditional simple module path.
ifnone
— It is illegal to specify both an condition for a module path and an unconditional simple
ifnone
module path for the same module path.
Example 1: The following are valid state-dependent path combinations:
if (C1) (IN => OUT) = (1,1);
ifnone (IN => OUT) = (2,2);
// add operation
if (opcode == 2'b00) (i1,i2 *> o1) = (25.0, 25.0);
// pass-through i1 operation
if (opcode == 2'b01) (i1 => o1) = (5.6, 8.0);
// pass-through i2 operation
if (opcode == 2'b10) (i2 => o1) = (5.6, 8.0);
// all other operations
ifnone (i2 => o1) = (15.0, 15.0);
if (C1) (posedge CLK => (Q +: D)) = (1,1);
ifnone (CLK => Q) = (2,2);
Example 2: The following module path description combination is illegal because it combines a
state-dependent path using an condition and an unconditional path for the same module path:
ifnone
if (a) (b => out) = (2,2);
if (b) (a => out) = (2,2);
ifnone (a => out) = (1,1);
(a => out) = (1,1);
846
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
30.4.5 Full connection and parallel connection paths
The operator shall be used to establish a full connection between source and destination. In a full
*>
connection, every bit in the source shall connect to every bit in the destination. The module path source need
not have the same number of bits as the module path destination.
The full connection can handle most types of module paths because it does not restrict the size or number of
source signals and destination signals. The following situations require the use of full connections:
— To describe a module path between a vector and a scalar
— To describe a module path between vectors of different sizes
— To describe a module path with multiple sources or multiple destinations in a single statement (see
30.4.6)
The operator shall be used to establish a parallel connection between source and destination. In a parallel
=>
connection, each bit in the source shall connect to one corresponding bit in the destination. Parallel module
paths can be created only between sources and destinations that contain the same number of bits.
Parallel connections are more restrictive than full connections. They only connect one source to one
destination, where each signal contains the same number of bits. Therefore, a parallel connection may only
be used to describe a module path between two vectors of the same size. Because scalars are 1-bit wide,
either *> or => may be used to set up bit-to-bit connections between two scalars.
Example 1: Figure30-2 illustrates how a parallel connection differs from a full connection between two
4-bit vectors.
Parallel module path Full module path
Input bits Output bits Input bits Output bits
0 0 0 0
1 1 1 1
2 2 2 2
3 3 3 3
N = number of bits = 4
Number of paths = N = 4 Number of paths = N * N = 16
Use => to define path Use *> to define path
bit-to-bit connections bit-to-vector connections
Figure30-2—Difference between parallel and full connection paths
Example 2: The following example shows module paths for a multiplexer with two 8-bit inputs and one
2:1
8-bit output:
module mux8 (in1, in2, s, q) ;
output [7:0] q;
847
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
input [7:0] in1, in2;
input s;
// Functional description omitted ...
specify
(in1 => q) = (3, 4) ;
(in2 => q) = (2, 3) ;
(s *> q) = 1;
endspecify
endmodule
The module path from to uses a full connection ( because it connects a scalar source—the 1-bit
s q *>)
select line—to a vector destination—the 8-bit output bus. The module paths from both input lines and
in1
to use a parallel connection ( ) because they set up parallel connections between two 8-bit buses.
in2 q =>
30.4.6 Declaring multiple module paths in a single statement
Multiple module paths may be described in a single statement by using the symbol to connect a comma-
*>
separated list of sources to a comma-separated list of destinations. When describing multiple module paths
in one statement, the lists of sources and destinations may contain a mix of scalars and vectors of any size.
The connection in a multiple module path declaration is always a full connection.
For example:
(a, b, c *> q1, q2) = 10;
is equivalent to the following six individual module path assignments:
(a *> q1) = 10 ;
(b *> q1) = 10 ;
(c *> q1) = 10 ;
(a *> q2) = 10 ;
(b *> q2) = 10 ;
(c *> q2) = 10 ;
30.4.7 Module path polarity
The polarity of a module path is an arbitrary specification indicating whether the direction of a signal
transition is inverted as it propagates from the input to the output. This arbitrary polarity description does not
affect the actual propagation of data or events through the model; how a rise or a fall at the source
propagates to the destination depends on the internal logic of the module.
Module paths may specify any of three polarities:
— Unknown polarity
— Positive polarity
— Negative polarity
30.4.7.1 Unknown polarity
By default, module paths shall have unknown polarity; that is, a transition at the path source may propagate
to the destination in an unpredictable way, as follows:
— A rise at the source may cause a rise transition, a fall transition, or no transition at the destination.
— A fall at the source may cause a rise transition, a fall transition, or no transition at the destination.
848
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A module path specified either as a full connection or as a parallel connection, but without a polarity
operator or , shall be treated as a module path with unknown polarity.
+ -
For example:
// Unknown polarity
(In1 => q) = In_to_q ;
*
(s > q) = s_to_q ;
30.4.7.2 Positive polarity
For module paths with positive polarity, any transition at the source may cause the same transition at the
destination, as follows:
— A rise at the source may cause either a rise transition or no transition at the destination.
— A fall at the source may cause either a fall transition or no transition at the destination.
A module path with positive polarity shall be specified by prefixing the polarity operator to or .
+ => *>
For example:
// Positive polarity
(In1 +=> q) = In_to_q ;
*
(s + > q) = s_to_q ;
30.4.7.3 Negative polarity
For module paths with negative polarity, any transition at the source may cause the opposite transition at the
destination, as follows:
— A rise at the source may cause either a fall transition or no transition at the destination.
— A fall at the source may cause either a rise transition or no transition at the destination.
A module path with negative polarity shall be specified by prefixing the polarity operator to or .
- => *>
For example:
// Negative polarity
(In1 -=> q) = In_to_q ;
*
(s - > q) = s_to_q ;
30.5 Assigning delays to module paths
The delays that occur at the module outputs where paths terminate shall be specified by assigning delay
values to the module path descriptions. The syntax for specifying delay values is shown in Syntax30-6.
path_delay_value ::= // from A.7.4
list_of_path_delay_expressions
| list_of_path_delay_expressions
( )
list_of_path_delay_expressions ::=
t_path_delay_expression
| trise_path_delay_expression tfall_path_delay_expression
,
| trise_path_delay_expression tfall_path_delay_expression tz_path_delay_expression
, ,
| t01_path_delay_expression t10_path_delay_expression t0z_path_delay_expression
, , ,
849
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
tz1_path_delay_expression t1z_path_delay_expression tz0_path_delay_expression
, ,
| t01_path_delay_expression t10_path_delay_expression t0z_path_delay_expression
, , ,
tz1_path_delay_expression t1z_path_delay_expression tz0_path_delay_expression
, , ,
t0x_path_delay_expression tx1_path_delay_expression t1x_path_delay_expression
, , ,
tx0_path_delay_expression txz_path_delay_expression tzx_path_delay_expression
, ,
t_path_delay_expression ::= path_delay_expression
path_delay_expression ::= constant_mintypmax_expression
Syntax30-6—Syntax for path delay value (excerpt from AnnexA)
In module path delay assignments, a module path description (see 30.4) is specified on the left-hand side,
and one or more delay values are specified on the right-hand side. The delay values may be optionally
enclosed in a pair of parentheses. There may be one, two, three, six, or twelve delay values assigned to a
module path, as described in 30.5.1. The delay values shall be constant expressions containing literals or
specparams, and there may be a delay expression of the form .
min:typ:max
For example:
specify
// Specify Parameters
specparam tRise_clk_q = 45:150:270, tFall_clk_q=60:200:350;
specparam tRise_Control = 35:40:45, tFall_control=40:50:65;
// Module Path Assignments
(clk => q) = (tRise_clk_q, tFall_clk_q);
(clr, pre *> q) = (tRise_control, tFall_control);
endspecify
In the preceding example, the specify parameters declared following the keyword specify
specparam
values for the module path delays. The module path assignments assign those module path delays to the
module paths.
30.5.1 Specifying transition delays on module paths
Each path delay expression may be a single value—representing the typical delay—or a colon-separated list
of three values—representing a minimum, typical, and maximum delay, in that order. If the path delay
expression results in a negative value, it shall be treated as zero. Table30-2 describes how different path
delay values shall be associated with various transitions. The path delay expression names refer to the names
used in Syntax30-6.
Table30-2—Associating path delay expressions with transitions
Number of path delay expressions specified
Transitions 1 2 3 6 12
0 > 1 t trise trise t01 t01
-
1 > 0 t tfall tfall t10 t10
-
0 > z t trise tz t0z t0z
-
z > 1 t trise trise tz1 tz1
-
1 > z t tfall tz t1z t1z
-
850
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table30-2—Associating path delay expressions with transitions (continued)
Number of path delay expressions specified
Transitions 1 2 3 6 12
z > 0 t tfall tfall tz0 tz0
-
0 > x a a a a t0x
-
x > 1 a a a a tx1
-
1 > x a a a a t1x
-
x > 0 a a a a tx0
-
x > z a a a a txz
-
z > x a a a a tzx
-
a See 30.5.2.
For example:
// one expression specifies all transitions
(C => Q) = 20;
(C => Q) = 10:14:20;
// two expressions specify rise and fall delays
specparam tPLH1 = 12, tPHL1 = 25;
specparam tPLH2 = 12:16:22, tPHL2 = 16:22:25;
(C => Q) = ( tPLH1, tPHL1 ) ;
(C => Q) = ( tPLH2, tPHL2 ) ;
// three expressions specify rise, fall, and z transition delays
specparam tPLH1 = 12, tPHL1 = 22, tPz1 = 34;
specparam tPLH2 = 12:14:30, tPHL2 = 16:22:40, tPz2 = 22:30:34;
(C => Q) = (tPLH1, tPHL1, tPz1);
(C => Q) = (tPLH2, tPHL2, tPz2);
// six expressions specify transitions to/from 0, 1, and z
specparam t01 = 12, t10 = 16, t0z = 13,
tz1 = 10, t1z = 14, tz0 = 34 ;
(C => Q) = ( t01, t10, t0z, tz1, t1z, tz0) ;
specparam T01 = 12:14:24, T10 = 16:18:20, T0z = 13:16:30 ;
specparam Tz1 = 10:12:16, T1z = 14:23:36, Tz0 = 15:19:34 ;
(C => Q) = ( T01, T10, T0z, Tz1, T1z, Tz0) ;
// twelve expressions specify all transition delays explicitly
specparam t01=10, t10=12, t0z=14, tz1=15, t1z=29, tz0=36,
t0x=14, tx1=15, t1x=15, tx0=14, txz=20, tzx=30 ;
(C => Q) = (t01, t10, t0z, tz1, t1z, tz0,
t0x, tx1, t1x, tx0, txz, tzx) ;
30.5.2 Specifying x transition delays
If the x transition delays are not explicitly specified, the calculation of delay values for x transitions is based
on the following two pessimistic rules:
851
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Transitions from a known state to shall occur as quickly as possible; that is, the shortest possible
x
delay shall be used for any transition to .
x
— Transitions from to a known state shall take as long as possible; that is, the longest possible delay
x
shall be used for any transition from .
x
Table30-3 presents the general algorithm for calculating delay values for x transitions along with specific
examples. The following two groups of x transitions are represented in the table:
a) Transition from a known state to :
s x s -> x
b) Transition from to a known state :
x s x -> s
Table30-3—Calculating delays for x transitions
X transition Delay value
General algorithm
s x minimum (s other known signals)
-> ->
x s maximum (other known signals s)
-> ->
Specific transitions
0 x minimum (0 z delay, 0 1 delay)
-> -> ->
1 x minimum (1 z delay, 1 0 delay)
-> -> ->
z x minimum (z 1 delay, z 0 delay)
-> -> ->
x 0 maximum (z 0 delay, 1 0 delay)
-> -> ->
x 1 maximum (z 1 delay, 0 1 delay)
-> -> ->
x z maximum (1 z delay, 0 z delay)
-> -> ->
Usage: (C => Q) = (5, 12, 17, 10, 6, 22) ;
0 x minimum (17, 5) = 5
->
1 x minimum (6, 12) = 6
->
z x minimum (10, 22) = 10
->
x 0 maximum (22, 12) = 22
->
x 1 maximum (10, 5) = 10
->
x z maximum (6, 17) = 17
->
30.5.3 Delay selection
The simulator shall determine the proper delay to use when a specify path output is to be scheduled to
transition. There may be specify paths to the output from more than one input, and the simulator must decide
which specify path to use.
The simulator shall do this by first determining which specify paths to the output are active. Active specify
paths are those whose input has transitioned most recently in time, and either they have no condition or their
conditions are true. In the presence of simultaneous input transitions, it is possible for many specify paths to
an output to be simultaneously active.
852
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Once the active specify paths are identified, a delay shall be selected from among them. This is done by
comparing the correct delay for the specific transition being scheduled from each specify path and choosing
the smallest.
Example 1:
(A => Y) = (6, 9);
(B => Y) = (5, 11);
For a transition from to , if transitioned more recently than , a delay of will be chosen. But if
Y 0 1 A B 6 B
transitioned more recently than , a delay of will be chosen. And if, the last time they transitioned, and
A 5 A B
did so simultaneously, then the smallest of the two rise delays would be chosen, which is the rise delay from
of . The fall delay from of would be chosen if was instead to transition from to .
B 5 A 9 Y 1 0
Example 2:
if (MODE < 5) (A => Y) = (5, 9);
if (MODE < 4) (A => Y) = (4, 8);
if (MODE < 3) (A => Y) = (6, 5);
if (MODE < 2) (A => Y) = (3, 2);
if (MODE < 1) (A => Y) = (7, 7);
Anywhere from zero to five of these specify paths might be active depending upon the value of . For
MODE
instance, when is , the first three specify paths are active. A rise transition would select a delay of
MODE 2 4
because that is the smallest rise delay among the first three. A fall transition would select a delay of
5
because that is the smallest fall delay among the first three.
30.6 Mixing module path delays and distributed delays
If a module contains module path delays and distributed delays (delays on primitive instances within the
module), the larger of the two delays for each path shall be used.
Example 1: Figure30-3 illustrates a simple circuit modeled with a combination of distributed delays and
path delays (only the D input to Q output path is illustrated). Here, the delay on the module path from input
to output is , while the sum of the distributed delays is + = . Therefore, a transition on caused
D Q 22 0 1 1 Q
by a transition on will occur time units after the transition on .
D 22 D
n
22
A = module path delay
B 0
1 Q n = distributed delay
C
0
D
Figure30-3—Module path delays longer than distributed delays
Example 2: In Figure30-4, the delay on the module path from to is , but the distributed delays along
D Q 22
that module path now add up to + = . Therefore, an event on caused by an event on will occur
10 20 30 Q D
time units after the event on .
30 D
853
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
22 n
A
= module path delay
B 10
20 Q
n = distributed delay
C
10
D
Figure30-4—Module path delays shorter than distributed delays
30.7 Detailed control of pulse filtering behavior
Two consecutive scheduled transitions closer together in time than the module path delay are deemed a
pulse. By default, pulses on a module path output are rejected. Consecutive transitions cannot be closer
together than the module path delay, and this is known as the inertial delay model of pulse propagation.
Pulse width ranges control how to handle a pulse presented at a module path output. They are as follows:
— A pulse width range for which a pulse shall be rejected
— A pulse width range for which a pulse shall be allowed to propagate to the path destination
— A pulse width range for which a pulse shall generate a logic on the path destination
x
Two pulse limit values define the pulse width ranges associated with each module path transition delay. The
pulse limit values are called the error limit and the reject limit. The error limit shall always be at least as
large as the reject limit. Pulses greater than or equal to the error limit pass unfiltered. Pulses less than the
error limit but greater than or equal to the reject limit are filtered to . Pulses less than the reject limit are
X
rejected, and no pulse emerges. By default, both the error limit and the reject limit are set equal to the delay.
These default values yield full inertial pulse behavior, rejecting all pulses smaller than the delay.
In Figure30-5, the rise delay from input to output is , and the fall delay is . By default, the error limit
A Y 7 9
and the reject limit for the rise delay are both . The error limit and the reject limit for the fall delay are both
7
. The pulse limits associated with the delay forming the trailing edge of the pulse determine whether and
9
how the pulse should be filtered. Waveform ' shows the waveform resulting from no pulse filtering. The
Y
width of the pulse is , which is less than the reject limit for the rise delay of ; therefore, the pulse is filtered
2 7
as shown in waveform .
Y
(A =>Y ) = 7, 9;
// Module path
// delay for a buffer
A
pulse width = 4
// Pulse considered
Y // at module path output
‚
pulse width = 2
// Pulse is filtered
Y
Figure30-5—Example of pulse filtering
854
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
There are three ways to modify the pulse limits from their default values. First, SystemVerilog provides the
specparam to modify the pulse limits from their default values. Second, invocation options can
PATHPULSE$
specify percentages applying to all module path delays to form the corresponding error limits and reject
limits. Third, SDF annotation can individually annotate the error limit and reject limit of each module path
transition delay.
30.7.1 Specify block control of pulse limit values
Pulse limit values may be set from within the specify block with the specparam. The syntax
PATHPULSE$
for using to specify the reject limit and error limit values is given in Syntax30-7.
PATHPULSE$
pulse_control_specparam ::=
reject_limit_value [ error_limit_value ]
PATHPULSE$= ( , )
| specify_input_terminal_descriptor specify_output_terminal_descriptor
PATHPULSE$ $
reject_limit_value [ error_limit_value ]
= ( , )
error_limit_value ::= limit_value
reject_limit_value ::= limit_value
limit_value ::= constant_mintypmax_expression
Syntax30-7—Syntax for PATHPULSE$ pulse control (excerpt from AnnexA)
If only the reject limit value is specified, it shall apply to both the reject limit and the error limit.
The reject limit and error limit may be specified for a specific module path. When no module path is
specified, the reject limit and error limit shall apply to all module paths defined in a module. If both
path-specific specparams and a nonpath-specific specparam appear in the same
PATHPULSE$ PATHPULSE$
module, then the path-specific specparams shall take precedence for the specified paths.
The module path input terminals and output terminals shall conform to the rules for module path inputs and
outputs, with the following restriction: the terminals may not be a bit-select or part-select of a vector.
When a module path declaration declares multiple paths, the specparam shall only be
PATHPULSE$
specified for the first path input terminal and the first path output terminal. The reject limit and error limit
specified shall apply to all other paths in the multiple path declaration. A specparam that
PATHPULSE$
specifies anything other than the first path input and path output terminals shall be ignored.
In the following example, the path acquires a reject limit of and an error limit of , as defined
(clk=>q) 2 9
by the first declaration. The paths and receive a reject limit of and an
PATHPULSE$ (clr*>q) (pre*>q) 0
error limit of , as specified by the second declaration. The path is not explicitly
4 PATHPULSE$ (data=>q)
defined in any of the declarations; therefore, it acquires reject and error limit of , as defined
PATHPULSE$ 3
by the last declaration.
PATHPULSE$
specify
(clk => q) = 12;
(data => q) = 10;
(clr, pre *> q) = 4;
specparam
PATHPULSE$clk$q = (2,9),
PATHPULSE$clr$q = (0,4),
PATHPULSE$ = 3;
endspecify
855
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
30.7.2 Global control of pulse limit values
Two invocation options can specify percentages applying globally to all module path transition delays. The
error limit invocation option specifies the percentage of each module path transition delay used for its error
limit value. The reject limit invocation option specifies the percentage of each module path transition delay
used for its reject limit value. The percentage values shall be an integer between and .
0 100
The default values for both the reject and error limit invocation options are . When neither option is
100%
present, then of each module transition delay is used as the reject and error limits.
100%
It is an error if the error limit percentage is smaller than the reject limit percentage. In such cases, the error
limit percentage is set equal to the reject limit percentage.
When both and global pulse limit invocation options are present, the values
PATHPULSE$ PATHPULSE$
shall take precedence.
30.7.3 SDF annotation of pulse limit values
SDF annotation can be used to specify the pulse limit values of module path transition delays. Clause32
describes this in greater detail.
When , global pulse limit invocation options, and SDF annotation of pulse limit values are
PATHPULSE$
present, SDF annotation values shall take precedence.
30.7.4 Detailed pulse control capabilities
The default style of pulse filtering behavior has two drawbacks. First, pulse filtering to the state may be
X
insufficiently pessimistic with an state duration too short to be useful. Second, unequal delays can result in
X
pulse rejection whenever the trailing edge precedes the leading edge, leaving no indication that a pulse was
rejected. This subclause introduces more detailed pulse control capabilities.
30.7.4.1 On-event versus on-detect pulse filtering
When an output pulse is to be filtered to , greater pessimism can be expressed if the module path output
X
transitions immediately to (on-detect) instead of at the already scheduled transition time of the leading
X
edge of the pulse (on-event).
The on-event method of pulse filtering to is the default. When an output pulse is to be filtered to , the
X X
leading edge of the pulse becomes a transition to , and the trailing edge becomes a transition from . The
X X
times of transition of the edges do not change.
Just like on-event, the on-detect method of pulse filtering changes the leading edge of the pulse into a
transition to and the trailing edge to a transition from , but the time of the leading edge is changed to
X X
occur immediately upon detection of the pulse.
Figure30-6 illustrates this behavior using a simple buffer with asymmetric rise/fall times and both the reject
limits and error limits equal to . An output waveform is shown for both on-detect and on-event approaches.
0
856
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
rise/fall
4/6
in out
10 12 14 18
in
out (on-event)
(default)
out (on-detect)
Figure30-6—On-detect versus on-event
On-detect versus on-event behavior can be selected in two different ways. First, one may be selected
globally for all module path outputs through use of the on-detect or on-event invocation option. Second, one
may be selected locally through use of specify block pulse style declarations.
The syntax for pulse style declarations is shown in Syntax30-8.
pulsestyle_declaration ::= // from A.7.1
list_of_path_outputs
pulsestyle_onevent ;
| list_of_path_outputs
pulsestyle_ondetect ;
Syntax30-8—Syntax for pulse style declarations (excerpt from AnnexA)
It is an error if a module path output appears in a pulse style declaration after it has already appeared in a
module path declaration.
The pulse style invocation options take precedence over pulse style specify block declarations.
30.7.4.2 Negative pulse detection
When the delays to a module path output are unequal, it is possible for the trailing edge of a pulse to be
scheduled for a time earlier than the schedule time of the leading edge, yielding a pulse with a negative
width. Under normal operation, if the schedule for a trailing pulse edge is earlier than the schedule for a
leading pulse edge, then the leading edge is cancelled. No transition takes place when the initial and final
states of the pulse are the same, leaving no indication a schedule was ever present.
Negative pulses can be indicated with the state by use of the showcancelled style of behavior. When the
X
trailing edge of a pulse would be scheduled before the leading edge, this style causes the leading edge to be
scheduled to and the trailing edge to be scheduled from . With on-event pulse style, the schedule to
X X X
857
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
replaces the leading edge schedule. With on-detect pulse style, the schedule to is made immediately upon
X
detection of the negative pulse.
Showcancelled behavior can be enabled in two different ways. First, it may be enabled globally for all
module path outputs through use of the and invocation options.
showcancelled noshowcancelled
Second, it may be enabled locally through use of specify block declarations.
showcancelled
The syntax for showcancelled declarations is shown in Syntax30-9.
showcancelled_declaration ::= // from A.7.1
list_of_path_outputs
showcancelled ;
| list_of_path_outputs
noshowcancelled ;
Syntax30-9—Syntax for showcancelled declarations (excerpt from AnnexA)
It is an error if a module path output appears in a showcancelled declaration after it has already appeared in
a module path declaration. The showcancelled invocation options take precedence over the showcancelled
specify block declarations.
The showcancelled behavior is illustrated in Figure30-7, which shows a narrow pulse presented at the input
to a buffer with unequal rise/fall delays. This causes the trailing edge of the pulse to be scheduled earlier
than leading edge. The leading edge of the input pulse schedules an output event 6 units later at the point
marked by . The pulse trailing edge occurs one time unit later, which schedules an output event units later
A 4
marked by point . This second schedule on the output is for a time prior to the already existing schedule for
B
the leading output pulse edge.
The output waveform is shown for three different operating modes. The first waveform shows the default
behavior with showcancelled behavior not enabled and with the default on-event style. The second
waveform shows showcancelled behavior in conjunction with on-event. The last waveform shows
showcancelled behavior in conjunction with on-detect.
858
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
(in=>out)=(4,6);
in out
10 11 15 16
in
B A
out (default)
out (showcan celled with on-event)
out (showcancelled with on-detect)
Figure30-7—Current event cancellation problem and correction
This same situation can also arise with nearly simultaneous input transitions, which is defined as two inputs
transitioning closer together in time than the difference in their respective delays to the output. Figure30-8
shows waveforms for a two-input NAND gate where initially is high and is low. B transitions at
A B 0->1
time , causing a output schedule at time . A transitions at time , causing a schedule
10 1->0 24 1->0 12 0->1
at time . Arrows mark the output transitions caused by the transitions on inputs and .
22 A B
The output waveform is shown for three different operating modes. The first waveform shows the default
behavior with showcancelled behavior not enabled and with the default on-event style. The second shows
showcancelled behavior in conjunction with on-event. The third shows showcancelled behavior in
conjunction with on-detect.
859
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
(A=>Q) = 10;
(B=>Q) = 14;
10 12 22 24
A
B
.
out (default)
out (showcancelled with on-event)
out (showcancelled with on-detect)
Figure30-8—NAND gate with nearly simultaneous input switching where
one event is scheduled prior to another that has not matured
One drawback of the on-event style with showcancelled behavior is that as the output pulse edges draw
closer together, the duration of the resulting state becomes smaller. Figure30-9 illustrates how the
X
on-detect style solves this problem.
860
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
(A=>Q) = 10
(B=>Q) = 14
10 14 24
A
B
out (default)
out (showcancelled with on-event)
out (showcancelled with on-detect)
Figure30-9—NAND gate with nearly simultaneous input switching with
output event scheduled at same time
Example 1:
specify
(a=>out)=(2,3);
(b =>out)=(3,4);
endspecify
Because no pulse style or showcancelled declarations appear within the specify block, the compiler applies
the default modes of on-event and noshowcancelled.
Example 2:
specify
(a=>out)=(2,3);
showcancelled out;
(b =>out)=(3,4);
endspecify
This showcancelled declaration is in error because it follows use of out in a module path declaration. It
would be contradictory for to have noshowcancelled behavior from input , but showcancelled behavior
out a
from input .
b
861
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 3: Both these specify blocks produce the same result. Outputs and are both declared
out out_b
showcancelled and on-detect.
specify
showcancelled out;
pulsestyle_ondetect out;
(a => out) = (2,3);
(b => out) = (4,5);
showcancelled out_b;
pulsestyle_ondetect out_b;
(a => out_b) = (3,4);
(b => out_b) = (5,6);
endspecify
specify
showcancelled out,out_b;
pulsestyle_ondetect out,out_b;
(a => out) = (2,3);
(b => out) = (4,5);
(a => out_b) = (3,4);
(b => out_b) = (5,6);
endspecify
862
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
31. Timing checks
31.1 General
This clause describes the following:
— Stability timing checks
— Clock and control timing checks
— Edge control specifiers
— Notifiers
— Enabling timing checks
— Vectors in timing checks
— Negative timing checks
31.2 Overview
Timing checks can be placed in specify blocks to verify the timing performance of a design by making sure
critical events occur within given time limits. The syntax for system timing checks is given in Syntax31-1.
system_timing_check ::= // from A.7.5.1
$setup_timing_check
| $hold_timing_check
| $setuphold_timing_check
| $recovery_timing_check
| $removal_timing_check
| $recrem_timing_check
| $skew_timing_check
| $timeskew_timing_check
| $fullskew_timing_check
| $period_timing_check
| $width_timing_check
| $nochange_timing_check
$setup_timing_check ::= // from A.7.5.1
data_event reference_event timing_check_limit [ [ notifier ] ]
$setup ( , , , ) ;
$hold_timing_check ::=
reference_event data_event timing_check_limit [ [ notifier ] ]
$hold ( , , , ) ;
$setuphold_timing_check ::=
reference_event data_event timing_check_limit timing_check_limit
$setuphold ( , , ,
[ [ notifier ] [ [ timestamp_condition ] [ [ timecheck_condition ]
, , ,
[ [ delayed_reference ] [ [ delayed_data ] ] ] ] ] ]
, , ) ;
$recovery_timing_check ::=
reference_event data_event timing_check_limit [ [ notifier ] ]
$recovery ( , , , ) ;
$removal_timing_check ::=
reference_event data_event timing_check_limit [ [ notifier ] ]
$removal ( , , , ) ;
$recrem_timing_check ::=
reference_event data_event timing_check_limit timing_check_limit
$recrem ( , , ,
[ [ notifier ] [ [ timestamp_condition ] [ [ timecheck_condition ]
, , ,
[ [ delayed_reference ] [ [ delayed_data ] ] ] ] ] ]
, , ) ;
$skew_timing_check ::=
863
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
reference_event data_event timing_check_limit [ [ notifier ] ]
$skew ( , , , ) ;
$timeskew_timing_check ::=
reference_event data_event timing_check_limit
$timeskew ( , ,
[ [ notifier ] [ [ event_based_flag ] [ [ remain_active_flag ] ] ] ]
, , , ) ;
$fullskew_timing_check ::=
reference_event data_event timing_check_limit timing_check_limit
$fullskew ( , , ,
[ [ notifier ] [ [ event_based_flag ] [ [ remain_active_flag ] ] ] ]
, , , ) ;
$period_timing_check ::=
controlled_reference_event timing_check_limit [ [ notifier ] ]
$period ( , , ) ;
$width_timing_check ::=
controlled_reference_event timing_check_limit threshold [ [ notifier ] ]
$width ( , , , ) ;
$nochange_timing_check ::=
reference_event data_event start_edge_offset end_edge_offset [ [ notifier ] ]
$nochange ( , , , , ) ;
Syntax31-1—Syntax for system timing checks (excerpt from AnnexA)
The syntax for time check conditions and timing check events is given in Syntax31-2.
timecheck_condition ::= mintypmax_expression // from A.7.5.2
controlled_reference_event ::= controlled_timing_check_event
data_event ::= timing_check_event
delayed_data ::=
terminal_identifier
| terminal_identifier constant_mintypmax_expression
[ ]
delayed_reference ::=
terminal_identifier
| terminal_identifier constant_mintypmax_expression
[ ]
end_edge_offset ::= mintypmax_expression
event_based_flag ::= constant_expression
notifier ::= variable_identifier
reference_event ::= timing_check_event
remain_active_flag ::= constant_mintypmax_expression
timestamp_condition ::= mintypmax_expression
start_edge_offset ::= mintypmax_expression
threshold ::= constant_expression
timing_check_limit ::= expression
timing_check_event ::= // from A.7.5.3
[timing_check_event_control] specify_terminal_descriptor [ timing_check_condition ]
&&&
controlled_timing_check_event ::=
timing_check_event_control specify_terminal_descriptor [ timing_check_condition ]
&&&
timing_check_event_control ::=
posedge
|
negedge
|
edge
| edge_control_specifier
specify_terminal_descriptor ::=
specify_input_terminal_descriptor
864
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| specify_output_terminal_descriptor
edge_control_specifier ::= edge_descriptor { edge_descriptor }
edge[ , ]
edge_descriptor33 ::= | | z_or_x zero_or_one | zero_or_one z_or_x
01 10
zero_or_one ::= |
0 1
z_or_x ::= | | |
x X z Z
timing_check_condition ::=
scalar_timing_check_condition
| scalar_timing_check_condition
( )
scalar_timing_check_condition ::=
expression
| expression
~
| expression scalar_constant
==
| expression scalar_constant
===
| expression scalar_constant
!=
| expression scalar_constant
!==
scalar_constant ::= | | | | | | | | |
1'b0 1'b1 1'B0 1'B1 'b0 'b1 'B0 'B1 1 0
33) Embedded spaces are illegal.
Syntax31-2—Syntax for time check conditions and timing check events (excerpt from AnnexA)
For ease of presentation, the timing checks are divided into two groups. The first group of timing checks are
described in terms of stability time windows:
$setup $hold $setuphold
$recovery $removal $recrem
The timing checks in the second group check clock and control signals and are described in terms of the
difference in time between two events (the check involves three events):
$nochange
$skew $timeskew $fullskew
$width $period $nochange
Although they begin with a , timing checks are not system tasks. The leading is present because of
$ $
historical reasons, and timing checks shall not be confused with system tasks. In particular, no system task
can appear in a specify block, and no timing check can appear in procedural code.
Some timing checks can accept negative limit values. This topic is discussed in detail in 31.9.
All timing checks have both a reference event and a data event, and Boolean conditions can be associated
with each. Some of the checks have two signal arguments, one of which is the reference event and the other
is the data event. Other checks have only one signal argument, and the reference and data events are derived
from it. Reference events and data events shall only be detected by timing checks when their associated
conditions are true. See 31.7 for more information about conditions in timing checks.
Timing check evaluation is based upon the times of two events, called the timestamp event and the
timecheck event. A transition on the timestamp event signal causes the simulator to record (stamp) the time
of transition for future use in evaluating the timing check. A transition on the timecheck event signal causes
the simulator to actually evaluate the timing check to determine whether a violation has taken place.
865
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For some checks, the reference event is always the timestamp event, and the data event is always the
timecheck event; while for other checks the reverse is true. And for yet other checks, the decision about
which is the timestamp and which is the timecheck event is based upon factors that are discussed in greater
detail in 31.3 and 31.4.
Every timing check can include an optional notifier that toggles whenever the timing check detects a
violation. The model can use the notifier to make behavior a function of timing check violations. Notifiers
are discussed in greater detail in 31.6.
Like expressions for module path delays, timing check limit values are constant expressions that can include
specparams.
31.3 Timing checks using a stability window
The following timing checks are discussed in this subclause:
$setup $hold $setuphold
$recovery $removal $recrem
These checks accept two signals, the reference event and the data event, and define a time window with
respect to one signal while checking the time of transition of the other signal with respect to the window. In
general, they all perform the following steps:
a) Define a time window with respect to the reference signal using the specified limit or limits.
b) Check the time of transition of the data signal with respect to the time window.
c) Report a timing violation if the data signal transitions within the time window.
31.3.1 $setup
The timing check syntax is shown in Syntax31-3.
$setup
$setup_timing_check ::= // from A.7.5.1
data_event reference_event timing_check_limit [ [ notifier ] ]
$setup ( , , , ) ;
data_event ::= timing_check_event // from A.7.5.2
notifier ::= variable_identifier
reference_event ::= timing_check_event
timing_check_limit ::= expression
Syntax31-3—Syntax for $setup (excerpt from AnnexA)
Table31-1 defines the timing check.
$setup
Table31-1—$setup arguments
Argument Description
data_event Timestamp event
reference_event Timecheck event
limit Non-negative constant expression
notifier (optional) Variable (see 31.6)
866
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The data event is usually a data signal, while the reference event is usually a clock signal.
The end points of the time window are determined as follows:
(beginning of time window) = (timecheck time) - limit
(end of time window) = (timecheck time)
The timing check reports a timing violation in the following case:
$setup
(beginning of time window) < (timestamp time) < (end of time window)
The end points of the time window are not part of the violation region. When the limit is zero, the
$setup
check shall never issue a violation.
31.3.2 $hold
The timing check syntax is shown in Syntax31-4.
$hold
$hold_timing_check ::= // from A.7.5.1
reference_event data_event timing_check_limit [ [ notifier ] ]
$hold ( , , , ) ;
data_event ::= timing_check_event // from A.7.5.2
notifier ::= variable_identifier
reference_event ::= timing_check_event
timing_check_limit ::= expression
Syntax31-4—Syntax for $hold (excerpt from AnnexA)
Table31-2 defines the timing check.
$hold
Table31-2—$hold arguments
Argument Description
reference_event Timestamp event
data_event Timecheck event
limit Non-negative constant expression
notifier (optional) Variable (see 31.6)
The data event is usually a data signal, while the reference event is usually a clock signal.
The end points of the time window are determined as follows:
(beginning of time window) = (timestamp time)
(end of time window) = (timestamp time) + limit
The timing check reports a timing violation in the following case:
$hold
(beginning of time window) <= (timecheck time) < (end of time window)
867
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Only the end of the time window is not part of the violation region. When the limit is zero, the check
$hold
shall never issue a violation.
31.3.3 $setuphold
The timing check syntax is shown in Syntax31-5.
$setuphold
$setuphold_timing_check ::= // from A.7.5.1
reference_event data_event timing_check_limit timing_check_limit
$setuphold ( , , ,
[ [ notifier ] [ [ timestamp_condition ] [ [ timecheck_condition ]
, , ,
[ [ delayed_reference ] [ [ delayed_data ] ] ] ] ] ]
, , ) ;
timecheck_condition ::= mintypmax_expression // from A.7.5.2
data_event ::= timing_check_event
delayed_data ::=
terminal_identifier
| terminal_identifier constant_mintypmax_expression
[ ]
delayed_reference ::=
terminal_identifier
| terminal_identifier constant_mintypmax_expression
[ ]
notifier ::= variable_identifier
reference_event ::= timing_check_event
timestamp_condition ::= mintypmax_expression
timing_check_limit ::= expression
Syntax31-5—Syntax for $setuphold (excerpt from AnnexA)
Table31-3 defines the timing check.
$setuphold
Table31-3—$setuphold arguments
Argument Description
reference_event Timecheck or timestamp event when setup limit is positive
Timestamp event when setup limit is negative
data_event Timecheck or timestamp event when hold limit is positive
Timestamp event when hold limit is negative
setup_limit Constant expression
hold_limit Constant expression
notifier (optional) Variable (see 31.6)
timestamp_condition (optional) Timestamp condition for negative timing checks
timecheck_condition (optional) Timecheck condition for negative timing checks
delayed_reference (optional) Delayed reference signal for negative timing checks
delayed_data (optional) Delayed data signal for negative timing checks
The timing check can accept negative limit values. This is discussed in greater detail in 31.9.
$setuphold
868
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The data event is usually a data signal, while the reference event is usually a clock signal.
When both the setup limit and the hold limit are positive, either the reference event or the data event can be
the timecheck event. It shall depend upon which occurs first in the simulation.
When either the setup limit or the hold limit is negative, the restriction becomes as follows:
setup_limit + hold_limit > (simulation unit of precision)
The timing check combines the functionality of the and timing checks into a
$setuphold $setup $hold
single timing check. Therefore, the invocation
$setuphold( posedge clk, data, tSU, tHLD );
is equivalent in functionality to the following, if and are not negative:
tSU tHLD
$setup( data, posedge clk, tSU );
$hold( posedge clk, data, tHLD );
When both setup and hold limits are positive and the data event occurs first, the end points of the time
window are determined as follows:
(beginning of time window) = (timecheck time) - limit
(end of time window) = (timecheck time)
And the timing check reports a timing violation in the following case:
$setuphold
(beginning of time window) < (timestamp time) <= (end of time window)
Only the beginning of the time window is not part of the violation region. The check shall
$setuphold
report a timing violation when the reference and data events occur simultaneously.
When both setup and hold limits are positive and the data event occurs second, the end points of the time
window are determined as follows:
beginning of time window) = (timestamp time)
(end of time window) = (timestamp time) + limit
And the timing check reports a timing violation in the following case:
$setuphold
(beginning of time window) <= (timecheck time) < (end of time window)
Only the end of the time window is not part of the violation region. The check shall report a
$setuphold
timing violation when the reference and data events occur simultaneously.
When both limits are zero, the check shall never issue a violation.
$setuphold
31.3.4 $removal
The timing check syntax is shown in Syntax31-6.
$removal
$removal_timing_check ::= // from A.7.5.1
reference_event data_event timing_check_limit [ [ notifier ] ]
$removal ( , , , ) ;
data_event ::= timing_check_event // from A.7.5.2
869
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
notifier ::= variable_identifier
reference_event ::= timing_check_event
timing_check_limit ::= expression
Syntax31-6—Syntax for $removal (excerpt from AnnexA)
Table31-4 defines the timing check.
$removal
Table31-4—$removal arguments
Argument Description
reference_event Timecheck event
data_event Timestamp event
limit Non-negative constant expression
notifier (optional) Variable (see 31.6)
The reference event is usually a control signal like clear, reset, or set, while the data event is usually a clock
signal.
The end points of the time window are determined as follows:
(beginning of time window) = (timecheck time) - limit
(end of time window) = (timecheck time)
The timing check reports a timing violation in the following case:
$removal
(beginning of time window) < (timestamp time) < (end of time window)
The end points of the time window are not part of the violation region. When the limit is zero, the
$removal
check shall never issue a violation.
31.3.5 $recovery
The timing check syntax is shown in Syntax31-7.
$recovery
$recovery_timing_check ::= // from A.7.5.1
reference_event data_event timing_check_limit [ [ notifier ] ]
$recovery ( , , , ) ;
data_event ::= timing_check_event // from A.7.5.2
notifier ::= variable_identifier
reference_event ::= timing_check_event
timing_check_limit ::= expression
Syntax31-7—Syntax for $recovery (excerpt from AnnexA)
870
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table31-5 defines the timing check.
$recovery
Table31-5—$recovery arguments
Argument Description
reference_event Timestamp event
data_event Timecheck event
limit Non-negative constant expression
notifier (optional) Variable (see 31.6)
The reference event is usually a control signal like clear, reset, or set, while the data event is usually a clock
signal.
The end points of the time window are determined as follows:
(beginning of time window) = (timestamp time)
(end of time window) = (timestamp time) + limit
The timing check reports a timing violation in the following case:
$recovery
(beginning of time window) <= (timecheck time) < (end of time window)
Only the end of the time window is not part of the violation region. When the limit is zero, the
$recovery
check shall never issue a violation.
31.3.6 $recrem
The timing check syntax is shown in Syntax31-8.
$recrem
$recrem_timing_check ::= // from A.7.5.1
reference_event data_event timing_check_limit timing_check_limit
$recrem ( , , ,
[ [ notifier ] [ [ timestamp_condition ] [ [ timecheck_condition ]
, , ,
[ [ delayed_reference ] [ [ delayed_data ] ] ] ] ] ]
, , ) ;
timecheck_condition ::= mintypmax_expression // from A.7.5.2
data_event ::= timing_check_event
delayed_data ::=
terminal_identifier
| terminal_identifier constant_mintypmax_expression
[ ]
delayed_reference ::=
terminal_identifier
| terminal_identifier constant_mintypmax_expression
[ ]
notifier ::= variable_identifier
reference_event ::= timing_check_event
timestamp_condition ::= mintypmax_expression
timing_check_limit ::= expression
Syntax31-8—Syntax for $recrem (excerpt from AnnexA)
871
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table31-6 defines the timing check.
$recrem
Table31-6—$recrem arguments
Argument Description
reference_event Timecheck or timestamp event when removal limit is positive
Timestamp event when removal limit is negative
data_event Timecheck or timestamp event when recovery limit is positive
Timestamp event when recovery limit is negative
recovery_limit Constant expression
removal_limit Constant expression
notifier (optional) Variable (see 31.6)
timestamp_condition (optional) Timestamp condition for negative timing checks
timecheck_condition (optional) Timecheck condition for negative timing checks
delayed_reference (optional) Delayed reference signal for negative timing checks
delayed_data (optional) Delayed data signal for negative timing checks
The timing check can accept negative limit values. This is discussed in greater detail in 31.9.
$recrem
When both the removal limit and the recovery limit are positive, either the reference event or the data event
can be the timecheck event. It shall depend upon which occurs first in the simulation.
When either the removal limit or the recovery limit is negative, the restriction becomes as follows:
removal_limit + recovery_limit > (simulation unit of precision)
The timing check combines the functionality of the and timing checks into
$recrem $removal $recovery
a single timing check. Therefore, the invocation
$recrem( posedge clear, posedge clk, tREC, tREM );
is equivalent in functionality to the following, if and are not negative:
tREC tREM
$removal( posedge clear, posedge clk, tREM );
$recovery( posedge clear, posedge clk, tREC );
When both removal and recovery limits are positive and the data event occurs first, the end points of the
time window are determined as follows:
(beginning of time window) = (timecheck time) - limit
(end of time window) = (timecheck time)
And the timing check reports a timing violation in the following case:
$recrem
(beginning of time window) < (timestamp time) <= (end of time window)
Only the beginning of the time window is not part of the violation region. The check shall report a
$recrem
timing violation when the reference and data events occur simultaneously.
872
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
When both removal and recovery limits are positive and the data event occurs second, the end points of the
time window are determined as follows:
(beginning of time window) = (timestamp time)
(end of time window) = (timestamp time) + limit
And the timing check reports a timing violation in the following case:
$recrem
(beginning of time window) <= (timecheck time) < (end of time window)
Only the end of the time window is not part of the violation region. The check shall report a timing
$recrem
violation when the reference and data events occur simultaneously.
When both limits are zero, the check shall never issue a violation.
$recrem
31.4 Timing checks for clock and control signals
The following timing checks are discussed in this subclause:
$skew $timeskew $fullskew $period $width $nochange
These checks accept one or two signals and verify that transitions on them are never separated by more than
the limit. For checks specifying only one signal, the reference event and data event are derived from that one
signal. In general, these checks all perform the following steps:
a) Determine the elapsed time between two events.
b) Compare the elapsed time to the specified limit.
c) Report a timing violation if the elapsed time violates the limit.
The skew checks have two different violation detection mechanisms, event-based and timer-based .
Event-based skew checking is performed only when a signal transitions, while timer-based skew checking
takes place as soon as the simulation time equal to the skew limit has elapsed.
The check involves three events rather than two.
$nochange
31.4.1 $skew
The timing check syntax is shown in Syntax31-9.
$skew
$skew_timing_check ::= // from A.7.5.1
reference_event data_event timing_check_limit [ [ notifier ] ]
$skew ( , , , ) ;
data_event ::= timing_check_event // from A.7.5.2
notifier ::= variable_identifier
reference_event ::= timing_check_event
timing_check_limit ::= expression
Syntax31-9—Syntax for $skew (excerpt from AnnexA)
873
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table31-7 defines the timing check.
$skew
Table31-7—$skew arguments
Argument Description
reference_event Timestamp event
data_event Timecheck event
limit Non-negative constant expression
notifier (optional) Variable (see 31.6)
The timing check reports a violation in the following case:
$skew
(timecheck time) - (timestamp time) > limit
Simultaneous transitions on the reference and data signals shall not cause to report a timing violation,
$skew
even when the skew limit value is zero.
The timing check is event-based; it is evaluated only after a data event. If there is never a data event
$skew
(i.e., the data event is infinitely late), the timing check shall never be evaluated, and no timing
$skew
violation shall ever be reported. In contrast, the and checks are timer-based by
$timeskew $fullskew
default, and they should be used if violation reports are absolutely required and the data event can be very
late or even absent altogether. These checks are discussed in 31.4.2 and 31.4.3.
shall wait indefinitely for the data event once it has detected a reference event, and it shall not report
$skew
a timing violation until the data event takes place. A second consecutive reference event shall cancel the old
wait for the data event and begin a new one.
After a reference event, the timing check shall never stop checking data events for a timing violation.
$skew
shall report timing violations for all data events occurring beyond the limit after a reference event.
$skew
31.4.2 $timeskew
The syntax for is shown in Syntax31-10.
$timeskew
$timeskew_timing_check ::= // from A.7.5.1
reference_event data_event timing_check_limit
$timeskew ( , ,
[ [ notifier ] [ [ event_based_flag ] [ [ remain_active_flag ] ] ] ]
, , , ) ;
data_event ::= timing_check_event // from A.7.5.2
event_based_flag ::= constant_expression
notifier ::= variable_identifier
reference_event ::= timing_check_event
remain_active_flag ::= constant_mintypmax_expression
timing_check_limit ::= expression
Syntax31-10—Syntax for $timeskew (excerpt from AnnexA)
874
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table31-8 defines the timing check arguments.
$timeskew
Table31-8—$timeskew arguments
Argument Description
reference_event Timestamp event
data_event Timecheck event
limit Non-negative constant expression
notifier (optional) Variable (see 31.6)
event_based_flag (optional) Constant expression
remain_active_flag (optional) Constant expression
The timing check reports a violation only in the following case:
$timeskew
(timecheck time) - (timestamp time) > limit
Simultaneous transitions on the reference and data signals shall not cause to report a timing
$timeskew
violation, even when the skew limit value is zero. shall also not report a violation if a new
$timeskew
timestamp event occurs exactly at the expiration of the time limit.
The default behavior for is timer-based. A violation shall be reported immediately upon an
$timeskew
elapse of time after the reference event equal to the limit, and the check shall become dormant and report no
more violations (even in response to data events) until after the next reference event. However, if a data
event occurs within the limit, then a violation shall not be reported, and the check shall become dormant
immediately. This check shall also become dormant if it detects a conditioned reference event when its
condition is false and the remain_active_flag is not set.
The check’s default timer-based behavior can be altered to event-based using the
$timeskew
event_based_flag. It behaves like the check when both the event_based_flag and the
$skew
remain_active_flag are set. The check behaves like the check when only the
$timeskew $skew
event_based_flag is set, except that it becomes dormant after reporting the first violation or if it detects a
conditioned reference event when its condition is false.
For example, see Figure31-1.
$timeskew (posedge CP &&& MODE, negedge CPN, 50, , event_based_flag,
remain_active_flag);
MODE
CP
A B F
50
CPN
C D E G H I J
Figure31-1—Sample $timeskew
875
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Case 1: event_based_flag not set, remain_active_flag not set.
After the first reference event on at , a violation is reported at as soon as time units have passed,
CP A B 50
turning the $timeskew check dormant, and no further violations are reported.
Case 2: event_based_flag set, remain_active_flag not set.
After the first reference event on at , the negative transition on at point causes a timing violation,
CP A CPN C
turning the check dormant, and no further violations are reported. The second reference event at
$timeskew
occurs while is false; therefore, the check remains dormant.
F MODE $timeskew
Case 3: event_based_flag set, remain_active_flag set.
After the first reference event on at , the first three negative transitions on at points , , and
CP A CPN C D E
cause timing violations. The second reference event at occurs while is false, but because the
F MODE
remain_active_flag is set, the check remains active. Therefore, additional violations are
$timeskew
reported at , , , and . In other words, all negative transitions on cause violations, which is identical
G H I J CPN
to behavior.
$skew
Case 4: event_based_flag not set, remain_active_flag set.
For the waveform depicted in Figure31-1, has the same behavior in Case 4 as in Case 1. The
$timeskew
difference between the two cases is illustrated by the waveform in Figure31-2.
MODE
CP
A F B
50
CPN
C D E G
Figure31-2—Sample $timeskew with remain_active_flag set
Although the reference event on at occurs while is false, it does not turn the check
CP F MODE $timeskew
dormant because the remain_active_flag is set. A violation will hence be reported at time , whereas for
B
Case 1, where the remain_active_flag is not set, the check would turn dormant at , and no
$timeskew F
violation would be reported.
31.4.3 $fullskew
The syntax for is shown in Syntax31-11.
$fullskew
$fullskew_timing_check ::= // from A.7.5.1
reference_event data_event timing_check_limit timing_check_limit
$fullskew ( , , ,
[ [ notifier ] [ [ event_based_flag ] [ [ remain_active_flag ] ] ] ]
, , , ) ;
data_event ::= timing_check_event // from A.7.5.2
event_based_flag ::= constant_expression
notifier ::= variable_identifier
876
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
reference_event ::= timing_check_event
remain_active_flag ::= constant_mintypmax_expression
timing_check_limit ::= expression
Syntax31-11—Syntax for $fullskew (excerpt from AnnexA)
Table31-9 defines the timing check arguments.
$fullskew
Table31-9—$fullskew arguments
Argument Description
reference_event Timestamp or timecheck event
data_event Timestamp or timecheck event
limit 1 Non-negative constant expression
limit 2 Non-negative constant expression
notifier (optional) Variable (see 31.6)
event_based_flag (optional) Constant expression
remain_active_flag (optional) Constant expression
is similar to except that the reference and data events can transition in either order.
$fullskew $timeskew
The first limit is the maximum time by which the data event should follow the reference event. The second
limit is the maximum time by which the reference event should follow the data event.
The reference event is the timestamp event, and the data event is the timecheck event when the reference
event precedes the data event. The data event is the timestamp event, and the reference event is the
timecheck event when the data event precedes the reference event.
The timing check reports a violation only in the following case, where limit is set to limit1
$fullskew
when the reference event transitions first and set to limit2 when the data event transitions first:
(timecheck time) - (timestamp time) > limit
Simultaneous transitions on the reference and data signals shall not cause to report a timing
$fullskew
violation, even when the skew limit value is zero. shall also not report a violation if a new
$fullskew
timestamp event occurs exactly at the expiration of the time limit.
The default behavior for is timer-based (event_based_flag not set). A violation shall be reported
$fullskew
immediately upon elapse of the time limit after the timestamp event if a timecheck event does not occur in
this time, turning the timing check dormant. However, if a timecheck event does occur within the time limit,
then no violation is reported, and the timing check turns dormant immediately.
A reference event or data event is a timestamp event and starts a new timing window, unless it is a
timecheck event occurring within the time limit after a preceding timestamp event, in which case it turns the
timing check dormant, as previously stated.
In the timer-based mode, a second timestamp event that occurs within the time limit starts a new timing
window that replaces the first one, unless the second timestamp event has an associated condition whose
value is false. In such a case, the behavior of depends on the remain_active_flag. If the flag is
$fullskew
877
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
set, then the second timestamp event is simply ignored. If the flag is not set and if the timing check is active,
then the timing check turns dormant.
The check’s default timer-based behavior can be altered to event-based using the
$fullskew
event_based_flag. In this mode, is similar to $skew in that a violation is reported not upon
$fullskew
elapse of the time limit after the timestamp event (as in timer-based mode), but rather if a timecheck event
occurs after the time limit. Such an event ends the first timing window and immediately begins a new timing
window, where it acts as the timestamp event of the new window. A timecheck event within the time limit
ends the timing window and turns the timing check dormant, and no violation is reported.
In the event-based mode, a second timestamp event that occurs before a timecheck event has occurred starts
a new timing window that replaces the first one, unless the second timestamp event has an associated
condition whose value is false. In such a case, the behavior of depends on the
$fullskew
remain_active_flag. If the flag is set, then the second timestamp event is simply ignored. If the flag is not set
and if the timing check is active, then the timing check turns dormant.
In both the timer-based and event-based modes, if the timestamp event has no condition or has a true
condition and if the timing check is dormant, then the timing check is activated.
For example, see Figure31-3.
$fullskew (posedge CP &&& MODE, negedge CPN, 50, 70,, event_based_flag,
remain_active_flag);
MODE
CP
J
50
A B
70
70
CPN
D
C E F G H I
Figure31-3—Sample $fullskew
Case 1: event_based_flag not set.
The transition at of while is true begins a wait for a negative transition on , and a violation is
A CP MODE CPN
reported at as soon as a period of time equal to time units has passed. This resets the check and readies
B 50
it for the next active transition.
A negative transition on occurs next at , beginning a wait for a positive transition on while is
CPN C CP MODE
true. At , a time equal to time units has passed without a positive edge on while is true;
D 70 CP MODE
therefore, a violation is reported, and the check is again reset to await the next active transition.
A transition on at also results in a timing violation, as does the transition at , because even though
CPN E F CP
transitions, is no longer true. Transitions at and also result in timing violations, but not the
MODE G H
transition at because it is followed by a positive transition on while is true.
I CP MODE
878
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Case 2: event_based_flag set.
The transition at of while is true begins a wait for a negative transition on , and a violation is
A CP MODE CPN
reported at on because it occurs beyond the time unit limit. This transition at also begins a wait
C CPN 50 C
of time units for a positive transition on while is true. But for transitions on at through ,
70 CP MODE CPN C H
there is no positive transition on while is true; therefore, no timing violations are reported. The
CP MODE
transition at on begins a wait of time units, and this is satisfied by the positive transition on at
I CPN 70 CP J
while is true.
MODE
Although the waveform in this particular example does not show the role of the remain_active_flag, it
should be recognized that this flag has a vital role in determining the behavior of the timing
$fullskew
check, just as it does for the $timeskew timing check.
31.4.4 $width
The timing check syntax is shown in Syntax31-12.
$width
$width_timing_check ::= // from A.7.5.1
controlled_reference_event timing_check_limit threshold [ [ notifier ] ]
$width ( , , , ) ;
controlled_reference_event ::= controlled_timing_check_event // from A.7.5.2
notifier ::= variable_identifier
threshold ::= constant_expression
timing_check_limit ::= expression
Syntax31-12—Syntax for $width (excerpt from AnnexA)
Table31-10 defines the timing check.
$width
Table31-10—$width arguments
Argument Description
reference_event Timestamp edge triggered event
data_event (implicit) Timecheck edge triggered event
limit Non-negative constant expression
threshold (optional) Non-negative constant expression
notifier (optional) Variable (see 31.6)
The timing check monitors the width of signal pulses by measuring the time from the timestamp
$width
event to the timecheck event. Because a data event is not passed to , it is derived from the reference
$width
event, as follows:
data event = reference event signal with opposite edge
Because of the way the data event is derived for , an edge triggered event has to be passed as the
$width
reference event. A compilation error shall occur if the reference event is not an edge specification.
879
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
While the timing check can be defined in terms of a time window, it is simpler to express it as the
$width
difference between the timecheck and timestamp times. The timing check reports a violation in the
$width
following case:
threshold < (timecheck time) - (timestamp time) < limit
The pulse width has to be greater than or equal to limit in order to avoid a timing violation, but no violation
is reported for glitches smaller than the threshold.
The threshold argument shall be included if the notifier argument is required. It is permissible to not specify
both the threshold and notifier arguments, making the default value for the threshold zero. If the notifier is
present, a non-null value for the threshold shall also be present. Here is a legal check when the
$width
notifier is required and the threshold is not:
$width (posedge clk, 6, 0, ntfr_reg);
The data event and the reference event shall never occur at the same simulation time because these events
are triggered by opposite transitions.
The following example demonstrates some examples of legal and illegal calls:
// Legal Calls
$width ( negedge clr, lim );
$width ( negedge clr, lim, thresh, notif );
$width ( negedge clr, lim, 0, notif );
// Illegal Calls
$width ( negedge clr, lim, , notif );
$width ( negedge clr, lim, notif );
31.4.5 $period
The timing check syntax is shown in Syntax31-13.
$period
$period_timing_check ::= // from A.7.5.1
controlled_reference_event timing_check_limit [ [ notifier ] ]
$period ( , , ) ;
controlled_reference_event ::= controlled_timing_check_event // from A.7.5.2
notifier ::= variable_identifier
timing_check_limit ::= expression
Syntax31-13—Syntax for $period (excerpt from AnnexA)
Table31-11 defines the timing check.
$period
Table31-11—$period arguments
Argument Description
reference_event Timestamp edge triggered event
data_event (implicit) Timecheck edge triggered event
limit Non-negative constant expression
notifier (optional) Variable (see 31.6)
880
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Because the data event is not passed as an argument to , it is derived from the reference event, as
$period
follows:
data event = reference event signal with the same edge
Because of the way the data event is derived for , an edge triggered event shall be passed as the
$period
reference event. A compilation error shall occur if the reference event is not an edge specification.
While the timing check can be defined in terms of a time window, it is simpler to express it as the
$period
difference between the timecheck and timestamp times. The timing check reports a violation in the
$period
following case:
(timecheck time) - (timestamp time) < limit
31.4.6 $nochange
The syntax is shown in Syntax31-14.
$nochange
$nochange_timing_check ::= // from A.7.5.1
reference_event data_event start_edge_offset end_edge_offset [ [ notifier ] ]
$nochange( , , , , );
data_event ::= timing_check_event // from A.7.5.2
end_edge_offset ::= mintypmax_expression
notifier ::= variable_identifier
reference_event ::= timing_check_event
start_edge_offset ::= mintypmax_expression
Syntax31-14—Syntax for $nochange (excerpt from AnnexA)
Table31-12 defines the timing check arguments.
$nochange
Table31-12—$nochange arguments
Argument Description
reference_event Edge triggered timestamp and/or timecheck event
data_event Timestamp or timecheck event
start_edge_offset Constant expression
end_edge_offset Constant expression
notifier (optional) Variable (see 31.6)
The timing check reports a timing violation if the data event occurs during the specified level of
$nochange
the control signal (the reference event). The reference event can be specified with the or the
posedge
keyword, but the edge-control specifiers (see 31.5) cannot be used.
negedge
The start edge and end edge offsets can expand or shrink the timing violation region, which is defined by the
duration of the reference event signal after the edge. For example, if the reference event is a posedge, then
the duration is the period during which the reference signal is high. A positive offset for start edge extends
the region by starting the timing violation region earlier; a negative offset for start edge shrinks the region by
starting the region later. Similarly, a positive offset for the end edge extends the timing violation region by
881
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
ending it later, while a negative offset for the end edge shrinks the region by ending it earlier. If both the
offsets are zero, the size of the region shall not change.
Unlike other timing checks, involves three, rather than two, transitions. The leading edge of the
$nochange
reference event defines the beginning of the time window, while the trailing edge of the reference event
defines the end of the time window. A violation results if the data event occurs anytime within the time
window.
The end points of the time window are determined as follows:
(beginning of time window) = (leading reference edge time) - start_edge_offset
(end of time window) = (trailing reference edge time) + end_edge_offset
The timing check reports a timing violation in the following case:
$nochange
(beginning of time window) < (data event time) < (end of time window)
The end points of the time window are not included. The values of and
start_edge_offset
play a significant role in determining which signal, the reference event or the data
end_edge_offset
event, is the timestamp or timecheck event.
For example:
$nochange( posedge clk, data, 0, 0) ;
In this example, the timing check shall report a violation if the signal changes while
$nochange data clk
is high. It shall not be a violation if and a transition on occur simultaneously.
posedgeclk data
31.5 Edge-control specifiers
The edge-control specifiers can be used to control events in timing checks based on specific edge transitions
between , , and . Syntax31-15 shows the syntax for edge-control specifiers.
0 1 x
edge_control_specifier ::= edge_descriptor { edge_descriptor } // from A.7.5.3
edge[ , ]
edge_descriptor33 ::= | | z_or_x zero_or_one | zero_or_one z_or_x
01 10
zero_or_one ::= |
0 1
z_or_x ::= | | |
x X z Z
33) Embedded spaces are illegal.
Syntax31-15—Syntax for edge-control specifier (excerpt from AnnexA)
Edge-control specifiers contain the keyword followed by a square-bracketed list of from one to six
edge
pairs of edge transitions between , , and , as follows:
0 1 x
01 Transition from 0 to 1
0x Transition from 0 to x
10 Transition from 1 to 0
1x Transition from 1 to x
x0 Transition from x to 0
x1 Transition from x to 1
882
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Edge transitions involving are treated the same way as edge transitions involving .
z x
The and keywords can be used as a shorthand for certain edge-control specifiers. For
posedge negedge
example, the construct
posedge clr
is equivalent to the following:
edge[01, 0x, x1] clr
Similarly, the construct
negedge clr
is the same as the following:
edge[10, x0, 1x] clr
However, edge-control specifiers offer the flexibility to declare edge transitions other than and
posedge
.
negedge
31.6 Notifiers: user-defined responses to timing violations
Timing check notifiers detect timing check violations behaviorally and, therefore, take an action as soon as a
violation occurs. Such notifiers can be used to print an informative error message describing the violation or
to propagate an value at the output of the device that reported the violation.
x
The notifier is a variable, declared in the module where timing check tasks are invoked, that is passed as the
last argument to a system timing check. Whenever a timing violation occurs, the timing check updates the
value of the notifier.
The notifier is an optional argument to all system timing checks and can be omitted from the timing check
call without adversely affecting its operation.
Table31-13 shows how the notifier values are toggled when timing violations occur.
Table31-13—Notifier value responses to timing violations
BEFORE violation AFTER violation
x Either 0 or 1
0 1
1 0
z z
Example 1:
$setup( data, posedge clk, 10, notifier ) ;
$width( posedge clk, 16, 0, notifier ) ;
883
A u t h o r i z e d l i c eConpyrsighte © 2d018 IEuEEs. Alle righ ts lresiervmed.i t e d t o : S i e m e n s A G G B S B & S S O L G M S . D o w n l o a d e d o n D e c e m b e r 0 3 , 2 0 2 5 a t 0 5 : 4 4 : 4 9 U T C f r o m I E E E X p l o r e . R e s t r i c t i o n s a p p l y .

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 2: Consider a more complex example of how to use notifiers in a behavioral model. The following
example uses a notifier to set the D flip-flop output to when a timing violation occurs in an edge-sensitive
x
UDP:
primitive posdff_udp(q, clock, data, preset, clear, notifier);
output q; reg q;
input clock, data, preset, clear, notifier;
table
//clock data p c notifier state q
//-------------------------------------
r 0 1 1 ? : ? : 0 ;
r 1 1 1 ? : ? : 1 ;
p 1 ? 1 ? : 1 : 1 ;
p 0 1 ? ? : 0 : 0 ;
n ? ? ? ? : ? : - ;
? * ? ? ? : ? : - ;
? ? 0 1 ? : ? : 1 ;
? ? * 1 ? : 1 : 1 ;
? ? 1 0 ? : ? : 0 ;
? ? 1 * ? : 0 : 0 ;
? ? ? ? * : ? : x ;// At any notifier event
// output x
endtable
endprimitive
module dff(q, qbar, clock, data, preset, clear);
output q, qbar;
input clock, data, preset, clear;
reg notifier;
and (enable, preset, clear);
not (qbar, ffout);
buf (q, ffout);
posdff_udp (ffout, clock, data, preset, clear, notifier);
specify
// Define timing check specparam values
specparam tSU = 10, tHD = 1, tPW = 25, tWPC = 10, tREC = 5;
// Define module path delay rise and fall min:typ:max values
specparam tPLHc = 4:6:9 , tPHLc = 5:8:11;
specparam tPLHpc = 3:5:6 , tPHLpc = 4:7:9;
// Specify module path delays
(clock *> q,qbar) = (tPLHc, tPHLc);
(preset,clear *> q,qbar) = (tPLHpc, tPHLpc);
// Setup time : data to clock, only when preset and clear are 1
$setup(data, posedge clock &&& enable, tSU, notifier);
// Hold time: clock to data, only when preset and clear are 1
$hold(posedge clock, data &&& enable, tHD, notifier);
// Clock period check
884
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
$period(posedge clock, tPW, notifier);
// Pulse width : preset, clear
$width(negedge preset, tWPC, 0, notifier);
$width(negedge clear, tWPC, 0, notifier);
// Recovery time: clear or preset to clock
$recovery(posedge preset, posedge clock, tREC, notifier);
$recovery(posedge clear, posedge clock, tREC, notifier);
endspecify
endmodule
NOTE—This model applies to edge-sensitive UDPs only; for level-sensitive models, an additional UDP for
x
propagation has to be generated.
31.7 Enabling timing checks with conditioned events
A construct called a conditioned event ties the occurrence of timing checks to the value of a conditioning
signal. Syntax31-16 shows the syntax for controlled timing check events.
timing_check_event ::= // from A.7.5.3
[timing_check_event_control] specify_terminal_descriptor [ timing_check_condition ]
&&&
controlled_timing_check_event ::=
timing_check_event_control specify_terminal_descriptor [ timing_check_condition ]
&&&
timing_check_event_control ::=
posedge
|
negedge
|
edge
| edge_control_specifier
specify_terminal_descriptor ::=
specify_input_terminal_descriptor
| specify_output_terminal_descriptor
timing_check_condition ::=
scalar_timing_check_condition
| scalar_timing_check_condition
( )
scalar_timing_check_condition ::=
expression
| expression
~
| expression scalar_constant
==
| expression scalar_constant
===
| expression scalar_constant
!=
| expression scalar_constant
!==
scalar_constant ::= | | | | | | | | |
1'b0 1'b1 1'B0 1'B1 'b0 'b1 'B0 'B1 1 0
Syntax31-16—Syntax for controlled timing check events (excerpt from AnnexA)
The comparisons used in the condition can be deterministic, as in , , , or no operation, or
=== !== ~
nondeterministic, as in or . When comparisons are deterministic, an value on the conditioning signal
== != x
shall not enable the timing check. For nondeterministic comparisons, an on the conditioning signal shall
x
enable the timing check.
The conditioning signal shall be a scalar net; if a vector net or an expression resulting in a multibit value is
used, then the LSB of the vector net or the expression value is used.
885
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If more than one conditioning signal is required for conditioning timing checks, appropriate logic shall be
combined in a separate signal outside the specify block, which can be used as the conditioning signal.
Example 1:To illustrate the difference between conditioned and unconditioned timing check events,
consider the following example with unconditioned timing check:
$setup( data, posedge clk, 10 );
Here, a setup timing check shall occur every time there is a positive edge on the signal .
clk
To trigger the setup check on the positive edge on the signal only when the signal is high, rewrite
clk clr
the command as
$setup( data, posedge clk &&& clr, 10 ) ;
Example 2: This example shows two ways to trigger the same timing check as in Example 1 (on the positive
edge) only when is low. The second method uses operator, which makes the comparison
clk clr the ===
deterministic.
$setup( data, posedge clk &&& (~clr), 10 ) ;
$setup( data, posedge clk &&& (clr===0), 10 );
Example 3: To perform the previous sample setup check on the positive edge only when and
clk clr set
are high, add the following statement outside the specify block:
and new_gate( clr_and_set, clr, set );
Then add the condition to the timing check using the signal as follows:
clr_and_set
$setup( data, posedge clk &&& clr_and_set, 10 );
31.8 Vector signals in timing checks
Either or both signals in a timing check can be a vector. This shall be interpreted as a single timing check
where the transition of one or more bits of a vector is considered a single transition of that vector.
For example:
module DFF (Q, CLK, DAT);
input CLK;
input [7:0] DAT;
output [7:0] Q;
always @(posedge clk)
Q = DAT;
specify
$setup (DAT, posedge CLK, 10);
endspecify
endmodule
If transitions from ' to at time and if transitions from to at time
DAT b00101110 'b01010011 100 CLK 0 1
, then the timing check shall still only report a single timing violation.
105 $setup
Simulators may provide an option causing vectors in timing checks to result in the creation of multiple
single-bit timing checks. For timing checks with only a single signal, such as or , a vector
$period $width
of width results in unique timing checks. For timing checks with two signals, such as , ,
N N $setup $hold
886
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
, , , , , , , and ,
$setuphold $skew $timeskew $fullskew $recovery $removal $recrem $nochange
where and are the widths of the signals, the result is unique timing checks. If there is a notifier, all
M N M*N
the timing checks trigger that notifier.
With such an option enabled, the preceding example yields six timing violation because 6 bits of
DAT
transitioned.
31.9 Negative timing checks
Both the and timing checks can accept negative values when the negative timing
$setuphold $recrem
check option is enabled. The behavior of these two timing checks is identical with respect to negative values.
The descriptions in this subclause are for the timing check, but apply equally to the
$setuphold $recrem
timing check.
The setup and hold timing check values define a timing violation window with respect to the reference
signal edge during which the data shall remain constant. Any change of the data during the specified
window causes a timing violation. The timing violation is reported, and through the notifier variable, other
actions can take place in the model, such as forcing the output of a flip-flop to when it detects a timing
X
violation.
A positive value for both setup and hold times implies this violation window straddles the reference signal
shown in Figure31-4.
clock
data
..........Setup time (+)
..........Hold Time (+)
Figure31-4—Data constraint interval, positive setup/hold
A negative hold or setup time means the violation window is shifted to either before or after the reference
edge. This can happen in a real device because of disparate internal device delays between the internal clock
and data signal paths. These internal device delays are illustrated in Figure31-5 showing how significant
differences in these delays can cause negative setup or hold values.
887
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
ASIC Cell
data D1 output
Seq.
Elem.
clock D2
Negative Hold time (D1>D2)
clock
data
..........Setup time (+)
..........Hold Time (-)
Negative Setup time (D2>D1)
clock
data
..........Setup time (-)
..........Hold Time (+)
Figure31-5—Data constraint interval, negative setup/hold
31.9.1 Requirements for accurate simulation
In order to accurately model negative value timing checks, the following requirements apply:
a) A timing violation shall be triggered if the signal changes in the violation window, exclusive of the
end points. Violation windows smaller than two units of simulation precision cannot yield timing
violations.
b) The value of the latched data shall be the one that is stable during the violation window, again,
exclusive of the end points.
To facilitate these modeling requirements, delayed copies of the data and reference signals are generated in
the timing checks, and these are used internally for timing check evaluation at run time. The setup and hold
times used internally are adjusted to shift the violation window and make it overlap the reference signal.
Delayed data and reference signals can be declared within the timing check so they can be used in the
model’s functional implementation for more accurate simulation. If no delayed signals are declared in the
888
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
timing check and if a negative setup or hold value is present, then implicit delayed signals are created.
Because implicit delayed signals cannot be used in defining model behavior, such a model can possibly
behave incorrectly.
Example 1:
$setuphold(posedge CLK, DATA, -10, 20);
Implicit delayed signals shall be created for and , but it shall not be possible to access them. The
CLK DATA
check shall be properly evaluated, but functional behavior shall not always be accurate. The
$setuphold
old value shall be incorrectly clocked in if transitions between and time units
DATA DATA posedge CLK 10
later.
Example 2:
$setuphold(posedge CLK, DATA1, -10, 20);
$setuphold(posedge CLK, DATA2, -15, 18);
Implicit delayed signals shall be created for , , and , one for each. Even though is
CLK DATA1 DATA2 CLK
referenced in two different timing checks, only one implicit delayed signal is created, and it is used for both
timing checks.
Example 3: If a given signal has a delayed signal in some timing checks but not in others, the delayed signal
shall be used in both cases:
$setuphold(posedge CLK, DATA1, -10, 20,,,, del_CLK, del_DATA1);
$setuphold(posedge CLK, DATA2, -15, 18);
Explicit delayed signals of and are created for and , while an implicit
del_CLK del_DATA1 CLK DATA1
delayed signal is created for . In other words, has only one delayed signal created for it,
DATA2 CLK
, rather than one explicit delayed signal for the first check and another implicit delayed signal for
del_CLK
the second check.
The delayed versions of the signals, whether implicit or explicit, shall be used in the , ,
$setup $hold
, , , , , , and timing checks; and
$setuphold $recovery $removal $recrem $width $period $nochange
these checks shall have their limits adjusted accordingly so that the notifier shall be toggled at the proper
moment. If the adjusted limit becomes less than or equal to , the limit shall be set to , and the simulator
0 0
shall issue a warning.
The delayed versions of the signals shall not be used for the , , and timing
$skew $fullskew $timeskew
checks because it can possibly result in the reversal of the order of signal transitions. This causes the
notifiers for these timing checks to toggle at the wrong time relative to the rest of the model, perhaps
resulting in transitions to due to a timing check violation being cancelled. This issue shall be addressed in
X
the model, possibly by using separate notifiers for these checks.
It is possible for a set of negative timing check values to be mutually inconsistent and produce no solution
for the delay values of delayed signals. In these situations, the simulator shall issue a warning. The
inconsistency shall be resolved by changing the smallest negative limit value to and recalculating the
0
delays for the delayed signals, and this shall be repeated until a solution is reached. This procedure shall
always produce a solution because in the worst case all negative limit values become and no delayed
0
signals are needed.
The delayed timing check signals are only actually delayed when negative limit values are present. If a
timing check signal becomes delayed by more than the propagation delay from that signal to an output, that
889
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
output shall take longer than its propagation delay to change. It shall instead transition at the same time that
the delayed timing check signal changes. Thus, the output shall behave as if its specify path delay were equal
to the delay applied to the timing check signal. This situation can only arise when unique setup/hold or
removal/recovery times are given for each edge of the data signal.
For example:
(CLK = Q) = 6;
$setuphold (posedge CLK, posedge D, -3, 8, , , , dCLK, dD);
$setuphold (posedge CLK, negedge D, -7, 13, , , , dCLK, dD);
The setup time of (the larger in absolute value of and ) creates a delay of for ; therefore,
-7 -3 -7 7 dCLK
output shall not change until time units after a positive edge on , rather than the 6 time units given in
Q 7 CLK
the specify path.
31.9.2 Conditions in negative timing checks
Conditions can be associated with both the reference and data signals by using the operator; but when
&&&
either the setup or hold time is negative, the conditions need to be paired with reference and data signals in a
more flexible way. This example illustrates why.
This pair of and checks works together to provide the same check as a single :
$setup $hold $setuphold
$setup (data, clk &&& cond1, tsetup, ntfr);
$hold (clk, data &&& cond1, thold, ntfr);
is the timecheck event for the check, while is the timecheck event for the check.
clk $setup data $hold
This cannot be represented in a single check; therefore, additional arguments are provided to
$setuphold
make this possible. These arguments are timestamp_condition and timecheck_condition, and they
immediately follow the notifier (see 31.3.3). The following check is equivalent to the separate
$setuphold
and checks shown above:
$setup $hold
$setuphold( clk, data, tsetup, thold, ntfr, , cond1);
The timestamp_condition argument is null, while the timecheck_condition argument is .
cond1
The timestamp_condition and timecheck_condition arguments are associated with either the reference or
data signals based on which delayed version of these signals occurs first. timestamp_condition is associated
with the delayed signal that transitions first, while timecheck_condition is associated with the delayed signal
that transitions second.
Delayed signals are only created for the reference and data signals and not for any condition signals
associated with them. Therefore, timestamp_condition and timecheck_condition are not implicitly delayed
by the simulator. Delayed condition signals for the timestamp_condition and timecheck_condition fields can
be created by making them a function of the delayed signals.
For example:
assign TE_cond_D = (dTE !== 1'b1);
assign TE_cond_TI = (dTE !== 1'b0);
assign DXTI_cond = (dTI !== dD);
specify
$setuphold(posedge CP, D, -10, 20, notifier, ,TE_cond_D, dCP, dD);
$setuphold(posedge CP, TI, 20, -10, notifier, ,TE_cond_TI, dCP, dTI);
890
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
$setuphold(posedge CP, TE, -4, 8, notifier, ,DXTI_cond, dCP, dTE);
endspecify
The assign statements create condition signals that are functions of the delayed signals. Creating delayed
signal conditions synchronizes the conditions with the delayed versions of the reference and data signals
used to perform the checks.
The first has a negative setup time; therefore, the timecheck condition is
$setuphold TE_cond_D
associated with data signal . The second has a negative hold time; therefore, the timecheck
D $setuphold
condition is associated with reference signals . The third has a negative setup
TE_cond_TI CP $setuphold
time; therefore, the timecheck condition is associated with data signal .
DXTI_cond TE
The violation windows for the example are shown in Figure31-6.
CP
500
D
510 520
TE
504 508
TI
480 490
Figure31-6—Timing check violation windows
These are the delay values calculated for the delayed signals:
dCP 10.01
dD 0.00
dTI 20.02
dTE 2.02
Use of delayed signals in creating the signals for the timestamp_condition and timecheck_condition
arguments is not required, but it is usually closer to actual device behavior.
31.9.3 Notifiers in negative timing checks
Because the reference and data signals are delayed internally, the detection of the timing violation is also
delayed. Notifier variables in negative timing checks shall be toggled when the timing check detects a
timing violation, which occurs when the delayed signals as measured by the adjusted timing check values
are in violation, not when the undelayed signals at the model inputs as measured by the original timing
check values are in violation.
31.9.4 Option behavior
As already mentioned, the ability of simulators to handle negative values in and
$setuphold $recrem
timing checks shall be enabled with an invocation option. It is possible models written to accept negative
timing check values with delayed reference and/or delayed data signals can be run without this invocation
option enabled. In this circumstance, the delayed reference and data signals become copies of the original
reference and data signals. The same occurs if an invocation option turning off all timing checks is used.
891
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
32. Backannotation using the standard delay format
32.1 General
This clause describes the following:
— Standard delay format (SDF) annotator
— Mapping SDF constructs to SystemVerilog
— Multiple annotations
— Multiple SDF files
— Pulse limit annotation
— SDF to SystemVerilog value mapping
— The $sdf_annotate SDF file reader
32.2 Overview
SDF files contain timing values for specify path delays, specparam values, timing check constraints, and
interconnect delays. SDF files can also contain other information in addition to simulation timing, but these
need not concern SystemVerilog simulation. The timing values in SDF files usually come from application-
specific integrated circuit (ASIC) delay calculation tools that take advantage of connectivity, technology,
and layout geometry information.
SystemVerilog backannotation is the process by which timing values from the SDF file update specify path
delays, specparam values, timing constraint values, and interconnect delays.
All this information is covered further in IEEE Std 1497™-2001 [B1].
32.3 The SDF annotator
The term SDF annotator refers to any tool capable of backannotating SDF data to a SystemVerilog
simulator. It shall issue a warning for any data it is unable to annotate.
An SDF file can contain many constructs that are not related to specify path delays, specparam values,
timing check constraint values, or interconnect delays. An example is any construct in the
TIMINGENV
section of the SDF file. All constructs unrelated to SystemVerilog timing shall be ignored without any
warnings issued.
Any SystemVerilog timing value for which the SDF file does not provide a value shall not be modified
during the backannotation process, and its prebackannotation value shall be unchanged.
32.4 Mapping of SDF constructs to SystemVerilog
SDF timing values appear within a declaration, which can contain one or more of ,
CELL DELAY
, and sections. The section contains propagation delay values for specify paths
TIMINGCHECK LABEL DELAY
and interconnect delays. The section contains timing check constraint values. The
TIMINGCHECK LABEL
section contains new values for specparams. Backannotation into SystemVerilog is done by matching SDF
constructs to the corresponding SystemVerilog declarations and then replacing the existing SystemVerilog
timing values with those from the SDF file.
892
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
32.4.1 Mapping of SDF delay constructs to SystemVerilog declarations
When annotating constructs that are not interconnect delays (covered in 32.4.4), the SDF annotator
DELAY
looks for specify paths where the names and conditions match. When annotating constructs,
TIMINGCHECK
the SDF annotator looks for timing checks of the same type where the names and conditions match.
Table32-1 shows which SystemVerilog structures can be annotated by each SDF construct in the
DELAY
section.
Table32-1—Mapping of SDF delay constructs to SystemVerilog declarations
SDF construct SystemVerilog annotated structure
( ... Conditional and nonconditional specify path pulse limits
PATHPULSE
( ... Conditional and nonconditional specify path pulse limits
PATHPULSEPERCENT
( ... Conditional and nonconditional specify path delays/pulse limits
IOPATH
( ( ... Conditional and nonconditional specify path delays/pulse limits,
IOPATH RETAIN
may be ignored
RETAIN
( ( ... Conditional specify path delays/pulse limits
COND IOPATH
( ( ( ... Conditional specify path delays/pulse limits, may be ignored
COND IOPATH RETAIN RETAIN
( ( ... ifnone
CONDELSE IOPATH
( ( ( ... ifnone, may be ignored
CONDELSE IOPATH RETAIN RETAIN
( ... All specify paths to module outputs. If no specify paths, all primitives
DEVICE
driving module outputs.
( port_instance... If port_instance is a module instance, all specify paths to module
DEVICE
outputs. If no specify paths, all primitives driving module outputs. If
port_instance is a module instance output, all specify paths to that
module output. If no specify path, all primitives driving that module
output.
In the following example, the source SDF signal matches the source SystemVerilog signal, and the
sel
destination SDF signal also matches the destination SystemVerilog signal. Therefore, the rise/fall
zout
times of and are annotated to the specify path.
1.3 1.7
SDF file:
(IOPATH sel zout (1.3) (1.7))
SystemVerilog specify path:
(sel => zout) = 0;
A conditional delay between two ports shall annotate only to SystemVerilog specify paths between
IOPATH
those same two ports with the same condition. In the following example, the rise/fall times of and
1.3 1.7
are annotated only to the second specify path:
SDF file:
(COND mode (IOPATH sel zout (1.3) (1.7)))
893
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.