IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
. . .
initial
begin
$dumpports(testbench.DUT, "testoutput.vcd");
. . .
end
endmodule
This example produces the following node information in the VCD file:
$scope module testbench.DUT $end
$var port 1 <0 count_out $end
$var port 1 <1 carry $end
$var port [0:3] <2 data $end
$var port 1 <3 reset $end
$upscope $end
At least one space shall separate each syntactical element. However, the formatting of the information is the
choice of the simulator vendor. All 4-state VCD syntax rules for the vector_index apply.
If the vector_index appears in the port declaration, this shall be the index dumped. If the vector_index is not
in the port declaration, the vector_index in the net or variable declaration matching the port name shall be
dumped. If no vector_index is found, the port is considered scalar (1-bit wide).
Concatenated ports shall appear in the extended VCD file as separate entries.
For example:
module addbit ({A, b}, ci, sum, co);
input A, b, ci;
output sum, co;
. . .
The VCD file output looks like the following:
$scope module addbit $end
$var port 1 <0 A $end
$var port 1 <1 b $end
$var port 1 <2 ci $end
$enddefinitions $end
. . .
21.7.4.3 Value changes
The value change section of the VCD file is also affected by , as Syntax21-29 shows.
$dumpports
value ::= port_value 0_strength_component 1_strength_component
p
Syntax21-29—Syntax for value change section (not in AnnexA)
The constructs are defined as follows:
Key character that indicates a port. There is no space between the and the
p p
port_value.
port_value State character (described as follows).
669
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
0_strength_component One of the eight SystemVerilog strengths that indicates the strength0
specification for the port.
1_strength_component One of the eight SystemVerilog strengths that indicates the strength1
specification for the port.
The SystemVerilog strength values are as follows (append keyword with or as appropriate for the
0 1
strength component):
highz
0
small
1
medium
2
weak
3
large
4
pull
5
strong
6
supply
7
identifier_code the integer preceded by the character as defined in the construct for the
< $var
port.
21.7.4.3.1 State characters
The following state information is listed in terms of input values from a test fixture, the output values of the
device under test (DUT), and the states representing unknown direction:
INPUT (TESTFIXTURE):
low
D
high
U
unknown
N
three-state
Z
low (two or more drivers active)
d
high (two or more drivers active)
u
OUTPUT (DUT):
low
L
high
H
unknown (do not care)
X
three-state
T
low (two or more drivers active)
l
high (two or more drivers active)
h
UNKNOWN DIRECTION:
low (both input and output are active with value)
0 0
high (both input and output are active with value)
1 1
unknown
?
three-state (input and output unconnected)
F
unknown (input and output )
A 0 1
unknown (input and output )
a 0 X
670
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
unknown (input and output )
B 1 0
unknown (input and output )
b 1 X
unknown (input and output )
C X 0
unknown (input and output )
c X 1
unknown (input and output three-stated)
f
21.7.4.3.2 Drivers
Drivers are considered only in terms of primitives, continuous assignments, and procedural continuous
assignments. Value / means both input and output are active with value / . and are conflict states.
01 01 0 1
The following rules apply to conflicts:
— If both input and output are driving the same value with the same range of strength, then this is a
conflict. The resolved value is / , and the strength is the stronger of the two.
01
— If the input is driving a strong strength (range) and the output is driving a weak strength (range), the
resolved value is d/u, and the strength is the strength of the input.
— If the input is driving a weak strength (range) and the output is driving a strong strength (range), then
the resolved value is l/h, and the strength is the strength of the output.
Range is as follows:
— Strength 7 to 5 : strong strength
— Strength 4 to 1: weak strength
21.7.4.4 Extended VCD file format example
The following example illustrates the format of the extended VCD file.
A module declaration:
module adder(data0, data1, data2, data3, carry, as, rdn, reset,
test, write);
inout data0, data1, data2, data3;
output carry;
input as, rdn, reset, test, write;
. . .
and the resulting VCD fragment:
$scope module testbench.adder_instance $end
$var port 1 <0 data0 $end
$var port 1 <1 data1 $end
$var port 1 <2 data2 $end
$var port 1 <3 data3 $end
$var port 1 <4 carry $end
$var port 1 <5 as $end
$var port 1 <6 rdn $end
$var port 1 <7 reset $end
$var port 1 <8 test $end
$var port 1 <9 write $end
$upscope $end
$enddefinitions $end
#0
$dumpports
pX 6 6 <0
671
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
pX 6 6 <1
pX 6 6 <2
pX 6 6 <3
pX 6 6 <4
pN 6 6 <5
pN 6 6 <6
pU 0 6 <7
pD 6 0 <8
pN 6 6 <9
$end
#180
pH 0 6 <4
#200000
pD 6 0 <5
pU 0 6 <6
pD 6 0 <9
#200500
pf 0 0 <0
pf 0 0 <1
pf 0 0 <2
pf 0 0 <3
21.7.5 VCD SystemVerilog type mappings
SystemVerilog does not extend the IEEE 1364-2005 VCD format. Some SystemVerilog types can be
dumped into a standard VCD file by masquerading as an IEEE 1364-2005 type. Table21-12 lists the basic
SystemVerilog types and their mapping to an IEEE 1364-2005 type for VCD dumping.
Table21-12—VCD type mapping
IEEE 1364-2005
SystemVerilog Size
Verilog
Total size of packed dimension
bit reg
Total size of packed dimension
logic reg
32
int integer
16
shortint reg
64
longint reg
8
byte reg
32
enum integer
—
shortreal real
Packed arrays and structures are dumped as a single vector of . Multiple packed array dimensions are
reg
collapsed into a single dimension.
If an declaration specified a type, it is dumped as that type rather than the default shown previoiusly.
enum
Unpacked structures appear as named fork-join blocks, and their member elements of the structure appear as
the preceding types. Because named fork-join blocks with variable declarations are seldom used in
testbenches and hardware models, this makes structures easy to distinguish from variables declared in
begin-end blocks, which are more frequently used in testbenches and models.
672
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Unpacked arrays and automatic variables are not dumped.
NOTE—The current VCD format does not indicate whether a variable has been declared as or .
signed unsigned
673
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
22. Compiler directives
22.1 General
This clause describes the following compiler directives (listed alphabetically):
[22.13]
`__FILE__
[22.13]
`__LINE__
[22.14]
`begin_keywords
[22.10]
`celldefine
[22.8]
`default_nettype
[22.5.1]
`define
[22.6]
`else
[22.6]
`elsif
[22.14]
`end_keywords
[22.10]
`endcelldefine
[22.6]
`endif
[22.6]
`ifdef
[22.6]
`ifndef
[22.4]
`include
[22.12]
`line
[22.9]
`nounconnected_drive
[22.11]
`pragma
[22.3]
`resetall
[22.7]
`timescale
[22.9]
`unconnected_drive
[22.5.2]
`undef
[22.5.3]
`undefineall
22.2 Overview
All compiler directives are preceded by the ( ) character. This character is called grave accent (ASCII
`
0x60). It is different from the character ( ), which is the apostrophe character (ASCII 0x27). The scope of a
'
compiler directive extends from the point where it is processed, across all files processed in the current
compilation unit, to the point where another compiler directive supersedes it or the processing of the
compilation unit completes. The semantics of compiler directives is defined in 3.12.1 and 5.6.4.
22.3 `resetall
When compiler directive is encountered during compilation, all compiler directives are set to
`resetall
the default values. This is useful for ensuring that only directives that are desired in compiling a particular
source file are active.
The recommended usage is to place at the beginning of each source text file, followed
`resetall
immediately by the directives desired in the file.
It shall be illegal for the directive to be specified within a design element.
`resetall
Not all compiler directives have a default value (e.g., and ). Directives that do not have
`define `include
a default are not affected by .
`resetall
674
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
22.4 `include
The file inclusion ( ) compiler directive is used to insert the entire contents of a source file in
`include
another file during compilation. The result is as though the contents of the included source file appear in
place of the compiler directive.
`include
The syntax of the compiler directive is given in Syntax22-1.
`include
include_compiler_directive ::=
filename
`include " "
| filename
`include < >
Syntax22-1—Syntax for include compiler directive (not in AnnexA)
The compiler directive can be specified anywhere within the SystemVerilog source description.
`include
Only white space or a comment may appear on the same line as the compiler directive.
`include
The filename is the name of the file to be included in the source file. The filename can be a full or relative
path name.
The filename can be enclosed in either quotes or angle brackets, which affects how a tool searches for the
file, as follows:
— When the filename is enclosed in double quotes ( filename ), for a relative path the compiler’s
" "
current working directory, and optionally user-specified locations are searched.
— When the filename is enclosed in angle brackets ( filename ), then only an implementation-
< >
dependent location containing files defined by the language standard is searched. Relative path
names are interpreted relative to that location.
When the filename is an absolute path, only that filename is included and only the double quote form of the
can be used.
`include
A file included in the source using the compiler directive may contain other compiler
`include `include
directives. The number of nesting levels for include files shall be finite. Implementations may limit the
maximum number of levels to which include files can be nested, but the limit shall be at least 15.
Examples of compiler directives are as follows:
`include
`include "parts/count.v"
`include "fileB" // including fileB
`include <List.vh>
22.5 `define, `undef, and `undefineall
A text macro substitution facility has been provided so that meaningful names can be used to represent
commonly used pieces of text. For example, in the situation where a constant number is repetitively used
throughout a description, a text macro would be useful in that only one place in the source description would
need to be altered if the value of the constant needed to be changed.
The text macro facility is not affected by the compiler directive .
`resetall
675
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
22.5.1 `define
The directive creates a macro for text substitution. This directive can be used both inside and
`define
outside design elements. After a text macro is defined, it can be used in the source description by using the
( ) character, followed by the macro name. The compiler shall substitute the text of the macro for the string
`
and any actual arguments that follow it. All compiler directives shall be considered
`text_macro_name
predefined macro names; it shall be illegal to redefine a compiler directive as a macro name.
A text macro can be defined with arguments. This allows the macro to be customized for each use
individually.
The syntax for text macro definitions is given in Syntax22-2.
text_macro_definition ::=
text_macro_name macro_text
`define
text_macro_name ::=
text_macro_identifier [ list_of_formal_arguments ]
( )
list_of_formal_arguments ::=
formal_argument { formal_argument }
,
formal_argument ::=
simple_identifier [ default_text ]
=
text_macro_identifier ::=
identifier
Syntax22-2—Syntax for text macro definition (not in AnnexA)
The macro text can be any arbitrary text specified on the same line as the text macro name. If more than one
line is necessary to specify the text, the newline character shall be preceded by a backslash ( ). The first
\
newline character not preceded by a backslash shall end the macro text. The newline character preceded by a
backslash shall be replaced in the expanded macro with a newline character (but without the preceding
backslash character).
When formal arguments are used to define a text macro, the scope of the formal argument shall extend up to
the end of the macro text. A formal argument can be used in the macro text in the same manner as an
identifier.
If formal arguments are used, the list of formal argument names shall be enclosed in parentheses following
the name of the macro. The formal argument names shall be simple_identifiers, separated by commas and
optionally white space. The left parenthesis shall follow the text macro name immediately, with no space in
between.
A formal macro argument may have a default. A default is specified by appending an = token after the
formal argument name, followed by the default text. The default text is substituted for the formal argument
if no corresponding actual argument is specified.
The default text may be explicitly specified to be empty by adding an = token after the formal argument
name, followed by a comma (or a right parenthesis if it is the last argument in the argument list).
If a one-line comment (that is, a comment specified with the characters //) is included in the text, then the
comment shall not become part of the substituted text. The macro text can be blank, in which case the text
macro is defined to be empty and no text is substituted when the macro is used.
676
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The syntax for using a text macro is given in Syntax22-3.
text_macro_usage ::=
text_macro_identifier [ list_of_actual_arguments ]
` ( )
list_of_actual_arguments ::=
actual_argument { actual_argument }
,
actual_argument ::=
expression
Syntax22-3—Syntax for text macro usage (not in AnnexA)
For a macro without arguments, the text shall be substituted as is for every occurrence of
. However, a text macro with one or more arguments shall be expanded by
`text_macro_identifier
substituting each formal argument with the expression used as the actual argument in the macro usage.
To use a macro defined with arguments, the name of the text macro shall be followed by a list of actual
arguments in parentheses, separated by commas. Actual arguments and defaults shall not contain comma or
right parenthesis characters outside matched pairs of left and right parentheses , square brackets ,
() []
braces , double quotes , or an escaped identifier.
{} ""
White space shall be allowed between the text macro name and the left parenthesis in the macro usage.
An actual argument may be empty or white space only, in which case the formal argument is substituted by
the argument default if one is specified or by nothing if no default is specified.
If fewer actual arguments are specified than the number of formal arguments and all the remaining formal
arguments have defaults, then the defaults are substituted for the additional formal arguments. It shall be an
error if any of the remaining formal arguments does not have a default specified. For a macro with
arguments, the parentheses are always required in the macro call, even if all the arguments have defaults. It
shall be an error to specify more actual arguments than the number of formal arguments.
Example macro without defaults:
`define D(x,y) initial $display("start", x , y, "end");
`D( "msg1" , "msg2" )
// expands to 'initial $display("start", "msg1" , "msg2", "end");'
`D( " msg1", )
// expands to 'initial $display("start", " msg1" , , "end");'
`D(, "msg2 ")
// expands to 'initial $display("start", , "msg2 ", "end");'
`D(,)
// expands to 'initial $display("start", , , "end");'
`D( , )
// expands to 'initial $display("start", , , "end");'
`D("msg1")
// illegal, only one argument
`D()
// illegal, only one empty argument
`D(,,)
// illegal, more actual than formal arguments
Example macros with defaults:
677
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
`define MACRO1(a=5,b="B",c) $display(a,,b,,c);
`MACRO1 ( , 2, 3 ) // argument a omitted, replaced by default
// expands to '$display(5,,2,,3);'
`MACRO1 ( 1 , , 3 ) // argument b omitted, replaced by default
// expands to '$display(1,,"B",,3);'
`MACRO1 ( , 2, ) // argument c omitted, replaced by nothing
// expands to '$display(5,,2,,);'
`MACRO1 ( 1 ) // ILLEGAL: b and c omitted, no default for c
`define MACRO2(a=5, b, c="C") $display(a,,b,,c);
`MACRO2 (1, , 3) // argument b omitted, replaced by nothing
// expands to '$display(1,,,,3);'
`MACRO2 (, 2, ) // a and c omitted, replaced by defaults
// expands to '$display(5,,2,,"C");'
`MACRO2 (, 2) // a and c omitted, replaced by defaults
// expands to '$display(5,,2,,"C");'
`define MACRO3(a=5, b=0, c="C") $display(a,,b,,c);
`MACRO3 ( 1 ) // b and c omitted, replaced by defaults
// expands to '$display(1,,0,,"C");'
`MACRO3 ( ) // all arguments replaced by defaults
// expands to '$display(5,,0,,"C");'
`MACRO3 // ILLEGAL: parentheses required
Once a text macro name has been defined, it can be used anywhere in the compilation unit where it is
defined. There are no other scope restrictions once inside the compilation unit. Implementations may also
allow text macros to be defined and used interactively.
The text specified for macro text shall not be split across the following lexical tokens:
— Comments
— Numbers
— String literals
— Identifiers
— Keywords
— Operators
For example:
`define wordsize 8
logic [1:`wordsize] data;
//define a nand with variable delay
`define var_nand(dly) nand #dly
`var_nand(2) g121 (q21, n10, n11);
`var_nand(5) g122 (q22, n10, n11);
The following is illegal syntax because it is split across a string:
`define first_half "start of string
$display(`first_half end of string");
678
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Each actual argument is substituted for the corresponding formal argument literally. Therefore, when an
expression is used as an actual argument, the expression will be substituted in its entirety. This may cause an
expression to be evaluated more than once if the formal argument was used more than once in the macro
text. For example:
`define max(a,b)((a) > (b) ? (a) : (b))
n = `max(p+q, r+s) ;
will expand as
n = ((p+q) > (r+s) ? (p+q) : (r+s)) ;
Here, the larger of the two expressions and will be evaluated twice.
p + q r + s
The word is known as a compiler directive keyword, and it is not part of the normal set of keywords.
define
Thus, normal identifiers in a SystemVerilog source description can be the same as compiler directive
keywords. The following problems should be considered:
a) Text macro names shall not be the same as compiler directive keywords.
b) Text macro names can reuse names being used as ordinary identifiers. For example,
signal_name
and are different.
`signal_name
c) Redefinition of text macros is allowed; the latest definition of a particular text macro read by the
compiler prevails when the macro name is encountered in the source text.
The macro text and argument defaults may contain usages of other text macros. Such usages shall be
substituted after the outer macro is substituted, not when it is defined. If an actual argument or an argument
default contains a macro usage, the macro usage shall be expanded only after substitution into the outer
macro text.
If a formal argument has a nonempty default and one wants to replace the formal argument with an empty
actual argument, one cannot simply omit the actual argument, as then the default will be used. However, one
can define an empty text macro, say , and use that as the actual argument. This will be substituted in
`EMPTY
place of the formal argument and will be replaced by empty text after expansion of the empty text macro.
When a macro usage is passed as an actual argument or a default to another macro, the argument expansion
does not introduce new uses of the formal arguments to the top-level macro.
Example:
`define TOP(a,b) a + b
`TOP( `TOP(b,1), `TOP(42,a) )
expands to:
b + 1 + 42 + a
not into:
42 + a + 1 + 42 + a
nor into:
b + 1 + 42 + b + 1
It shall be an error for a macro to expand directly or indirectly to text containing another usage of itself (a
recursive macro). However, an actual argument to a macro or a default may contain a usage of itself, as in
the previous example.
Macro substitution and argument substitution shall not occur within string literals. For example,
module main;
`define HI Hello
`define LO "`HI, world"
679
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
`define H(x) "Hello, x"
initial begin
$display("`HI, world");
$display(`LO);
$display(`H(world));
end
endmodule
will print:
`HI, world
`HI, world
Hello, x
The macro text can also include , , and
`define `" `\`" ``.
An overrides the usual lexical meaning of and indicates that the expansion shall include the quotation
`" "
mark, substitution of actual arguments, and expansions of embedded macros. This allows string literals to be
constructed from macro arguments.
A mixture of and is allowed in the macro text, however the use of always starts a string literal and
`" " "
must have a terminating . Any characters embedded inside this string literal, including , become part of
" `"
the string in the replaced macro text. Thus, if is followed by , the starts a string literal whose last
" `" "
character is and is terminated by the of .
` " `"
A indicates that the expansion should include the escape sequence . For example:
`\`" \"
`define msg(x,y) `"x: `\`"y`\`"`"
An example of using this macro is:
`msg
$display(`msg(left side,right side));
The preceding example expands to:
$display("left side: \"right side\"");
A delimits lexical tokens without introducing white space, allowing identifiers to be constructed from
``
arguments. For example:
`define append(f) f``_master
An example of using this macro is:
`append
`append(clock)
This example expands to:
clock_master
The directive can be followed by a macro, instead of a string literal:
`include
`define home(filename) `"/home/mydir/filename`"
`include `home(myfile)
680
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
22.5.2 `undef
The directive shall undefine the specified text macro if previously defined by a compiler
`undef `define
directive within the compilation unit. An attempt to undefine a text macro that was not previously defined
using a compiler directive can issue a warning. The syntax for the compiler directive is
`define `undef
given in Syntax22-4.
undefine_compiler_directive ::=
text_macro_identifier
`undef
Syntax22-4—Syntax for undef compiler directive (not in AnnexA)
An undefined text macro has no value, just as if it had never been defined.
22.5.3 `undefineall
The directive shall undefine all text macros previously defined by compiler
`undefineall `define
directives within the compilation unit. This directive takes no arguments and may appear anywhere in the
source description.
22.6 `ifdef, `else, `elsif, `endif, `ifndef
These conditional compilation compiler directives are used to include optionally lines of SystemVerilog
source description during compilation.
These directives may appear anywhere in the source description.
Situations where the , , , , and compiler directives may be useful
`ifdef `else `elsif `endif `ifndef
include the following:
— Selecting different representations of a design element such as behavioral, structural, or switch level
— Choosing different timing or structural information
— Selecting different stimulus for a given run
The , , , , and compiler directives have the syntax shown in
`ifdef `else `elsif `endif `ifndef
Syntax22-5.
conditional_compilation_directive ::=
ifdef_directive
| ifndef_directive
ifdef_directive ::=
text_macro_identifier ifdef_group_of_lines
`ifdef
{ text_macro_identifier elsif_group_of_lines }
`elsif
[ else_group_of_lines ]
`else
`endif
ifndef_directive ::=
text_macro_identifier ifndef_group_of_lines
`ifndef
{ text_macro_identifier elsif_group_of_lines }
`elsif
[ else_group_of_lines ]
`else
`endif
Syntax22-5—Syntax for conditional compilation directives (not in AnnexA)
681
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The text_macro_identifier is a SystemVerilog identifier. The ifdef_group_of_lines, ifndef_group_of_lines,
elsif_group_of_lines, and the else_group_of_lines are parts of a SystemVerilog source description. The
and compiler directives and all of the groups of lines are optional.
`else `elsif
The , , , and compiler directives work together in the following manner:
`ifdef `else `elsif `endif
— When an is encountered, the text_macro_identifier is tested to see whether it is
`ifdef `ifdef
defined as a text macro name using within the SystemVerilog source description.
`define
— If the text_macro_identifier is defined, the group of lines is compiled as part of the
`ifdef `ifdef
description; and if there are or compiler directives, these compiler directives and
`else `elsif
corresponding groups of lines are ignored.
— If the text_macro_identifier has not been defined, the group of lines is ignored.
`ifdef `ifdef
— If there is an compiler directive, the text macro identifier is tested to see whether it
`elsif `elsif
is defined as a text macro name using within the SystemVerilog source description.
`define
— If the text macro identifier is defined, the group of lines is compiled as part of the
`elsif `elsif
description; and if there are other or compiler directives, the other or
`elsif `else `elsif `else
directives and corresponding groups of lines are ignored.
— If the first text_macro_identifier has not been defined, the first group of lines is
`elsif `elsif
ignored.
— If there are multiple compiler directives, they are evaluated like the first compiler
`elsif `elsif
directive in the order they are written in the SystemVerilog source description.
— If there is an compiler directive, the group of lines is compiled as part of the
`else `else
description.
The , , , and compiler directives work together in the following manner:
`ifndef `else `elsif `endif
— When an is encountered, the text_macro_identifier is tested to see whether it is
`ifndef `ifndef
defined as a text macro name using within the SystemVerilog source description.
`define
— If the text_macro_identifier is not defined, the group of lines is compiled as part
`ifndef `ifndef
of the description; and if there are or compiler directives, these compiler directives
`else `elsif
and corresponding groups of lines are ignored.
— If the text_macro_identifier is defined, the group of lines is ignored.
`ifndef `ifndef
— If there is an compiler directive, the text_macro_identifier is tested to see whether
`elsif `elsif
it is defined as a text macro name using within the SystemVerilog source description.
`define
— If the text_macro_identifier is defined, the group of lines is compiled as part of the
`elsif `elsif
description; and if there are other or compiler directives, the other or
`elsif `else `elsif `else
directives and corresponding groups of lines are ignored.
— If the first text_macro_identifier has not been defined, the first group of lines is
`elsif `elsif
ignored.
— If there are multiple compiler directives, they are evaluated like the first compiler
`elsif `elsif
directive in the order they are written in the SystemVerilog source description.
— If there is an compiler directive, the group of lines is compiled as part of the
`else `else
description.
Although the names of compiler directives are contained in the same name space as text macro names, the
names of compiler directives are considered not to be defined by , , and .
`ifdef `ifndef `elsif
Nesting of , , , , and compiler directives shall be permitted.
`ifdef `ifndef `else `elsif `endif
Any group of lines that the compiler ignores shall still follow the SystemVerilog lexical conventions for
white space, comments, numbers, strings, identifiers, keywords, and operators.
682
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 1: The following example shows a simple usage of an directive for conditional
`ifdef
compilation. If the identifier is defined, a continuous net assignment will be compiled in;
behavioral
otherwise, an gate will be instantiated.
and
module and_op (a, b, c);
output a;
input b, c;
`ifdef behavioral
wire a = b & c;
`else
and a1 (a,b,c);
`endif
endmodule
Example 2: The following example shows usage of nested conditional compilation directives:
module test(out);
output out;
`define wow
`define nest_one
`define second_nest
`define nest_two
`ifdef wow
initial $display("wow is defined");
`ifdef nest_one
initial $display("nest_one is defined");
`ifdef nest_two
initial $display("nest_two is defined");
`else
initial $display("nest_two is not defined");
`endif
`else
initial $display("nest_one is not defined");
`endif
`else
initial $display("wow is not defined");
`ifdef second_nest
initial $display("second_nest is defined");
`else
initial $display("second_nest is not defined");
`endif
`endif
endmodule
Example 3: The following example shows usage of chained nested conditional compilation directives:
module test;
`ifdef first_block
`ifndef second_nest
initial $display("first_block is defined");
`else
initial $display("first_block and second_nest defined");
`endif
`elsif second_block
initial $display("second_block defined, first_block is not");
`else
`ifndef last_result
683
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
initial $display("first_block, second_block,",
" last_result not defined.");
`elsif real_last
initial $display("first_block, second_block not defined,",
" last_result and real_last defined.");
`else
initial $display("Only last_result defined!");
`endif
`endif
endmodule
22.7 `timescale
This directive specifies the time unit and time precision of the design elements that follow it. The time unit is
the unit of measurement for time values such as the simulation time and delay values.
To use design elements with different time units in the same design, the following timescale constructs are
useful:
— The and keywords to specify the unit of measurement for time and
timeunit timeprecision
precision of time in specific design elements (see 3.14.2.2)
— The compiler directive to specify the unit of measurement for time and precision of
`timescale
time in the design elements that follow the directive
— The system task to display the time unit and precision of a design element
$printtimescale
— The and system functions, the system task, and the format
$time $realtime $timeformat %t
specification to specify how time information is reported
The compiler directive specifies the default unit of measurement for time and delay values and
`timescale
the degree of accuracy for delays in all design elements that follow this directive, and that do not have
and constructs specified within the design element, until another
timeunit timeprecision `timescale
compiler directive is read.
See 3.14.2.3 for the precedence rules of the and constructs versus the
timeunit timeprecision
directive.
`timescale
If there is no specified or it has been reset by a directive, the default time unit and
`timescale `resetall
precision are tool-specific.
The syntax for the directive is given in Syntax22-6.
`timescale
timescale_compiler_directive ::=
time_unit time_precision
`timescale /
Syntax22-6—Syntax for timescale compiler directive (not in AnnexA)
The time_unit argument specifies the unit of measurement for times and delays.
The time_precision argument specifies how delay values are rounded before being used in simulation.
The time_precision argument shall be at least as precise as the time_unit argument; it cannot specify a longer
unit of time than time_unit.
684
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The integers in these arguments specify an order of magnitude for the size of the value; the valid integers are
1, 10, and 100. The character strings represent units of measurement; the valid character strings are , ,
s ms
, , , and .
us ns ps fs
See 3.14 for the semantics and effects of time_unit and time_precision.
The following example shows how this directive is used:
`timescale 1 ns / 1 ps
Here, all time values in the design elements that follow the directive are multiples of 1 ns because the
argument is “1 ns.” Delays are rounded to real numbers with three decimal places—or precise
time_unit
to within one thousandth of a nanosecond—because the argument is “1 ps,” or one
time_precision
thousandth of a nanosecond.
Consider the following example:
`timescale 10 us / 100 ns
The time values in the design elements that follow this directive are multiples of because the
10 us
argument is “10 us.” Delays are rounded to within one tenth of a microsecond because the
time_unit
argument is “100 ns,” or one tenth of a microsecond.
time_precision
The following example shows a directive in the context of a module:
`timescale
`timescale 10 ns / 1 ns
module test;
logic set;
parameter d = 1.55;
initial begin
#d set = 0;
#d set = 1;
end
endmodule
The compiler directive specifies that the time unit for module is 10 ns.
`timescale 10 ns / 1 ns test
As a result, the time values in the module are multiples of 10 ns, rounded to the nearest 1 ns; therefore, the
value stored in parameter is scaled to a delay of 16 ns. In other words, the value 0 is assigned to variable
d
at simulation time 16 ns (1.6  10 ns), and the value 1 at simulation time 32 ns.
set
Parameter retains its value no matter what timescale is in effect.
d
These simulation times are determined as follows:
a) The value of parameter is rounded from 1.55 to 1.6 according to the time precision.
d
b) The time unit of the module is 10 ns, and the precision is 1 ns; therefore, the delay of parameter is
d
scaled from 1.6 to 16.
c) The assignment of 0 to variable is scheduled at simulation time 16 ns, and the assignment of
set
1at simulation time 32 ns. The time values are not rounded when the assignments are scheduled.
22.8 `default_nettype
The directive controls the net type created for implicit net declarations (see 6.10). It
`default_nettype
can be used only outside design elements. Multiple directives are allowed. The latest
`default_nettype
685
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
occurrence of this directive in the source controls the type of nets that will be implicitly declared.
Syntax22-7 contains the syntax of the directive.
default_nettype_compiler_directive ::=
default_nettype_value
`default_nettype
default_nettype_value ::= | | | | | | | | | |
wire tri tri0 tri1 wand triand wor trior trireg uwire none
Syntax22-7—Syntax for default_nettype compiler directive (not in AnnexA)
When no directive is present or if the directive is specified, implicit nets
`default_nettype `resetall
are of type . When the is set to , all nets shall be explicitly declared. If a net
wire `default_nettype none
is not explicitly declared, an error is generated.
22.9 `unconnected_drive and `nounconnected_drive
All unconnected input ports of a module, program or interface appearing between the directives
and are pulled up or pulled down instead of the normal
`unconnected_drive `nounconnected_drive
default.
The directive takes one of two arguments— or . When is
`unconnected_drive pull1 pull0 pull1
specified, all unconnected input ports are automatically pulled up. When is specified, unconnected
pull0
ports are pulled down. It is advisable to pair each with a
`unconnected_drive
, but it is not required. The latest occurrence of either directive in the source
`nounconnected_drive
controls what happens to unconnected ports. These directives shall be specified outside the design element
declarations.
The directive includes the effects of a directive.
`resetall `nounconnected_drive
22.10 `celldefine and `endcelldefine
The directives and tag modules as cell modules. Cells are used by certain
`celldefine `endcelldefine
PLI routines and may be useful for applications such as delay calculations. It is advisable to pair each
with an , but it is not required. The latest occurrence of either directive in
`celldefine `endcelldefine
the source controls whether modules are tagged as cell modules. More than one of these pairs may appear in
a single source description.
These directives may appear anywhere in the source description, but it is recommended that the directives be
specified outside any design elements.
The directive includes the effects of a directive.
`resetall `endcelldefine
22.11 `pragma
The directive is a structured specification that alters interpretation of the SystemVerilog source.
`pragma
The specification introduced by this directive is referred to as a pragma. The effect of pragmas other than
those specified in this standard is implementation-specific. The syntax for the directive is given in
`pragma
Syntax22-8.
pragma ::=
pragma_name [ pragma_expression { pragma_expression } ]
`pragma ,
pragma_name ::= simple_identifier
686
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
pragma_expression ::=
pragma_keyword
| pragma_keyword pragma_value
=
| pragma_value
pragma_value ::=
pragma_expression { pragma_expression }
( , )
| number
| string
| identifier
pragma_keyword ::= simple_identifier
Syntax22-8—Syntax for pragma compiler directive (not in AnnexA)
The pragma specification is identified by the pragma_name, which follows the directive. The
`pragma
pragma_name is followed by an optional list of pragma_expressions, which qualify the altered
interpretation indicated by the pragma_name. Unless otherwise specified, pragma directives for
pragma_names that are not recognized by an implementation shall have no effect on interpretation of the
SystemVerilog source text.
22.11.1 Standard pragmas
The and pragmas shall restore the default values and state of pragma_keywords
reset resetall
associated with the affected pragmas. These default values shall be the values that the tool defines before
any SystemVerilog text has been processed. The pragma shall reset the state for all pragma_names
reset
that appear as pragma_keywords in the directive. The pragma shall reset the state of all
resetall
pragma_names recognized by the implementation.
The pragma is used to specify protected envelopes, as described in Clause34.
protect
22.12 `line
It is important for SystemVerilog tools to keep track of the file names of the SystemVerilog source files and
the line numbers in the files. This information can be used for error messages or source code debugging and
can be accessed by the Programming Language Interface (PLI) (see Clause36).
In many cases, however, the SystemVerilog source is preprocessed by some other tool, and the line and file
information of the original source file can be lost because the preprocessor might add additional lines to the
source code file, combine multiple source code lines into one line, concatenate multiple source files, and so
on.
The compiler directive can be used to specify the original source code line number and file name.
`line
This allows the location in the original file to be maintained if another process modifies the source. After the
new line number and file name are specified, the compiler can correctly refer to the original source location.
However, a tool is not required to produce directives. These directives are not intended to be inserted
`line
manually into the code, although they can be.
The compiler shall maintain the current line number and file name of the file being compiled. The
`line
directive shall set the line number and file name of the following line to those specified in the directive. The
directive can be specified anywhere within the SystemVerilog source description. However, only white
space may appear on the same line as the directive. Comments are not allowed on the same line as a
`line
directive. All parameters in the directive are required. The results of this directive are not
`line `line
affected by the directive.
`resetall
687
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The syntax for the compiler directive is given in Syntax22-9.
`line
line_compiler_directive ::=
number filename level
`line " "
Syntax22-9—Syntax for line compiler directive (not in AnnexA)
The number parameter shall be a positive integer that specifies the new line number of the following text
line. The filename parameter shall be a string literal that is treated as the new name of the file. The filename
can also be a full or relative path name. The level parameter shall be 0, 1, or 2. The value 1 indicates that the
following line is the first line after an include file has been entered. The value 2 indicates that the following
line is the first line after an include file has been exited. The value 0 indicates any other line.
For example:
`line 3 "orig.v" 2
// This line is line 3 of orig.v after exiting include file
As the compiler processes the remainder of the file and new files, the line number shall be incremented as
each line is read, and the name shall be updated to the new current file being processed. The line number
shall be reset to 1 at the beginning of each file. When beginning to read include files, the current line and file
name shall be stored for restoration at the termination of the include file. The updated line number and file
name information shall be available for PLI access. The mechanism of library searching is not affected by
the effects of the compiler directive.
`line
22.13 `__FILE__ and `__LINE__
expands to the name of the current input file, in the form of a string literal. This is the path by
`__FILE__
which a tool opened the file, not the short name specified in or as a tool’s input file name
`include
argument. The format of this path name may be implementation dependent.
expands to the current input line number, in the form of a simple decimal number.
`__LINE__
and are useful in generating an error message to report a problem; the message can
`__FILE__ `__LINE__
state the source line at which the problem was detected.
For example:
$display("Internal error: null handle at %s, line %d.",
`__FILE__, `__LINE__);
An directive changes the expansions of and to correspond to the
`include `__FILE__ `__LINE__
included file. At the end of that file, when processing resumes on the input file that contained the
`include
directive, the expansions of and revert to the values they had before the
`__FILE__ `__LINE__ `include
(but is then incremented by one as processing moves to the line after the ).
`__LINE__ `include
A directive changes and may change as well.
`line `__LINE__ `__FILE__
688
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
22.14 `begin_keywords, `end_keywords
A pair of directives, and , can be used to specify what identifiers are
`begin_keywords `end_keywords
reserved as keywords within a block of source code, based on a specific version of IEEE Std 1364 or
IEEEStd 1800.
The syntax of the and directives is given in Syntax22-10.
`begin_keywords `end_keywords
keywords_directive ::= version_specifier
`begin_keywords " "
version_specifier ::=
1800-2017
| 1800-2012
| 1800-2009
| 1800-2005
| 1364-2005
| 1364-2001
| 1364-2001-noconfig
| 1364-1995
endkeywords_directive ::=
`end_keywords
Syntax22-10—Syntax for begin_keywords and end_keywords compiler directives (not in AnnexA)
The version_specifier specifies that only the identifiers listed as reserved keywords in the specified version
are considered to be reserved words. The and directives only specify
`begin_keywords `end_keywords
the set of identifiers that are reserved as keywords. The directives do not affect the semantics, tokens, and
other aspects of the SystemVerilog language.
Implementations and other standards are permitted to extend the directive with custom
`begin_keywords
version specifiers. It shall be an error if an implementation does not recognize the version_specifier used
with the directive.
`begin_keywords
The and directives can only be specified outside a design element
`begin_keywords `end_keywords
(see 3.2). The directive affects all source code that follows the directive, even across
`begin_keywords
source code file boundaries, until the matching directive or the end of the compilation
`end_keywords
unit. The results of these directives are not affected by the directive.
`resetall
The ... directive pair can be nested. Each nested pair is stacked so that
`begin_keywords `end_keywords
when an directive is encountered, the implementation returns to using the version_
`end_keywords
specifier that was in effect prior to the matching directive.
`begin_keywords
If no directive is specified, then the reserved keyword list shall be the implementation’s
`begin_keywords
default set of keywords. The default set of reserved keywords used by an implementation shall be
implementation dependent. For example, an implementation based on IEEE Std 1800-2005 would most
likely use the IEEE 1800-2005 set of reserved keywords as its default, whereas an implementation based on
IEEE Std1364-2001 would most likely use the IEEE 1364-2001 set of reserved keywords as its default.
Implementations may provide other mechanisms for specifying the set of reserved keywords to be used as
the default. One possible use model might be for an implementation to use invocation options to specify its
default set of reserved keywords. Another possible use model might be the use of source file name
extensions for determining a default set of reserved keywords to be used for each source file.
689
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
22.14.1 Examples
In the following example, it is assumed that the definition of module does not have a
m1 `begin_keywords
directive specified prior to the module definition. Without this directive, the set of reserved keywords in
effect for this module shall be the implementation’s default set of reserved keywords.
module m1; // module definition with no `begin_keywords directive
...
endmodule
The following example specifies a directive. The source code within
`begin_keywords "1364-2001"
the module uses the identifier as a variable name. The directive would be
logic `begin_keywords
necessary in this example if an implementation uses IEEE Std 1800-2005 as its default set of keywords
because is a reserved keyword in SystemVerilog. Specifying that the or
logic "1364-1995" "1364-
Verilog keyword lists should be used would also work with this example.
2005"
`begin_keywords "1364-2001" // use IEEE Std 1364-2001 Verilog keywords
module m2 (...);
reg [63:0] logic; // OK: "logic" is not a keyword in 1364-2001
...
endmodule
`end_keywords
The next example is the same code as the previous example, except that it explicitly specifies that the
IEEE1800-2005 SystemVerilog keywords should be used. This example shall result in an error because
is reserved as a keyword in this standard.
logic
`begin_keywords "1800-2005" // use IEEE Std 1800-2005 SystemVerilog keywords
module m2 (...);
reg [63:0] logic; // ERROR: "logic" is a keyword in 1800-2005
...
endmodule
`end_keywords
The following example specifies a directive on an declaration. The
`begin_keywords interface
directive specifies that an implementation shall use the set of reserved keywords specified in this standard.
`begin_keywords "1800-2005" // use IEEE Std 1800-2005 SystemVerilog keywords
interface if1 (...);
...
endinterface
`end_keywords
The next example is nearly identical to the preceding one, except that the directive
`begin_keywords
specifies that the IEEE 1364-2005 Verilog set of keywords are to be used. This example shall result in errors
because the identifiers and are not reserved keywords in IEEE Std 1364-2005.
interface endinterface
`begin_keywords "1364-2005" // use IEEE Std 1364-2005 Verilog keywords
interface if2 (...); // ERROR: "interface" is not a keyword in 1364-2005
...
endinterface // ERROR: "endinterface" is not a keyword in 1364-2005
`end_keywords
690
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
22.14.2 IEEE 1364-1995 keywords
The version_specifier specifies that the identifiers listed as reserved keywords in
"1364-1995"
IEEEStd1364-1995 are considered to be reserved words. These identifiers are listed in Table22-1.
Table22-1—IEEE 1364-1995 reserved keywords
always ifnone rpmos
and initial rtran
assign inout rtranif0
begin input rtranif1
buf integer scalared
bufif0 join small
bufif1 large specify
case macromodule specparam
casex medium strong0
casez module strong1
cmos nand supply0
deassign negedge supply1
default nmos table
defparam nor task
disable not time
edge notif0 tran
else notif1 tranif0
end or tranif1
endcase output tri
endfunction parameter tri0
endmodule pmos tri1
endprimitive posedge triand
endspecify primitive trior
endtable pull0 trireg
endtask pull1 vectored
event pulldown wait
for pullup wand
force rcmos weak0
forever real weak1
fork realtime while
function reg wire
highz0 release wor
highz1 repeat xnor
if rnmos xor
22.14.3 IEEE 1364-2001 keywords
The version_specifier specifies that the identifiers listed as reserved keywords in
"1364-2001"
IEEEStd1364-2001 are considered to be reserved words. This version includes the identifiers listed in
version " " (see Table22-1) plus all identifiers in listed in Table22-2.
1364-1995
691
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table22-2—IEEE 1364-2001 additional reserved keywords
automatic incdir pulsestyle_onevent
cell include showcancelled
config instance signed
design liblist unsigned
endconfig library use
endgenerate localparam
generate noshowcancelled
genvar pulsestyle_ondetect
22.14.4 IEEE 1364-2001-noconfig keywords
The version_specifier behaves similarly to the version_specifier,
"1364-2001-noconfig" "1364-2001"
with the exception that the following identifiers are excluded from the reserved list in Table22-2:
cell
config
design
endconfig
incdir
include
instance
liblist
library
use
22.14.5 IEEE 1364-2005 keywords
The version_specifier specifies that the identifiers listed as reserved keywords in
"1364-2005"
IEEEStd1364-2005 are considered to be reserved words. This version includes the identifiers listed in
versions (see Table22-1) and (see Table22-2) plus the additional identifiers
"1364-1995" "1364-2001"
listed in Table22-3.
Table22-3—IEEE 1364-2005 additional reserved keywords
uwire
22.14.6 IEEE 1800-2005 keywords
The version_specifier specifies that the identifiers listed as reserved keywords in IEEEStd
"1800-2005"
1800-2005 are considered to be reserved words. This version includes the identifiers listed in versions
(see Table22-1), (see Table22-2), and (see Table22-3) plus
"1364-1995" "1364-2001" "1364-2005"
the additional identifiers listed in Table22-4.
692
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table22-4—IEEE 1800-2005 additional reserved keywords
alias endsequence pure
always_comb enum rand
always_ff expect randc
always_latch export randcase
assert extends randsequence
assume extern ref
before final return
bind first_match sequence
bins foreach shortint
binsof forkjoin shortreal
bit iff solve
break ignore_bins static
byte illegal_bins string
chandle import struct
class inside super
clocking int tagged
const interface this
constraint intersect throughout
context join_any timeprecision
continue join_none timeunit
cover local type
covergroup logic typedef
coverpoint longint union
cross matches unique
dist modport var
do new virtual
endclass null void
endclocking package wait_order
endgroup packed wildcard
endinterface priority with
endpackage program within
endprogram property
endproperty protected
22.14.7 IEEE 1800-2009 keywords
The version_specifier specifies that the identifiers listed as reserved keywords in
"1800-2009"
IEEEStd1800-2009 are considered to be reserved words. This version includes the identifiers listed in all
previous versions, plus the additional identifiers listed in Table22-5.
Table22-5—IEEE 1800-2009 additional reserved keywords
accept_on reject_on sync_accept_on
checker restrict sync_reject_on
endchecker s_always unique0
eventually s_eventually until
global s_nexttime until_with
implies s_until untyped
let s_until_with weak
nexttime strong
693
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
22.14.8 IEEE 1800-2012 keywords
The version_specifier specifies that the identifiers listed as reserved keywords in
"1800-2012"
IEEEStd1800-2012 are considered to be reserved words. This version includes the identifiers listed in all
previous versions, plus the additional identifiers listed in Table22-6.
Table22-6—IEEE 1800-2012 additional reserved keywords
implements nettype
interconnect soft
22.14.9 IEEE 1800-2017 keywords
The version_specifier specifies that the identifiers listed as reserved keywords in
"1800-2017"
IEEEStd1800-2017 are considered to be reserved words. This version includes the identifiers listed in all
previous versions and does not add new reserved keywords.
The full set of reserved identifiers for the current version of this standard is listed in AnnexB, which reflects
the combination of all version tables.
694
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Part Two:
Hierarchy Constructs
695
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
23. Modules and hierarchy
23.1 General
This clause describes the following:
— Formal syntax for module definitions
— Formal syntax for module instantiations
— Nested modules
— Extern modules
— Hierarchical name referencing
— Scope rules
— Parameter redefinition
— Elaboration considerations
— Binding
23.2 Module definitions
The module construct is the basic building block of a SystemVerilog design. The primary purpose of a
module is to encapsulate the data, functionality, and timing of digital hardware objects. A module can
represent low-level digital components, such as a simple AND gate, or an entire complex digital system. A
module can represent function and timing at a very detailed level, at a very abstract level, or as a mix of
abstract and detail levels. Modules can instantiate other design elements, thereby creating a design
hierarchy.
A module definition shall be enclosed between the keywords and . The identifier
module endmodule
following the keyword shall be the name of the module being defined. The keyword
module macromodule
can be used interchangeably with the keyword to define a module. An implementation may choose
module
to treat module definitions beginning with the keyword differently.
macromodule
23.2.1 Module header definition
The module header defines the following:
— The name of the module
— The port list of the module
— The direction and size of each port
— The type of data passed through each port
— The parameter constants of the module
— A package import list of the module
— The default lifetime (static or automatic) of subroutines defined within the module
There are two styles of module header definitions, the non-ANSI header and the ANSI header.
The non-ANSI header style separates the definition of the module header from the declarations of the
module ports and internal data. The informal syntax of a non-ANSI style module header is as follows:
module_name ( port_list ) ;
parameter_declaration_list
port_direction_and_size_declarations
port_type_declarations
696
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The module header definition is syntactically completed by the semicolon after the closing parenthesis of the
port list. Declarations that define the characteristics of the ports (direction, size, data type, signedness, etc.)
are local definitions within the module.
The ANSI header style makes the declarations of the port characteristics part of the module header (which is
still terminated by a semicolon). The informal general syntax of an ANSI style module header is as follows:
module_name #( parameter_port_list )
( port_direction_and_type_list ) ;
The formal syntax for module declarations is shown in Syntax23-1.
module_declaration ::= // from A.1.2
module_nonansi_header [ timeunits_declaration ] { module_item }
[ module_identifier ]
endmodule :
| module_ansi_header [ timeunits_declaration ] { non_port_module_item }
[ module_identifier ]
endmodule :
| { attribute_instance } module_keyword [ lifetime ] module_identifier
( .* ) ;
[ timeunits_declaration ] { module_item } [ module_identifier ]
endmodule :
| module_nonansi_header
extern
| module_ansi_header
extern
module_nonansi_header ::=
{ attribute_instance } module_keyword [ lifetime ] module_identifier
{ package_import_declaration } [ parameter_port_list ] list_of_ports
;
module_ansi_header ::=
{ attribute_instance } module_keyword [ lifetime ] module_identifier
{ package_import_declaration }1 [ parameter_port_list ] [ list_of_port_declarations ]
;
module_keyword ::= |
module macromodule
timeunits_declaration ::=
time_literal [ time_literal ]
timeunit / ;
| time_literal
timeprecision ;
| time_literal time_literal
timeunit ;timeprecision ;
| time_literal time_literal
timeprecision ;timeunit ;
parameter_port_list ::= // from A.1.3
list_of_param_assignments { parameter_port_declaration }
# ( , )
| parameter_port_declaration { parameter_port_declaration }
# ( , )
|
#( )
parameter_port_declaration ::=
parameter_declaration
| local_parameter_declaration
| data_type list_of_param_assignments
| list_of_type_assignments
type
1) A package_import_declaration in a module_ansi_header, interface_ansi_header, or program_ansi_header shall be
followed by a parameter_port_list or list_of_port_declarations, or both.
Syntax23-1—Module declaration syntax (excerpt from AnnexA)
697
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
23.2.2 Port declarations
Ports provide a means of interconnecting a hardware description consisting of modules and primitives. For
example, module A can instantiate module B, using port connections appropriate to module A. These port
names can differ from the names of the internal nets and variables specified in the definition of module B.
A port can be a declaration of an interface, an event, or a variable or net of any allowed data type, including
an array, a structure, or a union.
typedef struct {
bit isfloat;
union { int i; shortreal f; } n;
} tagged_st; // named structure
module mh1 (input var int in1,
input var shortreal in2,
output tagged_st out);
...
endmodule
Implementations may limit the maximum number of ports in a module definition, but the limit shall be at
least 256.
23.2.2.1 Non-ANSI style port declarations
In the non-ANSI style of module header, separate declarations are used for the module list_of_ports and the
declarations of the port characteristics (direction, size, signedness) and the type of data passed through the
ports.
The syntax for the non-ANSI style list_of_ports module header declaration is given in Syntax23-2.
module_nonansi_header ::= // from A.1.2
{ attribute_instance } module_keyword [ lifetime ] module_identifier
{ package_import_declaration } [ parameter_port_list ] list_of_ports
;
list_of_ports ::= port { port }
( , )
port ::=
[ port_expression ]
| port_identifier [ port_expression ]
. ( )
port_expression ::=
port_reference
| port_reference { port_reference }
{ , }
port_reference ::=
port_identifier constant_select
Syntax23-2—Non-ANSI style module header declaration syntax (excerpt from AnnexA)
The port reference for each port in the list_of_ports in the module header can be one of the following:
— A simple identifier or escaped identifier
— A bit-select of a vector declared within the module
— A part-select of a vector declared within the module
— A concatenation of any of the above
698
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The port expression is optional because ports can be defined that do not connect to anything internal to the
module. Once a port has been defined, there shall not be another port definition with this same name.
The first type of module port, with only a port_expression, is an implicit port.
The second type is the explicit port. This explicitly specifies the port_identifier used for connecting module
instance ports by name (see 23.3.2.2) and the port_expression that contains identifiers declared inside the
module as described below. Named port connections shall not be used for implicit ports unless the
port_expression is a simple identifier or escaped identifier, which shall be used as the port name.
Each port_identifier in a port_expression in the list of ports for the module declaration shall also be declared
in the body of the module as one of the following port declarations: , , (bidirectional),
input output inout
, or as an interface port (see Clause25). This is in addition to any net or variable declaration for a
ref
particular port_identifier.
The syntax for non-ANSI style module port_declarations is given in Syntax23-3.
port_declaration ::= // from A.1.3
{ attribute_instance } inout_declaration
| { attribute_instance } input_declaration
| { attribute_instance } output_declaration
| { attribute_instance } ref_declaration
| { attribute_instance } interface_port_declaration
inout_declaration ::= // from A.2.1.2
net_port_type list_of_port_identifiers
inout
input_declaration ::=
net_port_type list_of_port_identifiers
input
| variable_port_type list_of_variable_identifiers
input
output_declaration ::=
net_port_type list_of_port_identifiers
output
| variable_port_type list_of_variable_port_identifiers
output
ref_declaration ::= variable_port_type list_of_variable_identifiers
ref
interface_port_declaration ::=
interface_identifier list_of_interface_identifiers
| interface_identifier modport_identifier list_of_interface_identifiers
.
Syntax23-3—Non-ANSI style port declaration syntax (excerpt from AnnexA)
If a port declaration includes a net or variable type, then the port is considered completely declared, and it is
an error for the port to be declared again in a variable or net data type declaration. Because of this, all other
aspects of the port shall be declared in such a port declaration, including the signed and range definitions if
needed.
If a port declaration does not include a net or variable type, then the port can be again declared in a net or
variable declaration. If the net or variable is declared as a vector, the range specification between the two
declarations of a port shall be identical. Once a name is used in a port declaration, it shall not be declared
again in another port declaration or in a data type declaration.
699
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For example:
input aport; // First declaration - okay
input aport; // Error - multiple declaration, port declaration
output aport; // Error - multiple declaration, port declaration
The signed attribute can be attached either to a port declaration or the corresponding net or variable
declaration or to both. If either the port or the net/variable is declared as signed, then the other shall also be
considered signed. It shall be illegal to specify for a port declared as an port.
signed interconnect
Nets connected to ports without an explicit net declaration shall be considered unsigned, unless the port is
declared as signed. Other implicit nets (see 6.10) shall be considered unsigned.
Using the non-ANSI header style with a port list followed by separate declarations for each port allows
flexibility on the internal data to be passed through ports.
Example 1: Implicitly named ports connected to internal nets or variables of the same name (non-ANSI style
module header)
module test(a,b,c,d,e,f,g,h);
input [7:0] a; // no explicit net declaration - net is unsigned
input [7:0] b;
input signed [7:0] c;
input signed [7:0] d; // no explicit net declaration - net is signed
output [7:0] e; // no explicit net declaration - net is unsigned
output [7:0] f;
output signed [7:0] g;
output signed [7:0] h; // no explicit net declaration - net is signed
wire signed [7:0] b; // port b inherits signed attribute from net decl.
wire [7:0] c; // net c inherits signed attribute from port
logic signed [7:0] f;// port f inherits signed attribute from logic decl.
logic [7:0] g; // logic g inherits signed attribute from port
endmodule
Example 2: Ports connected to internal nets of a different name (non-ANSI style module header)
module complex_ports ( {c,d}, .e(f) );
// Nets {c,d} receive the first port bits.
// Name 'f' is declared inside the module.
// Name 'e' is defined outside the module.
// Cannot use named port connections of first port.
Example 3: Ports connected to split of internal vector (non-ANSI style module header)
module split_ports (a[7:4], a[3:0]);
// First port is upper 4 bits of 'a'.
// Second port is lower 4 bits of 'a'.
// Cannot use named port connections because
// of part-select port 'a'.
Example 4: Two ports with different names connected to same internal net (non-ANSI style module header)
module same_port (.a(i), .b(i));
// Name 'i' is declared inside the module as an inout port.
// Names 'a' and 'b' are defined for port connections.
700
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 5: Explicitly named port connected to concatenation of internal nets or variables (non-ANSI style
module header)
module renamed_concat (.a({b,c}), f, .g(h[1]));
// Names 'b', 'c', 'f', 'h' are defined inside the module.
// Names 'a', 'f', 'g' are defined for port connections.
// Can use named port connections.
Example 6: Two implicitly named ports connected to same internal net (non-ANSI style module header)
module same_input (a,a);
input a; // This is legal. The inputs are tied together.
Example 7: Explicitly named port with mix of input and output directions (non-ANSI style module header)
module mixed_direction (.p({a, e}));
input a; // p contains both input and output directions.
output e;
23.2.2.2 ANSI style list of port declarations
An alternate syntax that minimizes the duplication of data can be used to specify the ports of a module. Each
module shall be declared either entirely with the list_of_ports syntax as described in 23.2.2.1 or entirely with
the list_of_port_declarations syntax as described in this subclause.
The syntax for ANSI style list_of_port_declarations module header is given in Syntax23-4.
module_ansi_header ::= // from A.1.2
{ attribute_instance } module_keyword [ lifetime ] module_identifier
{ package_import_declaration }1 [ parameter_port_list ] [ list_of_port_declarations ]
;
list_of_port_declarations2 ::= // from A.1.3
[ { attribute_instance} ansi_port_declaration { { attribute_instance} ansi_port_declaration } ]
( , )
ansi_port_declaration ::=
[ net_port_header | interface_port_header ] port_identifier { unpacked_dimension }
[ constant_expression ]
=
| [ variable_port_header ] port_identifier { variable_dimension } [ constant_expression ]
=
| [ port_direction ] port_identifier [ expression ]
. ( )
net_port_header ::= [ port_direction ] net_port_type
variable_port_header ::= [ port_direction ] variable_port_type
interface_port_header ::=
interface_identifier [ modport_identifier ]
.
| [ modport_identifier ]
interface .
port_direction ::= | | |
input output inout ref
net_port_type ::= // from A.2.2.1
[ net_type ] data_type_or_implicit
| net_type_identifier
| implicit_data_type
interconnect
701
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
variable_port_type ::= var_data_type
var_data_type ::= data_type | data_type_or_implicit
var
1) A package_import_declaration in a module_ansi_header, interface_ansi_header, or program_ansi_header shall be
followed by a parameter_port_list or list_of_port_declarations, or both.
2) The list_of_port_declarations syntax is explained in 23.2.2, which also imposes various semantic restrictions, e.g., a
port shall be of a variable type and an port shall not be. It shall be illegal to initialize a port that is not
ref inout
a variable port or to specify a default value for a port that is not an port.
output input
Syntax23-4—ANSI style list_of_port_declarations syntax (excerpt from AnnexA)
Each port declaration provides the complete information about the port. The port’s direction, width, net or
variable type, and signedness are completely described. The port identifier shall not be redeclared, in part or
in full, inside the module body.
The same syntax for input, inout, and output declarations is used in the module header as would be used for
the list of port style declaration, except that the list_of_port_declarations is included in the module header
rather than separately (after the that terminates the module header).
;
As an example, the module named listed in 23.2.2.1 Example 1 could alternatively be declared as
test
follows:
module test (
input [7:0] a,
input signed [7:0] b, c, d, // Multiple ports that share all
// attributes can be declared together.
output [7:0] e, // Every attribute of the declaration
// must be in the one declaration.
output var signed [7:0] f, g,
output signed [7:0] h) ;
// It is illegal to redeclare any ports of
// the module in the body of the module.
endmodule
Generic interface ports (see 25.3.3) cannot be declared using the non-ANSI style list_of_ports syntax (see
23.2.2.1). Generic interface ports can only be declared using the ANSI style list_of_port_declarations
syntax.
module cpuMod(interface d, interface j);
...
endmodule
ANSI style port declarations can be explicitly named, allowing elements of arrays and structures,
concatenations of elements, and assignment pattern expressions of elements declared in a module, interface,
or program to be specified on the port list.
Like explicitly named ports in a module port declaration, port identifiers exist in their own name space for
each port list. When a port item is just a simple port identifier, that identifier is used as both a reference to an
interface item and a port identifier. Once a port identifier has been defined, there shall not be another port
definition with this same name.
702
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For example:
module mymod (
output .P1(r[3:0]),
output .P2(r[7:4]),
ref .Y(x),
input R );
logic [7:0] r;
int x;
...
endmodule
The self-determined type of the port expression becomes the type for the port. The port expression shall not
be considered an assignment-like context. The port expression shall resolve to a legal expression for type of
module port (see 23.3.3). The port expression is optional because ports can be defined that do not connect to
anything internal to the port.
23.2.2.3 Rules for determining port kind, data type, and direction
Within this subclause, the term port kind is used to mean any of the net type keywords, or the keyword ,
var
which are used to explicitly declare a port of one of these kinds. If these keywords are omitted in a port
declaration, there are default rules for determining the port kind, specified as follows.
Within this subclause, the term data type means both explicit and implicit data type declarations and does
not include unpacked dimensions. An explicit data type declaration uses the data_type syntax. An implicit
data type declaration uses the implicit_data_type syntax and includes only a signedness keyword and/or
packed dimensions. An implicit data type declaration implies a net unless the keyword is used.
var
Unpacked dimensions shall not be inherited from the previous port declaration and must be repeated for
each port with the same dimensions.
If the direction, port kind, and data type are all omitted for the first port in the port list, then all ports shall be
assumed to be non-ANSI style, and port direction and optional type declarations shall be declared after the
port list. Otherwise, all ports shall be assumed to be ANSI style.
For the first port in an ANSI style port list:
— If the direction is omitted, it shall default to .
inout
— If the data type is omitted, it shall default to , except for ports, which have no
logic interconnect
data type.
— If the port kind is omitted:
• For and ports, the port shall default to a net of default net type. The default net
input inout
type can be changed using the compiler directive (see 22.8).
`default_nettype
• For ports, the default port kind depends on how the data type is specified:
output
— If the data type is omitted or declared with the implicit_data_type syntax, the port kind
shall default to a net of default net type.
— If the data type is declared with the explicit data_type syntax, the port kind shall default to
variable.
• A port is always a variable.
ref
703
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Examples:
// Declarations must follow the port list because the first port
// does not have a direction, kind, or type specified
module mh_nonansi(x, y);
input wire x;
output tri0 y;
...
endmodule
module mh0 (wire x); // inout wire logic x
module mh1 (integer x); // inout wire integer x
module mh2 (inout integer x); // inout wire integer x
module mh3 ([5:0] x); // inout wire logic [5:0] x
module mh4 (var x); // ERROR: direction defaults to inout,
// which cannot be var
module mh5 (input x); // input wire logic x
module mh6 (input var x); // input var logic x
module mh7 (input var integer x); // input var integer x
module mh8 (output x); // output wire logic x
module mh9 (output var x); // output var logic x
module mh10(output signed [5:0] x); // output wire logic signed [5:0] x
module mh11(output integer x); // output var integer x
module mh12(ref [5:0] x); // ref var logic [5:0] x
module mh13(ref x [5:0]); // ref var logic x [5:0]
For subsequent ports in an ANSI style port list:
— If the direction, port kind and data type are all omitted, then they shall be inherited from the previous
port. If the previous port was an port, this port shall also be an port.
interconnect interconnect
Otherwise:
— If the direction is omitted, it shall be inherited from the previous port.
— If the port kind is omitted, it shall be determined as previously specified.
— If the data type is omitted, it shall default to except for ports that have no
logic interconnect
data type.
Examples:
module mh14(wire x, y[7:0]); // inout wire logic x
// inout wire logic y[7:0]
module mh15(integer x, signed [5:0] y); // inout wire integer x
// inout wire logic signed [5:0] y
704
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
module mh16([5:0] x, wire y); // inout wire logic [5:0] x
// inout wire logic y
module mh17(input var integer x, wire y); // input var integer x
// input wire logic y
module mh18(output var x, input y); // output var logic x
// input wire logic y
module mh19(output signed [5:0] x, integer y);
// output wire logic signed [5:0] x
// output var integer y
module mh20(ref [5:0] x, y); // ref var logic [5:0] x
// ref var logic [5:0] y
module mh21(ref x [5:0], y); // ref var logic x [5:0]
// ref var logic y
The preceding rules do not apply to explicit port declarations (i.e., of the form .port_identifier(expression),
see 23.2.2.2). Explicit port declarations shall inherit only the port direction from the preceding port (if not
explicitly specified), but not other properties. The data type of the port is the self-determined data type of the
expression.
A port declaration that immediately follows an explicit port declaration shall inherit only the port direction
(if not explicitly specified) from the explicit port declaration, but not other properties. The port kind and data
type of such a port shall be determined using the same rules as for the first port in the port list.
Example:
module mh22 (input wire integer p_a, .p_b(s_b), p_c);
logic [5:0] s_b;
In this example, port is fully declared. is an explicitly named port that inherits only the direction
p_a p_b
from port . Its data type is that of . Port inherits only the direction from , and defaults
input p_a s_b p_c p_b
to the net port kind and to the data type.
logic
23.2.2.4 Default port values
A module declaration may specify a default value for each singular input port. These default values shall be
constant expressions evaluated in the scope of the module where they are defined, not in the scope of the
instantiating module.
The informal syntax to declare a default input port value in a module is as follows:
module module_name (
...,
[ input ] [ type ] port_identifier = constant_expression,
... ) ;
Defaults can be specified only for input ports and only in ANSI style declarations. A default shall not be
specified for a port declared as (an port).
interconnect interconnect
When the module is instantiated, input ports with default values can be omitted from the instantiation, and
the compiler shall insert the corresponding default values. If a connection is not specified for an input port
705
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
and the port does not have a default value, then, depending on the connection style (ordered list, named
connections, implicit named connections, or implicit .* connections), the port shall either be left
unconnected or result in an error, as discussed in 23.3.2.1 through 23.3.2.4.
The following example illustrates default port semantics and parameter scope resolution:
parameter logic [7:0] My_DataIn = 8'hFF;
module bus_conn (
output logic [7:0] dataout,
input [7:0] datain = My_DataIn);
assign dataout = datain;
endmodule
module bus_connect1 (
output logic [31:0] dataout,
input [ 7:0] datain);
parameter logic [7:0] My_DataIn = 8'h00;
bus_conn bconn0 (dataout[31:24], 8'h0F);
// Constant literal overrides default in bus_conn definition
bus_conn bconn1 (dataout[23:16]);
// Omitted port for datain, default parameter value 8'hFF in
// bus_conn used
bus_conn bconn2 (dataout[15:8], My_DataIn);
// The parameter value 8'h00 from the instantiating scope is used
bus_conn bconn3 (dataout[7:0]);
endmodule
23.2.3 Parameterized modules
Port declarations can be based on parameter declarations. Parameter types can be redefined for each instance
of a module, providing a means of customizing the characteristics of each instance of a module.
Example 1: Parameterized module declaration using non-ANSI style module header:
module generic_fifo (clk, read, write, reset, out, full, empty );
parameter MSB=3, LSB=0, DEPTH=4; // these parameters can be redefined
input [MSB:LSB] in;
input clk, read, write, reset;
output [MSB:LSB] out;
output full, empty;
wire [MSB:LSB] in;
wire clk, read, write, reset;
logic [MSB:LSB] out;
logic full, empty;
...
endmodule
Example 2: Parameterized module declaration using ANSI style module header:
module generic_fifo
#(parameter MSB=3, LSB=0, DEPTH=4) // these parameters can be redefined
706
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
(input wire [MSB:LSB] in,
input wire clk, read, write, reset,
output logic [MSB:LSB] out,
output logic full, empty );
...
endmodule
Parameter redefinition is discussed in 23.10.
The order used in defining the list of parameters can be significant when instantiating the module (see
23.10.2.1).
Example 3: Parameterized module header with local parameters using ANSI style header:
module generic_decoder
#(num_code_bits = 3, localparam num_out_bits = 1 << num_code_bits)
(input [num_code_bits-1:0] A, output reg [num_out_bits-1:0] Y);
23.2.4 Module contents
The module definition can contain zero or more module items. The syntax is shown in Syntax23-5.
module_common_item ::= // from A.1.4
module_or_generate_item_declaration
| interface_instantiation
| program_instantiation
| assertion_item
| bind_directive
| continuous_assign
| net_alias
| initial_construct
| final_construct
| always_construct
| loop_generate_construct
| conditional_generate_construct
module_item ::=
port_declaration
;
| non_port_module_item
module_or_generate_item ::=
{ attribute_instance } parameter_override
| { attribute_instance } gate_instantiation
| { attribute_instance } udp_instantiation
| { attribute_instance } module_instantiation
| { attribute_instance } module_common_item
module_or_generate_item_declaration ::=
package_or_generate_item_declaration
| genvar_declaration
| clocking_declaration
| clocking_identifier
defaultclocking ;
| expression_or_dist
default disable iff ;
non_port_module_item ::=
generate_region
707
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| module_or_generate_item
| specify_block
| { attribute_instance } specparam_declaration
| program_declaration
| module_declaration
| interface_declaration
| timeunits_declaration3
parameter_override ::= list_of_defparam_assignments
defparam ;
bind_directive4 ::=
bind_target_scope [ bind_target_instance_list] bind_instantiation
bind : ;
| bind_target_instance bind_instantiation
bind ;
bind_target_scope ::=
module_identifier
| interface_identifier
bind_target_instance ::=
hierarchical_identifier constant_bit_select
bind_target_instance_list ::=
bind_target_instance { bind_target_instance }
,
bind_instantiation ::=
program_instantiation
| module_instantiation
| interface_instantiation
| checker_instantiation
3) A timeunits_declaration shall be legal as a non_port_module_item, non_port_interface_item,
non_port_program_item, or package_item only if it repeats and matches a previous timeunits_declaration within
the same time scope.
4) If the bind_target_scope is an interface_identifier or the bind_target_instance is an interface_instance_identifier,
then the bind_instantiation shall be an interface_instantiation or a checker_instantiation.
Syntax23-5—Module item syntax (excerpt from AnnexA)
The module items define what constitutes a module and can include many different types of declarations and
definitions, which are described in various clauses throughout this document.
23.3 Module instances (hierarchy)
A module can be instantiated in two ways, hierarchical or top level. Top-level modules are implicitly
instantiated (see 23.3.1). Hierarchical modules can be instantiated explicitly (see 23.3.2) or implicitly as a
nested module (see 23.4).
23.3.1 Top-level modules and $root
Top-level modules are modules that are included in the SystemVerilog source text, but do not appear in any
module instantiation statement, as described in 23.3.2. This applies even if the module instantiation appears
in a generate block that is not itself instantiated (see 27.3). A design shall contain at least one top-level
module. A top-level module is implicitly instantiated once, and its instance name is the same as the module
name. Such an instance is called a top-level instance.
The name is used to unambiguously refer to a top-level instance or to an instance path starting from
$root
the root of the instantiation tree. is the root of the instantiation tree.
$root
708
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For example:
$root.A.B // item B within top instance A
$root.A.B.C // item C within instance B within instance A
allows explicit access to the top of the instantiation tree. This is useful to disambiguate a local path
$root
(which takes precedence) from the rooted path. If is not specified, a hierarchical path is ambiguous.
$root
For example, can mean the local or the top-level (assuming there is an instance that
A.B.C A.B.C A.B.C A
contains an instance at both the top level and in the current module). The ambiguity is resolved by giving
B
priority to the local scope and thereby preventing access to the top-level path. allows explicit access
$root
to the top level in those cases in which the name of the top-level module is insufficient to uniquely identify
the path.
23.3.2 Module instantiation syntax
Explicit module instantiation creates a hierarchical instance of a module. The syntax for explicit module
instantiation is as follows in Syntax23-6.
module_instantiation ::= // from A.4.1.1
module_identifier [ parameter_value_assignment ] hierarchical_instance { hierarchical_instance }
, ;
parameter_value_assignment ::= [ list_of_parameter_assignments ]
# ( )
list_of_parameter_assignments ::=
ordered_parameter_assignment { ordered_parameter_assignment }
,
| named_parameter_assignment { named_parameter_assignment }
,
ordered_parameter_assignment ::= param_expression
named_parameter_assignment ::= parameter_identifier [ param_expression ]
. ( )
hierarchical_instance ::= name_of_instance [ list_of_port_connections ]
( )
name_of_instance ::= instance_identifier { unpacked_dimension }
list_of_port_connections29 ::=
ordered_port_connection { ordered_port_connection }
,
| named_port_connection { named_port_connection }
,
ordered_port_connection ::= { attribute_instance } [ expression ]
named_port_connection ::=
{ attribute_instance } port_identifier [ [ expression ] ]
. ( )
| { attribute_instance }
.*
param_expression ::= mintypmax_expression | data_type | // from A.8.3
$
29) The token shall appear at most once in a list of port connections.
.*
Syntax23-6—Module instance syntax (excerpt from AnnexA)
Hierarchical instantiation allows more than one instance of the same module. The module name can be a
module previously declared or one declared later. Parameter assignments can be named or ordered. Port
connections can be named, ordered, or implicitly connected. They can be nets, variables, or other kinds of
interfaces, events, or expressions. See 23.3.3 for the connection rules.
The instantiations of modules can contain a range specification. This allows an array of instances to be
created. The array of instances is described in 28.3.5 (also see 23.3.3.5). The syntax and semantics of arrays
of instances defined for gates and primitives apply for modules as well.
709
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The list of port connections shall be provided only for modules defined with ports. The parentheses shall be
required on all module instantiations, even when the instantiated module does not have ports.
One or more module instances (identical copies of a module) can be specified in a single module
instantiation statement. For example, three instances of a module called can be instantiated as:
ffnand
ffnand ff1 (.q(), .qbar(out1), .clear(in1), .preset(in2)),
ff2 (.q(), .qbar(out2), .clear(in2), .preset(in1), .q());
ff3 (.q(out3), .qbar(), .clear(in1), .preset(in2));
Connections can be made to module instances in the following four ways:
— Positional connections by port order (see 23.3.2.1)
— Named port connections using fully explicit connections (see 23.3.2.2)
— Named port connections using implicit connections (see 23.3.2.3)
— Named port connections using a wildcard port name (see 23.3.2.4)
Positional and named module port connections shall not be mixed in the same module instantiation;
connections to the ports of a particular module instance shall be all by order or all by name. The three forms
of named port connections can be mixed.
An ALU accumulator ( ) example module is used to illustrate these four forms of port
alu_accum
connections. The ALU accumulator includes instantiations of an ALU module, an accumulator register
( ) module, and a sign-extension ( ) module. The module headers for the three instantiated
accum xtend
modules are shown in the following example code:
parameter logic [7:0] My_DataIn = 8'hFF;
module alu (
output reg [7:0] alu_out,
output reg zero,
input [7:0] ain, bin,
input [2:0] opcode);
// RTL code for the alu module
endmodule
module accum (
output reg [7:0] dataout,
input [7:0] datain = My_DataIn,
input clk, rst_n = 1'b1);
// RTL code for the accumulator module
endmodule
module xtend (
output reg [7:0] dout,
input din,
input clk, rst = 1'b0 );
// RTL code for the sign-extension module
endmodule
23.3.2.1 Connecting module instance ports by ordered list
One method of making the connection between the port expressions listed in a module instantiation and the
ports declared within the instantiated module is the ordered list; that is, the port expressions listed for the
module instance shall be in the same order as the ports listed in the module declaration.
710
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A connection can be a simple reference to a variable or a net identifier, an expression, or a blank. An
expression can be used for supplying a value to a module input port. A blank port connection shall represent
the situation where the port is not to be connected. However, if a port connection is omitted (indicated by a
missing argument in the comma-separated list) to an input port with a default value, the default value shall
be used.
Examples of module instantiations with positional port connections and default values are shown in the
following module example:
alu_accum1
module alu_accum1 (
output [15:0] dataout,
input [7:0] ain, bin,
input [2:0] opcode,
input clk, rst_n, rst);
wire [7:0] alu_out;
alu alu (alu_out, , ain, bin, opcode); // zero output is unconnected
accum accum (dataout[7:0], alu_out, clk, rst_n);
xtend xtend (dataout[15:8], alu_out[7], clk); // rst gets default
// value 1'b0
endmodule
Refer to 23.3.3 for additional port connection rules.
23.3.2.2 Connecting module instance ports by name
The second way to connect module ports consists of explicitly linking the two names for each side of the
connection: the port declaration name from the module declaration to the expression, i.e., the name used in
the module declaration, followed by the name used in the instantiating module. This compound name is then
placed in the list of module connections. The informal syntax for named port connections of a module with
two ports is as follows:
module_name instance_name ( .port_name(expression), .port_name(expression) );
The port_name shall be the name specified in the module declaration. The port name cannot be a bit-select,
a part-select, or a concatenation of ports.
The port expression can be any valid expression. The port expression is optional so that the instantiating
module can document the existence of the port without connecting it to anything. The parentheses are
required.
If an input port with a specified default value has an explicit empty named port connection [i.e.,
], then the port shall be left unconnected and the default value shall not be used. When
.port_name()
connecting ports by name, an unconnected port can also be indicated by omitting it in the port list providing
there is no default value.
Examples of module instantiations with named port connections and default values are shown in the
following module example:
alu_accum2
module alu_accum2 (
output [15:0] dataout,
input [7:0] ain, bin,
input [2:0] opcode,
input clk, rst_n, rst);
wire [7:0] alu_out;
711
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
alu alu (.alu_out(alu_out), .zero(),
.ain(ain), .bin(bin), .opcode(opcode));
// zero output is unconnected
accum accum (.dataout(dataout[7:0]), .datain(alu_out),
.clk(clk));
// rst_n is not in the port list and so gets default value 1'b1
xtend xtend (.dout(dataout[15:8]), .din(alu_out[7]),
.clk(clk), .rst() );
// rst has a default value, but has an empty port connection,
// therefore it is left unconnected
endmodule
Because the connections in the preceding example are made by name, the order in which they appear is
irrelevant.
Multiple module instance port connections are not allowed. The following example instantiation is illegal:
module test;
A ia ( .i (a), .i (b), // illegal connection of input port twice
.o (c), .o (d), // illegal connection of output port twice
.e (e), .e (f)); // illegal connection of inout port twice
endmodule
module A (input i, output o, inout e);
...
endmodule
Refer to 23.3.3 for additional port connection rules.
23.3.2.3 Connecting module instance using implicit named port connections (.name)
SystemVerilog can implicitly instantiate ports using a .name syntax if the instance port name matches the
connecting port name and their data types are equivalent.
This eliminates the requirement to list an identifier name twice when the port name and expression name are
the same, while still listing all of the ports of the instantiated module for documentation purposes.
If a signal of the same name does not exist in the instantiating module, the port connection shall not create an
implicit net declaration and an error shall be issued, even if the port has a specified default value. The
purpose of using default values is to implicitly assign constant expressions to otherwise unconnected input
ports. If an implicit .name port connection is used, it is assumed that the coder’s intent is to connect this port
value and not use the default value. To leave a port with a default value unconnected, empty parentheses
must be used after .name, i.e., .
.name()
In the following example, all of the ports of the instantiated module match the names of
alu_accum3 alu
the declarations connected to the ports, except for the unconnected port, which is listed using a named
zero
port connection, showing that the port is unconnected. Implicit .name port connections are made for all
name and equivalent type matching connections on the instantiated module.
In the same example, the module has an 8-bit port called that is connected to
alu_accum3 accum dataout
a 16-bit bus called . Because the internal and external sizes of do not match, the port
dataout dataout
must be connected by name, showing which bits of the 16-bit bus are connected to the 8-bit port. The
port on the is connected to a bus by a different name ( ); therefore, this port is also
datain accum alu_out
712
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
connected by name. is connected using an implicit .name port connection while the port is left
clk rst_n
unconnected because it uses empty parentheses. Also in the same example, the module
alu_accum3 xtend
has an 8-bit output port called and a 1-bit input port called . Because neither of these port names
dout din
matches the names (or sizes) of the connecting declarations, both are connected by name. is connected
clk
using an implicit .name port connection, but the signal does not exist in the instantiation module and
rst
hence will result in an error even though a default port value exists.
module alu_accum3 (
output [15:0] dataout,
input [7:0] ain, bin,
input [2:0] opcode,
input clk, rst_n);
wire [7:0] alu_out;
alu alu (.alu_out, .zero(), .ain, .bin, .opcode);
accum accum (.dataout(dataout[7:0]), .datain(alu_out), .clk, .rst_n());
xtend xtend (.dout(dataout[15:8]), .din(alu_out[7]), .clk, .rst);
// Error: rst does not exist in the instantiation module
endmodule
A .port_identifier port connection is semantically equivalent to the named port connection
.port_identifier with the following exceptions:
(port_identifier)
— The port connection shall not create an implicit net declaration.
— The declarations on each side of the port connection shall have equivalent data types.
— An implicit .port_identifier port connection between nets of two dissimilar net types shall issue an
error when it is a warning in an explicit named port connection as required by 23.3.3.7.
It shall be an error if the name has not been declared (explicitly or implicitly) or
port_identifier
imported from a package (by explicit or wildcard import) prior to the .port_identifier implicit port
connection.
23.3.2.4 Connecting module instances using wildcard named port connections ( .*)
SystemVerilog can implicitly instantiate ports using a wildcard syntax for all ports where the instance
.*
port name matches the connecting port name and their data types are equivalent. This eliminates the
requirement to list any port where the name and type of the connecting declaration match the name and
equivalent type of the instance port. This implicit port connection style is used to indicate that all port names
and types match the connections where emphasis is placed only on the exception ports. A named port
connection can be mixed with a connection to override a port connection to a different expression or to
.*
leave a port unconnected. The implicit port connection syntax can greatly facilitate rapid block-level
.*
testbench generation where all of the testbench declarations are chosen to match the instantiated module port
names and types.
An implicit port connection is semantically equivalent to an implicit .name port connection for every
.*
port declared in the instantiated module, with the following two exceptions:
1) If an instantiation uses a .name port connection, the default value to that port shall not be used. If the
name does not exist in the instantiating scope, an error shall occur. When using , however, the
.*
default value shall be used if the name does not exist in the instantiating scope. In this case, if an
unconnected port is truly needed for a specific instantiation, then .name() can be used in addition to
.
.*
2) Using .* does not create a sufficient reference for a wildcard import of a name from a package. A
named or implicit .name connection can be mixed with a connection to create a sufficient
.*
reference for a wildcard import of a name from a package.
713
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In the following example, all of the ports of the instantiated module match the names of
alu_accum4 alu
the variables connected to the ports, except for the unconnected port, which is listed using a named
zero
port connection, showing that the port is unconnected. The implicit port connection syntax connects all
.*
other ports on the instantiated module.
In the same example, the module has an 8-bit port called that is connected to
alu_accum4 accum dataout
a 16-bit bus called . Because the internal and external sizes of do not match, the port
dataout dataout
must be connected by name, showing which bits of the 16-bit bus are connected to the 8-bit port. The
port on the is connected to a bus by a different name ( ); therefore, this port is also
datain accum alu_out
connected by name. The port is connected using an implicit .* port connection while does not
clk rst_n
exist at the instantiation level, and therefore the default value is used. Also in the same
rst_n alu_accum4
example, the module has an 8-bit output port called and a 1-bit input port called . Because
xtend dout din
neither of these port names matches the names (or sizes) of the connecting declarations, both are connected
by name. The port is connected using an implicit port connection while again does not exist at
clk .* rst
the instantiation level, and therefore the default value is used.
rst
module alu_accum4 (
output [15:0] dataout,
input [7:0] ain, bin,
input [2:0] opcode,
input clk);
wire [7:0] alu_out;
alu alu (.*, .zero());
accum accum (.*, .dataout(dataout[7:0]), .datain(alu_out));
xtend xtend (.*, .dout(dataout[15:8]), .din(alu_out[7]));
endmodule
When the implicit port connection is mixed in the same instantiation with named port connections, the
.*
implicit port connection token can be placed anywhere in the port list. The token can only appear at
.* .*
most once in the port list.
Modules can be instantiated into the same parent module using any combination of legal positional, named,
implicit .name connected and implicit connected instances, as shown in the follwoing
.* alu_accum5
example:
module alu_accum5 (
output [15:0] dataout,
input [7:0] ain, bin,
input [2:0] opcode,
input clk, rst_n);
wire [7:0] alu_out;
// mixture of named port connections and
// implicit .name port connections
alu alu (.ain(ain), .bin(bin), .alu_out, .zero(), .opcode);
// positional port connections
accum accum (dataout[7:0], alu_out, clk, rst_n);
// mixture of named port connections and implicit .* port connections
xtend xtend (.dout(dataout[15:8]), .*, .din(alu_out[7]));
endmodule
714
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
23.3.3 Port connection rules
Values of all data types on variables and nets can be passed through ports. This is accomplished by allowing
both sides of a port connection to have assignment-compatible data types and by allowing continuous
assignments to variables. The port type allows shared variable behavior across a port by passing a
ref
hierarchical reference.
Each port connection shall be a continuous assignment of source to sink, where one connected item shall be
a signal source and the other shall be a signal sink. The assignment shall be a continuous assignment from
source to sink for input or output ports. The assignment is a non-strength-reducing transistor connection for
inout ports.
The same rules are used for compatible port types as for assignment compatibility (see 6.22.3).
If the internal and external connections to a port are of user-defined nettypes, they shall be of matching
nettypes and shall be merged into a single simulated net. If only one of the two connections is of a user-
defined then the connections shall have matching data types, the port shall be of mode input or
nettype
output and the connection shall be treated as a continuous assignment from source to sink.
23.3.3.1 Port coercion
A port that is declared as input (output) but used as an output (input) or inout may be coerced to inout. If not
coerced to inout, a warning shall be issued.
23.3.3.2 Port connection rules for variables
If a port declaration has a variable data type, then its direction controls how it can be connected when
instantiated, as follows:
— An port can be connected to any expression of a compatible data type. A continuous
input
assignment shall be implied when a variable is connected to an input port declaration. Assignments
to variables declared as input ports shall be illegal. If left unconnected, the port shall have the default
initial value corresponding to the data type.
— An port can be connected to a variable (or a concatenation) of a compatible data type. A
output
continuous assignment shall be implied when a variable is connected to the output port of an
instance. Procedural or continuous assignments to a variable connected to the output port of an
instance shall be illegal.
— An port can be connected to a net (or a concatenation) of a compatible data type. In this
output
case, multiple drivers shall be permitted on the net.
— A variable data type is not permitted on either side of an port.
inout
— A port shall be connected to an equivalent variable data type. References to the port variable
ref
shall be treated as hierarchical references to the variable to which it is connected in its instantiation.
This kind of port cannot be left unconnected. See 6.22.2.
— It shall be illegal to connect a port variable to an port or net.
interconnect interconnect
23.3.3.3 Port connection rules for nets with built-in net types
If a port declaration has a net type, such as , then its direction controls how it can be connected, as
wire
follows:
— An can be connected to any expression of a compatible data type. If left unconnected, it shall
input
have the value .
'z
— An can be connected to a net or variable (or a concatenation of nets or variables) of a
output
compatible data type.
715
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— An can be connected to a net (or a concatenation of nets) of a compatible data type or left
inout
unconnected, but cannot be connected to a variable.
If there is a data type difference between the port declaration and connection, an initial value change event
can be caused at time zero.
See 23.3.3.7 for additional rules when net types or nets are used on both sides of a port
interconnect
connection.
23.3.3.4 Port connection rules for interfaces
A port declaration can be a generic interface or named interface type. An interface port instance shall always
be connected to an interface instance or a higher level interface port. An interface port cannot be left
unconnected.
If a port declaration has a generic interface type, then it can be connected to an interface instance of any
type. If a port declaration has a named interface type, then it shall be connected to an interface instance of
the identical type.
23.3.3.5 Unpacked array ports and arrays of instances
For an unpacked array port, the port and the array connected to the port shall have the same number of
unpacked dimensions, and each dimension of the port shall have the same size as the corresponding
dimension of the array being connected.
If the size and type of the port connection match the size and type of a single instance port, the connection
shall be made to each instance in an array of instances.
If the port connection is an unpacked array, the slowest varying unpacked array dimensions of each port
connection shall be compared with the dimensions of the instance array. If they match exactly in size, each
element of the port connection shall be matched to the port left index to left index, right index to right index.
If they do not match it shall be considered an error.
For example:
module child(output o, input i[5]);
//...
endmodule : child
module parent(output o[8][4],
input i[8][4][5] );
child c[8][4](o,i);
//...
endmodule : parent
If the port connection is a packed array, each instance shall get a part-select of the port connection, starting
with all right-hand indices to match the rightmost part-select and iterating through the rightmost dimension
first. Too many or too few bits to connect all the instances shall be considered an error.
In the following example, a two-dimensional array of instances is connected to form M pipelines with
DFF
N stages.
module MxN_pipeline #(M=3,N=4)
(input [M-1:0] in, output [M-1:0] out, input clk);
716
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
typedef logic T [M-1:0][1:N];
T Ins, Outs;
DFF dff[M-1:0][1:N](Outs, Ins, clk);
for (genvar I = M-1; I >= 0; I--) begin
for (genvar J = 1; J <= N; J++) begin
case (J)
1: begin
assign out[I] = Outs[I][1];
assign Ins[I][J] = Outs[I][2];
end
default: assign Ins[I][J] = Outs[I][J+1];
N: assign Ins[I][N] = in[I];
endcase
end
end
endmodule : MxN_pipeline
23.3.3.6 Single source nets (uwire)
If the net on either side of a port has the net type , a warning shall be issued if the nets are not merged
uwire
into a single net, as described in 23.3.3.7.
23.3.3.7 Port connections with dissimilar net types (net and port collapsing)
When different net types are connected through a module port, the nets on both sides of the port can take on
the same type. The resulting net type can be determined as shown in Table23-1. In the table, external net
means the net specified in the module instantiation, and internal net means the net specified in the module
definition. The net whose type is used is said to be the dominating net. The net whose type is changed is said
to be the dominated net. It is permissible to merge the dominating and dominated nets into a single net,
whose type shall be that of the dominating net. The resulting net is called the simulated net, and the
dominated net is called a collapsed net.
The simulated net shall take the delay specified for the dominating net. If the dominating net is of the type
, any strength value specified for the trireg net shall apply to the simulated net.
trireg
When the two nets connected by a port are of different net types, the resulting single net can be assigned one
of the following:
— The dominating net type if one of the two nets is dominating, or
— The net type external to the module
When a dominating net type does not exist, the external net type shall be used.
The simulated net shall take the net type specified in the table and the delay specified for that net. If the
simulated net selected is a , any strength value specified for the trireg net applies to the simulated
trireg
net.
717
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table23-1—Net types resulting from dissimilar port connections
External net
Internal
net wire, wand, wor,
trireg tri0 tri1 uwire supply0 supply1
tri triand trior
wire, tri external external external external external external external external external
wand, triand internal external external external external external external external external
warn warn warn warn warn
wor, trior internal external external external external external external external external
warn warn warn warn warn
trireg internal external external external external external external external external
warn warn warn
tri0 internal external external internal external external external external external
warn warn warn warn
tri1 internal external external internal external external external external external
warn warn warn warn
uwire internal internal internal internal internal internal external external external
warn warn warn warn warn
supply0 internal internal internal internal internal internal internal external external
warn
supply1 internal internal internal internal internal internal internal external external
warn
KEY:
external = The external net type shall be used.
internal = The internal net type shall be used.
warn = A warning shall be issued.
23.3.3.7.1 Port connections with interconnect net types
Any port connection with an net shall merge the dominating and dominated nets into a
interconnect
single net.
If the internal and external nets are both nets, the merged net shall be an
interconnect interconnect
net. If only one net is an net, the merged net shall be the type of the other net.
interconnect
It shall be illegal for the type of a simulated net (see 23.3.3.7) at the end of elaboration to be an
net.
interconnect
Example:
module netlist;
interconnect iwire;
dut1 child1(iwire);
dut2 child2(iwire);
endmodule
module dut1(inout wire w);
assign w = 1;
718
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
endmodule
module dut2(inout wand w);
assign w = 0;
endmodule
The net will merge with the nets from each of the children resulting in a simulation
interconnect iwire
net with net_type .
wand
23.3.3.7.2 Terminal connections with interconnect net types
When connected to a primitive or user-defined primitive (UDP) terminal, an net shall be
interconnect
treated as though connecting to a scalar wire.
23.3.3.8 Connecting signed values via ports
The sign attribute shall not cross hierarchy. In order to have the signed type cross hierarchy, the
signed
keyword shall be used in the object’s declaration at the different levels of hierarchy. Any expressions on a
port shall be treated as any other expression in an assignment. It shall be typed, sized, and evaluated, and the
resulting value assigned to the object on the other side of the port using the same rules as an assignment.
23.4 Nested modules
A module can be declared within another module. The outer name space is visible to the inner module so
that any name declared there can be used, unless hidden by a local name, provided the module is declared
and instantiated in the same scope.
One purpose of nesting modules is to show the logical partitioning of a module without using ports. Names
that are global are in the outermost scope, and names that are only used locally can be limited to local
modules.
// This example shows a D-type flip-flop made of NAND gates
module dff_flat(input d, ck, pr, clr, output q, nq);
wire q1, nq1, q2, nq2;
nand g1b (nq1, d, clr, q1);
nand g1a (q1, ck, nq2, nq1);
nand g2b (nq2, ck, clr, q2);
nand g2a (q2, nq1, pr, nq2);
nand g3a (q, nq2, clr, nq);
nand g3b (nq, q1, pr, q);
endmodule
// This example shows how the flip-flop can be structured into 3 RS latches.
module dff_nested(input d, ck, pr, clr, output q, nq);
wire q1, nq1, nq2;
module ff1;
nand g1b (nq1, d, clr, q1);
nand g1a (q1, ck, nq2, nq1);
endmodule
ff1 i1();
719
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
module ff2;
wire q2; // This wire can be encapsulated in ff2
nand g2b (nq2, ck, clr, q2);
nand g2a (q2, nq1, pr, nq2);
endmodule
ff2 i2();
module ff3;
nand g3a (q, nq2, clr, nq);
nand g3b (nq, q1, pr, q);
endmodule
ff3 i3();
endmodule
The nested module declarations can also be used to create a library of modules that is local to part of a
design.
module part1(....);
module and2(input a, b, output z);
....
endmodule
module or2(input a, b, output z);
....
endmodule
....
and2 u1(....), u2(....), u3(....);
.....
endmodule
This allows the same module name, e.g., , to occur in different parts of the design and represent
and2
different modules. An alternative way of handling this problem is to use configurations.
Nested modules with no ports that are not explicitly instantiated shall be implicitly instantiated once with an
instance name identical to the module name. Otherwise, if they have ports and are not explicitly instantiated,
they are ignored.
23.5 Extern modules
To support separate compilation, extern declarations of a module can be used to declare the ports on a
module without defining the module itself. An extern module declaration consists of the keywords
extern
followed by the module name and the list of ports for the module. Both the ANSI style
module
list_of_port_declarations syntax (possibly with parameters) and the non-ANSI style list_of_ports syntax
may be used.
NOTE—The potential existence of defparams precludes the checking of the port connection information prior to
elaboration time even for the ANSI style list_of_port_declarations syntax.
The following example demonstrates the usage of extern module declarations:
extern module m (a,b,c,d);
extern module a #(parameter size= 8, parameter type TP = logic [7:0])
(input [size:0] a, output TP b);
module top ();
wire [8:0] a;
logic [7:0] b;
wire c, d;
720
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
m mm (.*);
a aa (.*);
endmodule
Modules and are then assumed to be instantiated as follows:
m a
module top ();
wire [8:0] a;
logic [7:0] b;
wire c, d;
m mm (a,b,c,d);
a aa (a,b);
endmodule
If an declaration exists for a module, it is possible to use as the ports of the module. This usage
extern .*
shall be equivalent to placing the ports (and possibly parameters) of the declaration on the module.
extern
For example:
extern module m (a,b,c,d);
extern module a #(parameter size = 8, parameter type TP = logic [7:0])
(input [size:0] a, output TP b);
module m (.*);
input a,b,c;
output d;
endmodule
module a (.*);
...
endmodule
is equivalent to writing
module m (a,b,c,d);
input a,b,c;
output d;
endmodule
module a #(parameter size = 8, parameter type TP = logic [7:0])
(input [size:0] a, output TP b);
...
endmodule
Extern module declarations can appear at any level of the instantiation hierarchy, but are visible only within
the level of hierarchy in which they are declared. An extern module declaration shall match the actual
module declaration’s port and parameter lists in correspondence of names, positions, and their equivalent
types.
23.6 Hierarchical names
Every identifier in a SystemVerilog description shall have a unique hierarchical path name. The hierarchy
of modules and the definition of items such as tasks and named blocks within the modules shall define these
names. The hierarchy of names can be viewed as a tree structure, where each module instance, generate
721
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
block instance, task, function, or named begin-end or fork-join block defines a new hierarchical level, or
scope, in a particular branch of the tree.
A design description contains one or more top-level modules (see 23.3.1). Each such module forms the top
of a name hierarchy. This root or these parallel root modules make up one or more hierarchies in a design
description or description. Inside any module, each module instance (including an arrayed instance),
generate block instance, task definition, function definition, and named begin-end or fork-join block shall
define a new branch of the hierarchy. Named blocks within named blocks and within tasks and functions
shall create new branches. Similarly, named action blocks of assertions shall create new branches. Unnamed
generate blocks are exceptions. They create branches that are visible only from within the block and within
any hierarchy instantiated by the block. See Clause27 for a discussion of unnamed generate blocks.
Each node in the hierarchical name tree shall be a separate scope with respect to identifiers. A particular
identifier can be declared at most once in any scope. See 23.9 for a discussion of scope rules and 3.13 for a
discussion of name spaces.
Any named SystemVerilog object or hierarchical name reference can be referenced uniquely in its full form
by concatenating the names of the modules, module instance names, generate blocks, tasks, functions,
assertion labels, named assertion action blocks, or named blocks that contain it. The period character shall
be used to separate each of the names in the hierarchy, except for escaped identifiers embedded in the
hierarchical name reference, which are followed by separators composed of white space and a period-
character.
The syntax for hierarchical path names is given in Syntax23-7.
hierarchical_identifier ::= [ ] { identifier constant_bit_select } identifier // from A.9.3
$root. .
Syntax23-7—Syntax for hierarchical path names (excerpt from AnnexA)
Hierarchical names consist of instance names separated by periods, where an instance name can be an array
element. The instance name refers to the top of the instantiated design and is used to unambiguously
$root
gain access to the top of the design.
$root.mymodule.u1 // absolute name
u1.struct1.field1 // u1 must be visible locally or above, including globally
adder1[5].sum
The complete path name to any object shall start at a top-level (root) module. This path name can be used
from any level in the hierarchy or from a parallel hierarchy.
The first node name in a path name can also be the top of a hierarchy that starts at the level where the path is
being used (which allows and enables downward referencing of items).
Objects declared in automatic tasks and functions are exceptions and cannot be accessed by hierarchical
name references. Objects declared in unnamed generate blocks are also exceptions. They can be referenced
by hierarchical names only from within the block and within any hierarchy instantiated by the block.
Names in a hierarchical path name that refer to instance arrays or loop generate blocks may be followed
immediately by a constant expression in square brackets. This expression selects a particular instance of the
array and is, therefore, called an instance select. The expression shall evaluate to one of the legal index
values of the array. If the array name is not the last path element in the hierarchical name, the instance select
expression is required.
722
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Hierarchical name referencing allows free data access to any object from any level in the hierarchy. If the
unique hierarchical path name of an item is known, its value can be sampled or changed from anywhere
within the description.
Hierarchical names can be read (in expressions), written (in assignments or in subroutine calls) or triggered
off (in event expressions). They can also be used to reference subroutine names.
Example 1: The code in this example defines a hierarchy of module instances and named blocks.
module cct (stim1, stim2);
input stim1, stim2;
// instantiate mod
mod amod(stim1),
bmod(stim2);
endmodule
module mod (in);
input in;
always @(posedge in) begin : keep
logic hold;
hold = in;
end
endmodule
module wave;
logic stim1, stim2;
cct a(stim1, stim2); // instantiate cct
initial begin :wave1
#100 fork :innerwave
reg hold;
join
#150 begin
stim1 = 0;
end
end
endmodule
Figure23-1 illustrates the hierarchy implicit in this code.
wave
a wave1
innerwave
amod bmod
keep keep
Figure23-1—Hierarchy in a model
723
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Following is a list of the hierarchical forms of the names of all the objects defined in the code.
wave
wave.stim1
wave.stim2
wave.a
wave.a.stim1
wave.a.stim2
wave.a.amod
wave.a.amod.in
wave.a.amod.keep
wave.a.amod.keep.hold
wave.a.bmod
wave.a.bmod.in
wave.a.bmod.keep
wave.a.bmod.keep.hold
wave.wave1
wave.wave1.innerwave
wave.wave1.innerwave.hold
Any of the preceding hierarchical names can also be preceded with .
$root
Example 2: The following example shows how a pair of named blocks can refer to items declared within
each other.
begin
fork : mod_1
reg x;
mod_2.x = 1;
join
fork : mod_2
reg x;
mod_1.x = 0;
join
end
Example 3: The following example shows when assertions and items in assertion action blocks may or may
not be referred to using hierarchical names.
module top();
logic clk, x, y, z;
m m_i(clk, x, y, z);
endmodule
module m(input logic clk, a, b, c);
assert #0 (a^b); // no label, assertion cannot be referred to
A1: assert #0 (a^b); // assertion can be accessed in control tasks
initial begin : B1
assert (a); // cannot be accessed in control tasks
A1: assert (a) // can be accessed, e.g., top.m_i.B1.A1
begin // unnamed block, d cannot be accessed
bit d;
d = a ^ b;
end
else
begin : B2 // name required to access items in action block
bit d; // d can be accessed using, e.g., top.m_i.B1.A1.B2.d
724
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
d = a ^ b;
end
end
logic e;
always_ff @(posedge clk) begin // unnamed block, no scope created
e <= a && c;
C1: cover property(e) // C1 and A2 can be referred to
begin // hierarchical name top.m_i.C1.A2
A2: assert (m_i.B1.A1.B2.d);
end
end
always_ff @(posedge clk) begin // unnamed block, scope created
// declaration of f causes begin-end to create scope
static logic f;
f <= a && c;
C2: cover property(f) // C2 and A3 cannot be referred to
begin
A3: assert (m_i.B1.A1.B2.d);
end
end
always_ff @(posedge clk) begin : B2 // named block and scope created
static logic f;
f <= a && c;
C3: cover property(f) // C3 and A4 can be referred to
begin // hierarchical name top.m_i.B2.C3.A4
A4: assert (m_i.B1.A1.B2.d);
end
end
assert property(@(posedge clk) a |-> b) else // unnamed assertion
begin: B3
static bit d; // d can be referred to, e.g., top.m_i.B3.d
…
A5: assert(d); // hierarchical name top.m_i.B3.A5
end
// Any other labelled object with name B3 at the module
// level shall be an error
endmodule
Hierarchical references into checkers (see Clause17) shall not be permitted.
23.7 Member selects and hierarchical names
A hierarchical name and a member select into a structure, union, class or covergroup object share the same
syntactic form of a sequence of name components separated by periods. Such names are called dotted names
prior to the determination of whether the name is a hierarchical name or member select. The distinguishing
aspect of a hierarchical name is that the first component of the name must match a scope name while the first
name component of a member select must match a data object or interface port name. The general approach
used is to attempt to resolve the first name component immediately and to use the results of that resolution
attempt to determine how to treat the overall name.
When a dotted name is encountered at its point of appearance, the first name in the sequence is resolved as
though it were a simple identifier. The following are the possible results:
725
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
a) The name resolves to a data object or interface port. The dotted name shall be considered to be a
select of that data object or interface port.
b) The name resolves to a directly visible scope name. The dotted name shall be considered to be a
hierarchical name.
c) The name resolves to an imported scope name. The dotted name shall be resolved in the same
manner as a hierarchical name prefixed by the package name from which the name was imported.
d) The name is not found. The dotted name shall be considered to be a hierarchical name.
It is important to note that resolution to an imported scope name is different than resolution to a directly
visible scope name (see 23.7.1).
Example:
package p;
struct { int x; } s1;
struct { int x; } s2;
function void f();
int x;
endfunction
endpackage
module m;
import p::*;
if (1) begin : s1
initial begin
s1.x = 1; // dotted name 1
s2.x = 1; // dotted name 2
f.x = 1; // dotted name 3
f2.x = 1; // dotted name 4
end
int x;
some_module s2();
end
endmodule
The following describes the resolution of each of the dotted names:
— Dotted name 1: The first name component is . Since is a directly visible scope name, rule b)
s1 s1
applies and the name is considered to be a hierarchical name.
s1.x
— Dotted name 2: The first name component is . Since at the time of analysis the module
s2
instantiation scope (from ) is not yet visible, the name binds to the
s2 some_module s2(); s2
visible name from package and rule a) applies. This causes to be imported into module m as
s2 p s2
would occur with a normal variable reference.
— Dotted name 3: The first name component is . Since is an imported scope name, rule c) applies
f f
and the name is considered to be a hierarchical name equivalent to .
f.x p::f.x
— Dotted name 4: The first name component is . Since has no visible definition, rule d) applies
f2 f2
and the name is considered to be a hierarchical name.
f2.x
23.7.1 Names with package or class scope resolution operator prefixes
A name with a package or class scope resolution prefix ( ) shall always resolve in a downwards manner
::
and shall never be subject to the upwards resolution rules in 23.8. If the prefix name can be resolved using
the normal scope resolution rules, the “ ” shall denote the class scope resolution operator. Otherwise the
::
“ ” shall denote the package scope resolution operator.
::
726
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
23.8 Upwards name referencing
The name of a module or module instance is sufficient to identify the module and its location in the
hierarchy. A lower level module can reference items in a module above it in the hierarchy. Variables can be
referenced if the name of the higher level module or its instance name is known. For tasks, functions, named
blocks, and generate blocks, SystemVerilog shall look in the enclosing module for the name until it is found
or until the root of the hierarchy is reached. It shall only search in higher enclosing modules for the name,
not instances.
The syntax for an upward reference is given in Syntax23-8.
upward_name_reference ::=
module_identifier item_name
.
item_name ::=
function_identifier
| block_identifier
| net_identifier
| parameter_identifier
| port_identifier
| task_identifier
| variable_identifier
Syntax23-8—Syntax for upward name referencing (not in AnnexA)
Upward name references can also be done with names of the form
scope_name.item_name
where is either a subroutine name, a module, program, or interface instance name or a
scope_name
generate block name. A name of this form shall be resolved as follows:
a) Look in the current scope for a scope named . If not found and the current scope is not
scope_name
the design element scope, look for the name in the enclosing scope, repeating as necessary until the
name is found or the design element scope is reached. If still not found, proceed to step b).
Otherwise, this name reference shall be treated as a downward reference from the scope in which the
name is found.
b) Look in the instantiation’s parent scope for a scope named . If found, the item name
scope_name
shall be resolved in a downwards manner from that scope. If all name components of the item name
are matched, the search terminates with the final matching item. If any component of the item name
matches the name of a structure, union, class, or covergroup object, no further upwards steps shall
occur even if the item name does not find a match. Continue upwards through the enclosing scopes,
repeating as necessary until the name is found or the design element scope is reached.
c) Repeat step b), going up the hierarchy.
There is an exception to these rules for hierarchical names on the left-hand side of statements.
defparam
See 23.10.4 for details.
In the following example, there are four modules, , , , and . Each module contains an integer . The
a b c d i
highest level modules in this segment of a model hierarchy are and . There are two copies of module
a d b
because module and instantiate . There are four copies of because each of the two copies of
a d b c.i b
instantiates twice.
c
727
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
module a;
integer i;
b a_b1();
endmodule
module b;
integer i;
c b_c1(),
b_c2();
initial // downward path references two copies of i:
#10 b_c1.i = 2; // a.a_b1.b_c1.i, d.d_b1.b_c1.i
endmodule
module c;
integer i;
initial begin // local name references four copies of i:
i = 1; // a.a_b1.b_c1.i, a.a_b1.b_c2.i,
// d.d_b1.b_c1.i, d.d_b1.b_c2.i
b.i = 1; // upward path references two copies of i:
// a.a_b1.i, d.d_b1.i
end
endmodule
module d;
integer i;
b d_b1();
initial begin // full path name references each copy of i
a.i = 1; d.i = 5;
a.a_b1.i = 2; d.d_b1.i = 6;
a.a_b1.b_c1.i = 3; d.d_b1.b_c1.i = 7;
a.a_b1.b_c2.i = 4; d.d_b1.b_c2.i = 8;
end
endmodule
23.8.1 Task and function name resolution
Task and function names are resolved following slightly different rules than other references. Task and
function name resolution follows the rules for upwards hierarchical name resolution as described in 23.8,
step a). Then, before proceeding with step b), an implementation shall look in the complete compilation unit
of the reference. If a task or function with a matching name is found there, the name resolves to that task or
function. Only then does the resolution proceed with step b) and iterate as normal. The special matching
within the compilation unit shall only take place the first time through the iteration through steps a) – c); a
task or function name shall never match a task or function in a compilation unit other than the compilation
unit enclosing the reference.
Example 1:
task t;
int x;
x = f(1); // valid reference to function f in $unit scope
endtask
function int f(int y);
return y+1;
endfunction
728
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 2:
package p;
function void f();
$display("p::f");
endfunction
endpackage
module top;
import p::*;
if (1) begin : b // generate block
initial f(); // reference to “f”
function void f();
$display("top.b.f");
endfunction
end
endmodule
The resolution of the name follows the hierarchical rules and therefore is resolved to the function
f
. The output of the example would be the output of the string .
top.b.f "top.b.f"
23.9 Scope rules
The following elements define a new scope in SystemVerilog:
— Modules
— Interfaces
— Programs
— Checkers
— Packages
— Classes
— Tasks
— Functions
— begin-end blocks (named or unnamed)
— fork-join blocks (named or unnamed)
— Generate blocks
An identifier shall be used to declare only one item within a scope. This rule means it is illegal to declare
two or more variables that have the same name, or to name a task the same as a variable within the same
module, or to give a gate instance the same name as the name of the net connected to its output. For generate
blocks, this rule applies regardless of whether the generate block is instantiated. An exception to this is made
for generate blocks in a conditional generate construct. See 27.6 for a discussion of naming conditional
generate blocks.
If an identifier is referenced directly (without a hierarchical path) within a task, function, named block, or
generate block, it shall be declared either within the task, function, named block, or generate block locally or
within a module, interface, program, checker, task, function, named block, or generate block that is higher in
the same branch of the name tree that contains the task, function, named block, or generate block. If it is
declared locally, then the local item shall be used; if not, the search shall continue upward until an item by
that name is found or until a module, interface, program, or checker boundary is encountered. If the item is a
variable, it shall stop at a module boundary; if the item is a task, function, named block, or generate block, it
729
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
continues to search higher level modules until found. This fact means that tasks and functions can use and
modify the variables within the containing module by name, without going through their formal arguments.
If an identifier is referenced with a hierarchical name, the path can start with a module name, interface name,
program name, checker name, instance name, task, function, named block, or named generate block. The
names shall be searched first at the current level and then in higher level modules until found. Because both
module, interface, program, or checker names as well as instance names can be used, precedence is given to
instance names if there is a module, interface, program, or checker named the same as an instance name.
Because of the upward searching, path names that are not strictly on a downward path can be used.
For example:
Example 1: In Figure23-2, each rectangle represents a local scope. The scope available to upward searching
extends outward to all containing rectangles—with the boundary of the module A as the outer limit. Thus
block G can directly reference identifiers in F, E, and A; it cannot directly reference identifiers in H, B, C,
and D.
module A
task E
Scopes not block B
Scopes available
available to
to block G
block G block F
block G
task C
block H
func D
Figure23-2—Scopes available to upward name referencing
Example 2: The following example shows how variables can be accessed directly or with hierarchical
names:
task t;
logic s;
begin : b
logic r;
t.b.r = 0;// These three lines access the same variable r
b.r = 0;
r = 0;
t.s = 0;// These two lines access the same variable s
s = 0;
730
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
end
endtask
23.10 Overriding module parameters
SystemVerilog provides two types of parameter constants that can be overridden, value parameters (see
6.20.2) and type parameters (see 6.20.3).
There are two different places parameters can be defined within a module (or interface or program). The first
is the module’s parameter_port_list (see 23.2), and the second is as a module_item (see 6.20). A module
declaration can contain parameter definitions of either or both types or can contain no parameter definitions.
For example:
module generic_fifo
#(MSB=3, LSB=0) // parameter port list parameters
(input wire [MSB:LSB] in,
input wire clk, read, write, reset,
output logic [MSB:LSB] out,
output logic full, empty );
parameter DEPTH=4; // module item parameter
localparam FIFO_MSB = DEPTH*MSB;
localparam FIFO_LSB = LSB;
// These constants are local, and cannot be overridden.
// They can be affected by altering the value parameters above
logic [FIFO_MSB:FIFO_LSB] fifo;
logic [LOG2(DEPTH):0] depth;
always @(posedge clk or posedge reset) begin
casez ({read,write,reset})
// implementation of fifo
endcase
end
endmodule
There are two ways to alter nonlocal parameters: the defparam statement, which allows assignment to
parameters using their hierarchical names, and the module instance parameter value assignment, which
allows values to be assigned in-line during module instantiation. The module instance parameter value
assignment comes in two forms, by ordered list or by name. The next two subclauses describe these two
methods. If a assignment conflicts with a module instance parameter, the parameter in the
defparam
module will take the value specified by the .
defparam
A value parameter (see 6.20.2) can have a type specification and a range specification. The effect of
parameter overrides on a value parameter’s type and range shall be in accordance with the following rules:
— A value parameter declaration with no type or range specification shall default to the type and range
of the final override value assigned to the parameter.
— A value parameter with a range specification, but with no type specification, shall have the range of
the parameter declaration and shall be unsigned. An override value shall be converted to the type
and range of the parameter.
— A value parameter with a type specification, but with no range specification, shall be of the type
specified. An override value shall be converted to the type of the parameter. A signed parameter
shall default to the range of the final override value assigned to the parameter.
731
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— A value parameter with a signed type specification and with a range specification shall be signed
and shall have the range of its declaration. An override value shall be converted to the type and
range of the parameter.
For example:
module m1 (a,b);
real r1,r2;
parameter [2:0] A = 3'h2;
parameter B = 3'h2;
initial begin
r1 = A;
r2 = B;
$display("r1 is %f r2 is %f",r1,r2);
end
endmodule: m1
module m2;
wire a,b;
defparam f1.A = 3.1415;
defparam f1.B = 3.1415;
m1 f1(a,b);
endmodule: m2
Parameter is a typed and/or ranged parameter; when its value is redefined, the parameter retains its original
A
type and sign. Therefore, the of with the value 3.1415 is performed by converting the
defparam f1.A
floating-point number 3.1415 into a fixed-point number 3, and then the low 3 bits of 3 are assigned to .
A
Parameter is not a typed and/or ranged parameter; when its value is redefined, the parameter type and
B
range take on the type and range of the new value. Therefore, the of with the value 3.1415
defparam f1.B
replaces ’s current value of 3'h2 with the floating-point number 3.1415.
B
23.10.1 defparam statement
Using the defparam statement, parameter values can be changed in any module, interface, or program
instance throughout the design using the hierarchical name of the parameter. See 23.6 for hierarchical
names.
However, a statement in a hierarchy in or under a generate block instance (see Clause27) or an
defparam
array of instances (see 28.3.5 and 23.3.2) shall not change a parameter value outside that hierarchy.
Each instantiation of a generate block is considered to be a separate hierarchy scope. Therefore, a
defparam
statement in a generate block may not target a parameter in another instantiation of the same generate block,
even when the other instantiation is created by the same loop generate construct. For example, the following
code is not allowed:
genvar i;
generate
for (i = 0; i < 8; i = i + 1) begin : somename
flop my_flop(in[i], in1[i], out1[i]);
defparam somename[i+1].my_flop.xyz = i ;
end
endgenerate
732
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Similarly, a statement in one instance of an array of instances may not target a parameter in
defparam
another instance of the array.
The expression on the right-hand side of assignments shall be a constant expression involving
defparam
only numbers and references to parameters. The referenced parameters (on the right-hand side of the
) shall be declared in the same module as the statement.
defparam defparam
The statement is particularly useful for grouping all of the parameter value override assignments
defparam
together in one module.
In the case of multiple defparams for a single parameter, the parameter takes the value of the last
defparam
statement encountered in the source text. When defparams are encountered in multiple source files, e.g.,
found by library searching, the from which the parameter takes its value is undefined.
defparam
For example:
module top;
logic clk;
logic [0:4] in1;
logic [0:9] in2;
wire [0:4] o1;
wire [0:9] o2;
vdff m1 (o1, in1, clk);
vdff m2 (o2, in2, clk);
endmodule
module vdff (out, in, clk);
parameter size = 1, delay = 1;
input [0:size-1] in;
input clk;
output [0:size-1] out;
logic [0:size-1] out;
always @(posedge clk)
# delay out = in;
endmodule
module annotate;
defparam
top.m1.size = 5,
top.m1.delay = 10,
top.m2.size = 10,
top.m2.delay = 20;
endmodule
The module has the statement, which overrides and parameter values for
annotate defparam size delay
instances and in the top-level module . The modules and would both be
m1 m2 top top annotate
considered top-level modules.
NOTE—The statement might be removed from future versions of the language. See C.4.1.
defparam
23.10.2 Module instance parameter value assignment
An alternative method for assigning values to parameters within module instances is to use one of the two
forms of module instance parameter value assignment: assignment by ordered list and assignment by name.
733
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The two types of module instance parameter value assignment shall not be mixed; parameter assignments to
a particular module instance shall be entirely by order or entirely by name.
Module instance parameter value assignment by ordered list is similar in appearance to the assignment of
delay values to gate instances, and assignment by name is similar to connecting module ports by name. It
supplies values for particular instances of a module to any parameters that have been specified in the
definition of that module.
A parameter declared in a named block, task, or function can only be directly redefined using a
defparam
statement. However, if the parameter value is dependent on a second parameter, then redefining the second
parameter will update the value of the first parameter as well (see 23.10.3).
23.10.2.1 Parameter value assignment by ordered list
The order of the assignments in the module instance parameter assignment by ordered list shall follow the
order of declaration of the parameters within the module. It is not necessary to assign values/types to all of
the parameters within a module when using this method. However, it is not possible to skip over a
parameter. Therefore, to assign values to a subset of the parameters declared within a module, the
declarations of the parameters that make up this subset shall precede the declarations of the remaining
parameters. An alternative is to assign values to all of the parameters, but to use the default value (the same
value assigned in the declaration of the parameter within the module definition) for those parameters that do
not need new values.
Consider the following example, where the parameters within module instances , , and
mod_a mod_c mod_d
are changed during instantiation:
module tb1;
wire [9:0] out_a, out_d;
wire [4:0] out_b, out_c;
logic [9:0] in_a, in_d;
logic [4:0] in_b, in_c;
logic clk;
// testbench clock & stimulus generation code ...
// Four instances of vdff with parameter value assignment by ordered list
// mod_a has new parameter values size=10 and delay=15
// mod_b has default parameters (size=5, delay=1)
// mod_c has one default size=5 and one new delay=12
// In order to change the value of delay,
// it is necessary to specify the (default) value of size as well.
// mod_d has a new parameter value size=10.
// delay retains its default value
vdff #(10,15) mod_a (.out(out_a), .in(in_a), .clk(clk));
vdff mod_b (.out(out_b), .in(in_b), .clk(clk));
vdff #( 5,12) mod_c (.out(out_c), .in(in_c), .clk(clk));
vdff #(10) mod_d (.out(out_d), .in(in_d), .clk(clk));
endmodule
module vdff (out, in, clk);
parameter size=5, delay=1;
output [size-1:0] out;
input [size-1:0] in;
734
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
input clk;
logic [size-1:0] out;
always @(posedge clk)
#delay out = in;
endmodule
Local parameters cannot be overridden; therefore, they are not considered part of the ordered list for
parameter value assignment, even if the local parameter appears in a module’s parameter_port_list. In the
following example, will be assigned the value 12, and will be assigned the value
addr_width data_width
16. will not be explicitly assigned a value due to the ordered list, but will have the value 4096 due
mem_size
to its declaration expression.
module my_mem (addr, data);
parameter addr_width = 16;
localparam mem_size = 1 << addr_width;
parameter data_width = 8;
...
endmodule
module top;
...
my_mem #(12, 16) m(addr,data);
endmodule
23.10.2.2 Parameter value assignment by name
Parameter assignment by name consists of explicitly linking the parameter name and its new value. The
name of the parameter shall be the name specified in the instantiated module.
It is not necessary to assign values to all of the parameters within a module when using this method. Only
parameters that are assigned new values need to be specified.
The parameter expression is optional so that the instantiating module can document the existence of a
parameter without assigning anything to it. The parentheses are required, and in this case the parameter
retains its default value. Once a parameter is assigned a value, there shall not be another assignment to this
parameter name.
Consider the following example, where both parameters of and only one parameter of and
mod_a mod_c
are changed during instantiation:
mod_d
module tb2;
wire [9:0] out_a, out_d;
wire [4:0] out_b, out_c;
logic [9:0] in_a, in_d;
logic [4:0] in_b, in_c;
logic clk;
// testbench clock & stimulus generation code ...
// Four instances of vdff with parameter value assignment by name
// mod_a has new parameter values size=10 and delay=15
// mod_b has default parameters (size=5, delay=1)
// mod_c has one default size=5 and one new delay=12
// mod_d has a new parameter value size=10.
// delay retains its default value
735
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
vdff #(.size(10),.delay(15)) mod_a (.out(out_a),.in(in_a),.clk(clk));
vdff mod_b (.out(out_b),.in(in_b),.clk(clk));
vdff #(.delay(12)) mod_c (.out(out_c),.in(in_c),.clk(clk));
vdff #(.delay( ),.size(10) ) mod_d (.out(out_d),.in(in_d),.clk(clk));
endmodule
module vdff (out, in, clk);
parameter size=5, delay=1;
output [size-1:0] out;
input [size-1:0] in;
input clk;
logic [size-1:0] out;
always @(posedge clk)
#delay out = in;
endmodule
It shall be legal to instantiate modules using different types of parameter redefinition in the same top-level
module. Consider the following example, where the parameters of are changed using parameter
mod_a
redefinition by ordered list and the second parameter of is changed using parameter redefinition by
mod_c
name during instantiation:
module tb3;
// declarations & code
// legal mixture of instance with positional parameters and
// another instance with named parameters
vdff #(10, 15) mod_a (.out(out_a), .in(in_a), .clk(clk));
vdff mod_b (.out(out_b), .in(in_b), .clk(clk));
vdff #(.delay(12)) mod_c (.out(out_c), .in(in_c), .clk(clk));
endmodule
It shall be illegal to instantiate any module using a mixture of parameter redefinitions by order and by name
as shown in the instantiation of below:
mod_a
// mod_a instance with ILLEGAL mixture of parameter assignments
vdff #(10, .delay(15)) mod_a (.out(out_a), .in(in_a), .clk(clk));
23.10.3 Parameter dependence
A parameter (for example, ) can be defined with an expression containing another parameter
memory_size
(for example, ). However, overriding a parameter, whether by a statement or in a
word_size defparam
module instantiation statement, effectively replaces the parameter definition with the new expression.
Because depends on the value of , a modification of changes the
memory_size word_size word_size
value of . For example, in the following parameter declaration, an update of ,
memory_size word_size
whether by statement or in an instantiation statement for the module that defined these
defparam
parameters, automatically updates . If is updated due to either a or
memory_size memory_size defparam
an instantiation statement, then it will take on that value, regardless of the value of .
word_size
parameter
word_size = 32,
memory_size = word_size * 4096;
736
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Parameters can also have type dependencies on other parameters, including type parameters. Examples of
such dependencies are as follows:
parameter p = 1;
parameter [p:0] p2 = 4;
parameter type T = int;
parameter T p3 = 7;
If parameter changes, the value of is recomputed based on the new size of the type. If the type
p p2
parameter changes, the value of is recomputed. It is possible for an override of a parameter to result in
T p3
an illegal parameter assignment. For example, if in the preceding example was overridden to a class type,
T
the evaluation of would be illegal and would cause elaboration to fail.
p3
If a module instance overrides a type parameter, assignments to parameters that depend on the type
parameter shall not occur with the default type.
class C ;
endclass
module M #( type T = C, T p = 4,
type T2, T2 p2 = 4
) () ;
endmodule
In the preceding example, if the type parameter is not overridden to an integral type, the evaluation of the
T
default value for parameter is illegal. If is overridden to an integral type, the default initialization of
p T p
shall occur only with the overridden type resulting in a legal initialization. Similarly, since requires an
T2
instantiation override, the evaluation of shall only occur with the type defined by the parameter override.
p2
23.10.4 Elaboration considerations
Elaboration is the process that occurs between parsing and simulation. It binds modules to module
instances, builds the model hierarchy, computes parameter values, resolves hierarchical names, establishes
net connectivity, and prepares all of this for simulation.
23.10.4.1 Order of elaboration
Because of generate constructs, the model hierarchy can depend on parameter values. Because
defparam
statements can alter parameter values from almost anywhere in the hierarchy, the result of elaboration can be
ambiguous when generate constructs are involved. The final model hierarchy can depend on the order in
which and generate constructs are evaluated.
defparams
The following algorithm defines an order that produces the correct hierarchy:
a) A list of starting points is initialized with the list of top-level modules.
b) The hierarchy below each starting point is expanded as much as possible without elaborating
generate constructs. All parameters encountered during this expansion are given their final values by
applying initial values, parameter overrides, and statements.
defparam
In other words, any statement whose target can be resolved within the hierarchy
defparam
elaborated so far shall have its target resolved and its value applied. statements whose
defparam
target cannot be resolved are deferred until the next iteration of this step. Because no
defparam
inside the hierarchy below a generate construct is allowed to refer to a parameter outside the
generate construct, it is possible for parameters to get their final values before going to step c).
737
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
c) Each generate construct encountered in step b) is revisited, and the generate scheme is evaluated.
The resulting generate block instantiations make up the new list of starting points. If the new list of
starting points is not empty, go to step b).
23.10.4.2 Early resolution of hierarchical names
In order to comply with this algorithm, hierarchical names in some statements will need to be
defparam
resolved prior to the full elaboration of the hierarchy. It is possible that when elaboration is complete, rules
for name resolution would dictate that a hierarchical name in a statement would have resolved
defparam
differently had early resolution not been required. This could result in a situation where an identical
hierarchical name in some other statement in the same scope would resolve differently from the one in the
statement. Following is an example of a design that has this problem:
defparam
module m;
m1 n();
endmodule
module m1;
parameter p = 2;
defparam m.n.p = 1;
initial $display(m.n.p);
generate
if (p == 1) begin : m
m2 n();
end
endgenerate
endmodule
module m2;
parameter p = 3;
endmodule
In this example, the must be evaluated before the conditional generate is elaborated. At this point
defparam
in elaboration, the name resolves to in module , and this parameter is used in the generate
parameter p m1
scheme. The result of the is to set that parameter to 1; therefore, the generate condition is true.
defparam
After the hierarchy below the generate construct is elaborated, the rules for hierarchical name resolution
would dictate that the name should have resolved to in module . In fact, the identical name
parameter p m2
in the statement will resolve to that other parameter.
$display
It shall be an error if a hierarchical name in a is resolved before the hierarchy is completely
defparam
elaborated and that name would resolve differently once the model is completely elaborated.
This situation will occur very rarely. In order to cause the error, there has to be a named generate block that
has the same name as one of the scopes in its full hierarchical name. Furthermore, there have to be two
instances with the same name, one in the generate block and one in the other scope with the same name as
the generate block. Then, inside these instances there have to be parameters with the same name. If this
problem occurs, it can be easily fixed by changing the name of the generate block.
23.11 Binding auxiliary code to scopes or instances
It is often desired to keep verification code separate from the design code. SystemVerilog provides a bind
construct that is used to specify one or more instantiations of a module, interface, program, or checker
without modifying the code of the target. So, for example, instrumentation code or assertions that are
738
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
encapsulated in a module, interface, program, or checker can be instantiated in a target module or a module
instance in a non-intrusive manner. Similarly, instrumentation code that is encapsulated in an interface can
be bound to a target interface or interface instance.
The syntax of the construct is as follows in Syntax23-9.
bind
bind_directive4 ::= // from A.1.4
bind_target_scope [ bind_target_instance_list] bind_instantiation
bind : ;
| bind_target_instance bind_instantiation
bind ;
bind_target_scope ::=
module_identifier
| interface_identifier
bind_target_instance ::=
hierarchical_identifier constant_bit_select
bind_target_instance_list ::=
bind_target_instance { bind_target_instance }
,
bind_instantiation ::=
program_instantiation
| module_instantiation
| interface_instantiation
| checker_instantiation
4) If the bind_target_scope is an interface_identifier or the bind_target_instance is an interface_instance_identifier,
then the bind_instantiation shall be an interface_instantiation or a checker_instantiation.
Syntax23-9—Bind construct syntax (excerpt from AnnexA)
The directive can be specified in any of the following:
bind
— A module
— An interface
— A compilation-unit scope
There are two forms of bind syntax. In the first form, bind_target_scope specifies a target scope into which
the bind_instantiation should be inserted. A bind target scope shall be a module or an interface. A bind
target instance shall be an instance of a module or an interface. In the absence of a bind_target_instance_list,
the bind_instantiation is inserted into all instances of the specified target scope, designwide. If a
bind_target_instance_list is present, the bind_instantiation is only inserted into the specified instances of
the target scope. The bind_instantiation is effectively a complete module, interface, program, or checker
instantiation statement.
The second form of bind syntax can be used to specify a single instance into which the bind_instantiation
should be inserted. If the second form of bind syntax is used and the bind_target_instance identifier resolves
to both an instance name and a module name, binding shall only occur to the specified instance.
Example of binding a program instance to a module:
bind cpu fpu_props fpu_rules_1(a,b,c);
where
— is the name of the target module.
cpu
739
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— is the name of the program to be instantiated.
fpu_props
— is the program instance name to be created in the target scope.
fpu_rules_1
— An instance named is instantiated in every instance of module .
fpu_rules_1 cpu
— The first three ports of program get bound to objects , , and in module (these
fpu_props a b c cpu
objects are viewed from module ’s point of view, and they are completely distinct from any
cpu
objects named , , and that are visible in the scope that contains the directive).
a b c bind
Example of binding a program instance to a specific instance of a module:
bind cpu: cpu1 fpu_props fpu_rules_1(a, b, c);
In the preceding example, the instance is bound into the instance of module .
fpu_rules_1 cpu1 cpu
Example of binding a program instance to multiple instances of a module:
bind cpu: cpu1, cpu2, cpu3 fpu_props fpu_rules_1(a, b, c);
In the preceding example, the instance is bound into instances , , and of
fpu_rules_1 cpu1 cpu2 cpu3
module .
cpu
By binding a program to a module or an instance, the program becomes part of the bound object. The names
of assertion-related declarations can be referenced using the SystemVerilog hierarchical naming
conventions.
Binding of a module instance or an interface instance works the same way as described for the previous
programs.
interface range (input clk, enable, input var int minval, expr);
property crange_en;
@(posedge clk) enable |-> (minval <= expr);
endproperty
range_chk: assert property (crange_en);
endinterface
bind cr_unit range r1(c_clk,c_en,v_low,(in1&&in2));
In this example, interface is instantiated in the module . Effectively, every instance of
range cr_unit
module shall contain the interface instance .
cr_unit r1
The bind_instantiation portion of the statement allows the complete range of SystemVerilog
bind
instantiation syntax. In other words, both parameter and port associations may appear in the
bind_instantiation. All actual ports and parameters in the bind_instantiation refer to objects from the
viewpoint of the bind_target_instance.
When an instance is bound into a target scope, the effect will be as if the instance was present at the very end
of the target scope. In other words, all declarations present in the target scope or imported into the target
scope are visible to the bound instance. Wildcard import candidates that have been imported into the scope
are visible, but a bind statement cannot cause the import of a wildcard candidate. Declarations present or
imported into are not visible in the bind statement.
$unit
User-defined type names that are used to override type parameters must be visible and matching in both the
scope containing the bind statement and in the target scope.
740
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If multiple statements are present in a given scope, the order of those statements is not important. An
bind
implementation is free to elaborate statements in any order it chooses.
bind
The following is an example of a module containing a statement with complex instantiation syntax.
bind
All identifiers in the instantiation are referenced from the bind target’s point of view in the overall
bind
design hierarchy.
bind targetmod
mycheck #(.param1(const4), .param2(8'h44))
i_mycheck(.*, .p1(f1({v1, 1'b0, b1.c}, v2 & v3)), .p2(top.v4));
If any controlling configuration library mapping is in effect at the time a statement is encountered, the
bind
mapping associated with the statement shall influence the elaboration of the bind_instantiation
bind
statement. In all cases, library mapping associated with the bind_target_instance shall be ignored during
elaboration of the bind_instantiation.
It shall be an error to use noninstance-based binding for a given target if the design contains more than one
module or interface with the target name. This can occur in the presence of configuration library mapping. In
such cases, instance-based binding syntax can be used to target individual instances of the design elements
with the ambiguous name.
Any statement located at a lower level of the bind_instantiation’s hierarchy shall not extend
defparam
influence outside the scope of that local hierarchy. This is similar to the rules for use of inside the
defparam
scope of generated hierarchy.
Hierarchical references to a bind_instantiation’s parameters may not be used outside the instantiation in any
context that requires a constant expression. Examples of such contexts include type descriptions and
generate conditions.
It is legal for more than one statement to bind a bind_instantiation into the same target scope.
bind
However, it shall be an error for a bind_instantiation to introduce an instance name that clashes with another
name in the module name space of the target scope (see 3.13). This applies to both preexisting names as well
as instance names introduced by other statements. The latter situation will occur if the design contains
bind
more than one instance of a module containing a statement.
bind
It shall be an error for a statement to bind a bind_instantiation underneath the scope of another
bind
bind_instantiation.
741
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
24. Programs
24.1 General
This clause describes the following:
— Program declarations
— Program scheduling semantics
— Programs in conjunction with clocking blocks
— Anonymous programs
24.2 Overview
The module is the basic building block for designs. Modules can contain hierarchies of other modules, nets,
variables, subroutine declarations, and procedural statements within always and initial procedures. This
construct works extremely well for the description of hardware. However, for the testbench, the emphasis is
not in the hardware-level details such as wires, structural hierarchy, and interconnects, but in modeling the
complete environment in which a design is verified. The environment must be properly initialized and
synchronized, avoiding races between the design and the testbench, automating the generation of input
stimuli, and reusing existing models and other infrastructure.
The program block serves the following three basic purposes:
— It provides an entry point to the execution of testbenches.
— It creates a scope that encapsulates programwide data, tasks, and functions.
— It provides a syntactic context that specifies scheduling in the reactive region set.
The program construct serves as a clear separator between design and testbench, and, more importantly, it
specifies specialized execution semantics in the reactive region set for all elements declared within the
program. Together with clocking blocks, the program construct provides for race-free interaction between
the design and the testbench and enables cycle- and transaction-level abstractions.
The abstraction and modeling constructs of SystemVerilog simplify the creation and maintenance of
testbenches. The ability to instantiate and individually connect each program instance enables their use as
generalized models.
24.3 The program construct
A typical program contains type and data declarations, subroutines, connections to the design, and one or
more procedural code streams. The connection between design and testbench uses the same interconnect
mechanism used to specify port connections, including interfaces. Program port declaration syntax and
semantics are the same as those of modules (see 23.2.2).
The syntax for the program block is as follows:
program_nonansi_header ::= // from A.1.2
{ attribute_instance } [ lifetime ] program_identifier
program
{ package_import_declaration } [ parameter_port_list ] list_of_ports
;
program_ansi_header ::=
{attribute_instance } [ lifetime ] program_identifier
program
{ package_import_declaration }1 [ parameter_port_list ] [ list_of_port_declarations ]
;
742
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
program_declaration ::=
program_nonansi_header [ timeunits_declaration ] { program_item }
[ program_identifier ]
endprogram :
| program_ansi_header [ timeunits_declaration ] { non_port_program_item }
[ program_identifier ]
endprogram :
| { attribute_instance } program_identifier
program ( .* ) ;
[ timeunits_declaration ] { program_item }
[ program_identifier ]
endprogram :
| program_nonansi_header
extern
| program_ansi_header
extern
program_item ::= // from A.1.7
port_declaration
;
| non_port_program_item
non_port_program_item ::=
{ attribute_instance } continuous_assign
| { attribute_instance } module_or_generate_item_declaration
| { attribute_instance } initial_construct
| { attribute_instance } final_construct
| { attribute_instance } concurrent_assertion_item
| timeunits_declaration3
| program_generate_item
program_generate_item5 ::=
loop_generate_construct
| conditional_generate_construct
| generate_region
lifetime ::= | // from A.2.1.3
static automatic
anonymous_program ::= { anonymous_program_item } // from A.1.11
program ; endprogram
anonymous_program_item ::=
task_declaration
| function_declaration
| class_declaration
| covergroup_declaration
| class_constructor_declaration
|
;
1) A package_import_declaration in a module_ansi_header, interface_ansi_header, or program_ansi_header shall be
followed by a parameter_port_list or list_of_port_declarations, or both.
3) A timeunits_declaration shall be legal as a non_port_module_item, non_port_interface_item,
non_port_program_item, or package_item only if it repeats and matches a previous timeunits_declaration within
the same time scope.
5) It shall be illegal for a program_generate_item to include any item that would be illegal in a program_declaration
outside a program_generate_item.
Syntax24-1—Program declaration syntax (excerpt from AnnexA)
For example:
program test (input clk, input [16:1] addr, inout [7:0] data);
initial ...
endprogram
743
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
or
program test ( interface device_ifc );
initial ...
endprogram
A more complete example is included in 14.8 and 14.9.
The construct can be considered a leaf module with special execution semantics. Once declared, a
program
program block can be instantiated in the required hierarchical location (typically at the top level), and its
ports can be connected in the same manner as any other module.
Program blocks can be nested within modules or interfaces. This allows multiple cooperating programs to
share variables local to the scope. Nested programs with no ports or top-level programs that are not
explicitly instantiated are implicitly instantiated once. Implicitly instantiated programs have the same
instance and declaration name. For example:
module test(...);
int shared; // variable shared by programs p1 and p1
program p1;
...
endprogram
program p2;
...
endprogram // p1 and p2 are implicitly instantiated once in module test
endmodule
A program block may contain one or more initial or final procedures. It shall not contain always procedures,
primitives, UDPs, or declarations or instances of modules, interfaces, or other programs.
When all initial procedures within a program have reached their end, that program shall immediately
terminate all descendent threads of initial procedures within that program. If there is at least one initial
procedure within at least one program block, the entire simulation shall terminate by means of an implicit
call to the system task immediately after all the threads and all their descendent threads originating
$finish
from all initial procedures within all programs have ended.
Type and data declarations within the program are local to the program scope and have static lifetime.
Variables declared within the scope of a program, including variables declared as ports, are called program
variables. Similarly, nets declared within the scope of a program are called program nets. Program variables
and nets are collectively termed program signals.
The dual of a program signal is a design signal. Any net or variable declared within a , ,
module interface
, or is considered to be a design signal.
package $unit
References to program signals from outside any program block shall be an error. It shall be legal for
hierarchical references to extend from one program scope to another program scope. However, anonymous
programs shall not contain hierarchical references to other program scopes.
24.3.1 Scheduling semantics of code in program constructs
Statements and constructs within a program block that are sensitive to changes (e.g., update events) on
design signals are scheduled in the Reactive region. Consider a program that contains the statement
744
Authorized licensed use limited to: Siemens AG GBSC Bo&pSyr iSgOhLt ©G M20S1. 8D IoEwEnElo.a Adell dr igohn tDs erecesmerbveerd 0.3,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
where is a design signal. Every transition of signal will cause the statement to be
@(clk) S1; clk clk S1
scheduled into the Reactive region. The continuous assignment would also be
assign tclk = clk;
scheduled in the Reactive region. Likewise, initial procedures within program blocks are scheduled in the
Reactive region. The standard # delay operator within program blocks schedules process resumption in the
Reactive region.
Nonblocking assignments in program code schedule their updates in the Re-NBA region. The Re-NBA
region is processed after the Reactive and Re-Inactive regions have been emptied of events. See 4.2.
Concurrent assertions are allowed in program blocks. Concurrent assertions have invariant scheduling
semantics—whether present in program code or design code. Assertions always sample the values available
while processing the Preponed region, and they are always evaluated when processing the Observed region.
If an assertion is clocked by activity on a program object (not recommended), the scheduler will iterate from
the reactive region set back around the outer loop in Figure4-1, through the Observed region, where the
assertion is evaluated.
Once a program process starts a thread of execution, all subsequent blocking statements in that thread are
scheduled in the Reactive region. This includes subroutine code called by the thread, even if the subroutine
code is declared in a module, package, or interface. Effectively, a section of sequential code anywhere in the
design or testbench inherits the scheduling region of the thread that calls it. Since program code can never be
called by module code, program code always executes as part of the reactive set processing. Code in a
module, interface, or package scope may execute as part of either the Active region set or the reactive set
processing.
24.3.2 Operation of program port connections in the absence of clocking blocks
The interaction of clocking blocks with program ports is described in Clause14. Clocking blocks are an
important component in establishing race-free behavior between designs and testbenches. However, it is
possible to construct a program that contains no clocking blocks. Such programs are more prone to races
when interacting with design code. This subclause defines the interaction of program ports with design code
in the absence of clocking blocks.
Program ports are program-scope objects. They are always connected to design objects (nets and variables),
since programs can only be instantiated in design scopes.
Sequential code declared in programs always executes in the reactive region set. Thus, variables on the other
side of a program port connection are updated in the reactive region set. Similarly, the driving and resolution
of nets on the other side of a program port connection also occurs in the reactive region set. Such driving and
resolution occurs immediately after an event causes a change to a driver on a program net. Design processes
sensitive to those cross-region variables and nets are scheduled for wake up in the active region set.
Consider the following example design, which contains both design constructs and program constructs:
module m;
logic r;
wire dw1, dw2;
initial begin
r = 0;
#10 r = 1;
end
assign dw1 = r;
p p_i(dw2, dw1);
745
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
always @(dw2)
$display("dw2 is %b", dw2);
endmodule
program p(output pw2, input pw1);
assign pw2 = pw1;
endprogram
In this design, the flow of data originates in and terminates in the execution of the
logic r always
procedure. Due to the presence of , it is necessary for simulators to perform multiple iterations
program p
over the entire loop in Figure4-1. This is because the statement in shall not be
assign program p
executed until the Reactive region. And when it executes and triggers activity on the procedure in
always
, that procedure is not executed until the Active region in the next iteration of the overall
module m always
scheduling loop.
24.4 Eliminating testbench races
There are two major sources of nondeterminism in SystemVerilog. The first one is that active events are
processed in an arbitrary order. The second one is that statements without time control constructs in
behavioral blocks do not execute as one event. However, from the testbench perspective, these effects are all
unimportant details. The primary task of a testbench is to generate valid input stimulus for the design under
test and to verify that the device operates correctly. Furthermore, testbenches that use cycle abstractions are
only concerned with the stable or steady state of the system for both checking the current outputs and for
computing stimuli for the next cycle. Formal tools also work in this fashion.
Because the program schedules events in the reactive region set, the clocking block construct is very useful
to automatically sample the steady-state values of previous time steps or clock cycles. Programs that read
design values exclusively through clocking blocks with clocks that are design signals are insensitive to read-
write races. It is important to understand that simply sampling input signals (or setting nonzero skews on
clocking block inputs) does not eliminate the potential for races. Proper input sampling only addresses a
single clocking block. With multiple clocks, the arbitrary order in which overlapping or simultaneous clocks
are processed is still a potential source for races. The program construct addresses this issue by scheduling
its execution in the Reactive region, after all design events have been processed, including clocks driven by
nonblocking assignments.
24.5 Blocking tasks in cycle/event mode
Calling program subroutines from within design modules is illegal and shall result in an error. This is
because the design should not be aware of the testbench. Programs are allowed to call subroutines in other
programs or within design modules. Functions within design modules can be called from a program and
require no special handling. When a task within a design module is called from a program, it shall use the
reactive region set for its scheduling activities. See 24.3.1.
module ...
task T;
S1: a = b; // executes in reactive region set if called from a program
#5;
S2: b <= 1'b1; // executes in reactive region set if called from a program
endtask
endmodule
If task , above, is called from within a module, then the statement can execute immediately when the
T S1
Active region is processed, before variable is updated by the nonblocking assignment. If the same task is
b
746
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
called from within a program, then the statement shall execute when the Reactive region is processed.
S1
Statement shall also execute in the Reactive region, and variable ’s update shall be scheduled in the
S2 b
Re-NBA region.
24.6 Programwide space and anonymous programs
The set of program definitions and instances define a space of programwide data, tasks, and functions that is
accessible only to programs.
Anonymous programs can be used inside packages (see Clause26) or compilation-unit scopes (see 3.12.1)
to declare items that are part of the programwide space without declaring a new scope. Items declared in an
anonymous program share the same name space as the package or compilation-unit scope in which they are
declared.
NOTE—Although identifiers declared inside an anonymous program cannot be referenced outside any program block,
attempting to declare another identifier with the same name outside the anonymous program block will generate an error.
This occurs because the identifier shares the same name space within the scope of the surrounding package or
compilation unit.
24.7 Program control tasks
In addition to the normal simulation control tasks ( and ), a program can use the
$stop $finish $exit
control task.
A program block may terminate the threads of all its initial procedures as well as all of their descendents
explicitly by calling the system task. The syntax for the system task is as follows:
$exit $exit
$exit();
Calling from a thread or its descendent thread originating in an procedure of a program
$exit initial
block shall terminate all initial procedures and their descendent threads within that originating program
block. Calling from a thread or its descendent thread that does not originate in an procedure
$exit initial
in a program shall be ignored, and a warning may be issued to indicate that the call to has been
$exit
ignored.
747
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd. o An llD reigcehmtsb reer s0e3r,v2e02d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
25. Interfaces
25.1 General
This clause describes the following:
— Purpose of interfaces
— Interface syntax
— Interface modports
— Interface methods
— Parameterized interfaces
— Virtual interfaces
— Accessing interface objects
25.2 Overview
The communication between blocks of a digital system is a critical area that can affect everything from ease
of RTL coding to hardware-software partitioning to performance analysis to bus implementation choices
and protocol checking. The interface construct in SystemVerilog was specifically created to encapsulate the
communication between blocks, allowing a smooth migration from abstract system-level design through
successive refinement down to lower level register-transfer and structural views of the design. By
encapsulating the communication between blocks, the interface construct also facilitates design reuse. The
inclusion of interface capabilities is an important advantage of SystemVerilog.
At its lowest level, an interface is a named bundle of nets or variables. The interface is instantiated in a
design and can be accessed through a port as a single item, and the component nets or variables referenced
where needed. A significant proportion of a design often consists of port lists and port connection lists,
which are just repetitions of names. The ability to replace a group of names by a single name can
significantly reduce the size of a description and improve its maintainability.
Additional power of the interface comes from its ability to encapsulate functionality as well as connectivity,
making an interface, at its highest level, more like a class template. An interface can have parameters,
constants, variables, functions, and tasks. The types of elements in an interface can be declared, or the types
can be passed in as parameters. The member variables and functions are referenced relative to the instance
name of the interface as instance members. Thus, modules that are connected via an interface can simply call
the subroutine members of that interface to drive the communication. With the functionality thus
encapsulated in the interface and isolated from the module, the abstraction level and/or granularity of the
communication protocol can be easily changed by replacing the interface with a different interface
containing the same members, but implemented at a different level of abstraction. The modules connected
via the interface do not need to change at all.
To provide direction information for module ports and to control the use of tasks and functions within
particular modules, the construct is provided. As the name indicates, the directions are those seen
modport
from the module.
In addition to subroutine methods, an interface can also contain processes (i.e., or
initial always
procedures) and continuous assignments, which are useful for system-level modeling and testbench
applications. This allows the interface to include, for example, its own protocol checker that automatically
verifies that all modules connected via the interface conform to the specified protocol. Other applications,
such as functional coverage recording and reporting, protocol checking, and assertions, can also be built into
the interface.
748
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The methods can be abstract, i.e., defined in one module and called in another, using the and
export
constructs. This could be coded using hierarchical path names, but this would impede reuse because
import
the names would be design-specific. A better way is to declare the subroutine names in the interface and to
use local hierarchical names from the interface instance for both definition and call. Broadcast
communication is modeled by tasks, which can be defined in more than one module and
forkjoin
executed concurrently.
25.3 Interface syntax
interface_declaration ::= // from A.1.2
interface_nonansi_header [ timeunits_declaration ] { interface_item }
[ interface_identifier ]
endinterface :
| interface_ansi_header [ timeunits_declaration ] { non_port_interface_item }
[ interface_identifier ]
endinterface :
| { attribute_instance } interface_identifier
interface ( .* ) ;
[ timeunits_declaration ] { interface_item }
[ interface_identifier ]
endinterface :
| interface_nonansi_header
extern
| interface_ansi_header
extern
interface_nonansi_header ::=
{ attribute_instance } [ lifetime ] interface_identifier
interface
{ package_import_declaration } [ parameter_port_list ] list_of_ports
;
interface_ansi_header ::=
{attribute_instance } [ lifetime ] interface_identifier
interface
{ package_import_declaration }1 [ parameter_port_list ] [ list_of_port_declarations ]
;
interface_item ::= // from A.1.6
port_declaration
;
| non_port_interface_item
non_port_interface_item ::=
generate_region
| interface_or_generate_item
| program_declaration
| modport_declaration
| interface_declaration
| timeunits_declaration3
modport_declaration ::= modport_item { modport_item } // from A.2.9
modport , ;
modport_item ::= modport_identifier modport_ports_declaration { modport_ports_declaration }
( , )
modport_ports_declaration ::=
{ attribute_instance } modport_simple_ports_declaration
| { attribute_instance } modport_tf_ports_declaration
| { attribute_instance } modport_clocking_declaration
modport_clocking_declaration ::= clocking_identifier
clocking
modport_simple_ports_declaration ::=
port_direction modport_simple_port { modport_simple_port }
,
modport_simple_port ::=
port_identifier
| port_identifier [ expression ]
. ( )
modport_tf_ports_declaration ::=
import_export modport_tf_port { modport_tf_port }
,
modport_tf_port ::=
749
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
method_prototype
| tf_identifier
import_export ::= |
import export
interface_instantiation ::= // from A.4.1.2
interface_identifier [ parameter_value_assignment ] hierarchical_instance { hierarchical_instance }
, ;
1) A package_import_declaration in a module_ansi_header, interface_ansi_header, or program_ansi_header shall be
followed by a parameter_port_list or list_of_port_declarations, or both.
3) A timeunits_declaration shall be legal as a non_port_module_item, non_port_interface_item,
non_port_program_item, or package_item only if it repeats and matches a previous timeunits_declaration within
the same time scope.
Syntax25-1—Interface syntax (excerpt from AnnexA)
The interface construct provides a new hierarchical structure. It can contain smaller interfaces and can be
passed through ports.
The aim of interfaces is to encapsulate communication. At the lower level, this means bundling variables
and nets in interfaces and can impose access restrictions with port directions in modports. The modules can
be made generic so that the interfaces can be changed. The following examples show these features. At a
higher level of abstraction, communication can be done by tasks and functions. Interfaces can include
subroutine definitions or just subroutine prototypes, with the definition in one module and the call in another
(see 25.7 and 25.7.3).
A simple interface declaration is as follows (see Syntax25-1 for the complete syntax):
interface identifier;
...
interface_items
...
endinterface [ : identifier ]
An interface can be instantiated hierarchically like a module, with or without ports. For example:
myinterface #(100) scalar1(), vector[9:0]();
In this example, 11 instances of the interface of type have been instantiated, and the first
myinterface
parameter within each interface is changed to 100. One instance is instantiated with the name
myinterface
, and an array of 10 interfaces are instantiated with instance names to
scalar1 myinterface vector[9]
.
vector[0]
Interfaces can be declared and instantiated in modules (either flat or hierarchical), but modules can neither
be declared nor instantiated in interfaces. In contrast to modules (see 23.3) and programs (see 24.3),
interfaces are never implicitly instantiated.
A within an instance whose port actuals refer to an arrayed interface shall not modify a parameter
defparam
outside the hierarchy of such an instance. If the actual of an interface port connection is a hierarchical
reference to an interface or a modport of a hierarchically referenced interface, the hierarchical reference
shall refer to an interface instance and shall not resolve through an arrayed instance or a block.
generate
The simplest use of an interface is to bundle wires, as illustrated in the following examples.
750
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
25.3.1 Example without using interfaces
This example shows a simple bus implemented without interfaces.
module memMod( input logic req,
logic clk,
logic start,
logic [1:0] mode,
logic [7:0] addr,
inout wire [7:0] data,
output bit gnt,
bit rdy );
logic avail;
...
endmodule
module cpuMod(
input logic clk,
logic gnt,
logic rdy,
inout wire [7:0] data,
output logic req,
logic start,
logic [7:0] addr,
logic [1:0] mode );
...
endmodule
module top;
logic req, gnt, start, rdy;
logic clk = 0;
logic [1:0] mode;
logic [7:0] addr;
wire [7:0] data;
memMod mem(req, clk, start, mode, addr, data, gnt, rdy);
cpuMod cpu(clk, gnt, rdy, data, req, start, addr, mode);
endmodule
25.3.2 Interface example using a named bundle
The simplest form of a SystemVerilog interface is a bundled collection of variables or nets. When an
interface is referenced as a port, the variables and nets in it are assumed to have and access,
ref inout
respectively. The following interface example shows the basic syntax for defining, instantiating, and
connecting an interface. Usage of the SystemVerilog interface capability can significantly reduce the
amount of code required to model port connections.
interface simple_bus; // Define the interface
logic req, gnt;
logic [7:0] addr, data;
logic [1:0] mode;
logic start, rdy;
endinterface: simple_bus
module memMod(simple_bus a, // Access the simple_bus interface
input logic clk);
751
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
logic avail;
// When memMod is instantiated in module top, a.req is the req
// signal in the sb_intf instance of the 'simple_bus' interface
always @(posedge clk) a.gnt <= a.req & avail;
endmodule
module cpuMod(simple_bus b, input logic clk);
...
endmodule
module top;
logic clk = 0;
simple_bus sb_intf(); // Instantiate the interface
memMod mem(sb_intf, clk); // Connect the interface to the module instance
cpuMod cpu(.b(sb_intf), .clk(clk)); // Either by position or by name
endmodule
In the preceding example, if the same identifier, , had been used to name the
sb_intf simple_bus
interface in the and module headers, then implicit port connections also could have been
memMod cpuMod
used to instantiate the and modules into the top module, as follows:
memMod cpuMod
module memMod (simple_bus sb_intf, input logic clk);
...
endmodule
module cpuMod (simple_bus sb_intf, input logic clk);
...
endmodule
module top;
logic clk = 0;
simple_bus sb_intf();
memMod mem (.*); // implicit port connections
cpuMod cpu (.*); // implicit port connections
endmodule
25.3.3 Interface example using a generic bundle
A module header can be created with an unspecified interface reference as a placeholder for an interface to
be selected when the module itself is instantiated. The unspecified interface is referred to as a generic
interface reference.
This generic interface reference can only be declared using the ANSI style list_of_port_declarations syntax
(see 23.2.2.2). It shall be illegal to declare such a generic interface reference using the non-ANSI style
list_of_ports syntax (see 23.2.2.1).
The following interface example shows how to specify a generic interface reference in a module definition:
// memMod and cpuMod can use any interface
module memMod (interface a, input logic clk);
...
endmodule
752
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
module cpuMod(interface b, input logic clk);
...
endmodule
interface simple_bus; // Define the interface
logic req, gnt;
logic [7:0] addr, data;
logic [1:0] mode;
logic start, rdy;
endinterface: simple_bus
module top;
logic clk = 0;
simple_bus sb_intf(); // Instantiate the interface
// Reference the sb_intf instance of the simple_bus
// interface from the generic interfaces of the
// memMod and cpuMod modules
memMod mem (.a(sb_intf), .clk(clk));
cpuMod cpu (.b(sb_intf), .clk(clk));
endmodule
An implicit port cannot be used to reference a generic interface. A named port shall be used to reference a
generic interface, as follows:
module memMod (interface a, input logic clk);
...
endmodule
module cpuMod (interface b, input logic clk);
...
endmodule
module top;
logic clk = 0;
simple_bus sb_intf();
memMod mem (.*, .a(sb_intf)); // partial implicit port connections
cpuMod cpu (.*, .b(sb_intf)); // partial implicit port connections
endmodule
25.4 Ports in interfaces
One limitation of simple interfaces is that the nets and variables declared within the interface are only used
to connect to a port with the same nets and variables. To share an external net or variable, one that makes a
connection from outside the interface as well as forming a common connection to all module ports that
instantiate the interface, an interface port declaration is required. The difference between nets or variables in
the interface port list and other nets or variables within the interface is that only those in the port list can be
connected externally by name or position when the interface is instantiated. Interface port declaration syntax
and semantics are the same as those of modules (see 23.2.2).
753
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
interface i1 (input a, output b, inout c);
wire d;
endinterface
The wires , , and can be individually connected to the interface and thus shared with other interfaces.
a b c
The following example shows how to specify an interface with inputs, allowing a wire to be shared between
two instances of the interface:
interface simple_bus (input logic clk); // Define the interface
logic req, gnt;
logic [7:0] addr, data;
logic [1:0] mode;
logic start, rdy;
endinterface: simple_bus
module memMod(simple_bus a); // Uses just the interface
logic avail;
always @(posedge a.clk) // the clk signal from the interface
a.gnt <= a.req & avail; // a.req is in the 'simple_bus' interface
endmodule
module cpuMod(simple_bus b);
...
endmodule
module top;
logic clk = 0;
simple_bus sb_intf1(clk); // Instantiate the interface
simple_bus sb_intf2(clk); // Instantiate the interface
memMod mem1(.a(sb_intf1)); // Reference simple_bus 1 to memory 1
cpuMod cpu1(.b(sb_intf1));
memMod mem2(.a(sb_intf2)); // Reference simple_bus 2 to memory 2
cpuMod cpu2(.b(sb_intf2));
endmodule
In the preceding example, the instantiated interface names do not match the interface names used in the
and modules; therefore, implicit port connections cannot be used for this example.
memMod cpuMod
25.5 Modports
To restrict interface access within a module, there are lists with directions declared within the
modport
interface. The keyword indicates that the directions are declared as if inside the module.
modport
interface i2;
wire a, b, c, d;
modport master (input a, b, output c, d);
modport slave (output a, b, input c, d);
endinterface
754
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In this example, the list name ( or ) can be specified in the module header, where
modport master slave
the interface name selects an interface and the name selects the appropriate directional information
modport
for the interface signals accessed in the module header.
module m (i2.master i);
...
endmodule
module s (i2.slave i);
...
endmodule
module top;
i2 i();
m u1(.i(i));
s u2(.i(i));
endmodule
The syntax of gives a local name for a hierarchical
interface_name.modport_namereference_name
reference. This technique can be generalized to any interface with a given modport name by writing
. .
interfacemodport_namereference_name
The list name ( or ) can also be specified in the port connection with the module
modport master slave
instance, where the name is hierarchical from the interface instance.
modport
module m (i2 i);
...
endmodule
module s (i2 i);
...
endmodule
module top;
i2 i();
m u1(.i(i.master));
s u2(.i(i.slave));
endmodule
If a port connection specifies a list name in both the module instance and module header
modport
declaration, then the two list names shall be identical.
modport
All of the names used in a declaration shall be declared by the same interface as the modport itself.
modport
In particular, the names used shall not be those declared by another enclosing interface, and a modport
declaration shall not implicitly declare new ports.
The following interface declarations would be illegal:
interface i;
wire x, y;
interface illegal_i;
wire a, b, c, d;
// x, y not declared by this interface
modport master(input a, b, x, output c, d, y);
755
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
modport slave(output a, b, x, input c, d, y);
endinterface : illegal_i
endinterface : i
interface illegal_i;
// a, b, c, d not declared by this interface
modport master(input a, b, output c, d);
modport slave(output a, b, input c, d);
endinterface : illegal_i
Adding modports to an interface does not require that any of the modports be used when the interface is
used. If no is specified in the module header or in the port connection, then all the nets and
modport
variables in the interface are accessible with direction or , as in the preceding examples.
inout ref
25.5.1 Example of named port bundle
This interface example shows how to use modports to control signal directions as in port declarations. It uses
the modport name in the module definition.
interface simple_bus (input logic clk); // Define the interface
logic req, gnt;
logic [7:0] addr, data;
logic [1:0] mode;
logic start, rdy;
modport slave (input req, addr, mode, start, clk,
output gnt, rdy,
ref data);
modport master(input gnt, rdy, clk,
output req, addr, mode, start,
ref data);
endinterface: simple_bus
module memMod (simple_bus.slave a); // interface name and modport name
logic avail;
always @(posedge a.clk) // the clk signal from the interface
a.gnt <= a.req & avail; // the gnt and req signal in the interface
endmodule
module cpuMod (simple_bus.master b);
...
endmodule
module top;
logic clk = 0;
simple_bus sb_intf(clk); // Instantiate the interface
initial repeat(10) #10 clk++;
memMod mem(.a(sb_intf)); // Connect the interface to the module instance
cpuMod cpu(.b(sb_intf));
endmodule
756
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
25.5.2 Example of connecting port bundle
This interface example shows how to use modports to restrict interface signal access and control their
direction. It uses the modport name in the module instantiation.
interface simple_bus (input logic clk); // Define the interface
logic req, gnt;
logic [7:0] addr, data;
logic [1:0] mode;
logic start, rdy;
modport slave (input req, addr, mode, start, clk,
output gnt, rdy,
ref data);
modport master(input gnt, rdy, clk,
output req, addr, mode, start,
ref data);
endinterface: simple_bus
module memMod(simple_bus a); // Uses just the interface name
logic avail;
always @(posedge a.clk) // the clk signal from the interface
a.gnt <= a.req & avail; // the gnt and req signal in the interface
endmodule
module cpuMod(simple_bus b);
...
endmodule
module top;
logic clk = 0;
simple_bus sb_intf(clk); // Instantiate the interface
initial repeat(10) #10 clk++;
memMod mem(sb_intf.slave); // Connect the modport to the module instance
cpuMod cpu(sb_intf.master);
endmodule
25.5.3 Example of connecting port bundle to generic interface
This interface example shows how to use modports to control signal directions. It shows the use of the
keyword in the module definition. The actual interface and modport are specified in the module
interface
instantiation.
interface simple_bus (input logic clk); // Define the interface
logic req, gnt;
logic [7:0] addr, data;
logic [1:0] mode;
logic start, rdy;
modport slave (input req, addr, mode, start, clk,
output gnt, rdy,
ref data);
757
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
modport master(input gnt, rdy, clk,
output req, addr, mode, start,
ref data);
endinterface: simple_bus
module memMod(interface a); // Uses just the interface
logic avail;
always @(posedge a.clk) // the clk signal from the interface
a.gnt <= a.req & avail; // the gnt and req signal in the interface
endmodule
module cpuMod(interface b);
...
endmodule
module top;
logic clk = 0;
simple_bus sb_intf(clk); // Instantiate the interface
memMod mem(sb_intf.slave); // Connect the modport to the module instance
cpuMod cpu(sb_intf.master);
endmodule
25.5.4 Modport expressions
A modport expression allows elements of arrays and structures, concatenations of elements, and assignment
pattern expressions of elements declared in an interface to be included in a modport list. This modport
expression is explicitly named with a port identifier, visible only through the modport connection.
Like explicitly named ports in a module port declaration, port identifiers exist in their own name space for
each modport list. When a modport item is just a simple port identifier, that identifier is used as both a
reference to an interface item and a port identifier. Once a port identifier has been defined, there shall not be
another port definition with this same name.
For example:
interface I;
logic [7:0] r;
const int x=1;
bit R;
modport A (output .P(r[3:0]), input .Q(x), R);
modport B (output .P(r[7:4]), input .Q(2), R);
endinterface
module M ( interface i);
initial i.P = i.Q;
endmodule
module top;
I i1 ();
M u1 (i1.A);
M u2 (i1.B);
initial #1 $display("%b", i1.r); // displays 00100001
endmodule
758
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The self-determined type of the port expression becomes the type for the port. The port expression shall not
be considered an assignment-like context. The port expression shall resolve to a legal expression for the type
of module port (see 23.3.3). In the preceding example, the port could not be an output or inout because the
Q
port expression is a constant. The port expression is optional because ports can be defined that do not
connect to anything internal to the port.
25.5.5 Clocking blocks and modports
The construct can also be used to specify the direction of blocks declared within an
modport clocking
interface. As with other declarations, the directions of the block are those seen from the
modport clocking
module in which the interface becomes a port. The syntax for this is shown in Syntax25-2.
modport_declaration ::= modport_item { modport_item } // from A.2.9
modport , ;
modport_item ::= modport_identifier modport_ports_declaration { modport_ports_declaration }
( , )
modport_ports_declaration ::=
{ attribute_instance } modport_simple_ports_declaration
| { attribute_instance } modport_tf_ports_declaration
| { attribute_instance } modport_clocking_declaration
modport_clocking_declaration ::= clocking_identifier
clocking
Syntax25-2—Modport clocking declaration syntax (excerpt from AnnexA)
All of the blocks used in a declaration shall be declared by the same interface as the
clocking modport
modport itself. Like all declarations, the direction of the clocking signals are those seen from the
modport
module in which the interface becomes a port. The following example shows how modports can be used to
create both synchronous as well as asynchronous ports. When used in conjunction with virtual interfaces
(see 25.9.2), these constructs facilitate the creation of abstract synchronous models.
interface A_Bus( input logic clk );
wire req, gnt;
wire [7:0] addr, data;
clocking sb @(posedge clk);
input gnt;
output req, addr;
inout data;
property p1; req ##[1:3] gnt; endproperty
endclocking
modport DUT ( input clk, req, addr, // Device under test modport
output gnt,
inout data );
modport STB ( clocking sb ); // synchronous testbench modport
modport TB ( input gnt, // asynchronous testbench modport
output req, addr,
inout data );
endinterface
The preceding interface can then be instantiated as follows:
A_Bus
759
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
module dev1(A_Bus.DUT b); // Some device: Part of the design
...
endmodule
module dev2(A_Bus.DUT b); // Some device: Part of the design
...
endmodule
module top;
logic clk;
A_Bus b1( clk );
A_Bus b2( clk );
dev1 d1( b1 );
dev2 d2( b2 );
T tb( b1, b2 );
endmodule
program T (A_Bus.STB b1, A_Bus.STB b2 ); // testbench: 2 synchronous ports
assert property (b1.sb.p1); // assert property from within program
initial begin
b1.sb.req <= 1;
wait( b1.sb.gnt == 1 );
...
b1.sb.req <= 0;
b2.sb.req <= 1;
wait( b2.sb.gnt == 1 );
...
b2.sb.req <= 0;
end
endprogram
This example shows the program block using the synchronous interface designated by the clocking modport
of interface ports and . In addition to the procedural drives and samples of the block
b1 b2 clocking
signals, the program asserts the property of one of its interfaces .
p1 b1
25.6 Interfaces and specify blocks
The block is used to describe various paths across a module and perform timing checks to verify
specify
that events occurring at the module inputs satisfy the timing constraints of the device described by the
module. The module paths are from module input ports to output ports, and the timing checks are relative to
the module inputs. The block refers to these ports as terminal descriptor. Module ports can
specify inout
function as either an input or output terminal. When one of the port instances is an interface, each signal in
the interface becomes an available terminal, with the default direction as defined for an interface or as
restricted by a modport. A port cannot be used as a terminal in a block.
ref specify
The following shows an example of using interfaces together with a block:
specify
interface itf;
logic c,q,d;
modport flop (input c,d, output q);
endinterface
760
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
module dtype (itf.flop ch);
always_ff @(posedge ch.c) ch.q <= ch.d;
specify
( posedge ch.c => (ch.q+:ch.d)) = (5,6);
$setup( ch.d, posedge ch.c, 1 );
endspecify
endmodule
25.7 Tasks and functions in interfaces
Subroutines (tasks and functions) can be defined within an interface, or they can be defined within one or
more of the modules connected. This allows a more abstract level of modeling. For example, “read” and
“write” can be defined as tasks, without reference to any wires, and the master module can merely call these
tasks. In a , these tasks are declared as tasks.
modport import
A function prototype specifies the types and directions of the arguments and the return value of a function
that is defined elsewhere. Similarly, a task prototype specifies the types and directions of the arguments of a
task that is defined elsewhere. In a modport, the and constructs can either use subroutine
import export
prototypes or use just the identifiers. The only exceptions are when a modport is used to import a subroutine
from another module and when default argument values or argument binding by name is used, in which
cases a full prototype shall be used.
The number and types of arguments in a prototype shall match the argument types in the subroutine
declaration. The rules for type matching are described in 6.22.1. If a default argument value is needed in a
subroutine call, it shall be specified in the prototype. If an argument has default values specified in both the
prototype and the declaration, the specified values need not be the same, but the default value used shall be
the one specified in the prototype. Formal argument names in a prototype shall be optional unless default
argument values or argument binding by name is used or additional unpacked dimensions are declared. The
formal argument names in the prototype shall be the same as the formal argument names in a declaration.
If a module is connected to a modport containing an exported subroutine and the module does not define that
subroutine, then an elaboration error shall occur. Similarly, if the modport contains an exported subroutine
prototype and the subroutine defined in the module does not exactly match that prototype, then an
elaboration error shall occur.
If the subroutines are defined in a module using a hierarchical name, they shall also be declared as
extern
in the interface or as in a .
export modport
Tasks (not functions) can be defined in a module that is instantiated twice, e.g., two memories driven from
the same CPU. Such multiple task definitions are allowed by an declaration in the
extern forkjoin
interface.
25.7.1 Example of using tasks in interface
interface simple_bus (input logic clk); // Define the interface
logic req, gnt;
logic [7:0] addr, data;
logic [1:0] mode;
logic start, rdy;
task masterRead(input logic [7:0] raddr); // masterRead method
// ...
endtask: masterRead
761
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
task slaveRead; // slaveRead method
// ...
endtask: slaveRead
endinterface: simple_bus
module memMod(interface a); // Uses any interface
logic avail;
always @(posedge a.clk) // the clk signal from the interface
a.gnt <= a.req & avail // the gnt and req signals in the interface
always @(a.start)
a.slaveRead;
endmodule
module cpuMod(interface b);
enum {read, write} instr;
logic [7:0] raddr;
always @(posedge b.clk)
if (instr == read)
b.masterRead(raddr); // call the Interface method
...
endmodule
module top;
logic clk = 0;
simple_bus sb_intf(clk); // Instantiate the interface
memMod mem(sb_intf);
cpuMod cpu(sb_intf);
endmodule
25.7.2 Example of using tasks in modports
This interface example shows how to use modports to control signal directions and task access in a full read/
write interface.
interface simple_bus (input logic clk); // Define the interface
logic req, gnt;
logic [7:0] addr, data;
logic [1:0] mode;
logic start, rdy;
modport slave (input req, addr, mode, start, clk,
output gnt, rdy,
ref data,
import slaveRead,
slaveWrite);
// import into module that uses the modport
modport master(input gnt, rdy, clk,
output req, addr, mode, start,
ref data,
import masterRead,
masterWrite);
762
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
// import into module that uses the modport
task masterRead(input logic [7:0] raddr); // masterRead method
// ...
endtask
task slaveRead; // slaveRead method
// ...
endtask
task masterWrite(input logic [7:0] waddr);
//...
endtask
task slaveWrite;
//...
endtask
endinterface: simple_bus
module memMod(interface a); // Uses just the interface
logic avail;
always @(posedge a.clk) // the clk signal from the interface
a.gnt <= a.req & avail; // the gnt and req signals in the interface
always @(a.start)
if (a.mode[0] == 1'b0)
a.slaveRead;
else
a.slaveWrite;
endmodule
module cpuMod(interface b);
enum {read, write} instr;
logic [7:0] raddr = $random();
always @(posedge b.clk)
if (instr == read)
b.masterRead(raddr); // call the Interface method
// ...
else
b.masterWrite(raddr);
endmodule
module omniMod( interface b);
//...
endmodule: omniMod
module top;
logic clk = 0;
simple_bus sb_intf(clk); // Instantiate the interface
memMod mem(sb_intf.slave); // only has access to the slave tasks
cpuMod cpu(sb_intf.master); // only has access to the master tasks
omniMod omni(sb_intf); // has access to all master and slave tasks
endmodule
763
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
25.7.3 Example of exporting tasks and functions
This interface example shows how to define tasks in one module and call them in another, using modports to
control task access.
interface simple_bus (input logic clk); // Define the interface
logic req, gnt;
logic [7:0] addr, data;
logic [1:0] mode;
logic start, rdy;
modport slave( input req, addr, mode, start, clk,
output gnt, rdy,
ref data,
export Read,
Write);
// export from module that uses the modport
modport master(input gnt, rdy, clk,
output req, addr, mode, start,
ref data,
import task Read(input logic [7:0] raddr),
task Write(input logic [7:0] waddr));
// import requires the full task prototype
endinterface: simple_bus
module memMod(interface a); // Uses just the interface keyword
logic avail;
task a.Read; // Read method
avail = 0;
...
avail = 1;
endtask
task a.Write;
avail = 0;
...
avail = 1;
endtask
endmodule
module cpuMod(interface b);
enum {read, write} instr;
logic [7:0] raddr;
always @(posedge b.clk)
if (instr == read)
b.Read(raddr); // call the slave method via the interface
...
else
b.Write(raddr);
endmodule
module top;
logic clk = 0;
764
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
simple_bus sb_intf(clk); // Instantiate the interface
memMod mem(sb_intf.slave); // exports the Read and Write tasks
cpuMod cpu(sb_intf.master); // imports the Read and Write tasks
endmodule
25.7.4 Example of multiple task exports
It is normally an error for more than one module to export the same task name. However, several instances
of the same modport type can be connected to an interface, such as memory modules in the previous
example. So that these can still export their read and write tasks, the tasks shall be declared in the interface
using the keywords.
externforkjoin
The call to in the following example behaves as follows:
extern forkjoin task countslaves( );
fork
top.mem1.a.countslaves;
top.mem2.a.countslaves;
join
For a read task, only one module should actively respond to the task call, e.g., the one containing the
appropriate address. The tasks in the other modules should return with no effect. Only then should the active
task write to the result variables.
Unlike tasks, multiple export of functions is not allowed because they always write to the result.
The effect of a on an task is as follows:
disable extern forkjoin
— If the task is referenced via the interface instance, all task calls shall be disabled.
— If the task is referenced via the module instance, only the task call to that module instance shall be
disabled.
— If an interface contains an task and no module connected to that interface
extern forkjoin
defines the task, then any call to that task shall report a run-time error and return immediately with
no effect.
This interface example shows how to define tasks in more than one module and call them in another using
. The multiple task export mechanism can also be used to count the instances of a
extern forkjoin
particular modport that are connected to each interface instance.
interface simple_bus (input logic clk); // Define the interface
logic req, gnt;
logic [7:0] addr, data;
logic [1:0] mode;
logic start, rdy;
int slaves = 0;
// tasks executed concurrently as a fork-join block
extern forkjoin task countSlaves();
extern forkjoin task Read (input logic [7:0] raddr);
extern forkjoin task Write (input logic [7:0] waddr);
modport slave (input req,addr, mode, start, clk,
output gnt, rdy,
ref data, slaves,
export Read, Write, countSlaves);
// export from module that uses the modport
765
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
modport master ( input gnt, rdy, clk,
output req, addr, mode, start,
ref data,
import task Read(input logic [7:0] raddr),
task Write(input logic [7:0] waddr));
// import requires the full task prototype
initial begin
slaves = 0;
countSlaves;
$display ("number of slaves = %d", slaves);
end
endinterface: simple_bus
module memMod #(parameter int minaddr=0, maxaddr=0;) (interface a);
logic avail = 1;
logic [7:0] mem[255:0];
task a.countSlaves();
a.slaves++;
endtask
task a.Read(input logic [7:0] raddr); // Read method
if (raddr >= minaddr && raddr <= maxaddr) begin
avail = 0;
#10 a.data = mem[raddr];
avail = 1;
end
endtask
task a.Write(input logic [7:0] waddr); // Write method
if (waddr >= minaddr && waddr <= maxaddr) begin
avail = 0;
#10 mem[waddr] = a.data;
avail = 1;
end
endtask
endmodule
module cpuMod(interface b);
typedef enum {read, write} instr;
instr inst;
logic [7:0] raddr;
integer seed;
always @(posedge b.clk) begin
inst = instr'($dist_uniform(seed, 0, 1));
raddr = $dist_uniform(seed, 0, 3);
if (inst == read) begin
$display("%t begin read %h @ %h", $time, b.data, raddr);
callr:b.Read(raddr);
$display("%t end read %h @ %h", $time, b.data, raddr);
end
else begin
$display("%t begin write %h @ %h", $time, b.data, raddr);
b.data = raddr;
callw:b.Write(raddr);
766
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
$display("%t end write %h @ %h", $time, b.data, raddr);
end
end
endmodule
module top;
logic clk = 0;
function void interrupt();
disable mem1.a.Read; // task via module instance
disable sb_intf.Write; // task via interface instance
if (mem1.avail == 0) $display ("mem1 was interrupted");
if (mem2.avail == 0) $display ("mem2 was interrupted");
endfunction
always #5 clk++;
initial begin
#28 interrupt();
#10 interrupt();
#100 $finish;
end
simple_bus sb_intf(clk);
memMod #(0, 127) mem1(sb_intf.slave);
memMod #(128, 255) mem2(sb_intf.slave);
cpuMod cpu(sb_intf.master);
endmodule
25.8 Parameterized interfaces
Interface definitions can take advantage of parameters and parameter redefinition in the same manner as
module definitions. The following example shows how to use parameters in interface definitions.
interface simple_bus #(AWIDTH = 8, DWIDTH = 8)
(input logic clk); // Define the interface
logic req, gnt;
logic [AWIDTH-1:0] addr;
logic [DWIDTH-1:0] data;
logic [1:0] mode;
logic start, rdy;
modport slave( input req, addr, mode, start, clk,
output gnt, rdy,
ref data,
import task slaveRead,
task slaveWrite);
// import into module that uses the modport
modport master(input gnt, rdy, clk,
output req, addr, mode, start,
ref data,
import task masterRead(input logic [AWIDTH-1:0] raddr),
task masterWrite(input logic [AWIDTH-1:0] waddr));
// import requires the full task prototype
task masterRead(input logic [AWIDTH-1:0] raddr); // masterRead method
767
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
...
endtask
task slaveRead; // slaveRead method
...
endtask
task masterWrite(input logic [AWIDTH-1:0] waddr);
...
endtask
task slaveWrite;
...
endtask
endinterface: simple_bus
module memMod(interface a); // Uses just the interface keyword
logic avail;
always @(posedge a.clk) // the clk signal from the interface
a.gnt <= a.req & avail; //the gnt and req signals in the interface
always @(a.start)
if (a.mode[0] == 1'b0)
a.slaveRead;
else
a.slaveWrite;
endmodule
module cpuMod(interface b);
enum {read, write} instr;
logic [7:0] raddr;
always @(posedge b.clk)
if (instr == read)
b.masterRead(raddr); // call the Interface method
// ...
else
b.masterWrite(raddr);
endmodule
module top;
logic clk = 0;
simple_bus sb_intf(clk); // Instantiate default interface
simple_bus #(.DWIDTH(16)) wide_intf(clk); // Interface with 16-bit data
initial repeat(10) #10 clk++;
memMod mem(sb_intf.slave); // only has access to the slaveRead task
cpuMod cpu(sb_intf.master); // only has access to the masterRead task
memMod memW(wide_intf.slave); // 16-bit wide memory
cpuMod cpuW(wide_intf.master); // 16-bit wide cpu
endmodule
768
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
25.9 Virtual interfaces
Virtual interfaces provide a mechanism for separating abstract models and test programs from the actual
signals that make up the design. A virtual interface allows the same subprogram to operate on different
portions of a design and to dynamically control the set of signals associated with the subprogram. Instead of
referring to the actual set of signals directly, users are able to manipulate a set of virtual signals. Changes to
the underlying design do not require the code using virtual interfaces to be rewritten. By abstracting the
connectivity and functionality of a set of blocks, virtual interfaces promote code reuse.
A virtual interface is a variable that represents an interface instance. The syntax to declare a virtual interface
variable is given in Syntax25-3.
data_declaration ::= // from A.2.1.3
[ ] [ ] [ lifetime ] data_type_or_implicit list_of_variable_decl_assignments 10
const var ;
| ...
data_type ::= // from A.2.2.1
...
| [ ] interface_identifier [ parameter_value_assignment ] [ modport_identifier ]
virtual interface .
10) In a data_declaration that is not within a procedural context, it shall be illegal to use the keyword. In
automatic
a data_declaration, it shall be illegal to omit the explicit data_type before a list_of_variable_decl_assignments
unless the keyword is used.
var
Syntax25-3—Virtual interface declaration syntax (excerpt from AnnexA)
Virtual interface variables may be passed as arguments to tasks, functions, or methods. A single virtual
interface variable can thus represent different interface instances at different times throughout the
simulation. A virtual interface shall be initialized before referencing a component of the virtual interface; it
has the value before it is initialized. Attempting to use a virtual interface shall result in a fatal
null null
run-time error.
The type of an interface shall include actual parameters, default or overridden, used in the instantiation of an
interface or the declaration of a virtual interface variable. The actual values and types of those parameters
shall match for an interface and virtual interface to be of the same type and to be assignment compatible (see
6.22.3). A virtual interface declaration may select a modport of an interface in which case the modport is
also part of its type. An interface instance or virtual interface with no modport selected may be assigned to a
virtual interface with a modport selected.
It shall be illegal to assign an interface instance to a virtual interface if there is a to a parameter of
defparam
that interface instance or interface hierarchy and that statement is declared outside the interface.
defparam
Although an interface may contain hierarchical references to objects outside its body or ports that reference
other interfaces, it shall be illegal to use an interface containing those references in the declaration of a
virtual interface.
Only the following operations are directly allowed on virtual interface variables:
— Assignment ( ) to the following:
=
• Another virtual interface of the same type
• An interface instance of the same type
• The special constant
null
769
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Equality ( ) and inequality ( ) with the following:
== !=
• Another virtual interface of the same type
• An interface instance of the same type
• The special constant
null
Virtual interfaces shall not be used as ports, interface items, or as members of unions.
Once a virtual interface has been initialized, all the components of the underlying interface instance are
directly available to the virtual interface via the dot notation. These components can only be used in
procedural statements; they cannot be used in continuous assignments or sensitivity lists. In order for a net to
be driven via a virtual interface, the interface itself must provide a procedural means to do so. This can be
accomplished either via a block or by including a driver that is updated by a continuous
clocking
assignment from a variable within the interface.
Virtual interfaces can be declared as class properties, which can be initialized procedurally or by an
argument to . This allows the same virtual interface to be used in different classes. The following
new()
example shows how the same transactor class can be used to interact with various different devices:
interface SBus; // A Simple bus interface
logic req, grant;
logic [7:0] addr, data;
endinterface
class SBusTransactor; // SBus transactor class
virtual SBus bus; // virtual interface of type SBus
function new( virtual SBus s );
bus = s; // initialize the virtual interface
endfunction
task request(); // request the bus
bus.req <= 1'b1;
endtask
task wait_for_bus(); // wait for the bus to be granted
@(posedge bus.grant);
endtask
endclass
module devA( SBus s ) ... endmodule // devices that use SBus
module devB( SBus s ) ... endmodule
module top;
SBus s[1:4] (); // instantiate 4 interfaces
devA a1( s[1] ); // instantiate 4 devices
devB b1( s[2] );
devA a2( s[3] );
devB b2( s[4] );
initial begin
SBusTransactor t[1:4]; // create 4 bus-transactors and bind
t[1] = new( s[1] );
t[2] = new( s[2] );
770
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
t[3] = new( s[3] );
t[4] = new( s[4] );
// test t[1:4]
end
endmodule
In the preceding example, the transaction class is a simple reusable component. It is
SbusTransctor
written without any global or hierarchical references and is unaware of the particular device with which it
will interact. Nevertheless, the class can interact with any number of devices (four in the example) that
adhere to the interface’s protocol.
An interface instance, or virtual interface, with no modport selected may be assigned to a virtual interface
with a modport selected.
interface PBus #(parameter WIDTH=8); // A parameterized bus interface
logic req, grant;
logic [WIDTH-1:0] addr, data;
modport phy(input addr, ref data);
endinterface
module top;
PBus #(16) p16();
PBus #(32) p32();
virtual PBus v8; // legal declaration, but no legal assignments
virtual PBus #(35) v35; // legal declaration, but no legal assignments
virtual PBus #(16) v16;
virtual PBus #(16).phy v16_phy;
virtual PBus #(32) v32;
virtual PBus #(32).phy v32_phy;
initial begin
v16 = p16; // legal – parameter values match
v32 = p32; // legal – parameter values match
v16 = p32; // illegal – parameter values don't match
v16 = v32; // illegal – parameter values don't match
v16_phy = v16; // legal assignment from no selected modport to
// selected modport
v16 = v16_phy; // illegal assignment from selected modport to
// no selected modport
v32_phy = p32; // legal assignment from no selected modport to
// selected modport
v32 = p32.phy; // illegal assignment from selected modport to
// no selected modport
end
endmodule
25.9.1 Virtual interfaces and clocking blocks
Interfaces and blocks can be combined to represent the interconnect between synchronous
clocking
blocks. Moreover, because blocks provide a procedural mechanism to assign values to both nets
clocking
and variables, they are ideally suited to be used by virtual interfaces. For example:
interface SyncBus( input logic clk );
wire a, b, c;
clocking sb @(posedge clk);
input a;
output b;
inout c;
771
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
endclocking
endinterface
typedef virtual SyncBus VI; // A virtual interface type
task do_it( VI v ); // handles any SyncBus via clocking sb
if( v.sb.a == 1 )
v.sb.b <= 0;
else
v.sb.c <= ##1 1;
endtask
In the preceding example, interface includes a block, which is used by task to
SyncBus clocking do_it
provide synchronous access to the interface’s signals: , , and . A change to the storage type of the
a b c
interface signals (from net to variable and vice versa) requires no changes to the task. The interfaces can be
instantiated as follows:
module top;
logic clk;
SyncBus b1( clk );
SyncBus b2( clk );
initial begin
VI v[2] = '{ b1, b2 };
repeat( 20 )
do_it( v[ $urandom_range( 0, 1 ) ] );
end
endmodule
This top module shows how a virtual interface can be used to randomly select among a set of interfaces to be
manipulated, in this case by the task.
do_it
25.9.2 Virtual interface modports and clocking blocks
As shown in the previous example, once a virtual interface is declared, its block can be
clocking
referenced using dot notation. However, this only works for interfaces with no modports. Typically, a DUT
and its testbench exhibit modport direction. This common case can be handled by including the clocking in
the corresponding modport as described in 25.5.5.
The following example shows how modports used in conjunction with virtual interfaces facilitate the
creation of abstract synchronous models.
interface A_Bus( input logic clk );
wire req, gnt;
wire [7:0] addr, data;
clocking sb @(posedge clk);
input gnt;
output req, addr;
inout data;
property p1; req ##[1:3] gnt; endproperty
endclocking
772
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
modport DUT ( input clk, req, addr, // Device under test modport
output gnt,
inout data );
modport STB ( clocking sb ); // synchronous testbench modport
modport TB ( input gnt, // asynchronous testbench modport
output req, addr,
inout data );
endinterface
The preceding interface can then be instantiated as follows:
A_Bus
module dev1(A_Bus.DUT b); // Some device: Part of the design
...
endmodule
module dev2(A_Bus.DUT b); // Some device: Part of the design
...
endmodule
program T (A_Bus.STB b1, A_Bus.STB b2 ); // Testbench: 2 synchronous ports
...
endprogram
module top;
logic clk;
A_Bus b1( clk );
A_Bus b2( clk );
dev1 d1( b1 );
dev2 d2( b2 );
T tb( b1, b2 );
endmodule
And, within the testbench program, the virtual interface can refer directly to the block.
clocking
program T (A_Bus.STB b1, A_Bus.STB b2 ); // Testbench: 2 synchronous ports
typedef virtual A_Bus.STB SYNCTB;
task request( SYNCTB s );
s.sb.req <= 1;
endtask
task wait_grant( SYNCTB s );
wait( s.sb.gnt == 1 );
endtask
task drive(SYNCTB s, logic [7:0] adr, data );
if( s.sb.gnt == 0 ) begin
request(s); // acquire bus if needed
wait_grant(s);
end
773
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
s.sb.addr = adr;
s.sb.data = data;
repeat(2) @s.sb;
s.sb.req = 0; //release bus
endtask
assert property (b1.sb.p1); // assert property from within program
initial begin
drive( b1, $random, $random );
drive( b2, $random, $random );
end
endprogram
This example shows how the block is referenced via the virtual interface by the tasks within the
clocking
program block.
25.10 Access to interface objects
Access to objects declared in an interface shall be available by hierarchical name reference, regardless of
whether the interface is also accessed through a port connection or through a virtual interface, and regardless
of the existence of any declared modports in that interface. A modport may be used to restrict access to
objects declared in an interface that are referenced through a port connection or virtual interface by
explicitly listing the accessible objects in the modport. However, objects that are not permissible to be listed
in a modport shall remain accessible. For example:
interface ebus_i;
integer I; // reference to I not allowed through modport mp
typedef enum {Y,N} choice;
choice Q;
localparam True = 1;
modport mp(input Q);
endinterface
module Top;
ebus_i ebus ();
sub s1 (ebus.mp);
endmodule
module sub(interface.mp i);
typedef i.choice yes_no; // import type from interface
yes_no P;
assign P = i.Q; // refer to Q with a port reference
initial
Top.ebus.Q = i.True; // refer to Q with a hierarchical reference
initial
Top.ebus.I = 0; // referring to i.I would not be legal because
// is not in modport mp
endmodule
774
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
26. Packages
26.1 General
This clause describes the following:
— Package declarations
— Referencing data within packages
— Package search order rules
— Exporting imported names from packages
— The built-in package
std
26.2 Package declarations
SystemVerilog packages provide an additional mechanism for sharing parameters, data, type, task, function,
sequence, property, and checker declarations among multiple SystemVerilog modules, interfaces, programs,
and checkers.
Packages are explicitly named scopes appearing at the outermost level of the source text (at the same level as
top-level modules and primitives). Types, nets, variables, tasks, functions, sequences, properties, and
checkers may be declared within a package. Such declarations may be referenced within modules,
interfaces, programs, checkers, and other packages by either import or fully resolved name.
Packages may contain processes inside checkers only. Therefore, net declarations with implicit continuous
assignments are not allowed.
package_declaration ::= // from A.1.2
{ attribute_instance } [ lifetime ] package_identifier
package ;
[ timeunits_declaration ] { { attribute_instance } package_item }
[ package_identifier ]
endpackage :
package_item ::= // from A.1.11
package_or_generate_item_declaration
| anonymous_program
| package_export_declaration
| timeunits_declaration3
package_or_generate_item_declaration ::=
net_declaration
| data_declaration
| task_declaration
| function_declaration
| checker_declaration
| dpi_import_export
| extern_constraint_declaration
| class_declaration
| class_constructor_declaration
| local_parameter_declaration
;
| parameter_declaration
;
| covergroup_declaration
| assertion_item_declaration
|
;
775
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
anonymous_program ::= { anonymous_program_item }
program ; endprogram
anonymous_program_item ::=
task_declaration
| function_declaration
| class_declaration
| covergroup_declaration
| class_constructor_declaration
|
;
3) A timeunits_declaration shall be legal as a non_port_module_item, non_port_interface_item,
non_port_program_item, or package_item only if it repeats and matches a previous timeunits_declaration within
the same time scope.
Syntax26-1—Package declaration syntax (excerpt from AnnexA)
The declaration creates a scope that contains declarations intended to be shared among one or
package
more compilation units, modules, interfaces, or programs. Items within packages are generally type
definitions, tasks, and functions. Items within packages shall not have hierarchical references to identifiers
except those created within the package or made visible by import of another package. A package shall not
refer to items defined in the compilation unit scope. (See 3.12.1.) It is also possible to populate packages
with parameters, variables, and nets. This may be useful for global items that are not conveniently passed
down through the hierarchy. Variable declaration assignments within the package shall occur before any
initial or always procedures are started, in the same way as variables declared in a compilation unit or
module.
The following is an example of a package:
package ComplexPkg;
typedef struct {
shortreal i, r;
} Complex;
function Complex add(Complex a, b);
add.r = a.r + b.r;
add.i = a.i + b.i;
endfunction
function Complex mul(Complex a, b);
mul.r = (a.r * b.r) - (a.i * b.i);
mul.i = (a.r * b.i) + (a.i * b.r);
endfunction
endpackage : ComplexPkg
26.3 Referencing data in packages
The compilation of a package shall precede the compilation of scopes in which the package is imported.
One way to use declarations made in a package is to reference them using the package scope resolution
operator .
::
ComplexPkg::Complex cout = ComplexPkg::mul(a, b);
An alternate method for utilizing package declarations is via the declaration (see Syntax26-2).
import
776
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
data_declaration ::= // from A.2.1.3
...
| package_import_declaration11
...
package_import_declaration ::=
package_import_item { package_import_item }
import , ;
package_import_item ::=
package_identifier identifier
::
| package_identifier
:: *
11) It shall be illegal to have an import statement directly within a class scope.
Syntax26-2—Package import syntax (excerpt from AnnexA)
The declaration provides direct visibility of identifiers within packages. It allows identifiers
import
declared within packages to be visible within the current scope without a package name qualifier. Two
forms of the declaration are provided: explicit import and wildcard import. Explicit import allows
import
control over precisely which symbols are imported:
import ComplexPkg::Complex;
import ComplexPkg::add;
An explicit import only imports the symbols specifically referenced by the import.
In the following example, the import of the enumeration type does not import the enumeration
teeth_t
literals and . In order to refer to the enumeration literal from package , either add
ORIGINAL FALSE FALSE q
or use a full package reference as in .
import q::FALSE teeth = q::FALSE;
package p;
typedef enum { FALSE, TRUE } bool_t;
endpackage
package q;
typedef enum { ORIGINAL, FALSE } teeth_t;
endpackage
module top1 ;
import p::*;
import q::teeth_t;
teeth_t myteeth;
initial begin
myteeth = q:: FALSE; // OK:
myteeth = FALSE; // ERROR: Direct reference to FALSE refers to the
end // FALSE enumeration literal imported from p
endmodule
module top2 ;
import p::*;
import q::teeth_t, q::ORIGINAL, q::FALSE;
teeth_t myteeth;
777
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.