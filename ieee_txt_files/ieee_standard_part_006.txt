IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
a |-> b
is evaluated as a vacuous success when is false. In that case the evaluation is independent of the value of b;
a
even though it is a successful evaluation, the property behavior is interpreted as not matching the user intent,
meaning that an assertion of this property is not considered a pass or a failure.
For a general property, nonvacuous evaluation is defined recursively on the structure of the property as
follows:
a) An evaluation attempt of a property that is a sequence is always nonvacuous.
b) An evaluation attempt of a property of the form sequence_expr is always nonvacuous.
strong( )
c) An evaluation attempt of a property of the form sequence_expr is always nonvacuous.
weak( )
d) An evaluation attempt of a property of the form property_expr is nonvacuous if, and only if, the
not
underlying evaluation attempt of property_expr is nonvacuous.
e) An evaluation attempt of a property of the form property_expr1 property_expr2 is nonvacuous
or
if, and only if, either the underlying evaluation attempt of property_expr1 is nonvacuous or the
underlying evaluation attempt of property_expr2 is nonvacuous.
f) An evaluation attempt of a property of the form property_expr1 property_expr2 is nonvacuous
and
if, and only if, either the underlying evaluation attempt of property_expr1 is nonvacuous or the
underlying evaluation attempt of property_expr2 is nonvacuous.
g) An evaluation attempt of a property of the form expression_or_dist property_expr1 is non-
if ( )
vacuous if, and only if, expression_or_dist evaluates to true and the underlying evaluation attempt
of property_expr1 is nonvacuous.
An evaluation attempt of a property of the form expression_or_dist property_expr1
if( ) else
property_expr2 is nonvacuous if, and only if, either expression_or_dist evaluates to true and the
underlying evaluation attempt of property_expr1 is nonvacuous, or expression_or_dist evaluates to
false and the underlying evaluation attempt of property_expr2 is nonvacuous.
h) An evaluation attempt of a property of the form sequence_expression property_expr is
|->
nonvacuous if, and only if, there is an end point of the antecedent sequence_expression and the
evaluation attempt of property_expr that starts at the end point is nonvacuous.
An evaluation attempt of a property of the form sequence_expression property_expr is
|=>
nonvacuous if, and only if, there is a match point of the antecedent sequence_expression and the
evaluation attempt of property_expr that starts at the clock event following the match point is
nonvacuous.
i) An evaluation attempt of an instance of a property is nonvacuous if, and only if, the underlying
evaluation attempt of the property_expr that results from substituting actual arguments for formal
arguments is nonvacuous.
j) An evaluation attempt of a property of the form sequence_expression property_expr is
#-#
nonvacuous if, and only if, there is an end point of the antecedent sequence_expression and the
evaluation attempt of property_expr that starts at the end point is nonvacuous.
k) An evaluation attempt of a property of the form sequence_expression property_expr is
#=#
nonvacuous if, and only if, there is a match point of the antecedent sequence_expression and the
evaluation attempt of property_expr that starts at the clock event following the match point is
nonvacuous.
l) An evaluation attempt of a property of the form property_expr is nonvacuous if, and only
nexttime
if, there is at least one more clock event, and in the evaluation attempt that starts in the next clock
event, property_expr is nonvacuous.
m) An evaluation attempt of a property of the form constant_expression property_expr is
nexttime[ ]
nonvacuous if, and only if, there is at least constant_expression more clock events, and
471
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
property_expr is nonvacuous in the evaluation attempt beginning at the last of the next
constant_expression clock events.
n) An evaluation attempt of a property of the form property_expr is nonvacuous if, and
s_nexttime
only if, there is at least one more clock event, and in the evaluation attempt starting at the next clock
event, property_expr is nonvacuous.
o) An evaluation attempt of a property of the form constant_expression property_expr
s_nexttime[ ]
is nonvacuous if, and only if, there is at least constant_expression more clock events, and
property_expr is nonvacuous in the evaluation attempt beginning at the last of the next
constant_expression clock events.
p) An evaluation attempt of a property of the form property_expr is nonvacuous if, and only
always
if, there is a clock event where the evaluation attempt of property_expr is nonvacuous, and
property_expr does not fail in prior clock events.
q) An evaluation attempt of a property of the form cycle_delay_const_range_expression
always[ ]
property_expr is nonvacuous if, and only if, there is a clock event within the range specified by
cycle_delay_const_range_expression, in which the evaluation attempt of property_expr is
nonvacuous, and the property_expr does not fail in prior clock events within the range specified by
cycle_delay_const_range_expression.
r) An evaluation attempt of a property of the form constant_range property_expr is
s_always[ ]
nonvacuous if, and only if, there is a clock event within the range specified by constant_range, in
which the evaluation attempt of property_expr is nonvacuous, and property_expr does not fail in
prior clock events within the range specified by constant_range.
s) An evaluation attempt of a property of the form property_expr is nonvacuous if,
s_eventually
and only if, there is a clock event in which the evaluation attempt of property_expr is nonvacuous,
and the property_expr does not hold in prior clock events.
t) An evaluation attempt of a property of the form
cycle_delay_const_range_expression property_expr is nonvacuous if, and only
s_eventually[ ]
if, there is a clock event within the range specified by cycle_delay_const_range_expression, in
which the evaluation attempt of property_expr is nonvacuous, and property_expr does not hold in
prior clock events within the range specified by cycle_delay_const_range_expression.
u) An evaluation attempt of a property of the form constant_range property_expr is
eventually[ ]
nonvacuous if, and only if, there is a clock event within the range specified by constant_range, in
which the evaluation attempt of property_expr is nonvacuous, and property_expr does not hold in
prior clock events within the range specified by constant_range.
v) An evaluation attempt of a property of the form property_expr1 property_expr2 is
until
nonvacuous if, and only if, there is a clock event in which either the evaluation attempt of
property_expr1 or the evaluation attempt of property_expr2 is nonvacuous, property_expr2 does not
hold in prior clock events, and property_expr1 holds in all prior clock events.
w) An evaluation attempt of a property of the form property_expr1 property_expr2 is
s_until
nonvacuous if, and only if, there is a clock event in which either the evaluation attempt of
property_expr1 or the evaluation attempt of property_expr2 is nonvacuous, property_expr2 does not
hold in prior clock events, and property_expr1 holds in all prior clock events.
x) An evaluation attempt of a property of the form property_expr1 property_expr2 is
until_with
nonvacuous if, and only if, there is a clock event in which the evaluation attempt of property_expr1
is nonvacuous, property_expr2 does not hold in prior clock events, and property_expr1 holds in all
prior clock events.
y) An evaluation attempt of a property of the form property_expr1 property_expr2 is
s_until_with
nonvacuous if, and only if, there is a clock event in which the evaluation attempt of property_expr1
is nonvacuous, property_expr2 does not hold in prior clock events, and property_expr1 holds in all
prior clock events.
472
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
z) An evaluation attempt of a property of the form property_expr1 property_expr2 is
implies
nonvacuous if, and only if, the underlying evaluation attempt of property_expr1 is true and
nonvacuous, and the underlying evaluation attempt of property_expr2 is nonvacuous.
aa) An evaluation attempt of a property of the form property_expr1 property_expr2 is nonvacuous
iff
if, and only if, either the evaluation attempt of property_expr1 is nonvacuous or the evaluation
attempt of property_expr2 is nonvacuous.
ab) An evaluation attempt of a property of the form expression_or_dist property_expr is
accept_on( )
nonvacuous if, and only if, the underlying evaluation attempt of property_expr is nonvacuous and
expression_or_dist does not hold in any time step of that evaluation attempt.
ac) An evaluation attempt of a property of the form expression_or_dist property_expr is
reject_on( )
nonvacuous if, and only if, the underlying evaluation attempt of property_expr is nonvacuous and
expression_or_dist does not hold in any time step of that evaluation attempt.
ad) An evaluation attempt of a property of the form (expression_or_dist)
sync_accept_on
property_expr is nonvacuous if, and only if, the underlying evaluation attempt of property_expr is
nonvacuous and expression_or_dist does not hold in any clock event of that evaluation attempt.
ae) An evaluation attempt of a property of the form (expression_or_dist)
sync_reject_on
property_expr is nonvacuous if, and only if, the underlying evaluation attempt of property_expr is
nonvacuous and expression_or_dist does not hold in any clock event of that evaluation attempt.
af) An evaluation attempt of a property of the form
expression_or_dist
case ( )
expression_or_dist property_stmt
1 : 1
...
expression_or_dist property_stmt
n : n
property_stmt
[ default : d ]
endcase
is nonvacuous if, and only if:
• For some index i such that 1 <= i <= n, (expression_or_dist expression_or_dist), and
=== i
• For each index j such that 1 <= j < i, (expression_or_dist expression_or_dist), and
!== j
• The underlying evaluation attempt of property_stmt is nonvacuous
i
or
• The default is present, and
• For each index i such that 1 <= i <= n, (expression_or_dist expression_or_dist), and
!== i
• The underlying evaluation attempt of property_stmt is nonvacuous.
d
ag) Anevaluation attempt of a property of the form expression_or_dist property_expr
disable iff( )
is nonvacuous if, and only if, the underlying evaluation attempt of property_expr is nonvacuous and
expression_or_dist does not hold in any time step of that evaluation attempt.
An evaluation attempt of a property succeeds nonvacuously if, and only if, the property evaluates to true and
the evaluation attempt is nonvacuous.
16.15 Disable iff resolution
module_or_generate_item_declaration ::= // from A.1.4
...
| clocking_identifier
defaultclocking ;
| expression_or_dist
defaultdisable iff ;
Syntax16-21—Default clocking and default disable syntax (excerpt from AnnexA)
473
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A may be declared within a generate block or within a module, interface, or
default disable iff
program declaration. It provides a default disable condition to all concurrent assertions in the scope and
subscopes of the declaration. Furthermore, the default extends to any nested
default disable iff
module, interface, or program declarations, and to nested generate blocks. However, if a nested module,
interface, or program declaration, or a generate block itself has a declaration, then
defaultdisable iff
that applies within the nested declaration or generate block and overrides any
default disable iff
from outside. Any signals referenced in the declaration that are
default disable iff disable iff
resolved using scopes will be resolved from the scope of the declaration.
The effect of a declaration is independent of the position of the declaration within
defaultdisable iff
that scope. More than one declaration within the same module, interface, program
defaultdisable iff
declaration, or generate block shall be an error. The scope does not extend into any instances of modules,
interfaces, or programs.
In the following example, module declares to be the default disable condition, and there is no
m1 rst1
declaration in the nested module . The default disable condition applies
default disable iff m2 rst1
throughout the declaration of and the nested declaration of . Therefore, the inferred disable condition
m1 m2
of both assertions and is .
a1 a2 rst1
module m1;
bit clk, rst1;
default disable iff rst1;
a1: assert property (@(posedge clk) p1); // property p1 is
// defined elsewhere
...
module m2;
bit rst2;
...
a2: assert property (@(posedge clk) p2); // property p2 is
// defined elsewhere
endmodule
...
endmodule
If there is a declaration in the nested module , then within this default disable
defaultdisable iff m2 m2
condition overrides the default disable condition declared in . Therefore, in the following example the
m1
inferred disable condition of is , but the inferred disable condition of is .
a1 rst1 a2 rst2
module m1;
bit clk, rst1;
default disable iff rst1;
a1: assert property (@(posedge clk) p1); // property p1 is
// defined elsewhere
...
module m2;
bit rst2;
default disable iff rst2;
...
a2: assert property (@(posedge clk) p2); // property p2 is
// defined elsewhere
endmodule
...
endmodule
The following rules apply for resolution of the disable condition:
474
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
a) If an assertion has a clause, then the disable condition specified in this clause shall be
disable iff
used and any declaration ignored for this assertion.
defaultdisable iff
b) If an assertion does not contain a clause, but the assertion is within the scope of a
disable iff
declaration, then the disable condition for the assertion is inferred from the
defaultdisable iff
declaration.
defaultdisable iff
c) Otherwise, no inference is performed (this is equivalent to the inference of a disable
1'b0
condition).
Following are two example modules illustrating the application of these rules:
module examples_with_default (input logic a, b, clk, rst, rst1);
default disable iff rst;
property p1;
disable iff (rst1) a |=> b;
endproperty
// Disable condition is rst1 - explicitly specified within a1
a1 : assert property (@(posedge clk) disable iff (rst1) a |=> b);
// Disable condition is rst1 - explicitly specified within p1
a2 : assert property (@(posedge clk) p1);
// Disable condition is rst - no explicit specification, inferred from
// default disable iff declaration
a3 : assert property (@(posedge clk) a |=> b);
// Disable condition is 1'b0. This is the only way to
// cancel the effect of default disable.
a4 : assert property (@(posedge clk) disable iff (1'b0) a |=> b);
endmodule
module examples_without_default (input logic a, b, clk, rst);
property p2;
disable iff (rst) a |=> b;
endproperty
// Disable condition is rst - explicitly specified within a5
a5 : assert property (@(posedge clk) disable iff (rst) a |=> b);
// Disable condition is rst - explicitly specified within p2
a6 : assert property (@ (posedge clk) p2);
// No disable condition
a7 : assert property (@ (posedge clk) a |=> b);
endmodule
16.16 Clock resolution
There are a number of ways to specify a clock for a property. They are as follows:
— Sequence instance with a clock, for example:
sequence s2; @(posedge clk) a ##2 b; endsequence
property p2; not s2; endproperty
assert property (p2);
475
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Property, for example:
property p3; @(posedge clk) not (a ##2 b); endproperty
assert property (p3);
— Contextually inferred clock from a procedural block, for example:
always @(posedge clk) assert property (not (a ##2 b));
— A block, for example:
clocking
clocking master_clk @(posedge clk);
property p3; not (a ##2 b); endproperty
endclocking
assert property (master_clk.p3);
— Default clock, for example:
default clocking master_clk ; // master clock as defined above
property p4; (a ##2 b); endproperty
assert property (p4);
In general, a clocking event applies throughout its scope except where superseded by an inner clocking
event, as with clock flow in multiclocked sequences and properties. The following rules apply (the term
maximal property, used in the rules below, is defined as the unique flattened property contained in the
assertion statement and obtained by applying the rewriting algorithm in F.4.1):
a) In a module, interface, program, or checker with a default clocking event, a concurrent assertion
statement that has no otherwise specified leading clocking event is treated as though the default
clocking event had been written explicitly as the leading clocking event. The default clocking event
does not apply to a sequence or property declaration except in the case that the declaration appears
in a block whose clocking event is the default.
clocking
b) The following rules apply within a block:
clocking
1) No explicit clocking event is allowed in any property or sequence declaration within the
block. All sequence and property declarations within the block are
clocking clocking
treated as though the clocking event of the block had been written explicitly as the
clocking
leading clocking event.
2) Multiclocked sequences and properties are not allowed within the block.
clocking
3) If a named sequence or property that is declared outside the block is instantiated
clocking
within the block, the instance shall be singly clocked and its clocking event shall be
clocking
identical to that of the block.
clocking
c) A contextually inferred clocking event from a procedural block supersedes a default clocking event.
The contextually inferred clocking event is treated as though it had been written as the leading
clocking event of any concurrent assertion statement to which the inferred clock applies.
d) An explicitly specified leading clocking event in a concurrent assertion statement supersedes a
default clocking event.
e) A multiclocked sequence or property can inherit the default clocking event as its leading clocking
event. If a multiclocked property is the maximal property of a concurrent assertion statement, then
the property shall have a unique semantic leading clock (see 16.16.1).
476
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
f) If a concurrent assertion statement has no explicit leading clocking event, there is no default
clocking event, and no contextually inferred clocking event applies to the assertion statement, then
the maximal property of the assertion statement shall be an instance of a sequence or property for
which a unique leading clocking event is determined.
The following are two example modules illustrating the application of these rules with some legal and some
illegal declarations, as indicated by the comments:
module examples_with_default (input logic a, b, c, clk);
property q1;
$rose(a) |-> ##[1:5] b;
endproperty
property q2;
@(posedge clk) q1;
endproperty
default clocking posedge_clk @(posedge clk);
property q3;
$fell(c) |=> q1;
// legal: q1 has no clocking event
endproperty
property q4;
$fell(c) |=> q2;
// legal: q2 has clocking event identical to that of
// the clocking block
endproperty
sequence s1;
@(posedge clk) b[*3];
// illegal: explicit clocking event in clocking block
endsequence
endclocking
property q5;
@(negedge clk) b[*3] |=> !b;
endproperty
always @(negedge clk)
begin
a1: assert property ($fell(c) |=> q1);
// legal: contextually inferred leading clocking event,
// @(negedge clk)
a2: assert property (posedge_clk.q4);
// legal: will be queued (pending) on negedge clk, then
// (if matured) checked at next posedge clk (see 16.14.6)
a3: assert property ($fell(c) |=> q2);
// illegal: multiclocked property with contextually
// inferred leading clocking event
a4: assert property (q5);
// legal: contextually inferred leading clocking event,
// @(negedge clk)
end
property q6;
q1 and q5;
477
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
endproperty
a5: assert property (q6);
// illegal: default leading clocking event, @(posedge clk),
// but semantic leading clock is not unique
a6: assert property ($fell(c) |=> q6);
// legal: default leading clocking event, @(posedge clk),
// is the unique semantic leading clock
sequence s2;
$rose(a) ##[1:5] b;
endsequence
c1: cover property (s2);
// legal: default leading clocking event, @(posedge clk)
c2: cover property (@(negedge clk) s2);
// legal: explicit leading clocking event, @(negedge clk)
endmodule
module examples_without_default (input logic a, b, c, clk);
property q1;
$rose(a) |-> ##[1:5] b;
endproperty
property q5;
@(negedge clk) b[*3] |=> !b;
endproperty
property q6;
q1 and q5;
endproperty
a5: assert property (q6);
// illegal: no leading clocking event
a6: assert property ($fell(c) |=> q6);
// illegal: no leading clocking event
sequence s2;
$rose(a) ##[1:5] b;
endsequence
c1: cover property (s2);
// illegal: no leading clocking event
c2: cover property (@(negedge clk) s2);
// legal: explicit leading clocking event, @(negedge clk)
sequence s3;
@(negedge clk) s2;
endsequence
c3: cover property (s3);
// legal: leading clocking event, @(negedge clk),
// determined from declaration of s3
c4: cover property (s3 ##1 b);
// illegal: no default, inferred, or explicit leading
// clocking event and maximal property is not an instance
478
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
endmodule
16.16.1 Semantic leading clocks for multiclocked sequences and properties
Throughout this subclause, s, s , and s denote sequences without clocking events; p, p , and p denote
1 2 1 2
properties without clocking events; m, m , and m denote multiclocked sequences, q, q , and q denote
1 2 1 2
multiclocked properties; and c, c , and c denote nonidentical clocking event expressions.
1 2
This subclause defines a notion of the set of semantic leading clocks for a multiclocked sequence or
property.
Some sequences and properties have no explicit leading clock event. Their initial clocking event is inherited
from an outer clocking event according to the flow of clocking event scope. In this case, the semantic
leading clock is said to be inherited. For example, in the property
c s p c p
@( ) |=> and @( 1) 1
the semantic leading clock of the subproperty p is inherited because the initial clock of p is the clock that
flows across .
|=>
A multiclocked sequence has a unique semantic leading clock, defined inductively as follows:
— The semantic leading clock of s is inherited.
— The semantic leading clock of s is c.
@(c)
— If inherited is the semantic leading clock of m, then the semantic leading clock of m is c.
@(c)
Otherwise, the semantic leading clock of m is equal to the semantic leading clock of m.
@(c)
— The semantic leading clock of (m) is equal to the semantic leading clock of m.
— The semantic leading clock of m m is equal to the semantic leading clock of m .
1##1 2 1
— The semantic leading clock of m m is equal to the semantic leading clock of m .
1##0 2 1
The set of semantic leading clocks of a multiclocked property is defined inductively as follows:
— The set of semantic leading clocks of m is {c}, where c is the unique semantic leading
strong( )
clock of m.
— The set of semantic leading clocks of m is {c}, where c is the unique semantic leading clock
weak( )
of m.
— The set of semantic leading clocks of p is {inherited}.
— If inherited is an element of the set of semantic leading clocks of q, then the set of semantic leading
clocks of q is obtained from the set of semantic leading clocks of q by replacing inherited by c.
@(c)
Otherwise, the set of semantic leading clocks of q is equal to the set of semantic leading clocks
@(c)
of q.
— The set of semantic leading clocks of (q) is equal to the set of semantic leading clocks of q.
— The set of semantic leading clocks of q is equal to the set of semantic leading clocks of q.
not
— The set of semantic leading clocks of q q is the union of the set of semantic leading clocks of
1and 2
q with the set of semantic leading clocks of q .
1 2
— The set of semantic leading clocks of q q is the union of the set of semantic leading clocks of q
1or 2 1
with the set of semantic leading clocks of q .
2
— The set of semantic leading clocks of m p is equal to the set of semantic leading clocks of m.
|->
— The set of semantic leading clocks of m p is equal to the set of semantic leading clocks of m.
|=>
— The set of semantic leading clocks of (b) q is {inherited}.
if
— The set of semantic leading clocks of (b) q q is {inherited}.
if 1else 2
479
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— The set of semantic leading clocks of (b) b q … b q [ q ] is
case 1: 1 n: n default: d endcase
{inherited}.
— The set of semantic leading clocks of q is {inherited}.
nexttime
— The set of semantic leading clocks of q is {inherited}.
always
— The set of semantic leading clocks of q is {inherited}.
s_eventually
— The set of semantic leading clocks of q q is {inherited}.
1until 2
— The set of semantic leading clocks of q q is {inherited}.
1until_with 2
— The set of semantic leading clocks of b q is the set of semantic leading clocks of q.
accept_on( )
— The set of semantic leading clocks of b q is the set of semantic leading clocks of q.
reject_on( )
— The set of semantic leading clocks of b q is {inherited}.
sync_accept_on( )
— The set of semantic leading clocks of b q is {inherited}.
sync_reject_on( )
— The set of semantic leading clocks of a property instance is equal to the set of semantic leading
clocks of the multiclocked property obtained from the body of its declaration by substituting in
actual arguments.
For example, the multiclocked sequence
c s c s
@( 1) 1 ##1 @( 2) 2
has c as its unique semantic leading clock, while the multiclocked property
1
p c p
not ( 1 and (@( 2) 2)
has {inherited, c } as its set of semantic leading clocks.
2
In the presence of an incoming outer clock, the inherited semantic leading clock is always understood to
refer to the incoming outer clock. Therefore, the clocking of a property q in the presence of incoming outer
clock c is equivalent to the clocking of the property q.
@(c)
A multiclocked property has a unique semantic leading clock in cases where all its leading clocks are
identical. Consider the following example:
wire clk1, clk2;
logic a, b;
...
assign clk2 = clk1;
a1: assert property (@(clk1) a and @(clk2) b); // Illegal
a2: assert property (@(clk1) a and @(clk1) b); // OK
always @(posedge clk1) begin
a3: assert property(a and @(posedge clk2)); //Illegal
a4: assert property(a and @(posedge clk1)); // OK
end
The assertions and are legal, while the assertions and are not. Though both clocks of have
a2 a4 a1 a3 a1
the same value, they are not identical. Therefore, does not have a unique semantic leading clock. The
a1
assertions and have as their inferred clock. This clock is not identical to
a3 a4 @(posedge clk1)
therefore does not have a unique semantic leading clock.
@(posedge clk2) a3
480
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
16.17 Expect statement
The statement is a procedural blocking statement that allows waiting on a property evaluation. The
expect
syntax of the statement accepts a named property or a property declaration and is given in
expect
Syntax16-22.
expect_property_statement ::= // from A.2.10
property_spec action_block
expect ( )
Syntax16-22—Expect statement syntax (excerpt from AnnexA)
The statement accepts the same syntax used to assert a property. An statement causes the
expect expect
executing process to block until the given property succeeds or fails. The statement following the is
expect
scheduled to execute after processing the Observed region in which the property completes its evaluation.
When the property succeeds or fails, the process unblocks, and the property stops being evaluated (i.e., no
property evaluation is started until that statement is executed again).
expect
When executed, the statement starts a single thread of evaluation for the given property on the
expect
subsequent clocking event, that is, the first evaluation shall take place on the next clocking event. If the
property fails at its clocking event, the optional clause of the action block is executed. If the property
else
succeeds, the optional pass statement of the action block is executed. The execution of pass and fail
statements can be controlled by using assertion action control tasks. The assertion action control tasks are
described in 20.12.
program tst;
initial begin
# 200ms;
expect( @(posedge clk) a ##1 b ##1 c ) else $error( "expect failed" );
ABC: ...
end
endprogram
In the preceding example, the statement specifies a property that consists of the sequence
expect a ##1 b
. The statement (second statement in the procedure of program ) blocks until
##1 c expect initial tst
the sequence is matched or is determined not to match. The property evaluation starts on
a ##1 b ##1 c
the occurrence of the event following the 200ms delay. If the sequence is matched, the
posedge clk
process is unblocked and continues to execute on the statement labeled . If the sequence fails to match,
ABC
then the clause is executed, which in this case generates a run-time error. For the preceding
else expect
statement to succeed, the sequence must match starting on the occurrence of the
a ##1 b ##1 c
event immediately after time . The sequence will not match if , , or is evaluated to
posedge clk 200ms a b c
be false at the first, second, or third clocking event occurrence, respectively.
The statement can appear anywhere a statement (see 9.4.3) can appear. Because it is a
expect wait
blocking statement, the property can refer to automatic variables as well as static variables. For example, the
task below waits between 1 and 10 clock ticks for the variable to equal a particular value, which is
data
specified by the automatic argument value. The second argument, , is used to return the result of
success
the statement: 1 for success and 0 for failure.
expect
integer data;
...
task automatic wait_for( integer value, output bit success );
expect( @(posedge clk) ##[1:10] data == value ) success = 1;
else success = 0;
endtask
481
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
initial begin
bit ok;
wait_for( 23, ok ); // wait for the value 23
...
end
16.18 Clocking blocks and concurrent assertions
If a variable used in a concurrent assertion is a block variable, it will be sampled only in the
clocking
block.
clocking
Examples:
module A;
logic a, clk;
clocking cb_with_input @(posedge clk);
input a;
property p1;
a;
endproperty
endclocking
clocking cb_without_input @(posedge clk);
property p1;
a;
endproperty
endclocking
property p1;
@(posedge clk) a;
endproperty
property p2;
@(posedge clk) cb_with_input.a;
endproperty
a1: assert property (p1);
a2: assert property (cb_with_input.p1);
a3: assert property (p2);
a4: assert property (cb_without_input.p1);
endmodule
Figure16-17 explains the behavior of all the assertions. In the preceding example, , , , and are
a1 a2 a3 a4
equivalent.
482
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
clk
a
a1/a2/a3/a4
cb.a
Figure16-17—Clocking blocks and concurrent assertion
483
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
17. Checkers
17.1 Overview
Assertions provide building blocks to validate the behavior of the design. In many cases there is a need to
group several assertions together into bigger blocks having a well-defined functionality. These verification
blocks may also need to contain modeling code to compute values of auxiliary variables used in assertions or
covergroup instances to be integrated with cover statements. The checker construct in SystemVerilog was
specifically created to represent such verification blocks encapsulating assertions along with the modeling
code. The intended use of checkers is to serve as verification library units, or as building blocks for creating
abstract auxiliary models used in formal verification.
The modeling mechanism in checkers is similar to the modeling mechanism in modules and interfaces,
though several limitations apply. For example, no nets can be declared and assigned in checkers. On the
other hand, checkers allow nondeterministic modeling, which does not exist in modules and interfaces. Each
variable declared in a checker may be either deterministic or random. Checker modeling is explained in
17.7. Random variables are useful to build abstract nondeterministic models for formal verification.
Reasoning about nondeterministic models is sometimes much easier than reasoning about deterministic RTL
models.
Deterministic variables allow a conventional (deterministic) modeling for assertions. Using random
variables instead of regular variables in checkers has the advantage that the same checker may be used for
both deterministic and nondeterministic cases.
17.2 Checker declaration
checker_declaration ::= // from A.1.2
checker_identifier [ [ checker_port_list ] ]
checker ( ) ;
{ { attribute_instance } checker_or_generate_item }
[ checker_identifier ]
endchecker :
checker_port_list ::= // from A.1.8
checker_port_item { checker_port_item}
,
checker_port_item ::=
{ attribute_instance } [ checker_port_direction ] property_formal_type formal_port_identifier
{variable_dimension} [ property_actual_arg ]
=
checker_port_direction ::=
|
input output
checker_or_generate_item ::=
checker_or_generate_item_declaration
| initial_construct
| always_construct
| final_construct
| assertion_item
| continuous_assign
| checker_generate_item
checker_or_generate_item_declaration ::=
[ ] data_declaration
rand
| function_declaration
| checker_declaration
| assertion_item_declaration
484
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| covergroup_declaration
| genvar_declaration
| clocking_declaration
| clocking_identifier
defaultclocking ;
| expression_or_dist
defaultdisableiff ;
|
;
checker_generate_item6 ::=
loop_generate_construct
| conditional_generate_construct
| generate_region
| elaboration_system_task
checker_identifier ::= // from A.9.3
identifier
6) It shall be illegal for a checker_generate_item to include any item that would be illegal in a checker_declaration
outside a checker_generate_item.
Syntax17-1—Checker declaration syntax (excerpt from AnnexA)
A checker may be declared in one of the following:
— A module
— An interface
— A program
— A checker
— A package
— A generate block
— A compilation unit scope
A checker is declared using the keyword followed by a name and optional formal argument list,
checker
and ending with the keyword .
endchecker
The following elements from the scope enclosing the checker declaration shall not be referenced in a
checker:
— Automatic variables and members or elements of dynamic variables (see 6.21).
— Elements of - , , or blocks.
fork join fork-join_any fork-join_none
Action blocks of assertions within a checker will be referred to as checker action blocks, and the rest of the
checker will be referred to as a checker body.
A checker body may contain the following elements:
— Declarations of constructs, sequences, properties, and functions
let
— Deferred assertions (see 16.4)
— Concurrent assertions (see 16.14)
— Checker declarations
— Other checker instantiations
— Covergroup declarations and instances
— Checker variable declarations and assignments (see 17.7)
— and declarations
defaultclocking defaultdisableiff
485
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— , , , , and procedures (see 9.2)
initial always_comb always_latch always_ff final
— Generate blocks, containing any of the above elements
Modules, interfaces, programs, and packages shall not be declared inside checkers. Modules, interfaces, and
programs shall not be instantiated inside checkers.
A formal argument of a checker may be optionally preceded by a direction qualifier: or . If
input output
no direction is specified explicitly then the direction of the previous argument shall be inferred. If the
direction of the first checker argument is omitted, it shall default to . An input checker formal
input
argument shall not be modified by a checker.
The legal data types for checker formal arguments are those legal for a property (see 16.12). The type of an
output argument shall not be of , , or . If the type of a checker formal
untyped sequence property
argument is omitted, it is inferred according to the following rules:
— If the argument has an explicit direction qualifier, it shall be an error to omit its type.
— Otherwise, if the argument is the first argument of the checker, it is assumed to be .
inputuntyped
— Otherwise, the type of the previous formal argument is inferred as described for sequences and
properties (see 16.8 and 16.12).
In a similar manner to sequences and properties, a checker declaration may specify a default value for each
singular input port, as described in 16.8. A checker declaration may also specify an initial value for each
singular output port using the same syntax as the default value specification for input arguments. Checker
output port initialization has the same semantics as a variable initialization (see 6.8).
Following are examples of simple checkers:
Example 1:
// Simple checker containing concurrent assertions
checker my_check1 (logic test_sig, event clock);
default clocking @clock; endclocking
property p(logic sig);
...
endproperty
a1: assert property (p (test_sig));
c1: cover property (!test_sig ##1 test_sig);
endchecker : my_check1
Example 2:
// Simple checker containing deferred assertions
checker my_check2 (logic a, b);
a1: assert #0 ($onehot0({a, b});
c1: cover #0 (a == 0 && b == 0);
c2: cover #0 (a == 1);
c3: cover #0 (b == 1);
endchecker : my_check2
Example 3:
// Simple checker with output arguments
checker my_check3 (logic a, b, event clock, output bit failure, undef);
default clocking @clock; endclocking
a1: assert property ($onehot0({a, b}) failure = 1'b0; else failure = 1'b1;
a2: assert property ($isunknown({a, b}) undef = 1'b0; else undef = 1'b1;
endchecker : my_check3
486
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 4:
// Checker with default input and initialized output arguments
checker my_check4 (input logic in,
en = 1'b1, // default value
event clock,
output int ctr = 0); // initial value
default clocking @clock; endclocking
always_ff @clock
if (en && in) ctr <= ctr + 1;
a1: assert property (ctr < 5);
endchecker : my_check4
Type and data declarations within the checker are local to the checker scope and are static. Clock and
contexts are inherited from the scope of the checker declaration (but see 17.4 for usage of
disableiff
context value functions for passing the instantiation context to the checker). For example:
module m;
default clocking @clk1; endclocking
default disable iff rst1;
checker c1;
// Inherits @clk1 and rst1
...
endchecker : c1
checker c2;
// Explicitly redefines its default values
default clocking @clk2; endclocking
default disable iff rst2;
...
endchecker : c2
...
endmodule : m
Variables used in a checker that are neither formal arguments to the checker nor internal variables of the
checker are resolved according to the scoping rules from the scope in which the checker is declared.
17.3 Checker instantiation
concurrent_assertion_item ::= // from A.2.10
...
| checker_instantiation
checker_instantiation ::= // from A.4.1.4
ps_checker_identifier name_of_instance [list_of_checker_port_connections]
( );
list_of_checker_port_connections29 ::=
ordered_checker_port_connection { ordered_checker_port_connection }
,
| named_checker_port_connection { named_checker_port_connection }
,
ordered_checker_port_connection ::= { attribute_instance } [ property_actual_arg ]
named_checker_port_connection ::=
{ attribute_instance } formal_port_identifier [ [ property_actual_arg ] ]
. ( )
| { attribute_instance }
.*
487
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
ps_checker_identifier ::= // from A.9.3
[ package_scope ] checker_identifier
29) The token shall appear at most once in a list of port connections.
.*
Syntax17-2—Checker instantiation syntax (excerpt from AnnexA)
A checker may be instantiated wherever a concurrent assertion may appear (see 16.14) with the following
exceptions:
— It shall be illegal to instantiate checkers in - , - , or -
fork join fork join_any fork join_none
blocks.
— It shall be illegal to instantiate a checker in a procedure of another checker.
A checker has different behavior depending on whether it is instantiated inside or outside procedural code. A
checker instantiation in procedural code is referred to as a procedural checker instance. A checker
instantiation outside procedural code is referred to as a static checker instance. See 16.14.6 for the
corresponding definitions of procedural and static assertion statements.
When a checker is instantiated, actual arguments are passed to the checker. The mechanism for passing input
arguments to a checker is similar to the mechanism for passing arguments to a property (see 16.12). The
rewriting algorithm for checkers (see F.4.2) applies to checker input arguments. The rewriting algorithm
substitutes actual arguments for references to the corresponding formal arguments in the body of the
declaration of the checker. The rewriting algorithm does not itself account for name resolution and assumes
that names have been resolved prior to the substitution of actual arguments. If the flattened checker is not
legal, then the instance is not legal and there shall be an error.
The following restrictions apply:
— As in the case of sequences and properties, if is an actual input argument to a checker instance,
$
then the corresponding formal argument shall be untyped and each of its references either shall be an
upper bound in a cycle_delay_const_range_expression or shall itself be an actual argument in an
instance of a named sequence or property, or in a checker instance.
— If an actual input argument contains any subexpression that is a cast or automatic value from
const
procedural code, then the corresponding formal argument shall not be used in a continuous
assignment or in the procedural code within the checker.
Checker actual output arguments shall be variable_lvalue or net_lvalue. The checker instantiation should be
treated as if there were continuous assignments, executed in the Reactive region, of the checker’s output
formal arguments to their corresponding actual arguments.
Checker formal arguments may be connected to their actual arguments in ways similar to module ports (see
23.3.2):
— Positional connections by port order.
— Named port connections using fully explicit connections.
— Named port connections using implicit connections.
— Named port connections using a wildcard port name.
The following example illustrates a checker instantiation:
checker mutex (logic [31:0] sig, event clock, output bit failure);
assert property (@clock $onehot0(sig))
failure = 1'b0; else failure = 1'b1;
488
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
endchecker : mutex
module m(wire [31:0] bus, logic clk);
logic res, scan;
// ...
mutex check_bus(bus, posedge clk, res);
always @(posedge clk) scan <= res;
endmodule : m
On each rising edge of the bits of are checked for mutual exclusion and the result is assigned to
clk bus res
in the Reactive region. If is changed in the Active region, will capture the value of generated
clk scan res
on the previous rising edge of .
clk
All contents of a checker instance other than static assertion statements are considered to exist during every
time step, regardless of whether the checker is static or procedural. One copy of these contents exists for
each instantiation. Procedural concurrent assertion statements in a checker shall be treated just like other
procedural assertion statements as described in 16.14.6. However, static assertion statements within a
checker are treated as if they appear at the checker’s instantiation point. If the checker is instantiated inside
some scope, any of its static assertions, both concurrent and deferred, are treated as if instantiated in this
scope. Therefore, the following applies for static assertions within a checker:
— If the checker is static, the concurrent assertions are continually monitored, and begin execution on
any time step matching their initial clock event. The deferred assertions are monitored whenever
their expressions change.
— If the checker is procedural, all static concurrent assertions in the checker are added to the pending
procedural assertion queue when the checker instantiation is reached in process execution, and then
may mature or be flushed like any procedural concurrent assertion (see 16.14.6.2). Similarly all
static deferred assertions in the checker are added to the pending deferred assertion report when the
checker instantiation is reached in its process execution, and may mature or be flushed like any
procedural deferred assertion (see 16.4.1).
— If the checker is statically instantiated inside another checker, any of its static assertions, concurrent
or deferred, are treated as if instantiated in the parent checker, and thus will be treated as procedural
assertions when an instantiation of its top-level ancestor in the checker hierarchy is visited in
procedural code.
The following example illustrates this behavior:
checker c1(event clk, logic[7:0] a, b);
logic [7:0] sum;
always_ff @(clk) begin
sum <= a + 1'b1;
p0: assert property (sum < `MAX_SUM);
end
p1: assert property (@clk sum < `MAX_SUM);
p2: assert property (@clk a != b);
p3: assert #0 ($onehot(a));
endchecker
module m(input logic rst, clk, logic en, logic[7:0] in1, in2,
in_array [20:0]);
c1 check_outside(posedge clk, in1, in2);
always @(posedge clk) begin
automatic logic [7:0] v1=0;
if (en) begin
// v1 is automatic, so current procedural value is used
c1 check_inside(posedge clk, in1, v1);
489
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
end
for (int i = 0; i < 4; i++) begin
v1 = v1+5;
if (i != 2) begin
// v1 is automatic, so current procedural value is used
c1 check_loop(posedge clk, in1, in_array[v1]);
end
end
end
endmodule : m
In this example, there are three instantiations of : , , and .
c1 check_outside check_inside check_loop
They have the following characteristics:
— is a static instantiation, while and are procedural.
check_outside check_inside check_loop
— Each of the three instantiations has its own version of , which is updated at every positive clock
sum
edge, regardless of whether that instance was visited in procedural code. Even in the case of
, there is only one instance of , and it will be updated using the sampled value of
check_loop sum
.
in1
— Each of the three instantiations will queue an evaluation of at every posedge of the clock
p0
(according to the rules in 16.14.6), which will mature and report a violation during any time step
when is not less than , regardless of the behavior of the procedural code in module .
sum MAX_SUM m
— For checker instance , and are checked at every positive clock edge. For
check_outside p1 p2
checker instance , and are queued to mature and be checked on any positive
check_inside p1 p2
clock edge when is true. For , three procedural instances of and are queued to
en check_loop p1 p2
mature on any positive clock edge. For , all three instances are identical, using the sampled value
p1
of ; but for , the three instances compare the sampled value of to the sampled value of
sum p2 in1
indexed by constant values of 5, 10, and 20, respectively.
in_array v1
— For checker instance , is checked whenever changes. In checker instances
check_outside p3 a
and , deferred assertion behaves as a procedural deferred assertion
check_inside check_loop p3
placed at the instantiation point of its checker.
17.4 Context inference
Context value functions (see 16.14.7) may be used as default values of formal arguments in a checker
declaration. These functions enable adjusting the checker behavior depending on its instantiation context.
For example:
// Context inference in a checker
checker check_in_context (logic test_sig,
event clock = $inferred_clock,
logic reset = $inferred_disable);
property p(logic sig);
...
endproperty
a1: assert property (@clock disable iff (reset) p(test_sig));
c1: cover property (@clock !reset throughout !test_sig ##1 test_sig);
endchecker : check_in_context
module m(logic rst);
wire clk;
logic a, en;
wire b = a && en;
// No context inference
check_in_context my_check1(.test_sig(b), .clock(clk), .reset(rst));
490
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
always @(posedge clk) begin
a <= ...;
if (en) begin
...
// inferred from context:
// .clock(posedge clk)
// .reset(1'b0)
check_in_context my_check2(a);
end
en <= ...;
end
endmodule : m
In the preceding example the default values of and in are taken from the
clock reset check_in_context
instantiation context. In the instantiation all formal arguments are provided explicitly. In the
my_check1
instantiation all optional arguments are passed their default value: the clock is inferred from the
my_check2
clock of the always procedure of the module , the disable condition is inferred to be .
m 1'b0
17.5 Checker procedures
The following procedures are allowed inside a checker body:
— procedure
initial
— procedure
always
— procedure
final
An procedure in a checker body may contain declarations, immediate, deferred, and
initial let
concurrent assertions, and a procedural timing control statement using an event control only.
The following forms of always procedures are allowed in checkers: , , and
always_comb always_latch
. Checker always procedures may contain the following statements:
always_ff
— Blocking assignments (see 10.4.1; and procedures only)
always_comb always_latch
— Nonblocking assignments (see 10.4.2)
— Selection statements (see 12.4 and 12.5)
— Loop statements (see 12.7)
— Timing event control (see 9.4.2; procedure only)
always_ff
— Subroutine calls (see Clause13)
— Immediate, deferred, and concurrent assertions
— declarations
let
Except for the variables used in the event control, all other expressions in procedures are
always_ff
sampled (see 16.5.1). It follows from this rule that the expressions in immediate and deferred assertions
instantiated in this procedure are also sampled. Expressions in and
always_comb always_latch
procedures are not implicitly sampled and the assignments appearing in these procedures use the current
values of their expressions. For example:
checker check(logic a, b, c, clk, rst);
logic x, y, z, v, t;
assign x = a; // current value of a
always_ff @(posedge clk or negedge rst) // current values of clk and rst
begin
491
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
a1: assert (b); // sampled value of b
if (rst) // current value of rst
z <= b; // sampled value of b
else z <= !c; // sampled value of c
end
always_comb begin
a2: assert (b); // current value of b
if (a) // current value of a
v = b; // current value of b
else v = !b; // current value of b
end
always_latch begin
a3: assert (b); // current value of b
if (clk) // current value of clk
t <= b; // current value of b
end
// ...
endchecker : check
The following example illustrates clock inference for checker procedures, following the rules in 16.14.6.
checker clocking_example (logic sig1, sig2, default_clk, rst,
event e1, e2, e3 );
bit local_sig;
default clocking @(posedge default_clk); endclocking
always_ff @(e1) begin: p1_block
p1a: assert property (sig1 == sig2);
p1b: assert property (@(e1) (sig1 == sig2));
end
always_ff @(e2 or e3) begin: p2_block
local_sig <= rst;
p2a: assert property (sig1 == sig2);
p2b: assert property (@(e2) (sig1 == sig2));
end
always_ff @(rst or e3) begin: p3_block
local_sig <= rst;
p3a: assert property (sig1 == sig2);
p3b: assert property (@(e3) (sig1 == sig2));
end
...
endchecker
...
clocking_example c1 (s1, s2, default_clk, rst,
posedge clk1 or posedge clk2,
posedge clk1,
negedge rst);
In instance of , the assertions will be clocked as follows:
c1 clocking_example
— Assertion will be clocked by . This is because after the substitution of
p1a posedgedefault_clk
the actual argument for the formal argument , it does not
posedge clk1 or posedge clk2 e1
satisfy the clock inference conditions in 16.14.6, particularly condition (b). If clocking based on
e1
is desired, it must be done explicitly as in property .
p1b
492
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Assertion will be clocked by . This is because the event control of
p2a posedge clk1 p2_block
satisfies the conditions in 16.14.6, including condition (c 2), after the formal arguments are
substituted with the actual arguments. Thus assertions and are equivalent.
p2a p2b
— Assertion will be clocked by . This is because the event control of
p3a posedge default_clk
does not satisfy the conditions in 16.14.6, particularly condition (c 2). If clocking based
p3_block
on is desired, it must be done explicitly as in property .
e3 p3b
A procedure may be specified within a checker in the same manner as in a module (see 9.2.3). This
final
allows for the checker to check conditions with immediate assertions or print out statistics at the end of
simulation. The operation of the procedure is independent of the instantiation context of the checker
final
that contains it. It will be executed once at the end of simulation for every instantiation of that checker.
There is no implied ordering in the execution of multiple procedures. A procedure within a
final final
checker may include any construct allowed in a non-checker procedure.
final
17.6 Covergroups in checkers
One or more declarations or instances (see 19.3) are permitted within a checker. These
covergroup
declarations and instances shall not appear in any procedural block in the checker. A may
covergroup
reference any variable visible in its scope, including checker formal arguments and checker variables.
However, it shall be an error if a formal argument referenced by a has a actual
covergroup const
argument. For example:
checker my_check(logic clk, active);
bit active_d1 = 1'b0;
always_ff @(posedge clk) begin
active_d1 <= active;
end
covergroup cg_active @(posedge clk);
cp_active : coverpoint active
{
bins idle = { 1'b0 };
bins active = { 1'b1 };
}
cp_active_d1 : coverpoint active_d1
{
bins idle = { 1'b0 };
bins active = { 1'b1 };
}
option.per_instance = 1;
endgroup
cg_active cg_active_1 = new();
endchecker : my_check
A covergroup may also be triggered by a procedural call to its method (see 19.8). The following
sample()
examples show how the method may be called from a sequence match item to trigger a
sample()
covergroup.
checker op_test (logic clk, vld_1, vld_2, logic [3:0] opcode);
bit [3:0] opcode_d1;
always_ff @(posedge clk) opcode_d1 <= opcode;
covergroup cg_op;
cp_op : coverpoint opcode_d1;
493
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
endgroup: cg_op
cg_op cg_op_1 = new();
sequence op_accept;
@(posedge clk) vld_1 ##1 (vld_2, cg_op_1.sample());
endsequence
cover property (op_accept);
endchecker
In this example, the coverpoint refers to the checker variable directly. It is triggered by a
cp_op opcode_d1
call to the default method from a sequence match item. This function call occurs in the Reactive
sample()
region, while nonblocking assignments to checker variables will occur in the Re-NBA region. As a result,
the covergroup will sample the old value of the checker variable .
opcode_d1
It is also possible to define a custom method for a covergroup (see 19.8.1). The following is an
sample()
example of this:
checker op_test (logic clk, vld_1, vld_2, logic [3:0] opcode);
bit [3:0] opcode_d1;
always_ff @(posedge clk) opcode_d1 <= opcode;
covergroup cg_op with function sample(bit [3:0] opcode_d1);
cp_op : coverpoint opcode_d1;
endgroup: cg_op
cg_op cg_op_1 = new();
sequence op_accept;
@(posedge clk) vld_1 ##1 (vld_2, cg_op_1.sample(opcode_d1));
endsequence
cover property (op_accept);
endchecker
In this example, a custom method has been defined for the covergroup , and the coverpoint
sample() cg_op
references the formal argument of the custom method. This custom method will be called
cp_op sample()
in the Reactive region upon a sequence match, but the sampled value of the sequential checker variable
will be passed to the function. As a result, the covergroup will sample the value
opcode_d1 sample()
from the Preponed region.
17.7 Checker variables
Variables may be defined in checkers, but defining nets in the checker body shall be illegal. All variables
defined in a checker body shall have static lifetimes (see 17.2). The variables defined in the checker body are
referred to as checker variables. The following example illustrates checker variable usage:
checker counter_model(logic flag);
bit [2:0] counter = '0;
always_ff @$global_clock
counter <= counter + 1'b1;
assert property (@$global_clock counter == 0 |-> flag);
endchecker : counter_model
Checker variables may have an optional qualifier. In this case, they are called free variables; free
rand
variables may behave nondeterministically.
494
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Formal analysis tools shall take into account all possible values of the free checker variables imposed by the
assumptions and assignments (see 17.7.1). Simulators shall assign random values to the free variables as
explained in 17.7.2.
The following example shows how free variables can be used for modeling for formal verification:
checker observer_model(bit valid, reset);
default clocking @$global_clock; endclocking
rand bit flag;
m1: assume property (reset |=> !flag);
m2: assume property (!reset && flag |=> flag);
m3: assume property ($rising_gclk(flag) |-> valid);
endchecker : observer_model
In this example, the following constraints are imposed on the free variable :
flag
— If it is high, it remains high as long as there is no .
reset
— If there is a , it becomes low at the next tick of the clock.
reset
— It may rise only when is high.
valid
Although the behavior of the free variable has been restricted by the assumptions , , and , it is
flag m1 m2 m3
still nondeterministic because it does not have to rise when is high. Figure17-1 shows two possible
valid
legal behaviors of this variable given the same behaviors of and . Formal analysis tools shall
reset valid
take all possible legal behaviors of into account. Simulators shall assign random values to the variable
flag
as explained in 17.7.2.
flag
Figure17-1—Nondeterministic free checker variable
The following example shows how free variables may be used to implement a nondeterministic choice:
// a may assume values 3 and 5 only
rand bit r;
let a = r ? 3'd3 : 3'd5;
A free variable declaration may have a qualifier. If a constant free variable is initialized, it retains its
const
initial value forever. An uninitialized constant free variable has a nondeterministic value at the initialization,
and this value does not change. The following examples demonstrate the usage of constant free checker
variables.
Formal analysis tools shall take into account any possible values of a constant free checker variable
consistent with the imposed assumptions. Simulators shall assign a random constant value to a constant free
variable as explained in 17.7.2.
495
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Examples:
Reasoning about a representative bit:
checker reason_about_one_bit(bit [63:0] data1, bit [63:0] data2,
event clock);
rand const bit [5:0] idx;
a1: assert property (@clock data1[idx] == data2[idx]);
endchecker : reason_about_one_bit
In this example the assertion states that any fixed bit of has the same value as the corresponding
a1 data1
bit of . Therefore, the checker is equivalent in formal verification to the
data2 reason_about_one_bit
following checker (these two checkers are not equivalent in simulation):
checker reason_about_all_bit(bit [63:0] data1, bit [63:0] data2,
event clock);
a1: assert property (@clock data1 == data2);
endchecker : reason_about_all_bit
The second realization of the checker compares two 64-bit values while the first one compares only 1-bit
values, for every possible index. The first version may be more efficient for some formal tools.
Data integrity checking:
// If start_ev is asserted then the value of out_data at the next assertion
// of end_ev has to be equal to the current value of in_data at start_ev.
//
// It is assumed that in_data and out_data have the same size
checker data_legal(start_ev, end_ev, in_data, out_data);
rand const bit [$bits(in_data)-1:0] mem_data;
sequence transaction;
start_ev && (in_data == mem_data) ##1 end_ev[->1];
endsequence
a1: assert property (@clock transaction |-> out_data == mem_data);
endchecker : data_legal
Since is a constant free variable, if is equal to at the beginning of the
mem_data in_data mem_data
transaction, then records that value and keeps it throughout the trace. In particular, at the end of
mem_data
the transaction, still holds that value and the assertion checks that it is equal to .
mem_data out_data
Moreover, was initialized with a nondeterministic value; it follows that for every value of
mem_data
, there exists a computation in which is equal to that value of , which in turn
in_data mem_data in_data
implies that the corresponding legality of data transfer through that transaction is being checked for formal
verification. In simulation will be randomly initialized (see 17.7.2), and it will only be checked
mem_data
that if at the transaction beginning equals to then at the transaction end will
in_data mem_data out_data
have the same value as at the beginning of the transaction.
in_data
The latter example may be rewritten for formal verification using local variables instead of constant free
variables (see 16.10; these implementations are not equivalent in simulation):
// If start_ev is asserted then the value of in_data has to be
// equal to the value of out_data at the next assertion of end_ev
//
// It is assumed that in_data and out_data have the same size
checker data_legal_with_loc(start_ev, end_ev, in_data, out_data);
sequence transaction (loc_var);
(start_ev, loc_var = in_data) ##1 end_ev[->1];
496
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
endsequence
property data_legal;
bit [$bits(in_data)-1:0] mem_data;
transaction(mem_data) |-> out_data == mem_data;
endproperty
a1: assert property (@clock data_legal);
endchecker : data_legal_with_loc
There is a difference between a constant and a non-constant free variable: a constant free variable does not
change its value, while a non-constant free variable can assume a new value any time. If a non-constant free
variable has been initialized but is never assigned then it can assume any value at any time step in formal
verification, or be randomized in subsequent time steps in simulation (see 17.7.2), except the first one where
its value is defined by the initialization. Consider the following declaration:
rand bit a = 1'b0, b;
The free variable has initial value 0, but in other time steps its value may change. The free checker variable
a
may assume any value 0 or 1 at any time (in formal verification or randomized in simulation), as opposed
b
to an uninitialized constant free checker variable, which keeps one specific value.
17.7.1 Checker variable assignments
Checker variables may be assigned using blocking and nonblocking procedural assignments, or
non-procedural continuous assignments.
The following rules and restrictions apply:
— In procedures only nonblocking assignments are allowed.
always_ff
— Referencing a checker variable using its hierarchical name in assignments (see 23.6) shall be illegal.
For example:
checker check(...)
bit a;
...
endchecker
module m(...)
...
check my_check(...);
...
wire x = my_check.a; // Illegal
bit y;
...
always @(posedge clk) begin
my_check.a = y; // Illegal
...
end
...
endmodule
— Continuous assignments and blocking procedural assignments to free checker variables shall be
illegal.
checker check1(bit a, b, event clk, ...);
rand bit x, y, z, v;
...
497
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
assign x = a & b; // Illegal
always_comb
y = a & b; // Illegal
always_ff @clk
z <= a & b; // OK
endchecker : check1
— A checker variable may not be assigned in an procedure, but may be initialized in its
initial
declaration. For example:
bit v;
initial v = 1'b0; // Illegal
bit w = 1'b0; // OK
— The right-hand side of a checker variable assignment may contain the sequence method
triggered
(see 16.13.6).
— The left-hand side of a nonblocking assignment may contain a free checker variable. The following
example illustrates usage of free variable assignments.
// Toggling variable:
// a may have either 0101... or 1010... pattern
rand bit a;
always_ff @clk a <= !a;
17.7.2 Checker variable randomization with assumptions
Checker statements are used to describe assumptions that may be made about the values of
assume
variables. They may be used by simulators to constrain the random generation of free checker variable
values or by formal tools to constrain the formal computation. As with normal statements, checker
assume
statements shall also be checked for violation during simulation.
assume
Assume-based checker variable randomization is the process of periodically solving a set of properties
appearing in statements (called an assume set) to find satisfying values for the free checker
assume
variables, and updating those variables with the newfound values. Unlike class-based constrained random
generation, solving is triggered by any of the clock events of the properties in the assume set (called an
assume set clock event) rather than by an explicit procedural call [e.g., there is no for
randomize()
checkers]. Once updated with solution values, free checker variables shall remain constant until the next
assume set clock event or the end of the time step, whichever comes first.
All non- free checker variables are treated as either active or inactive for assume-based
const
randomization, in the same way as variables for class-based constrained random generation (see 17.9),
rand
but without an explicit control facility [such as ]. All other variables (such as non-free
rand_mode()
checker variables and checker formals) are always treated as inactive. Any free checker variables that appear
on the left-hand side of a checker variable assignment (see 17.7.1) are inactive; all other free checker
variables are active. Free checker variables are active or inactive for each singular element of the variable.
For example, a packed array or structure is active or inactive monolithically, whereas the elements of an
unpacked array or structure are separately active or inactive.
All free checker variables, both and non- , active and inactive, are initialized with
const const
unconstrained random values unless explicitly initialized in their declaration.
Each checker instance has one and only one assume set, which may be empty. Like checker procedures and
variables, checker assume sets are considered to exist at every time step, regardless of whether the checker
instance is static or procedural (see 17.3).
498
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The assume set of a checker instance is formed from the checker statements and child checker
assume
statements. Any of these statements that references a formal whose actual argument
assume assume
contains any subexpression that is a cast or automatic value (see 17.3) is excluded from the assume
const
set. This restriction allows a single copy of the assume set to exist for each instantiation that is valid for the
entire simulation, as described in 17.3. Among the remaining statements, those that reference active
assume
free variables of the checker are included in the assume set. For example:
module my_mod();
bit mclk, v1, v2;
checker c1(bit fclk, bit a, bit b);
default clocking @ (posedge fclk); endclocking
checker c2(bit bclk, bit x, bit y);
default clocking @ (posedge bclk); endclocking
rand bit m, n;
u1: assume property (f1(x,m));
u2: assume property (f2(y,n));
endchecker
rand bit q, r;
c2 B1(fclk, q+r, r);
always_ff @ (posedge fclk)
r <= a || q; // assignment makes r inactive
u3: assume property (f3(a, q));
u4: assume property (f4(b, r));
endchecker
...
c1 F1(mclk, v1, const'(v2));
endmodule
The assume set of consists of and . The property is included because it
F1 F1.u3 F1.B1.u1 F1.B1.u1
references the formal , whose actual expression involves an active free checker variable. is
x q+r F1.u4
excluded because it references the formal , which is associated with the cast actual .
b const v2 F1.B1.u2
is excluded because the only formal referenced is , which is not associated with an active free variable
y
actual (the actual is inactive). However, checker instance has its own assume set, which includes
r F1.B1
as well as ; neither of those statements involve formals with cast or automatic actuals.
u2 u1 assume const
When a solution attempt is made on an assume set, values shall be sought for all active checker variables
such that, together with the inactive variables and state, none of the assumptions will fail in that time step. If
a set of such values is found, the solution attempt is successful. Otherwise, any values may be chosen for the
active variables and the solution attempt is unsuccessful. There is no requirement that a solution be found if
it exists or that “dead end” states (states where no solution exists) be avoided. For example,
u_deadend: assume property (@(posedge clk) x |=> ##5 1'b0);
If the value 1 is chosen for , the property would not fail in the current time step; however, it would
x
inevitably fail six clock cycles later. Such an inevitable future failure is called a dead end. Despite the dead
end, selecting 1 for is considered a successful solution attempt.
x
Empty assume sets shall be considered to have an implicit assume set clock event in every time step before
the Observed region. Active variables in checkers with empty assume sets are called implicitly clocked
active free variables; those with nonempty assume sets are explicitly clocked. Implicitly clocked active
variables may be updated with unconstrained random values at every time step. Once updated, the variables
stay constant until the end of the time step.
Active variables that do not appear in any property in a nonempty assume set are unconstrained but
explicitly clocked. They may be updated with random values at every assume set clock event.
499
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
When an implementation is about to begin the Observed region, it shall solve for all the active free checker
variables using sampled values of all other variables. A sampled value of an active checker variable is
defined as its current value (see 16.5.1). Note that checker procedures and properties execute in the Reactive
and Observed regions (see 17.7.3), and so have the new values available.
When a solution attempt is unsuccessful, any resulting assumption failure(s) do not occur until an
unsatisfied property is clocked and checked in the Observed region.
17.7.3 Scheduling semantics
Statements and constructs within a checker that are sensitive to changes (e.g., clocking events, continuous
assignments) and all blocking statements are scheduled in the Reactive region (similarly to programs, see
24.3.1). The nonblocking assignments of checker variables schedule their updates in the Re-NBA region.
The Re-NBA region is processed after the Reactive and Re-Inactive regions have been emptied of events
(see 4.2). These scheduling rules make possible assignment of sequence end point values to checker
variables. For example:
checker my_check(...);
...
sequence s; ...; endsequence
always_ff @clk a <= s.triggered;
endchecker
For every transition of signal , the simulator will update the variable in the Re-NBA region with the
clk a
value of captured in the Reactive region. Had the checker captured the value of
s.triggered
in the Active region, would always be assigned , since is evaluated in
s.triggered a 1'b0 s.triggered
the Observed region, and the preceding code would be meaningless.
If a free variable is referenced in several assumptions, and some of these assumptions are governed by a
clock changing in the Active region, and others by a clock changing in the Reactive region, assertions and
assumptions referencing this free variable can be executed twice in the same time step. This can result in an
undesired behavior in simulation. For example:
checker check(bit clk1); // clk1 assigned in the Active region
rand bit v, w;
assign clk2 = clk1;
m1: assume property (@clk1 !(v && w));
m2: assume property (@clk2 v || w);
a1: assert property (@clk1 v != w);
// ...
endchecker : check
After changes in the Active region, assumption and assertion are executed in the Observed
clk1 m1 a1
region. Both free variables and may be assigned the value , which causes assertion to fail. Then
v w 0 a1
changes in the Reactive region, and the simulator enters the Observed region again, where assumption
clk2
is evaluated. As a result, new values are assigned to and (see 17.7.2), and these values can become
m2 v w 0
and , respectively. The free variables and then keep their values until the next tick of .
1 v w clk1
Concurrent assertions have invariant scheduling semantics, whether present in checker code or design code.
17.8 Functions in checkers
The formal arguments and internal variables of functions used in checkers shall not be declared as free
variables. However, free variables are allowed to be passed in as actual arguments to a function.
500
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Expressions at the right-hand side of checker variable assignments are allowed to include function calls with
the same restrictions that are imposed on function calls in concurrent assertions (see 16.6):
— Functions that appear in expressions shall not contain or arguments ( is
output ref constref
allowed).
— Functions shall be automatic (or preserve no state information) and have no side effects.
See an example of a function used in a checker in 17.9.
17.9 Complex checker example
The checkers in the following examples make sure that the expression is true in a window delimited by
and . When and are Boolean, the checker may be
start_event end_event start_event end_event
implemented as shown in Example 1.
Example 1:
typedef enum { cover_none, cover_all } coverage_level;
checker assert_window1 (
logic test_expr, // Expression to be true in the window
untyped start_event, // Window opens at the completion of the start_event
untyped end_event, // Window closes at the completion of the end_event
event clock = $inferred_clock,
logic reset = $inferred_disable,
string error_msg = "violation",
coverage_level clevel = cover_all // This argument should be bound to an
// elaboration time constant expression
);
default clocking @clock; endclocking
default disable iff reset;
bit window = 1'b0, next_window = 1'b1;
// Compute next value of window
always_comb begin
if (reset || window && end_event)
next_window = 1'b0;
else if (!window && start_event)
next_window = 1'b1;
else
next_window = window;
end
always_ff @clock
window <= next_window;
property p_window;
start_event && !window |=> test_expr[+] ##0 end_event;
endproperty
a_window: assert property (p_window) else $error(error_msg);
generate if (clevel != cover_none) begin : cover_b
cover_window_open: cover property (start_event && !window)
$display("window_open covered");
cover_window: cover property (
start_event && !window
##1 (!end_event && window) [*]
##1 end_event && window
501
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
) $display("window covered");
end : cover_b
endgenerate
endchecker : assert_window1
If and may be arbitrary sequences, and not necessary Boolean values, the
start_event end_event
checker needs to be implemented differently, as shown in Example 2. This case requires a different
implementation because the reset of the triggered status of a sequence does not create an event (see 9.4.4),
and therefore a sequence method should not be used in the right-hand side of a continuous
triggered
assignment or of an assignment in an procedure.
always_comb
Example 2:
typedef enum { cover_none, cover_all } coverage_level;
checker assert_window2 (
logic test_expr, // Expression to be true in the window
sequence start_event, // Window opens at the completion of the start_event
sequence end_event, // Window closes at the completion of the end_event
event clock = $inferred_clock,
logic reset = $inferred_disable,
string error_msg = "violation",
coverage_level clevel = cover_all // This argument should be bound to an
// elaboration time constant expression
);
default clocking @clock; endclocking
default disable iff reset;
bit window = 0;
let start_flag = start_event.triggered;
let end_flag = end_event.triggered;
// Compute next value of window
function bit next_window (bit win);
if (reset || win && end_flag)
return 1'b0;
if (!win && start_flag)
return 1'b1;
return win;
endfunction
always_ff @clock
window <= next_window(window);
property p_window;
start_flag && !window |=> test_expr[+] ##0 end_flag;
endproperty
a_window: assert property (p_window) else $error(error_msg);
generate if (clevel != cover_none) begin : cover_b
cover_window_open: cover property (start_flag && !window)
$display("window_open covered");
cover_window: cover property (
start_flag && !window
##1 (!end_flag && window) [*]
##1 end_flag && window
) $display("window covered");
end : cover_b
endgenerate
endchecker : assert_window2
502
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
18. Constrained random value generation
18.1 General
This clause describes the following:
— Random variables
— Constraint blocks
— Randomization methods
— Disabling randomization
— Controlling constraints
— Scope variable randomization
— Seeding the random number generator (RNG)
— Random weighted case statements
— Random sequence generation
18.2 Overview
Constraint-driven test generation allows users to automatically generate tests for functional verification.
Random testing can be more effective than a traditional, directed testing approach. By specifying
constraints, one can easily create tests that can find hard-to-reach corner cases. SystemVerilog allows users
to specify constraints in a compact, declarative way. The constraints are then processed by a solver that
generates random values that meet the constraints.
The random constraints are typically specified on top of an object-oriented data abstraction that models the
data to be randomized as objects that contain random variables and user-defined constraints. The constraints
determine the legal values that can be assigned to the random variables. Objects are ideal for representing
complex aggregate data types and protocols such as Ethernet packets.
Subclause 18.3 provides an overview of object-based randomization and constraint programming. The rest
of this clause provides detailed information on random variables, constraint blocks, and the mechanisms
used to manipulate them.
18.3 Concepts and usage
This subclause introduces the basic concepts and uses for generating random stimulus within objects.
SystemVerilog uses an object-oriented method for assigning random values to the member variables of an
object, subject to user-defined constraints. For example:
class Bus;
rand bit[15:0] addr;
rand bit[31:0] data;
constraint word_align {addr[1:0] == 2'b0;}
endclass
The class models a simplified bus with two random variables, and , representing the address
Bus addr data
and data values on a bus. The constraint declares that the random values for must be
word_align addr
such that is word-aligned (the low-order 2 bits are 0).
addr
The method is called to generate new random values for a bus object:
randomize()
503
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Bus bus = new;
repeat (50) begin
if ( bus.randomize() == 1 )
$display ("addr = %16h data = %h\n", bus.addr, bus.data);
else
$display ("Randomization failed.\n");
end
Calling causes new values to be selected for all of the random variables in an object so that
randomize()
all of the constraints are true (satisfied). In the preceding program test, a object is created and then
bus
randomized 50 times. The result of each randomization is checked for success. If the randomization
succeeds, the new random values for and are printed; if the randomization fails, an error
addr data
message is printed. In this example, only the value is constrained, while the value is
addr data
unconstrained. Unconstrained variables are assigned any value in their declared range.
Constraint programming is a powerful method that lets users build generic, reusable objects that can later be
extended or constrained to perform specific functions. The approach differs from both traditional procedural
and object-oriented programming, as illustrated in this example that extends the class:
Bus
typedef enum {low, mid, high} AddrType;
class MyBus extends Bus;
rand AddrType atype;
constraint addr_range
{
(atype == low ) -> addr inside { [0 : 15] };
(atype == mid ) -> addr inside { [16 : 127]};
(atype == high) -> addr inside {[128 : 255]};
}
endclass
The class inherits all of the random variables and constraints of the class and adds a random
MyBus Bus
variable called that is used to control the address range using another constraint. The
atype addr_range
constraint uses implication to select one of three range constraints depending on the random value of .
atype
When a object is randomized, values for , , and are computed so that all of the
MyBus addr data atype
constraints are satisfied. Using inheritance to build layered constraint systems enables the development of
general-purpose models that can be constrained to perform application-specific functions.
Objects can be further constrained using the construct, which declares additional
randomize() with
constraints in-line with the call to :
randomize()
task exercise_bus (MyBus bus);
int res;
// EXAMPLE 1: restrict to low addresses
res = bus.randomize() with {atype == low;};
// EXAMPLE 2: restrict to address between 10 and 20
res = bus.randomize() with {10 <= addr && addr <= 20;};
// EXAMPLE 3: restrict data values to powers-of-two
res = bus.randomize() with {(data & (data - 1)) == 0;};
endtask
504
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
This example illustrates several important properties of constraints, as follows:
— Constraints can be any SystemVerilog expression with variables and constants of integral type (e.g.,
, , , , , ).
bit reg logic integer enum packed struct
— The constraint solver shall be able to handle a wide spectrum of equations, such as algebraic
factoring, complex Boolean expressions, and mixed integer and bit expressions. In the previous
example, the power-of-two constraint was expressed arithmetically. It could have also been defined
with expressions using a shift operator; for example, , where is a 5-bit random variable.
1 << n n
— If a solution exists, the constraint solver shall find it. The solver can fail only when the problem is
over-constrained and there is no combination of random values that satisfy the constraints.
— Constraints interact bidirectionally. In this example, the value chosen for depends on
addr atype
and how it is constrained, and the value chosen for depends on and how it is
atype addr
constrained.All expression operators are treated bidirectionally, including the implication operator
( ).
->
— Constraints support only 2-state values. The 4-state values ( or ) or 4-state operators (e.g., ,
X Z ===
) are illegal and shall result in an error.
!==
— For each active random variable of type,the solver shall select a value from the set of named
enum
constants defined by the corresponding .The solver shall not assign a value to a random vari-
enum
able of type that lies outside its associated named constant set, even if the value can be suc-
enum
cessfully cast to the enumerated type. Note that state variables of type may contain values
enum
outside the set of named constants, which may still allow a valid solution.
enum
Sometimes it is desirable to disable constraints on random variables. For example, to deliberately generate
an illegal address (nonword-aligned):
task exercise_illegal(MyBus bus, int cycles);
int res;
// Disable word alignment constraint.
bus.word_align.constraint_mode(0);
repeat (cycles) begin
// CASE 1: restrict to small addresses.
res = bus.randomize() with {addr[0] || addr[1];};
...
end
// Reenable word alignment constraint
bus.word_align.constraint_mode(1);
endtask
The method can be used to enable or disable any named constraint block in an
constraint_mode()
object. In this example, the word-alignment constraint is disabled, and the object is then randomized with
additional constraints forcing the low-order address bits to be nonzero (and thus unaligned).
The ability to enable or disable constraints allows users to design constraint hierarchies. In these hierarchies,
the lowest level constraints can represent physical limits grouped by common properties into named
constraint blocks, which can be independently enabled or disabled.
Similarly, the method can be used to enable or disable any random variable. When a random
rand_mode()
variable is disabled, it behaves in exactly the same way as other nonrandom variables.
Occasionally, it is desirable to perform operations immediately before or after randomization. That is
accomplished via two built-in methods, and , which are
pre_randomize() post_randomize()
505
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
automatically called before and after randomization. These methods can be overridden with the desired
functionality:
class XYPair;
rand integer x, y;
endclass
class MyXYPair extends XYPair
function void pre_randomize();
super.pre_randomize();
$display("Before randomize x=%0d, y=%0d", x, y);
endfunction
function void post_randomize();
super.post_randomize();
$display("After randomize x=%0d, y=%0d", x, y);
endfunction
endclass
By default, and call their overridden base class methods. When
pre_randomize() post_randomize()
or are overridden, care must be taken to invoke the base class’s
pre_randomize() post_randomize()
methods, unless the class is a base class (has no base class). Otherwise, the base class methods shall not be
called.
The random stimulus generation capabilities and the object-oriented constraint-based verification
methodology enable users to quickly develop tests that cover complex functionality and better assure design
correctness.
18.4 Random variables
Class variables can be declared random using the and type-modifier keywords.
rand randc
The syntax to declare a random variable in a class is as follows in Syntax18-1.
class_property ::= // from A.1.9
{ property_qualifier } data_declaration
property_qualifier8 ::=
random_qualifier
| class_item_qualifier
random_qualifier8 ::=
rand
|
randc
8) In any one declaration, only one of or is allowed, only one of or is allowed,
protected local rand randc
and and/or can appear only once.
static virtual
Syntax18-1—Random variable declaration syntax (excerpt from AnnexA)
— The solver can randomize singular variables of any integral type.
— Arrays can be declared or , in which case all of their member elements are treated as
rand randc
or .
rand randc
506
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Individual array elements can be constrained, in which case the index expression may include
iterative constraint loop variables, constants, and state variables.
— Dynamic arrays, associative arrays and queues can be declared or . All of the elements
rand randc
in the array are randomized, overwriting any previous data.
— The size of a dynamic array or queue declared as or can also be constrained. In that
rand randc
case, the array shall be resized according to the size constraint, and then all the array elements shall
be randomized. The array size constraint is declared using the method. For example:
size
rand bit [7:0] len;
rand integer data[];
constraint db { data.size == len; }
The variable is declared to be 8 bits wide. The randomizer computes a random value for the
len len
variable in the 8-bit range of 0 to 255 and then randomizes the first elements of the data array.
len
When a dynamic array is resized by , the resized array is initialized (see 7.5.1) with
randomize()
the original array. When a queue is resized by , elements are inserted or deleted (see
randomize()
7.10.2.2 and 7.10.2.3) at the back (i.e., right side) of the queue as necessary to produce the new
queue size; any new elements inserted take on the default value of the element type. That is, the
resize grows or shrinks the array. This is significant for a dynamic array or queue of class handles.
does not allocate any class objects. Up to the new size, existing class objects are
randomize()
retained and their content randomized. If the new size is greater than the original size, each of the
additional elements has a value requiring no randomization.
null
In resizing a dynamic array or queue by or , the of each retained
randomize() new rand_mode
element is preserved and the of each new element is set to active.
rand_mode
If a dynamic array’s size is not constrained, then the array shall not be resized and all the array
elements shall be randomized.
— An object handle can be declared , in which case all of that object’s variables and constraints
rand
are solved concurrently with the variables and constraints of the object that contains the handle.
Randomization shall not modify the actual object handle. Object handles shall not be declared
.
randc
— An unpacked structure can be declared , in which case all of that structure’s random members
rand
are solved concurrently using one of the rules listed in this subclause. Unpacked structures shall not
be declared . A member of an unpacked structure can be made random by having a or
randc rand
modifier in the declaration of its type.
randc
For example:
class packet;
typedef struct {
randc int addr = 1 + constant;
int crc;
rand byte data [] = {1,2,3,4};
} header;
rand header h1;
endclass
packet p1=new;
— Unpacked unions shall not be declared or .
rand randc
— Packed tagged unions shall not be declared or .
rand randc
— A packed untagged union can be declared or , in which case that union is treated as an
rand randc
integral type. Members of packed untagged unions shall not have a random modifier.
507
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— A packed structure can be declared or , in which case that structure is treated as an
rand randc
integral type. Members of packed structures shall not have a random modifier.
— If a variable of packed structure or packed untagged union type has a member of type,
rand enum
the rules in 18.3 restricting the random values of an variable shall not apply to that member.
enum
For example:
typedef enum bit [1:0] { A=2'b00, B=2'b11 } ab_e;
typedef struct packed {
ab_e ValidAB;
} VStructEnum;
typedef union packed {
ab_e ValidAB;
} VUnionEnum;
When randomizing a variable of type , the solver can only select a random value of or
ab_e 2'b00
( or , respectively). However, when randomizing a variable of type or
2'b11 A B VStructEnum
, the solver can select , , or .
VUnionEnum 2'b00 2'b01 2'b10 2'b11
18.4.1 Rand modifier
Variables declared with the keyword are standard random variables. Their values are uniformly
rand
distributed over their range. For example:
rand bit [7:0] y;
This is an 8-bit unsigned integer with a range of 0 to 255. If unconstrained, this variable shall be assigned
any value in the range of 0 to 255 with equal probability. In this example, the probability of the same value
repeating on successive calls to is 1/256.
randomize()
18.4.2 Randc modifier
Variables declared with the keyword are random-cyclic variables that cycle through all the values in
randc
a random permutation of their declared range.
To understand , consider a 2-bit random variable :
randc y
randc bit [1:0] y;
The variable can take on the values 0, 1, 2, and 3 (range of 0 to 3). computes an initial
y randomize()
random permutation of the range values of and then returns those values in order on successive calls. After
y
it returns the last element of a permutation, it repeats the process by computing a new random permutation.
The basic idea is that randomly iterates over all the values in the range and that no value is repeated
randc
within an iteration. When the iteration finishes, a new iteration automatically starts (see Figure18-1).
The permutation sequence for any given variable is recomputed whenever the constraints change on
randc
that variable or when none of the remaining values in the permutation can satisfy the constraints. The
permutation sequence shall contain only 2-state values.
To reduce memory requirements, implementations may impose a limit on the maximum size of a
randc
variable, but it shall be no less than 8 bits.
508
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
initial permutation: 0 3 2 1
next permutation: 2 1 3 0
...
next permutation: 2 0 1 3
Figure18-1—Example of randc
The semantics of random-cyclical variables requires that they be solved before other random variables. A set
of constraints that includes both and variables shall be solved so that the variables are
rand randc randc
solved first, and this can sometimes cause to fail.
randomize()
If a random variable is declared as , the randc state of the variable shall also be static. Thus
static
chooses the next cyclic value (from a single sequence) when the variable is randomized
randomize()
through any instance of the base class.
18.5 Constraint blocks
The values of random variables are determined using constraint expressions that are declared using
constraint blocks. Constraint blocks are class members, like tasks, functions, and variables. Constraint block
names shall be unique within a class.
The syntax to declare a constraint block is as follows in Syntax18-2.
constraint_declaration ::= // from A.1.10
[ ] constraint_identifier constraint_block
static constraint
constraint_block ::= { constraint_block_item }
{ }
constraint_block_item ::=
solve_before_list solve_before_list
solve before ;
| constraint_expression
solve_before_list ::= constraint_primary { constraint_primary }
,
constraint_primary ::= [ implicit_class_handle | class_scope ] hierarchical_identifier select
.
constraint_expression ::=
[ ] expression_or_dist
soft ;
| expression constraint_set
–>
| expression constraint_set [ constraint_set ]
if( ) else
| ps_or_hierarchical_array_identifier loop_variables constraint_set
foreach ( [ ])
| constraint_primary
disablesoft ;
constraint_set ::=
constraint_expression
| { constraint_expression }
{ }
dist_list ::= dist_item { dist_item }
,
dist_item ::= value_range [ dist_weight ]
dist_weight ::=
expression
:=
| expression
:/
509
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
constraint_prototype ::= [constraint_prototype_qualifier] [ ] constraint_identifier
static constraint ;
constraint_prototype_qualifier ::= |
extern pure
extern_constraint_declaration ::=
[ ] class_scope constraint_identifier constraint_block
static constraint
identifier_list ::= identifier { identifier }
,
expression_or_dist ::= expression [ dist_list ] // from A.2.10
dist{ }
loop_variables ::= [ index_variable_identifier ] { [ index_variable_identifier ] } // from A.6.8
,
Syntax18-2—Constraint syntax (excerpt from AnnexA)
The constraint_identifier is the name of the constraint block. This name can be used to enable or disable a
constraint using the method (see 18.9).
constraint_mode()
The constraint_block is a list of expression statements that restrict the range of a variable or define relations
between variables. A constraint_expression is any SystemVerilog expression or one of the
constraint-specific operators, and (see 18.5.4 and 18.5.6, respectively).
dist ->
The declarative nature of constraints imposes the following restrictions on constraint expressions:
— Functions are allowed with certain limitations (see 18.5.12).
— Operators with side effects, such as and , are not allowed.
++ --
— variables cannot be specified in ordering constraints (see ... in 18.5.10).
randc solve before
— expressions cannot appear in other expressions.
dist
18.5.1 External constraint blocks
Constraint blocks can be declared outside their enclosing class declaration if a constraint prototype appears
in the enclosing class declaration. A constraint prototype specifies that the class shall have a constraint of the
specified name, but does not specify a constraint block to implement that constraint. A constraint prototype
can take either of two forms, as shown in the following example:
class C;
rand int x;
constraint proto1; // implicit form
extern constraint proto2; // explicit form
endclass
For both forms the constraint can be completed by providing an external constraint block using the class
scope resolution operator, as in the following example:
constraint C::proto1 { x inside {-4, 5, 7}; }
constraint C::proto2 { x >= 0; }
An external constraint block shall appear in the same scope as the corresponding class declaration and shall
appear after the class declaration in that scope. If the explicit form of constraint prototype is used, it shall be
an error if no corresponding external constraint block is provided. If the implicit form of prototype is used
and there is no corresponding external constraint block, the constraint shall be treated as an empty constraint
and a warning may be issued. An empty constraint is one that has no effect on randomization, equivalent to
a constraint block containing the constant expression 1.
For either form, it shall be an error if more than one external constraint block is provided for any given
prototype, and it shall be an error if a constraint block of the same name as a prototype appears in the same
class declaration.
510
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
18.5.2 Constraint inheritance
Constraints follow the same general rules for inheritance as other class members. The
randomize()
method is virtual and therefore honors constraints of the object on which it was called, regardless of the data
type of the object handle through which the method was called.
A derived class shall inherit all constraints from its superclass. Any constraint in a derived class having the
same name as a constraint in its superclass shall replace the inherited constraint of that name. Any constraint
in a derived class that does not have the same name as a constraint in the superclass shall be an additional
constraint.
If a derived class has a constraint prototype with the same name as a constraint in its superclass, that
constraint prototype shall replace the inherited constraint. Completion of the derived class’s constraint
prototype shall then follow the rules described in 18.5.1.
An abstract class (i.e., a class declared using the syntax , as described in 8.21) may contain
virtual class
pure constraints. A pure constraint is syntactically similar to a constraint prototype but uses the
pure
keyword, as in the following example:
virtual class D;
pure constraint Test;
endclass
A pure constraint represents an obligation on any non-abstract derived class (i.e., a derived class that is not
) to provide a constraint of the same name. It shall be an error if a non-abstract class does not have
virtual
an implementation of every pure constraint that it inherits. It shall be an error to declare a pure constraint in
a non-abstract class.
It shall be an error if a class containing a pure constraint also has a constraint block, constraint prototype or
external constraint block of the same name. However, any class (whether abstract or not) may contain a
constraint block or constraint prototype of the same name as a pure constraint that the class inherits; such a
constraint shall override the pure constraint, and shall be a non-pure constraint for the class and any class
derived from it.
An abstract class that inherits a constraint from its superclass may have a pure constraint of the same name.
In this case, the pure constraint in the derived virtual class shall replace the inherited constraint.
A constraint that overrides a pure constraint may be declared using a constraint block in the body of the
overriding class, or may be declared using a constraint prototype and external constraint as described in
18.5.1.
18.5.3 Set membership
Constraints support integer value sets and the set membership operator (as defined in 11.4.13).
Absent any other constraints, all values (either single values or value ranges) have an equal probability of
being chosen by the operator.
inside
The negated form of the operator denotes that expression lies outside the set:
inside !(expression
.
inside { set })
For example:
rand integer x, y, z;
constraint c1 {x inside {3, 5, [9:15], [24:32], [y:2*y], z};}
511
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
rand integer a, b, c;
constraint c2 {a inside {b, c};}
integer fives[4] = '{ 5, 10, 15, 20 };
rand integer v;
constraint c3 { v inside {fives}; }
In SystemVerilog, the operator is bidirectional; thus, the preceding second example is equivalent to
inside
.
a == b || a == c
18.5.4 Distribution
In addition to set membership, constraints support sets of weighted values called distributions. Distributions
have two properties: they are a relational test for set membership, and they specify a statistical distribution
function for the results.
The syntax to define a distribution expression is as follows in Syntax18-3.
constraint_expression ::= // from A.1.10
expression_or_dist
;
...
dist_list ::= dist_item { dist_item }
,
dist_item ::= value_range [ dist_weight ]
dist_weight ::=
expression
:=
| expression
:/
expression_or_dist ::= expression [ dist_list ] // from A.2.10
dist{ }
Syntax18-3—Constraint distribution syntax (excerpt from AnnexA)
The expression can be any integral SystemVerilog expression.
The distribution operator evaluates to true if the value of the expression is contained in the set;
dist
otherwise, it evaluates to false.
Absent any other constraints, the probability that the expression matches any value in the list is proportional
to its specified weight. If there are constraints on some expressions that cause the distribution weights on
these expressions to be not satisfiable, implementations are only required to satisfy the constraints. An
exception to this rule is a weight of zero, which is treated as a constraint.
The distribution set is a comma-separated list of integral expressions and ranges. Optionally, each term in
the list can have a weight, which is specified using the or operators. If no weight is specified for an
:= :/
item, the default weight is 1. The weight can be any integral SystemVerilog expression.
:=
The operator assigns the specified weight to the item or, if the item is a range, to every value in the range.
:=
The operator assigns the specified weight to the item or, if the item is a range, to the range as a whole. If
:/
there are values in the range, the weight of each value is . For example:
n range_weight / n
x dist {100 := 1, 200 := 2, 300 := 5}
512
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
means is equal to 100, 200, or 300 with weighted ratio of 1-2-5. If an additional constraint is added that
x
specifies that cannot be 200,
x
x != 200;
x dist {100 := 1, 200 := 2, 300 := 5}
then is equal to 100 or 300 with weighted ratio of 1-5.
x
It is easier to think about mixing ratios, such as 1-2-5, than the actual probabilities, because mixing ratios do
not have to be normalized to 100%. Converting probabilities to mixing ratios is straightforward.
When weights are applied to ranges, they can be applied to each value in the range, or they can be applied to
the range as a whole. For example:
x dist { [100:102] := 1, 200 := 2, 300 := 5}
means is equal to 100, 101, 102, 200, or 300 with a weighted ratio of 1-1-1-2-5, and
x
x dist { [100:102] :/ 1, 200 := 2, 300 := 5}
means is equal to one of 100, 101, 102, 200, or 300 with a weighted ratio of 1/3-1/3-1/3-2-5.
x
In general, distributions guarantee two properties: set membership and monotonic weighting. In other
words, increasing a weight increases the likelihood of choosing those values.
Limitations are as follows:
— A operation shall not be applied to variables.
dist randc
— A expression requires that the expression contain at least one variable.
dist rand
18.5.5 Uniqueness constraints
A group of variables can be constrained using the constraint so that no two members of the group
unique
have the same value after randomization. The group of variables to be constrained shall be specified using a
restricted form of the open_range_list syntax in which each item in the comma-separated list shall be one of
the following:
— A scalar variable of integral type
— An unpacked array variable whose leaf element type is integral, or a slice of such a variable
constraint_expression ::= // from A.1.10
...
| uniqueness_constraint
;
uniqueness_constraint ::=
open_range_list9
unique{ }
9) The open_range_list in a uniqueness_constraint shall contain only expressions that denote scalar or array variables, as
described in 18.5.5.
Syntax18-4—Uniqueness constraint syntax (excerpt from AnnexA)
A leaf element of an unpacked array is found by descending through the array until an element is reached
that is not of unpacked array type.
513
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
All members of the group of variables so specified (that is, any scalar variables, and all leaf elements of any
arrays or slices) shall be of equivalent type. No variable shall appear in the group.
randc
If the group of variables so specified contains fewer than two members, the constraint shall have no effect
and shall not cause a constraint contradiction.
In the following example, variables , , , and will all contain different values after
a[2] a[3] b excluded
randomization. Because of the constraint , none of the variables , , and will contain
exclusion a[2] a[3] b
the value 5.
rand byte a[5];
rand byte b;
rand byte excluded;
constraint u { unique {b, a[2:3], excluded}; }
constraint exclusion { excluded == 5; }
18.5.6 Implication
Constraints provide two constructs for declaring conditional (predicated) relations: implication and
.
if-else
The implication operator ( ) can be used to declare an expression that implies a constraint.
–>
The syntax to define an implication constraint is as follows in Syntax18-5.
constraint_expression ::= // from A.1.10
...
| expression constraint_set
–>
Syntax18-5—Constraint implication syntax (excerpt from AnnexA)
The expression can be any integral SystemVerilog expression.
The Boolean equivalent of the implication operator is . This states that if the expression
a -> b (!a || b)
is true, then random numbers generated are constrained by the constraint (or constraint set). Otherwise, the
random numbers generated are unconstrained.
The constraint_set represents any valid constraint or an unnamed constraint set. If the expression is true, all
of the constraints in the constraint set shall also be satisfied.
For example:
mode == little -> len < 10;
mode == big -> len > 100;
In this example, the value of implies that the value of shall be constrained to less than 10 (
mode len mode
), greater than 100 ( ), or unconstrained ( and
== little mode == big mode != little mode !=
).
big
In the example
rand bit [3:0] a, b;
constraint c { (a == 0) -> (b == 1); }
514
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
both and are 4 bits; therefore, there are 256 combinations of and . Constraint says that
a b a b c a == 0
implies that , thereby eliminating 15 combinations: {0,0}, {0,2}, … {0,15}. Therefore, the
b == 1
probability that is thus 1/(256-15) or 1/241.
a == 0
18.5.7 if–else constraints
The style constraints are also supported.
if–else
The syntax to define an constraint is as follows in Syntax18-6.
if–else
constraint_expression ::= // from A.1.10
...
| expression constraint_set [ constraint_set ]
if( ) else
Syntax18-6—If–else constraint syntax (excerpt from AnnexA)
The expression can be any integral SystemVerilog expression.
The constraint_set represents any valid constraint or an unnamed constraint set. If the expression is true, all
of the constraints in the first constraint or constraint set shall be satisfied; otherwise, all of the constraints in
the optional constraint or constraint set shall be satisfied. Constraint sets can be used to group multiple
else
constraints.
The style constraint declarations are equivalent to implications
if–else
if (mode == little)
len < 10;
else if (mode == big)
len > 100;
which is equivalent to
mode == little -> len < 10 ;
mode == big -> len > 100 ;
In this example, the value of implies that the value of is less than 10, greater than 100, or
mode len
unconstrained.
Just like implication, style constraints are bidirectional. In the preceding declaration, the value of
if–else
constrains the value of , and the value of constrains the value of .
mode len len mode
Because the part of an style constraint declaration is optional, there can be confusion when
else if–else
an is omitted from a nested sequence. This is resolved by always associating the with the
else if else
closest previous that lacks an . In the following example, the goes with the inner , as shown
if else else if
by indentation:
if (mode != big)
if (mode == little)
len < 10;
else // the else applies to preceding if
len > 100;
515
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
18.5.8 Iterative constraints
Iterative constraints allow arrayed variables to be constrained using loop variables and indexing expressions,
or by using array reduction methods.
18.5.8.1 foreach iterative constraints
The syntax to define a iterative constraint is as follows in Syntax18-7.
foreach
constraint_expression ::= // from A.1.10
...
| ps_or_hierarchical_array_identifier loop_variables constraint_set
foreach ( [ ])
loop_variables ::= [ index_variable_identifier ] { [ index_variable_identifier ] } // from A.6.8
,
Syntax18-7—Foreach iterative constraint syntax (excerpt from AnnexA)
The construct specifies iteration over the elements of an array. Its argument is an identifier that
foreach
designates any type of array (fixed-size, dynamic, associative, or queue) followed by a list of loop variables
enclosed in square brackets. Each loop variable corresponds to one of the dimensions of the array.
For example:
class C;
rand byte A[] ;
constraint C1 { foreach ( A [ i ] ) A[i] inside {2,4,8,16}; }
constraint C2 { foreach ( A [ j ] ) A[j] > 2 * j; }
endclass
constrains each element of the array to be in the set [2,4,8,16]. constrains each element of the array
C1 A C2
to be greater than twice its index.
A
The number of loop variables shall not exceed the number of dimensions of the array variable. The scope of
each loop variable is the constraint construct, including its constraint_set. The type of each loop
foreach
variable is implicitly declared to be consistent with the type of array index. An empty loop variable indicates
no iteration over that dimension of the array. As with default arguments, a list of commas at the end can be
omitted; thus, ) is a shorthand for . It shall be
foreach( arr [ j ] foreach( arr [ j, , , , ] )
an error for any loop variable to have the same identifier as the array.
The mapping of loop variables to array indices is determined by the dimension cardinality, as described in
20.7.
// 1 2 3 3 4 1 2 -> Dimension numbers
int A [2][3][4]; bit [3:0][2:1] B [5:1][4];
foreach( A [ i, j, k ] ) ...
foreach( B [ q, r, , s ] ) ...
The first causes to iterate from 0 to 1, from 0 to 2, and from 0 to 3. The second
foreach i j k foreach
causes to iterate from 5 to 1, from 0 to 3, and from 2 to 1.
q r s
iterative constraints can include predicates. For example:
foreach
516
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
class C;
rand int A[] ;
constraint c1 { A.size inside {[1:10]}; }
constraint c2 { foreach ( A[ k ] ) (k < A.size - 1) -> A[k + 1] > A[k]; }
endclass
The first constraint, , constrains the size of the array to be between 1 and 10. The second constraint, ,
c1 A c2
constrains each array value to be greater than the preceding one, i.e., an array sorted in ascending order.
Within a , predicate expressions involving only constants, state variables, object handle
foreach
comparisons, loop variables, or the size of the array being iterated behave as guards against the creation of
constraints, and not as logical relations. For example, the implication in constraint above involves only a
c2
loop variable and the size of the array being iterated; thus, it allows the creation of a constraint only when
k
, which in this case prevents an out-of-bounds access in the constraint. Guards are
< A.size() - 1
described in more detail in 18.5.13.
Index expressions can include loop variables, constants, and state variables. Invalid or out-of-bounds array
indices are not automatically eliminated; users must explicitly exclude these indices using predicates.
The size method of a dynamic array or queue can be used to constrain the size of the array (see constraint
c1
above). If an array is constrained by both size constraints and iterative constraints, the size constraints are
solved first and the iterative constraints next. As a result of this implicit ordering between size constraints
and iterative constraints, the size method shall be treated as a state variable within the block of the
foreach
corresponding array. For example, the expression is treated as a random variable in constraint
A.size c1
and as a state variable in constraint . This implicit ordering can cause the solver to fail in some situations.
c2
18.5.8.2 Array reduction iterative constraints
The array reduction methods can produce a single integral value from an unpacked array of integral values
(see 7.12.3). In the context of a constraint, an array reduction method is treated as an expression iterated over
each element of the array, joined by the relevant operand for each method. The result returns a single value
of the same type as the array element type or, if specified, the type of the expression in the clause. For
with
example:
class C;
rand bit [7:0] A[] ;
constraint c1 { A.size == 5; }
constraint c2 { A.sum() with (int'(item)) < 1000; }
endclass
The constraint will be interpreted as
c2
( int'(A[0])+int'(A[1])+int'(A[2])+int'(A[3])+int'(A[4]) ) < 1000
18.5.9 Global constraints
When an object member of a class is declared , all of its constraints and random variables are
rand
randomized simultaneously along with the other class variables and constraints. Constraint expressions
involving random variables from other objects are called global constraints (see Figure18-2).
class A; // leaf node
rand bit [7:0] v;
endclass
517
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
class B extends A; // heap node
rand A left;
rand A right;
constraint heapcond {left.v <= v; right.v > v;}
endclass
.v
B
.left .right
.v .v
A A
Figure18-2—Global constraints
This example uses global constraints to define the legal values of an ordered binary tree. Class represents a
A
leaf node with an 8-bit value . Class extends class and represents a heap node with value , a left
v B A v
subtree, and a right subtree. Both subtrees are declared as in order to randomize them at the same time
rand
as other class variables. The constraint block named has two global constraints relating the left
heapcond
and right subtree values to the heap node value. When an instance of class is randomized, the solver
B
simultaneously solves for and its left and right children, which in turn can be leaf nodes or more heap
B
nodes.
The following rules determine which objects, variables, and constraints are to be randomized:
a) First, determine the set of objects that are to be randomized as a whole. Starting with the object that
invoked the method, add all objects that are contained within it, are declared ,
randomize() rand
and are active (see in 18.8). The definition is recursive and includes all of the active
rand_mode
random objects that can be reached from the starting object. The objects selected in this step are
referred to as the active random objects.
b) Second, select all of the active constraints from the set of active random objects. These are the
constraints that are applied to the problem.
c) Third, select all of the active random variables from the set of active random objects. These are the
variables that are to be randomized. All other variable references are treated as state variables,
whose current value is used as a constant.
18.5.10 Variable ordering
The solver shall assure that the random values are selected to give a uniform value distribution over legal
value combinations (that is, all combinations of legal values have the same probability of being the
solution). This important property guarantees that all legal value combinations are equally probable, which
allows randomization to better explore the whole design space.
Sometimes, however, it is desirable to force certain combinations to occur more frequently. Consider the
case where a 1-bit control variable constrains a 32-bit data value :
s d
class B;
rand bit s;
rand bit [31:0] d;
constraint c { s -> d == 0; }
endclass
518
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The constraint says “ implies equals zero.” Although this reads as if determines , in fact and are
c s d s d s d
determined together. There are 1 + 232 legal value combinations of , but is true only for one of
{s,d} s
them. Table18-1 lists each of the legal value combinations and the probability of occurrence of each:
Table18-1—Unordered constraint c legal value probability
s d Probability
1/(1 + 232)
1 'h00000000
1/(1 + 232)
0 'h00000000
1/(1 + 232)
0 'h00000001
1/(1 + 232)
0 'h00000002
0 ...
1/(1 + 232)
0 'hfffffffe
1/(1 + 232)
0 'hffffffff
The constraints provide a mechanism for ordering variables so that can be chosen independently of . This
s d
mechanism defines a partial ordering on the evaluation of variables and is specified using the
solve
keyword.
class B;
rand bit s;
rand bit [31:0] d;
constraint c { s -> d == 0; }
constraint order { solve s before d; }
endclass
In this case, the order constraint instructs the solver to solve for before solving for . The effect is that is
s d s
now chosen 0 or 1 with 50/50% probability, and then is chosen subject to the value of . Adding this order
d s
constraint does not change the set of legal value combinations, but alters their probability of occurrence, as
shown in Table18-2:
Table18-2—Ordered constraint c legal value probability
s d Probability
1/2
1 'h00000000
1/2  1/232
0 'h00000000
1/2  1/232
0 'h00000001
1/2  1/232
0 'h00000002
0 ...
1/2  1/232
0 'hfffffffe
1/2  1/232
0 'hffffffff
Note that the probability of is 1/(1 + 232), near 0%, without the order constraint, and is 1/2  1/232,
d==0
slightly over 50%, with the order constraint.
519
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Variable ordering can be used to force selected corner cases to occur more frequently than they would
otherwise. However, a “ ... ...” constraint does not change the solution space and, therefore,
solve before
cannot cause the solver to fail.
The syntax to define variable order in a constraint block is as follows in Syntax18-8.
constraint_block_item ::= // from A.1.10
solve_before_list solve_before_list
solve before ;
| constraint_expression
solve_before_list ::= solve_before_primary { solve_before_primary }
,
solve_before_primary ::= [ implicit_class_handle | class_scope ] hierarchical_identifier select
.
Syntax18-8—Solve...before constraint ordering syntax (excerpt from AnnexA)
The following restrictions apply to variable ordering:
— Only random variables are allowed, that is, they shall be .
rand
— variables are not allowed. variables are always solved before any other.
randc randc
— The variables shall be integral values.
— A constraint block can contain both regular value constraints and ordering constraints.
— There shall be no circular dependencies in the ordering, such as “solve a before b” combined with
“solve b before a.”
— Variables that are not explicitly ordered shall be solved with the last set of ordered variables. These
values are deferred until as late as possible to assure a good distribution of values.
— Variables that are partially ordered shall be solved with the latest set of ordered variables so that all
ordering constraints are met. These values are deferred until as late as possible to assure a good
distribution of values.
— Variables can be solved in an order that is not consistent with the ordering constraints, provided that
the outcome is the same. An example situation where this might occur is as follows:
x == 0;
x < y;
solve y before x;
In this case, because has only one possible assignment (0), can be solved for before . The
x x y
constraint solver can use this flexibility to speed up the solving process.
18.5.11 Static constraint blocks
A constraint block can be defined as static by including the keyword in its definition.
static
The syntax to declare a static constraint block is as follows in Syntax18-9.
constraint_declaration ::= // from A.1.10
[ ] constraint_identifier constraint_block
static constraint
Syntax18-9—Static constraint syntax (excerpt from AnnexA)
520
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If a constraint block is declared as , then calls to shall affect all instances of
static constraint_mode()
the specified constraint in all objects. Thus, if a static constraint is set to OFF, it is off for all instances of that
particular class.
When a constraint is declared using a constraint prototype and an external constraint block, the
static
keyword shall be applied to both the constraint prototype and the external constraint block, or to neither. It
shall be an error if one but not the other is qualified . Similarly, a pure constraint may be qualified
static
but any overriding constraint must match the pure constraint’s qualification or absence thereof.
static
18.5.12 Functions in constraints
Some properties are unwieldy or impossible to express in a single expression. For example, the natural way
to compute the number of ones in a packed array uses a loop:
function int count_ones ( bit [9:0] w );
for( count_ones = 0; w != 0; w = w >> 1 )
count_ones += w & 1'b1;
endfunction
Such a function could be used to constrain other random variables to the number of 1 bits:
constraint C1 { length == count_ones( v ) ; }
Without the ability to call a function, this constraint requires the loop to be unrolled and expressed as a sum
of the individual bits:
constraint C2
{
length == ((v>>9)&1) + ((v>>8)&1) + ((v>>7)&1) + ((v>>6)&1) + ((v>>5)&1) +
((v>>4)&1) + ((v>>3)&1) + ((v>>2)&1) + ((v>>1)&1) + ((v>>0)&1);
}
Unlike the function, more complex properties, which require temporary state or unbounded
count_ones
loops, may be impossible to convert into a single expression. The ability to call functions, thus, enhances the
expressive power of the constraint language and reduces the likelihood of errors. The two constraints,
C1
and , from above are not completely equivalent; is bidirectional ( can constrain and vice
C2 C2 length v
versa), whereas is not.
C1
To handle these common cases, SystemVerilog allows constraint expressions to include function calls, but it
imposes certain semantic restrictions, as follows:
— Functions that appear in constraint expressions cannot contain or arguments (
output ref const
is allowed).
ref
— Functions that appear in constraint expressions should be automatic (or preserve no state informa-
tion) and have no side effects.
— Functions that appear in constraints cannot modify the constraints, for example, calling
rand_mode
or methods.
constraint_mode
— Functions shall be called before constraints are solved, and their return values shall be treated as
state variables.
— Random variables used as function arguments shall establish an implicit variable ordering or
priority. Constraints that include only variables with higher priority are solved before other, lower
priority constraints. Random variables solved as part of a higher priority set of constraints become
state variables to the remaining set of constraints. For example:
521
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
class B;
rand int x, y;
constraint C { x <= F(y); }
constraint D { y inside { 2, 4, 8 } ; }
endclass
forces to be solved before . Thus, constraint is solved separately before constraint , which uses
y x D C
the values of and as state variables. In SystemVerilog, the behavior for variable ordering
y F(y)
implied by function arguments differs from the behavior for ordering specified using the
“ ... ...” constraint; function argument variable ordering subdivides the solution space
solve before
thereby changing it. Because constraints on higher priority variables are solved without considering
lower priority constraints at all, this subdivision can cause the overall constraints to fail. Within each
prioritized set of constraints, cyclical ( ) variables are solved first.
randc
— Circular dependencies created by the implicit variable ordering shall result in an error.
— Function calls in active constraints are executed an unspecified number of times (at least once) in an
unspecified order.
18.5.13 Constraint guards
Constraint guards are predicate expressions that function as guards against the creation of constraints and
not as logical relations to be satisfied by the solver. These predicate expressions are evaluated before the
constraints are solved and are characterized by involving only the following items:
— Constants
— State variables
— Object handle comparisons (comparisons between two handles or a handle and the constant )
null
In addition to these, iterative constraints (see 18.5.8) also consider loop variables and the size of the array
being iterated as state variables.
Treating these predicate expressions as constraint guards prevents the solver from generating evaluation
errors, thereby failing on some seemingly correct constraints. This enables users to write constraints that
avoid errors due to nonexistent object handles or array indices out of bounds. For example, the sort
constraint of the singly linked list, , shown below is intended to assign a random sequence of numbers
SList
that is sorted in ascending order. However, the constraint expression will fail on the last element when
results in an evaluation error due to a nonexistent handle.
next.n
class SList;
rand int n;
rand Slist next;
constraint sort { n < next.n; }
endclass
This error condition can be avoided by writing a predicate expression to guard against that condition:
constraint sort { if( next != null ) n < next.n; }
In the preceding sort constraint, the prevents the creation of a constraint when , which in
if next==null
this case avoids accessing a nonexistent object. Both implication ( ) and … can be used as guards.
–> if else
Guard expressions can themselves include subexpressions that result in evaluation errors (e.g., null
references), and they are also guarded from generating errors. This logical sifting is accomplished by
evaluating predicate subexpressions using the following 4-state representation:
522
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Subexpression evaluates to .
0 FALSE FALSE
— Subexpression evaluates to .
1 TRUE TRUE
— Subexpression causes an evaluation error.
E ERROR
— Expression includes random variables and cannot be evaluated.
R RANDOM
Every subexpression within a predicate expression is evaluated to yield one of the previous four values. The
subexpressions are evaluated in an arbitrary order, and the result of that evaluation plus the logical operation
define the outcome in the alternate 4-state representation. A conjunction ( ), disjunction ( ), or
&& ||
negation ( ) of subexpressions can include some (perhaps all) guard subexpressions. The following rules
!
specify the resulting value for the guard:
— Conjunction ( ): If any one of the subexpressions evaluates to , then the guard evaluates to
&& FALSE
. If any one subexpression evaluates to , then the guard evaluates to . Otherwise,
FALSE ERROR ERROR
the guard evaluates to .
TRUE
• If the guard evaluates to , then the constraint is eliminated.
FALSE
• If the guard evaluates to , then a (possibly conditional) constraint is generated.
TRUE
• If the guard evaluates to , then an error is generated and fails.
ERROR randomize()
— Disjunction ( ): If any one of the subexpressions evaluates to , then the guard evaluates to
|| TRUE
. If any one subexpression evaluates to , then the guard evaluates to . Otherwise,
TRUE ERROR ERROR
the guard evaluates to .
FALSE
• If the guard evaluates to , then a (possibly conditional) constraint is generated.
FALSE
• If the guard evaluates to , then an unconditional constraint is generated.
TRUE
• If the guard evaluates to , then an error is generated and fails.
ERROR randomize()
— Negation ( ): If the subexpression evaluates to , then the guard evaluates to . Other-
! ERROR ERROR
wise, if the subexpression evaluates to or , then the guard evaluates to or ,
TRUE FALSE FALSE TRUE
respectively.
These rules are codified by the truth tables shown in Figure18-3.
&& 0 1 E R || 0 1 E R !
0 0 0 0 0 0 0 1 E R 0 1
1 0 1 E R 1 1 1 1 1 1 0
E 0 E E E E E 1 E E E E
R 0 R E R R R 1 E R R R
Conjunction Disjunction Negation
Figure18-3—Truth tables for conjunction, disjunction, and negation rules
These rules are applied recursively until all subexpressions are evaluated. The final value of the evaluated
predicate expression determines the outcome as follows:
— If the result is , then an unconditional constraint is generated.
TRUE
— If the result is , then the constraint is eliminated and can generate no error.
FALSE
— If the result is , then an unconditional error is generated and the constraint fails.
ERROR
— If the final result of the evaluation is , then a conditional constraint is generated.
RANDOM
523
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
When the final value is , a traversal of the predicate expression tree is needed to collect all
RANDOM
conditional guards that evaluate to . When the final value is , a subsequent traversal of the
RANDOM ERROR
expression tree is not required, allowing implementations to issue only one error.
Example 1:
class D;
int x;
endclass
class C;
rand int x, y;
D a, b;
constraint c1 { (x < y || a.x > b.x || a.x == 5 ) -> x+y == 10; }
endclass
In Example 1, the predicate subexpressions are , , and , which are all
(x < y) (a.x > b.x) (a.x == 5)
connected by disjunction. Some possible cases are as follows:
— Case 1: is non- , is , is 5.
a null b null a.x
Because is true, the fact that generates an error does not result in an error.
(a.x==5) b.x
The unconditional constraint is generated.
(x+y == 10)
— Case 2: is .
a null
This always results in error, irrespective of the other conditions.
— Case 3: is non- , is non- , is 10, is 20.
a null b null a.x b.x
All the guard subexpressions evaluate to .
FALSE
The conditional constraint is generated.
(x<y) -> (x+y == 10)
Example 2:
class D;
int x;
endclass
class C;
rand int x, y;
D a, b;
constraint c1 { (x < y && a.x > b.x && a.x == 5 ) -> x+y == 10; }
endclass
In Example 2, the predicate subexpressions are , , and , which are all
(x < y) (a.x > b.x) (a.x == 5)
connected by conjunction. Some possible cases are as follows:
— Case 1: is non- , is , is 6.
a null b null a.x
Because is false, the fact that generates an error does not result in an error.
(a.x==5) b.x
The constraint is eliminated.
— Case 2: is
a null
This always results in error, irrespective of the other conditions.
— Case 3: is non- , is non- , is 5, is 2.
a null b null a.x b.x
All the guard subexpressions evaluate to , producing constraint .
TRUE (x<y) -> (x+y == 10)
524
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 3:
class D;
int x;
endclass
class C;
rand int x, y;
D a, b;
constraint c1 { (x < y && (a.x > b.x || a.x ==5)) -> x+y == 10; }
endclass
In Example 3, the predicate subexpressions are and , which are
(x < y) (a.x > b.x || a.x == 5)
connected by disjunction. Some possible cases are as follows:
— Case 1: is non- , is , is 5.
a null b null a.x
The guard expression evaluates to , which evaluates to
(ERROR || a.x==5) (ERROR || TRUE)
The guard subexpression evaluates to .
TRUE
The conditional constraint is generated.
(x<y) -> (x+y == 10)
— Case 2: is non- , is , is 8.
a null b null a.x
The guard expression evaluates to and generates an error.
(ERROR || FALSE)
— Case 3: is
a null
This always results in error, irrespective of the other conditions.
— Case 4: is non- , is non- , is 5, is 2.
a null b null a.x b.x
All the guard subexpressions evaluate to .
TRUE
The conditional constraint is generated.
(x<y) -> (x+y == 10)
18.5.14 Soft constraints
The constraints described up to this point can be denoted as hard constraints because the solver must always
satisfy them or result in a solver failure. In contrast, when there is no solution that satisfies all active hard
constraints (if any) simultaneously with a constraint defined as soft, the solver shall discard that soft
constraint and find a solution that satisfies the remaining constraints. If there are two or more soft constraint
expressions that cannot be satisfied simultaneously, the soft constraints shall be discarded as specified in
18.5.14.1.
Soft constraints enable authors of generic verification blocks to provide complete working environments
that are more easily extended because the constraint solver automatically disregards generic soft constraints
overridden by subsequent, more specialized constraints. Soft constraints are often used to specify default
values and distributions for random variables. For example, the author of a generic packet class might add a
constraint to ensure packets of legal size are generated by default (absent any other constraints):
class Packet;
rand bit mode;
rand int length;
constraint deflt {
soft length inside {32,1024};
soft mode -> length == 1024;
// Note: soft mode -> {length == 1024;} is not legal syntax,
// as soft must be followed by an expression
}
endclass
Packet p = new();
p.randomize() with { length == 1512;} // mode will randomize to 0
p.randomize() with { length == 1512; mode == 1;} // mode will randomize to 1
525
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If the constraint expression is not defined as soft, the call to
length inside {32,1024} randomize()
will fail and require special attention. The failure might be resolved by explicitly turning off the constraint,
which requires additional procedural code, or by using a new class to extend the base class and override the
constraint with a new one, which significantly complicates the test. In contrast, a default value specified by a
soft constraint is automatically overridden, which results in a simpler layered test.
18.5.14.1 Soft constraint priorities
Soft constraints only express a preference for one solution over another; they are discarded when they are
contradicted by other more important constraints. Regular (hard) constraints must always be satisfied; they
are never discarded and are thus considered to be of the same highest priority. Conversely, soft constraints
may be overridden by hard constraints or other higher-priority soft constraints, therefore, a specific priority
shall be associated with every soft constraint. The soft priorities are designed such that the last constraint
specified by the user will prevail. Hence, constraints specified in subsequent layers of the verification
environment are assigned higher priorities than those in the preceding layers.
The following rules determine the priorities of soft constraints:
— Constraints within the scope of the same construct—constraint block, class, or struct—are assigned
a priority relative to their syntactic declaration order. Constraint expressions that appear later in the
construct have higher priority.
— Constraints within external constraint blocks are assigned a priority relative to the declaration order
of the constraint prototype ( declaration) in the class. The priority depends on the prototype
extern
declaration and not on the out-of-body declaration. Constraint expressions in out-of-body constraint
blocks whose prototypes appear later in the class have higher priority.
— Constraints in contained objects ( class handles) have lower priority than all constraints in the
rand
container object ( or ).
class struct
— Constraints in each contained object ( class handle) are assigned a priority relative to the
rand
declaration order of their class handle. Constraints in objects whose handles appear later in the
container object ( or ) have higher priority. If the same object is contained multiple
class struct
times, the constraints in the contained object shall have the priority of the highest priority object—
the object whose handle is declared last.
— Constraints in a derived class shall have higher priority than all constraints in its superclasses.
— Constraints within in-line constraint blocks shall have higher priority than constraints in the class
being randomized.
— Soft constraints within a shall have a priority that is defined by iteration order; latter
foreach
iterations shall have higher priority. If the relational operator is not defined for an index type of an
associative array, the priority is implementation dependent.
The following example illustrates the preceding rules:
class B1;
rand int x;
constraint a { soft x > 10 ; soft x < 100 ; }
endclass /* a1 */ /* a2 */
class D1 extends B1;
constraint b { soft x inside {[5:9]} ; }
endclass /* b1 */
class B2;
rand int y;
constraint c { soft y > 10 ; }
endclass /* c1 */
526
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
class D2 extends B2;
constraint d { soft y inside {[5:9]} ; }
constraint e ; /* d1 */
rand D1 p1;
rand B1 p2;
rand D1 p3;
constraint f { soft p1.x < p2.x ; }
endclass /* f1 */
constraint D2::e { soft y > 100 ; }
/* e1 */
D2 d = new();
initial begin
d.randomize() with { soft y inside {10,20,30} ; soft y < p1.x ; };
end /* i1 */ /* i2 */
The relative priority of the soft constraints (highest to lowest) in the preceding example is:
i2 i1 f1 e1 d1 c1 p3.b1 p3.a2 p3.a1 p2.a2->p2.a1->p1.b1->p1.a2 p1.a1
If handles and refer to the same object, the relative priority is:
p1 p3
i2 i1 f1 e1 d1 c1 p3.b1 p3.a2 p3.a1 p2.a2 p2.a1
Soft constraints can only be specified on random variables; they may not be specified for variables.
randc
The constraint solver implements the following conceptual model:
— Consider two soft constraints and , such that has higher priority than .
c1 c2 c1 c2
1) The constraint solver will first try to produce a solution satisfying both and .
c1 c2
2) If it fails in (1) then it will try to produce a solution satisfying only .
c1
3) If it fails in (2) then it will try to produce a solution satisfying only .
c2
4) If it fails in (3) then it will discard both and .
c1 c2
— The constraint solver shall satisfy the following properties:
• If a call to only involves soft constraints, the call can never fail.
randomize()
• If the soft constraints do not exhibit any contradictions, then the result is the same as if all
constraints were declared hard.
18.5.14.2 Discarding soft constraints
A constraint on a random variable specifies that all lower priority soft constraints that
disable soft
reference the given random variable shall be discarded. For example:
class A;
rand int x;
constraint A1 { soft x == 3; }
constraint A2 { disable soft x; } // discard soft constraints
constraint A3 { soft x inside { 1, 2 }; }
endclass
initial begin
A a = new();
a.randomize();
end
527
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The constraint instructs the solver to discard all soft constraints of lower priority on random variable ,
A2 x
resulting in constraint being discarded. Thus, the solver only has to satisfy the last constraint . As a
A1 A3
result the previous example will result in random variable taking on the values 1 and 2. Note that if the
x
constraint was omitted, then the variable would be unconstrained.
A3
A constraint causes lower priority soft constraints to be discarded regardless of whether
disable soft
those constraints create a contradiction. This feature is very useful to extend the solution space beyond the
default values specified by any preceding soft constraints. The following example illustrates this behavior:
class B;
rand int x;
constraint B1 { soft x == 5; }
constraint B2 { disable soft x; soft x dist {5, 8};}
endclass
initial begin
B b = new();
b.randomize();
end
In this example, the constraint preceding the soft distribution in block causes the lower
disablesoft B2
priority constraint on variable in block to be discarded. Hence, the solver will assign to the values
x B1 x
5and 8 with equal distribution—the result of solving constraint: .
x dist {5,8}
Contrast the behavior of the previous example when the disable soft constraint is omitted:
class B;
rand int x;
constraint B1 { soft x == 5; }
constraint B3 { soft x dist {5, 8}; }
endclass
initial begin
B b = new();
b.randomize();
end
In this preceding, the soft distribution constraint in block can be satisfied for the value of 5. Hence, the
B3
solver will assign the value 5. In general, if it is desired for the distribution weights of a
x soft dist
constraint to be satisfied regardless of the presence of lower priority soft constraints then those soft
constraints should be discarded first.
18.6 Randomization methods
18.6.1 Randomize()
Variables in an object are randomized using the class method. Every class has a built-in
randomize()
virtual method, declared as follows:
randomize()
virtual function int randomize();
The method is a virtual function that generates random values for all the active random
randomize()
variables in the object, subject to the active constraints.
The method returns 1 if it successfully sets all the random variables and objects to valid
randomize()
values; otherwise, it returns 0.
528
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example:
class SimpleSum;
rand bit [7:0] x, y, z;
constraint c {z == x + y;}
endclass
This class definition declares three random variables, , , and . Calling the method shall
x y z randomize()
randomize an instance of class :
SimpleSum
SimpleSum p = new;
int success = p.randomize();
if (success == 1 ) ...
Checking the return status can be necessary because the actual value of state variables or addition of
constraints in derived classes can render seemingly simple constraints unsatisfiable.
18.6.2 Pre_randomize() and post_randomize()
Every class contains and methods, which are automatically called
pre_randomize() post_randomize()
by before and after computing new random values.
randomize()
The prototype for the method is as follows:
pre_randomize()
function void pre_randomize();
The prototype for the method is as follows:
post_randomize()
function void post_randomize();
When is invoked, it first invokes on and also all of its random
obj.randomize() pre_randomize() obj
object members that are enabled. After the new random values are computed and assigned,
randomize()
invokes on and also all of its random object members that are enabled.
post_randomize() obj
Users can override the in any class to perform initialization and set preconditions
pre_randomize()
before the object is randomized. If the class is a derived class and no user-defined implementation
of exists, then will automatically invoke
pre_randomize() pre_randomize()
.
super.pre_randomize()
Users can override the in any class to perform cleanup, print diagnostics, and check
post_randomize()
post-conditions after the object is randomized. If the class is a derived class and no user-defined
implementation of exists, then will automatically invoke
post_randomize() post_randomize()
.
super.post_randomize()
If these methods are overridden, they shall call their associated base class methods; otherwise, their pre- and
post-randomization processing steps shall be skipped.
The and methods are not virtual. However, because they are
pre_randomize() post_randomize()
automatically called by the method, which is virtual, they appear to behave as virtual
randomize()
methods.
529
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
18.6.3 Behavior of randomization methods
— Random variables declared as static are shared by all instances of the class in which they are
declared. Each time the method is called, the variable is changed in every class
randomize()
instance.
— If fails, the constraints are infeasible, and the random variables retain their previous
randomize()
values.
— If fails, is not called.
randomize() post_randomize()
— The method is built-in and cannot be overridden.
randomize()
— The method implements object random stability. An object can be seeded by calling
randomize()
its method (see 18.13.3).
srandom()
— The built-in methods and are functions and cannot block.
pre_randomize() post_randomize()
18.7 In-line constraints—randomize() with
By using the construct, users can declare in-line constraints at the point where the
randomize()with
method is called. These additional constraints are applied along with the object constraints.
randomize()
The syntax for is as follows in Syntax18-10.
randomize()with
inline_constraint _declaration ::= // not in Annex A
class_variable_identifier [ [ variable_identifier_list | ] ]
. randomize ( null )
[ [ identifier_list ] ] constraint_block
with ( )
randomize_call ::= // from A.1.10
{ attribute_instance }
randomize
[ [ variable_identifier_list | ] ]
( null )
[ [ [ identifier_list ] ] constraint_block ]38
with ( )
38) In a randomize_call that is not a method call of an object of class type (i.e., a scope randomize), the optional
parenthesized identifier_list after the keyword shall be illegal, and the use of shall be illegal.
with null
Syntax18-10—Inline constraint syntax (excerpt from AnnexA)
The class_variable_identifier is the name of an instantiated object.
The unnamed constraint_block contains additional in-line constraints to be applied along with the object
constraints declared in the class.
For example:
class SimpleSum;
rand bit [7:0] x, y, z;
constraint c {z == x + y;}
endclass
task InlineConstraintDemo(SimpleSum p);
int success;
success = p.randomize() with {x < y;};
endtask
530
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
This is the same example used before; however, is used to introduce an additional
randomize()with
constraint that .
x < y
The construct can be used anywhere an expression can appear. The constraint block
randomize()with
following can define all of the same constraint types and forms as would otherwise be declared in a
with
class.
The constraint block can also reference local variables and subroutine arguments,
randomize()with
eliminating the need for mirroring a local state as member variables in the object class. When the constraint
block is not preceded by the optional parenthesized identifier_list, the constraint block is considered to be
unrestricted. The scope for resolution of variable names referenced in an unrestricted constraint block
begins with the object class; that is, the class of the object handle used in the method
randomize()with
call to . Then, if a name fails to resolve within the object class, the name
randomize() randomize()with
is resolved normally starting in the scope containing the in-line constraint. Names qualified by or
this
shall bind to the class of the object handle used in the call to the method. Hence,
super randomize()with
it shall be an error if the qualified name fails to resolve within the object class. Dotted
randomize()with
names other than those qualified by or shall first be resolved in a downwards manner (see 23.3)
this super
starting in the scope of the object class. If the dotted name does not resolve in the
randomize() with
scope of the object class, it shall be resolved following normal resolution rules in the
randomize() with
scope containing the in-line constraint.
The qualifier (see 18.7.1) is used to bypass the scope of the ( object) class and
local:: randomize()with
begin the name resolution procedure in the (local) scope that contains the method call.
randomize()
When the constraint_block is preceded by the optional parenthesized identifier_list, the constraint block is
considered to be restricted. In a restricted constraint block, only variables whose name resolution begins
with identifiers in the identifier_list shall resolve into the object class; all other names
randomize()with
shall resolve starting in the scope containing the method call. When the parenthesized
randomize()
identifier_list is present and the qualifier is used, the qualified name shall resolve starting in the
local::
scope containing the method call independent of whether the name is present in the
randomize()
identifier_list.
In the following example, the class is .
randomize()with C1
class C1;
rand integer x;
endclass
class C2;
integer x;
integer y;
task doit(C1 f, integer x, integer z);
int result;
result = f.randomize() with {x < y + z;};
endtask
endclass
In the constraint block, is a member of class and hides the in class . It also
f.randomize()with x C1 x C2
hides the argument in the task. is a member of is a local argument.
x doit() y C2.z
A restricted constraint block can be used to guarantee that local variable references will resolve into a local
scope.
531
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
class C;
rand integer x;
endclass
function int F(C obj, integer y);
F = obj.randomize() with (x) { x < y; };
endfunction
In this example, only is resolved into the object since only is listed in the identifier_list. The
x obj x
reference to will never bind into even if a later change adds a property named into class .
y obj y C
18.7.1 local:: scope resolution
The constraint block can reference both class properties and variables local to the
randomize()with
method call. Unqualified names in an unrestricted in-lined constraint block are then resolved by searching
first in the scope of the object class followed by a search of the scope containing the
randomize()with
method call—the local scope. The qualifier modifies the resolution search order. When applied to
local::
an identifier within an in-line constraint, the qualifier bypasses the scope of the
local::
[ object] class and resolves the identifier in the local scope.
randomize()with
In the following example, the class is , and the local scope is the function :
randomize()with C F()
class C;
rand integer x;
endclass
function int F(C obj, integer x);
F = obj.randomize() with { x < local::x; };
endfunction
In the unrestricted in-line constraint block of the call, the unqualified name, , binds to
obj.randomize() x
the property of class (the scope of the object being randomized) while the qualified name binds
C local::x
to the argument of the function (the local scope).
F()
As a result of the preceding rules, the following apply:
— Names qualified only by or shall bind to the class of the object handle used in the
this super
method call.
randomize()with
— Names qualified by shall bind to the scope containing the method call,
local:: randomize()
including the special names or (i.e., ).
this super local::this
— The prefix may be used to qualify class scopes and type names.
local::
— As it pertains to wildcard package imports, the syntactic form shall be semantically
local::a
identical to the unqualified name a declared in the local scope.
— Given a method call , the name shall bind to the scope of the
obj.randomize()with local::obj
object class.
randomize()with
18.8 Disabling random variables with rand_mode()
The method can be used to control whether a random variable is active or inactive. When a
rand_mode()
random variable is inactive, it is treated the same as if it had not been declared or . Inactive
rand randc
variables are not randomized by the method, and their values are treated as state variables by
randomize()
the solver. All random variables are initially active.
The syntax for the method is as follows:
rand_mode()
532
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
task object[.random_variable]::rand_mode( bit on_off );
or
function int object.random_variable::rand_mode();
The object is any expression that yields the object handle in which the random variable is defined.
The random_variable is the name of the random variable to which the operation is applied. If it is not
specified (only allowed when called as a task), the action is applied to all random variables within the
specified object.
When called as a task, the argument to the method determines the operation to be performed as
rand_mode
shown in Table18-3.
Table18-3—rand_mode argument
Value Meaning Description
0 OFF Sets the specified variables to inactive so that they are not randomized
on subsequent calls to the method.
randomize()
1 ON Sets the specified variables to active so that they are randomized on
subsequent calls to the method.
randomize()
For unpacked array variables, can specify individual elements using the corresponding
random_variable
index. Omitting the index results in all the elements of the array being affected by the call.
For unpacked structure variables, can specify individual members using the
random_variable
corresponding member. Omitting the member results in all the members of the structure being affected by
the call.
If the random variable is an object handle, only the mode of the variable is changed, not the mode of random
variables within that object (see global constraints in 18.5.9).
A compiler error shall be issued if the specified variable does not exist within the class hierarchy or it exists
but is not declared as or .
rand randc
When called as a function, returns the current active state of the specified random variable. It
rand_mode()
returns 1 if the variable is active ( ) and 0 if the variable is inactive ( ).
ON OFF
The function form of only accepts singular variables; thus, if the specified variable is an
rand_mode()
unpacked array, a single element shall be selected via its index.
Example:
class Packet;
rand integer source_value, dest_value;
... other declarations
endclass
int ret;
Packet packet_a = new;
// Turn off all variables in object
533
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
packet_a.rand_mode(0);
// ... other code
// Enable source_value
packet_a.source_value.rand_mode(1);
ret = packet_a.dest_value.rand_mode();
This example first disables all random variables in the object and then enables only the
packet_a
variable. Finally, it sets the variable to the active status of variable .
source_value ret dest_value
The method is built-in and cannot be overridden.
rand_mode()
If a random variable is declared as , the rand_mode state of the variable shall also be static. For
static
example, if is set to inactive, the random variable is inactive in all instances of the base class.
rand_mode()
18.9 Controlling constraints with constraint_mode()
The method can be used to control whether a constraint is active or inactive. When a
constraint_mode()
constraint is inactive, it is not considered by the method. All constraints are initially active.
randomize()
The syntax for the method is as follows:
constraint_mode()
task object[.constraint_identifier]::constraint_mode( bit on_off );
or
function int object.constraint_identifier::constraint_mode();
The object is any expression that yields the object handle in which the constraint is defined.
The constraint_identifier is the name of the constraint block to which the operation is applied. The
constraint name can be the name of any constraint block in the class hierarchy. If no constraint name is
specified (only allowed when called as a task), the operation is applied to all constraints within the specified
object.
When called as a task, the argument to the task method determines the operation to be
constraint_mode
performed as shown in Table18-4.
Table18-4—constraint_mode argument
Value Meaning Description
0 OFF Sets the specified constraint block to inactive so that it is not
enforced by subsequent calls to the method.
randomize()
1 ON Sets the specified constraint block to active so that it is considered
on subsequent calls to the method.
randomize()
A compiler error shall be issued if the specified constraint block does not exist within the class hierarchy.
When called as a function, returns the current active state of the specified constraint
constraint_mode()
block. It returns 1 if the constraint is active ( ) and 0 if the constraint is inactive ( ).
ON OFF
534
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example:
class Packet;
rand integer source_value;
constraint filter1 { source_value > 2 * m; }
endclass
function integer toggle_rand( Packet p );
if ( p.filter1.constraint_mode() )
p.filter1.constraint_mode(0);
else
p.filter1.constraint_mode(1);
toggle_rand = p.randomize();
endfunction
In this example, the function first checks the current active state of the constraint in
toggle_rand filter1
the specified object . If the constraint is active, the function deactivates it; if it is inactive, the
Packet p
function activates it. Finally, the function calls the method to generate a new random value
randomize()
for variable .
source_value
The method is built-in and cannot be overridden.
constraint_mode()
18.10 Dynamic constraint modification
There are several ways to dynamically modify randomization constraints, as follows:
— Implication and style constraints allow declaration of predicated constraints.
if–else
— Constraint blocks can be made active or inactive using the built-in method.
constraint_mode()
Initially, all constraint blocks are active. Inactive constraints are ignored by the
randomize()
function.
— Random variables can be made active or inactive using the built-in method. Initially,
rand_mode()
all and variables are active. Inactive variables are not randomized by the
rand randc
method, and their values are treated as state variables by the solver.
randomize()
— The weights in a constraint can be changed, affecting the probability that particular values in
dist
the set are chosen.
18.11 In-line random variable control
The method can be used to temporarily control the set of random and state variables within a
randomize()
class instance or object. When the method is called with no arguments, it behaves as
randomize()
described in the previous subclauses, that is, it assigns new values to all random variables in an object—
those declared as or —so that all of the constraints are satisfied. When is called
rand randc randomize()
with arguments, those arguments designate the complete set of random variables within that object; all other
variables in the object are considered state variables. For example, consider the following class and calls to
:
randomize()
class CA;
rand byte x, y;
byte v, w;
constraint c1 { x < v && y > w );
endclass
535
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
CA a = new;
a.randomize(); // random variables: x, y state variables: v, w
a.randomize( x ); // random variables: x state variables: y, v, w
a.randomize( v, w ); // random variables: v, w state variables: x, y
a.randomize( w, x ); // random variables: w, x state variables: y, v
This mechanism controls the set of active random variables for the duration of the call to ,
randomize()
which is conceptually equivalent to making a set of calls to the method to disable or enable
rand_mode()
the corresponding random variables. Calling with arguments allows changing the random
randomize()
mode of any class property, even those not declared as or . This mechanism, however, does not
rand randc
affect the cyclical random mode; it cannot change a nonrandom variable into a cyclical random variable
( ) and cannot change a cyclical random variable into a noncyclical random variable (change from
randc
to ).
randc rand
The scope of the arguments to the method is the object class. Arguments are limited to the
randomize()
names of properties of the calling object; expressions are not allowed. The random mode of local class
members can only be changed when the call to has access to those properties, that is, within
randomize()
the scope of the class in which the local members are declared.
18.11.1 In-line constraint checker
Normally, calling the method of a class that has no random variables causes the method to
randomize()
behave as a checker. In other words, it assigns no random values and only returns a status: 1 if all constraints
are satisfied and 0 otherwise. The in-line random variable control mechanism can also be used to force the
method to behave as a checker.
randomize()
The method accepts the special argument to indicate no random variables for the
randomize() null
duration of the call. In other words, all class members behave as state variables. This causes the
method to behave as a checker instead of a generator. A checker evaluates all constraints and
randomize()
simply returns 1 if all constraints are satisfied and 0 otherwise. For example, if class defined previously
CA
executes the following call:
success = a.randomize( null ); // no random variables
then the solver considers all variables as state variables and only checks whether the constraint is satisfied,
namely, that the relation ( ) is true using the current values of , , , and .
x < v && y > w x y v w
18.12 Randomization of scope variables—std::randomize()
The built-in class method operates exclusively on class member variables. Using classes to
randomize()
model the data to be randomized is a powerful mechanism that enables the creation of generic, reusable
objects containing random variables and constraints that can be later extended, inherited, constrained,
overridden, enabled, disabled, and merged with or separated from other objects. The ease with which classes
and their associated random variables and constraints can be manipulated makes classes an ideal vehicle for
describing and manipulating random data and constraints. However, some less-demanding problems that do
not require the full flexibility of classes can use a simpler mechanism to randomize data that do not belong to
a class. The scope randomize function, , enables users to randomize data in the current
std::randomize()
scope without the need to define a class or instantiate a class object.
The syntax of the scope randomize function is as follows in Syntax18-11.
536
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
scope_randomize ::=
[ ] [ variable_identifier_list ] [ constraint_block ]
std :: randomize( ) with
Syntax18-11—Scope randomize function syntax (not in AnnexA)
The scope randomize function behaves exactly the same as a class randomize method, except that it operates
on the variables of the current scope instead of class member variables. Arguments to this function specify
the variables that are to be assigned random values, i.e., the random variables.
For example:
module stim;
bit [15:0] addr;
bit [31:0] data;
function bit gen_stim();
bit success, rd_wr;
success = randomize( addr, data, rd_wr ); // call std::randomize
return rd_wr ;
endfunction
...
endmodule
The function calls with three variables as arguments: , , and
gen_stim std::randomize() addr data
. Thus, assigns new random variables to the variables that are visible in the
rd_wr std::randomize()
scope of the function. In the preceding example, and have module scope, whereas
gen_stim addr data
has scope local to the function. The preceding example can also be written using a class:
rd_wr
class stimc;
rand bit [15:0] addr;
rand bit [31:0] data;
rand bit rd_wr;
endclass
function bit gen_stim( stimc p );
bit [15:0] addr;
bit [31:0] data;
bit success;
success = p.randomize();
addr = p.addr;
data = p.data;
return p.rd_wr;
endfunction
However, for this simple application, the scope randomize function leads to a straightforward
implementation.
The scope randomize function returns 1 if it successfully sets all the random variables to valid values;
otherwise, it returns 0. If the scope randomize function is called with no argument, it shall not change the
value of any variable but instead it shall check its constraints. All constraint expressions in its
constraint_block shall be evaluated, and if one or more of those expressions evaluates to false (0) then the
randomize call shall return 0; otherwise it shall return 1.
537
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
18.12.1 Adding constraints to scope variables—std::randomize() with
The form of the scope randomize function allows users to specify random
std::randomize() with
constraints to be applied to the local scope variables. When specifying constraints, the arguments to the
scope randomize function become random variables; all other variables are considered state variables.
task stimulus( int length );
int a, b, c, success;
success = std::randomize( a, b, c ) with { a < b ; a + b < length ; };
...
success = std::randomize( a, b ) with { b - a > length ; };
...
endtask
The preceding task stimulus calls twice resulting in two sets of random values for its
std::randomize
local variables , , and . In the first call, variables and are constrained so that variable is less than
a b c a b a b
and their sum is less than the task argument length, which is designated as a state variable. In the second call,
variables and are constrained so that their difference is greater than the state variable length.
a b
18.13 Random number system functions and methods
18.13.1 $urandom
The system function provides a mechanism for generating pseudo-random numbers. The
$urandom
function returns a new 32-bit random number each time it is called. The number shall be unsigned.
The syntax for is as follows:
$urandom
[ ]
function int unsigned $urandom (int seed ) ;
The is an optional argument that determines the sequence of random numbers generated. The seed can
seed
be any integral expression. The random number generator (RNG) shall generate the same sequence of
random numbers every time the same seed is used.
The RNG is deterministic. Each time the program executes, it cycles through the same random sequence.
This sequence can be made nondeterministic by seeding the function with an extrinsic random
$urandom
variable, such as the time of day.
For example:
bit [64:1] addr;
bit [ 3:0] number;
addr[32:1] = $urandom( 254 ); // Initialize the generator,
// get 32-bit random number
addr = {$urandom, $urandom }; // 64-bit random number
number = $urandom & 15; // 4-bit random number
18.13.2 $urandom_range()
The function returns an unsigned integer within a specified range.
$urandom_range()
The syntax for is as follows:
$urandom_range()
538
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
function int unsigned $urandom_range( int unsigned maxval,
int unsigned minval = 0 );
The function shall return an unsigned integer in the range of ... .
maxval minval
Example 1:
val = $urandom_range(7,0);
If is omitted, the function shall return a value in the range of ... .
minval maxval 0
Example 2:
val = $urandom_range(7);
If is less than , the arguments are automatically reversed so that the first argument is larger
maxval minval
than the second argument.
Example 3:
val = $urandom_range(0,7);
All of the three previous examples produce a value in the range of 0 to 7, inclusive.
is automatically thread stable (see 18.14.2).
$urandom_range()
18.13.3 srandom()
The method allows manually seeding the RNG of objects or threads. The RNG of a process can
srandom()
be seeded using the method of the process (see 9.7).
srandom()
The prototype of the method is as follows:
srandom()
function void srandom( int seed );
The method initializes an object’s RNG using the value of the given seed.
srandom()
18.13.4 get_randstate()
The method retrieves the current state of an object’s RNG. The state of the RNG
get_randstate()
associated with a process is retrieved using the method of the process (see 9.7).
get_randstate()
The prototype of the method is as follows:
get_randstate()
function string get_randstate();
The method returns a copy of the internal state of the RNG associated with the given
get_randstate()
object.
The RNG state is a string of unspecified length and format. The length and contents of the string are
implementation dependent.
539
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
18.13.5 set_randstate()
The method sets the state of an object’s RNG. The state of the RNG associated with a
set_randstate()
process is set using the method of the process (see 9.7).
set_randstate()
The prototype of the method is as follows:
set_randstate()
function void set_randstate( string state );
The method copies the given state into the internal state of an object’s RNG.
set_randstate()
The RNG state is a string of unspecified length and format. Calling with a string value
set_randstate()
that was not obtained from , or from a different implementation of ,
get_randstate() get_randstate()
is undefined.
18.14 Random stability
The RNG is localized to threads and objects. Because the sequence of random values returned by a thread or
object is independent of the RNG in other threads or objects, this property is called random stability.
Random stability applies to the following:
— The system randomization calls, and
$urandom() $urandom_range()
— The array manipulation method
shuffle()
— The procedural and statements
randcase randsequence
— The object and process random seeding method,
srandom()
— The object and scope randomization method,
randomize()
Testbenches with this feature exhibit more stable RNG behavior in the face of small changes to the user
code. Additionally, it enables more precise control over the generation of random values by manually
seeding threads and objects.
18.14.1 Random stability properties
Random stability encompasses the following properties:
— Initialization RNG. Each module instance, interface instance, program instance, and package has an
initialization RNG. Each initialization RNG is seeded with the default seed. The default seed is an
implementation-dependent value. An initialization RNG shall be used in the creation of static
processes and static initializers (see the following list items). Static processes are defined in
AnnexP.
— Thread stability. Each thread has an independent RNG for all randomization system calls invoked
from that thread. When a new dynamic thread is created, its RNG is seeded with the next random
value from its parent thread. This property is called hierarchical seeding. When a static process is
created, its RNG is seeded with the next value from the initialization RNG of the module instance,
interface instance, program instance, or package containing the thread declaration.
Program and thread stability can be achieved as long as thread creation and random number
generation are done in the same order as before. When adding new threads to an existing test, they
can be added at the end of a code block in order to maintain random number stability of previously
created work.
— Object stability. Each class instance (object) has an independent RNG for all randomization methods
in the class. When an object is created using , its RNG is seeded with the next random value
new
from the thread that creates the object. When a class object is created by a static declaration
initializer, there is no active thread; thus, the RNG of the created object is seeded with the next
540
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
random value of the initialization RNG of the module instance, interface instance, program instance,
or package in which the declaration occurred.
Object stability shall be preserved when object and thread creation and random number generation
are done in the same order as before. In order to maintain random number stability, new objects,
threads, and random numbers can be created after existing objects are created.
— Manual seeding. All noninitialization RNGs can be manually seeded. Combined with hierarchical
seeding, this facility allows users to define the operation of a subsystem (hierarchy subtree)
completely with a single seed at the root thread of the subsystem.
18.14.2 Thread stability
Random values returned from the and system calls,
$urandom $urandom_range std::randomize()
scope randomization method, and array manipulation method are independent of thread
shuffle()
execution order. Random values generated to select branches of the procedural and
randcase
statements are also independent of thread execution order. For example:
randsequence
integer x, y, z;
fork //set a seed at the start of a thread
begin process::self.srandom(100); x = $urandom; end
//set a seed during a thread
begin y = $urandom; process::self.srandom(200); end
// draw 2 values from the thread RNG
begin z = $urandom + $urandom ; end
join
The preceding program fragment illustrates the following several properties:
— Thread locality. The values returned for , , and are independent of the order of thread execution.
x y z
This is an important property because it allows development of subsystems that are independent,
controllable, and predictable.
— Hierarchical seeding. When a thread is created, its random state is initialized using the next random
value from the parent thread as a seed. The three forked threads are all seeded from the parent
thread.
Each thread is seeded with a unique value, determined solely by its parent. The root of a thread execution
subtree determines the random seeding of its children. This allows entire subtrees to be moved and preserves
their behavior by manually seeding their root thread.
18.14.3 Object stability
The method built into every class exhibits object stability. This is the property that calls to
randomize()
in one instance are independent of calls to in other instances and are
randomize() randomize()
independent of calls to other randomize functions.
For example:
class C1;
rand integer x;
endclass
class C2;
rand integer y;
endclass
initial begin
541
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
C1 c1 = new();
C2 c2 = new();
integer z;
void'(c1.randomize());
// z = $random;
void'(c2.randomize());
end
— The values returned for and are independent of each other.
c1.x c2.y
— The calls to are independent of the system call. If one uncomments the line
randomize() $random
above, there is no change in the values assigned to and .
z = $random c1.x c2.y
— Each instance has a unique source of random values that can be seeded independently. That random
seed is taken from the parent thread when the instance is created.
— Objects can be seeded at any time using the method.
srandom()
class C3
function new (integer seed);
//set a new seed for this instance
this.srandom(seed);
endfunction
endclass
Once an object is created, there is no guarantee that the creating thread can change the object’s random state
before another thread accesses the object. Therefore, it is best that objects self-seed within their method
new
rather than externally.
An object’s seed can be set from any thread. However, a thread’s seed can only be set from within the thread
itself.
18.15 Manually seeding randomize
Each object maintains its own internal RNG, which is used exclusively by its method. This
randomize()
allows objects to be randomized independently of each other and of calls to other system randomization
functions. When an object is created, its RNG is seeded using the next value from the RNG of the thread that
creates the object. This process is called hierarchical object seeding.
Sometimes it is desirable to manually seed an object’s RNG using the method. This can be done
srandom()
either in a class method or external to the class definition:
An example of seeding the RNG internally, as a class method, is as follows:
class Packet;
rand bit[15:0] header;
...
function new (int seed);
this.srandom(seed);
...
endfunction
endclass
An example of seeding the RNG externally is as follows:
Packet p = new(200); // Create p with seed 200.
p.srandom(300); // Re-seed p with seed 300.
542
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Calling in an object’s function assures the object’s RNG is set with the new seed before
srandom() new()
any class member values are randomized.
18.16 Random weighted case—randcase
statement_item ::= // from A.6.4
...
| randcase_statement
randcase_statement ::= // from A.6.7
randcase_item { randcase_item }
randcase endcase
randcase_item ::= expression statement_or_null
:
Syntax18-12—Randcase syntax (excerpt from AnnexA)
The keyword introduces a statement that randomly selects one of its branches. The
randcase case
randcase_item expressions are non-negative integral values that constitute the branch weights. An item’s
weight divided by the sum of all weights gives the probability of taking that branch. For example:
randcase
3 : x = 1;
1 : x = 2;
4 : x = 3;
endcase
The sum of all weights is 8; therefore, the probability of taking the first branch is 0.375, the probability of
taking the second is 0.125, and the probability of taking the third is 0.5.
If a branch specifies a zero weight, then that branch is not taken. If all randcase_items specify zero weights,
then no branch is taken and a warning can be issued.
The randcase weights can be arbitrary expressions, not just constants. For example:
byte a, b;
randcase
a + b : x = 1;
a - b : x = 2;
a ^ ~b : x = 3;
12'h800 : x = 4;
endcase
The precision of each weight expression is self-determined. The sum of the weights is computed using
standard addition semantics (maximum precision of all weights), where each summand is unsigned. Each
weight expression is evaluated at most once (implementations can cache identical expressions) in an
unspecified order. In the preceding example, the first three weight expressions are computed using 8-bit
precision, and the fourth expression is computed using 12-bit precision. The resulting weights are added as
unsigned values using 12-bit precision. The weight selection then uses unsigned 12-bit comparison.
Each call to retrieves one random number in the range of 0 to the sum of the weights. The
randcase
weights are then selected in declaration order: smaller random numbers correspond to the first (top) weight
statements.
543
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Randcase statements exhibit thread stability. The random numbers are obtained from
$urandom_
; thus, random values drawn are independent of thread execution order. This can result in multiple
range()
calls to to handle greater than 32 bits.
$urandom_range()
18.17 Random sequence generation—randsequence
Parser generators, such as yacc, use a BNF or similar notation to describe the grammar of the language to be
parsed. The grammar is thus used to generate a program that is able to check whether a stream of tokens
represents a syntactically correct utterance in that language. SystemVerilog’s sequence generator reverses
this process. It uses the grammar to randomly create a correct utterance (i.e., a stream of tokens) of the
language described by the grammar. The random sequence generator is useful for randomly generating
structured sequences of stimulus such as instructions or network traffic patterns.
The sequence generator uses a set of rules and productions within a block. The syntax of the
randsequence
block is as follows in Syntax18-13.
randsequence
statement_item ::= // from A.6.4
...
| randsequence_statement
randsequence_statement ::= [ production_ identifier ] // from A.6.12
randsequence ( )
production { production }
endsequence
production ::= [ data_type_or_void ] production_identifier [ tf_port_list ] rs_rule { rs_rule }
( ) : | ;
rs_rule ::= rs_production_list [ weight_specification [ rs_code_block ] ]
:=
rs_production_list ::=
rs_prod { rs_prod }
| [ expression ] production_item production_item { production_item }
rand join ( )
weight_specification ::=
integral_number
| ps_identifier
| expression
( )
rs_code_block ::= { data_declaration } { statement_or_null }
{ }
rs_prod ::=
production_item
| rs_code_block
| rs_if_else
| rs_repeat
| rs_case
production_item ::= production_identifier [ list_of_arguments ]
( )
rs_if_else ::= expression production_item [ production_item ]
if ( ) else
rs_repeat ::= expression production_item
repeat ( )
rs_case ::= case_expression rs_case_item { rs_case_item }
case ( ) endcase
rs_case_item ::=
case_item_expression { case_item_expression } production_item
, : ;
| [ ] production_item
default : ;
case_expression ::= expression // from A.6.7
case_item_expression ::= expression
Syntax18-13—Randsequence syntax (excerpt from AnnexA)
544
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A grammar is composed of one or more productions. Each production contains a name and
randsequence
a list of production items. Production items are further classified into terminals and nonterminals.
Nonterminals are defined in terms of terminals and other nonterminals. A terminal is an indivisible item that
needs no further definition than its associated code block. Ultimately, every nonterminal is decomposed into
its terminals. A production list contains a succession of production items, indicating that the items must be
streamed in sequence. A single production can contain multiple production lists separated by the | symbol.
Production lists separated by a | imply a set of choices, which the generator will make at random.
A simple example illustrates the basic concepts:
randsequence( main )
main : first second done ;
first : add | dec ;
second : pop | push ;
done : { $display("done"); } ;
add : { $display("add"); } ;
dec : { $display("dec"); } ;
pop : { $display("pop"); } ;
push : { $display("push"); } ;
endsequence
The production is defined in terms of three nonterminals: , , and . When is
main first second done main
chosen, it generates the sequence, , , and . When the first production is generated, it is
first second done
decomposed into its productions, which specify a random choice between and . Similarly, the
add dec
second production specifies a choice between and . All other productions are terminals; they are
pop push
completely specified by their code block, which in the example displays the production name. Thus, the
grammar leads to the following possible outcomes:
add pop done
add push done
dec pop done
dec push done
When the statement is executed, it generates a grammar-driven stream of random
randsequence
productions. As each production is generated, the side effects of executing its associated code blocks
produce the desired stimulus. In addition to the basic grammar, the sequence generator provides for random
weights, interleaving, and other control mechanisms. Although the statement does not
randsequence
intrinsically create a loop, a recursive production will cause looping.
The statement creates an automatic scope. All production identifiers are local to the scope.
randsequence
In addition, each code block within the block creates an anonymous automatic scope.
randsequence
Hierarchical references to the variables declared within the code blocks are not allowed. To declare a static
variable, the prefix shall be used. The keyword can be followed by an optional
static randsequence
production name (inside the parentheses) that designates the name of the top-level production. If
unspecified, the first production becomes the top-level production.
18.17.1 Random production weights
The probability that a production list is generated can be changed by assigning weights to production lists.
The probability that a particular production list is generated is proportional to its specified weight.
545
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
production ::= // from A.6.12
[ data_type_or_void ] production_identifier [ tf_port_list ] rs_rule { rs_rule }
( ) : | ;
rs_rule ::= rs_production_list [ weight_specification [ rs_code_block ] ]
:=
Syntax18-14—Random production weights syntax (excerpt from AnnexA)
The operator assigns the weight specified by the weight_specification to its production list. A
:=
weight_specification shall evaluate to an integral non-negative value. A weight is only meaningful when
assigned to alternative productions, that is, production lists separated by a |. Weight expressions are
evaluated when their enclosing production is selected, thus allowing weights to change dynamically. For
example, the first production of the previous example can be rewritten as follows:
first : add := 3
| dec := (1 + 1) // 2
;
This defines the production in terms of two weighted production lists, and . The production
first add dec
will be generated with 60% probability, and the production will be generated with 40% probability.
add dec
If no weight is specified, a production shall use a weight of 1. If only some weights are specified, the
unspecified weights shall use a weight of 1.
18.17.2 if–else production statements
A production can be made conditionally by means of an production statement. The syntax of the
if–else
production statement is as follows in Syntax18-15.
if–else
rs_if_else ::= expression production_item [ production_item ] // from A.6.12
if ( ) else
Syntax18-15—If–else conditional random production syntax (excerpt from AnnexA)
The expression can be any expression that evaluates to a Boolean value. If the expression evaluates to true,
the production following the expression is generated; otherwise, the production following the optional else
statement is generated. For example:
randsequence()
...
PP_OP : if ( depth < 2 ) PUSH else POP ;
PUSH : { ++depth; do_push(); };
POP : { --depth; do_pop(); };
endsequence
This example defines the production . If the variable depth is less than 2, then production is
PP_OP PUSH
generated. Otherwise, production is generated. The variable depth is updated by the code blocks of both
POP
the and productions.
PUSH POP
18.17.3 Case production statements
A production can be selected from a set of alternatives using a production statement. The syntax of the
case
production statement is as follows in Syntax18-16.
case
546
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
rs_case ::= case_expression rs_case_item { rs_case_item } // from A.6.12
case ( ) endcase
rs_case_item ::=
case_item_expression { case_item_expression } production_item
, : ;
| [ ] production_item
default : ;
case_expression ::= expression // from A.6.7
case_item_expression ::= expression
Syntax18-16—Case random production syntax (excerpt from AnnexA)
The case production statement is analogous to the procedural statement except as noted below. The
case
case expression is evaluated, and its value is compared against the value of each case_item expression, all of
which are evaluated and compared in the order in which they are given. The production generated is the one
associated with the first case_item expression matching the case expression. If no matching case_item
expression is found, then the production associated with the optional default item is generated, or nothing if
there is no default item. Multiple default statements in one case production statement shall be illegal. The
case_item expressions separated by commas allow multiple expressions to share the production. For
example:
randsequence()
SELECT : case ( device & 7 )
0 : NETWORK ;
1, 2 : DISK ;
default : MEMORY ;
endcase ;
...
endsequence
This example defines the production with a statement. The case_expression ( ) is
SELECT case device & 7
evaluated and compared against the two case_item_expressions. If the expression matches 0, the production
is generated; if it matches 1 or 2, the production is generated. Otherwise, the production
NETWORK DISK
is generated.
MEMORY
18.17.4 Repeat production statements
The production statement is used to iterate over a production a specified number of times. The
repeat
syntax of the production statement is as follows in Syntax18-17.
repeat
rs_repeat ::= expression production_item // from A.6.12
repeat ( )
Syntax18-17—Repeat random production syntax (excerpt from AnnexA)
The expression shall evaluate to a non-negative integral value. That value specifies the number of
repeat
times that the corresponding production is generated. For example:
randsequence()
...
PUSH_OPER : repeat( $urandom_range( 2, 6 ) ) PUSH ;
PUSH : ...
endsequence
547
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In this example, the production specifies that the production be repeated a random
PUSH_OPER PUSH
number of times (between 2 and 6) depending on the value returned by .
$urandom_range()
The production statement itself cannot be terminated prematurely. A statement will
repeat break
terminate the entire block (see 18.17.6).
randsequence
18.17.5 Interleaving productions—rand join
The production control is used to randomly interleave two or more production sequences while
randjoin
maintaining the relative order of each sequence. The syntax of the production control is as
rand join
follows in Syntax18-18.
rs_production_list ::= // from A.6.12
rs_prod { rs_prod }
| [ expression ] production_item production_item { production_item }
rand join ( )
Syntax18-18—Rand join random production syntax (excerpt from AnnexA)
For example:
randsequence( TOP )
TOP : rand join S1 S2 ;
S1 : A B ;
S2 : C D ;
endsequence
The generator will randomly produce the following sequences:
A B C D
A C B D
A C D B
C D A B
C A B D
C A D B
The optional expression following the keywords shall be a real number in the range of 0.0 to 1.0.
randjoin
The value of this expression represents the degree to which the length of the sequences to be interleaved
affects the probability of selecting a sequence. A sequence’s length is the number of productions not yet
interleaved at a given time. If the expression is 0.0, the shortest sequences are given higher priority. If the
expression is 1.0, the longest sequences are given priority. For instance, using the previous example,
TOP : rand join (0.0) S1 S2 ;
gives higher priority to the sequences: , and
A B C D C D A B
TOP : rand join (1.0) S1 S2 ;
gives higher priority to the sequences: .
A C B D A C D B C A B D C A D B
If unspecified, the generator used the default value of 0.5, which does not prioritize any sequence length.
At each step, the generator interleaves nonterminal symbols to depth of 1.
548
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
18.17.6 Aborting productions—break and return
Two procedural statements can be used to terminate a production prematurely: and . These
break return
two statements can appear in any code block; they differ in what they consider the scope from which to exit.
The statement terminates the sequence generation. When a statement is executed from within
break break
a production code block, it forces a jump out of the block. For example:
randsequence
randsequence()
WRITE : SETUP DATA ;
SETUP : { if( fifo_length >= max_length ) break; } COMMAND ;
DATA : ...
endsequence
next_statement : ...
When the preceding example executes the statement within the production, the
break SETUP COMMAND
production is not generated, and execution continues on the line labeled . Use of the
next_statement
statement within a loop statement behaves as defined in 12.8. Thus, the statement terminates
break break
the smallest enclosing looping statement; otherwise, it terminates the block.
randsequence
The statement aborts the generation of the current production. When a statement is
return return
executed from within a production code block, the current production is aborted. Sequence generation
continues with the next production following the aborted production. For example:
randsequence()
TOP : P1 P2 ;
P1 : A B C ;
P2 : A { if( flag == 1 ) return; } B C ;
A : { $display( "A" ); } ;
B : { if( flag == 2 ) return; $display( "B" ); } ;
C : { $display( "C" ); } ;
endsequence
Depending on the value of variable , the preceding example displays the following:
flag
flag == 0 ==> A B C A B C
flag == 1 ==> A B C A
flag == 2 ==> A C A C
When , production is aborted in the middle, after generating . When ,
flag == 1 P2 A flag == 2
production is aborted twice (once as part of and once as part of ); however, each time, generation
B P1 P2
continues with the next production, .
C
18.17.7 Value passing between productions
Data can be passed down to a production about to be generated, and generated productions can return data to
the nonterminals that triggered their generation. Passing data to a production is similar to a task call and uses
the same syntax. Returning data from a production requires that a type be declared for the production, which
uses syntax similar to a function declaration.
Productions that accept data include a formal argument list. The syntax for declaring the arguments to a
production is similar to a task prototype; the syntax for passing data to the production is the same as a task
call (see Syntax18-19).
549
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
production ::=
[ data_type_or_void ] production_identifier [ tf_port_list ] rs_rule { rs_rule } // from A.6.12
( ) : | ;
Syntax18-19—Random production syntax (excerpt from AnnexA)
For example, the previous first example could be written as follows:
randsequence( main )
main : first second gen ;
first : add | dec ;
second : pop | push ;
add : gen("add") ;
dec : gen("dec") ;
pop : gen("pop") ;
push : gen("push") ;
gen( string s = "done" ) : { $display( s ); } ;
endsequence
In this example, the production accepts a string argument whose default is . Five other
gen "done"
productions generate this production, each with a different argument (the one in uses the default).
main
A production creates a scope, which encompasses all its rules and code blocks. Thus, arguments passed
down to a production are available throughout the production.
Productions that return data require a type declaration. The optional return type precedes the production.
Productions that do not specify a return type shall assume a void return type.
A value is returned from a production by using the with an expression. When the statement
return return
is used with a production that returns a value, it shall specify an expression of the correct type, just like
nonvoid functions. The statement assigns the given expression to the corresponding production.
return
The return value can be read in the code blocks of the production that triggered the generation of the
production returning a value. Within these code blocks, return values are accessed using the production
name plus an optional indexing expression.
Within a rule, a variable is implicitly declared for each production (of the rule) that returns a value. The type
of the variable is determined by the return type of the production and the number of times the production
syntactically appears with the rule. If a production appears only once in a rule, the type of the implicit
variable is the return type of the production. If a production appears multiple times, the type is an array
where the element type is the return type of the production. The array is indexed from 1 to the number of
times the production appears within the rule. The elements of the array are assigned the values returned by
the instances of the production according to the syntactic order of appearance.
Example 1:
randsequence( bin_op )
void bin_op : value operator value // void type is optional
{ $display("%s %b %b", operator, value[1], value[2]); }
;
bit [7:0] value : { return $urandom; } ;
string operator : add := 5 { return "+" ; }
| dec := 2 { return "-" ; }
| mult := 1 { return "*" ; }
;
endsequence
550
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In the preceding example, the and productions return a string and an 8-bit value,
operator value
respectively. The production includes these two value-returning productions. Therefore, the code
bin_op
block associated with production has access to the following implicit variable declarations:
bin_op
bit [7:0] value [1:2];
string operator;
Example 2:
int cnt;
...
randsequence( A )
void A : A1 A2;
void A1 : { cnt = 1; } B repeat(5) C B
{ $display("c=%d, b1=%d, b2=%d", C, B[1], B[2]); }
;
void A2 : if (cond) D(5) else D(20)
{ $display("d1=%d, d2=%d", D[1], D[2]); }
;
int B : C { return C;}
| C C { return C[2]; }
| C C C { return C[3]; }
;
int C : { cnt = cnt + 1; return cnt; };
int D (int prm) : { return prm; };
endsequence
In Example 2, the code block in production has access to the implicit variable declarations:
A1
int B[1:2];
int C;
The code block in production has access to the implicit variable declaration:
A2
int D[1:2];
If is true, the first element is assigned the value returned by . If is false, the second element
cond D(5) cond
is assigned the value returned by .
D(20)
The code block in the first rule of production has access to the implicit variable declaration:
B
int C;
The code block in the third rule of production has access to the implicit variable declaration:
B
int C[1:3];
Accessing these implicit variables yields the values returned from the corresponding productions. When
executed, Example 1, above, displays a simple three-item random sequence: an operator followed by two
8-bit values. The operators , , and are chosen with a distribution of 5/8, 2/8, and 1/8, respectively.
+ - *
Only the return values of productions already generated (i.e., to the left of the code block accessing them)
can be retrieved. Attempting to read the return value of a production that has not been generated results in an
undefined value. For example:
551
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
X : A {int y = B;} B ; // invalid use of B
X : A {int y = A[2];} B A ; // invalid use of A[2]
X : A {int y = A;} B {int j = A + B;} ; // valid
The sequences produced by can be driven directly into a system, as a side effect of
randsequence
production generation, or the entire sequence can be generated for future processing. For example, the
following function generates and returns a queue of random numbers in the range given by its arguments.
The first and last queue items correspond to the lower and upper bounds, respectively. Also, the size of the
queue is randomly selected based on the production weights.
function int[$] GenQueue(int low, int high);
int[$] q;
randsequence()
TOP : BOUND(low) LIST BOUND(high) ;
LIST : LIST ITEM := 8 { q = { q, ITEM }; }
| ITEM := 2 { q = { q, ITEM }; }
;
int ITEM : { return $urandom_range( low, high ); } ;
BOUND(int b) : { q = { q, b }; } ;
endsequence
GenQueue = q;
endfunction
When the in function executes, it generates the production, which causes
randsequence GenQueue TOP
three productions to be generated: with argument , , and with argument . The
BOUND low LIST BOUND high
production simply appends its argument to the queue. The production consists of a weighted
BOUND LIST
production and an production. The production is generated with 80%
LIST ITEM ITEM LIST ITEM
probability, which causes the production to be generated recursively, thereby postponing the
LIST
generation of the production. The selection between and is repeated until the
ITEM LISTITEM ITEM ITEM
production is selected, which terminates the production. Each time the production is generated,
LIST ITEM
it produces a random number in the indicated range, which is later appended to the queue.
The following example uses a block to produce random traffic for a DSL packet network:
randsequence
class DSL; ... endclass // class that creates valid DSL packets
randsequence (STREAM)
STREAM : GAP DATA := 80
| DATA := 20 ;
DATA : PACKET(0) := 94 { transmit( PACKET ); }
| PACKET(1) := 6 { transmit( PACKET ); } ;
DSL PACKET (bit bad) : { DSL d = new;
if( bad ) d.crc ^= 23; // mangle crc
return d;
);
GAP: { ## {$urandom_range( 1, 20 )}; };
endsequence
In this example, the traffic consists of a stream of (good and bad) data packets and gaps. The first
production, , specifies that 80% of the time the traffic consists of a followed by some and
STREAM GAP DATA
20% of the time it consists of just (no ). The second production, , specifies that 94% of all
DATA GAP DATA
data packets are good packets and the remaining 6% are bad packets. The production implements
PACKET
the packet creation; if the production argument is 1, then a bad packet is produced by mangling the
DSL crc
of a valid packet. Finally, the production implements the transmission gaps by waiting a random
DSL GAP
number of cycles between 1 and 20.
552
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
19. Functional coverage
19.1 General
This clause describes the following:
— Defining coverage groups
— Defining coverage points
— Defining cross coverage
— Coverage options
— Coverage system tasks and system functions
— Coverage computation
19.2 Overview
Functional verification comprises a large portion of the resources required to design and validate a complex
system. Often, the validation must be comprehensive without redundant effort. To minimize wasted effort,
coverage is used as a guide for directing verification resources by identifying tested and untested portions of
the design.
Coverage is defined as the percentage of verification objectives that have been met. It is used as a metric for
evaluating the progress of a verification project in order to reduce the number of simulation cycles spent in
verifying a design.
Broadly speaking, there are two types of coverage metrics: those that can be automatically extracted from
the design code, such as code coverage, and those that are user-specified in order to tie the verification
environment to the design intent or functionality. The latter form is referred to as functional coverage and is
the topic of this clause.
Functional coverage is a user-defined metric that measures how much of the design specification, as
enumerated by features in the test plan, has been exercised. It can be used to measure whether interesting
scenarios, corner cases, specification invariants, or other applicable design conditions—captured as features
of the test plan—have been observed, validated, and tested.
The key aspects of functional coverage are as follows:
— It is user-specified and is not automatically inferred from the design.
— It is based on the design specification (i.e., its intent) and is thus independent of the actual design
code or its structure.
Because it is fully specified by the user, functional coverage requires more up-front effort (someone has to
write the coverage model). Functional coverage also requires a more structured approach to verification.
Although functional coverage can shorten the overall verification effort and yield higher quality designs, its
shortcomings can impede its adoption.
The SystemVerilog functional coverage extensions address these shortcomings by providing language
constructs for easy specification of functional coverage models. This specification can be efficiently
executed by the SystemVerilog simulation engine, thus enabling coverage data manipulation and analysis
tools that speed up the development of high-quality tests. The improved set of tests can exercise more corner
cases and required scenarios, without redundant work.
The SystemVerilog functional coverage constructs enable the following:
— Coverage of variables and expressions, as well as cross coverage between them
— Automatic as well as user-defined coverage bins
553
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Associate bins with sets of values, transitions, or cross products
— Filtering conditions at multiple levels
— Events and sequences to automatically trigger coverage sampling
— Procedural activation and query of coverage
— Optional directives to control and regulate coverage
19.3 Defining the coverage model: covergroup
The construct encapsulates the specification of a coverage model. Each
covergroup covergroup
specification can include the following components:
— A clocking event that synchronizes the sampling of coverage points
— A set of coverage points
— Cross coverage between coverage points
— Optional formal arguments
— Coverage options
The construct is a user-defined type. The type definition is written once, and multiple
covergroup
instances of that type can be created in different contexts. Similar to a class, once defined, a
covergroup
instance can be created via the operator. A can be defined in a package, module,
new() covergroup
program, interface, checker, or class (see Syntax19-1).
covergroup_declaration ::= // from A.2.11
covergroup_identifier [ [ tf_port_list ] ] [ coverage_event ]
covergroup ( ) ;
{ coverage_spec_or_option }
[ covergroup_identifier ]
endgroup :
coverage_spec_or_option ::=
{attribute_instance} coverage_spec
| {attribute_instance} coverage_option
;
coverage_option ::=
member_identifier expression
option. =
| member_identifier constant_expression
type_option. =
coverage_spec ::=
cover_point
| cover_cross
coverage_event ::=
clocking_event
| [ tf_port_list ]
withfunctionsample( )
| block_event_expression
@@( )
block_event_expression ::=
block_event_expression block_event_expression
or
| hierarchical_btf_identifier
begin
| hierarchical_btf_identifier
end
hierarchical_btf_identifier ::=
hierarchical_tf_identifier
| hierarchical_block_identifier
| [ hierarchical_identifier | class_scope ] method_identifier
.
Syntax19-1—Covergroup syntax (excerpt from AnnexA)
554
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The identifier associated with the declaration defines the name of the coverage model. Using
covergroup
this name, an arbitrary number of coverage model instances can be created. For example:
covergroup cg; ... endgroup
cg cg_inst = new;
The preceding example defines a named . An instance of is declared as and
covergroup cg cg cg_inst
created using the operator.
new
A covergroup can specify an optional list of arguments as described in 13.5. When the covergroup specifies
a list of formal arguments, its instances shall provide to the operator all the actual arguments that are not
new
defaulted. Actual arguments are evaluated when the operator is executed. A argument allows a
new ref
different variable to be sampled by each instance of a covergroup. Input arguments will not track the value
of their arguments; they will use the value passed to the operator.
new
An or shall be illegal as a formal argument. Since a covergroup cannot modify any argument
output inout
to the operator, a argument will be treated the same as a read-only argument. The
new ref const ref
formal arguments of a covergroup cannot be accessed using a hierarchical name (the formals cannot be
accessed outside the covergroup declaration).
If a clocking event is specified, it defines the event at which coverage points are sampled. Because it is in the
scope of the covergroup, the clocking event can be based on arguments of the covergroup. If an
ref
automatic variable is passed by reference, behavior is undefined. If a clocking event is not specified, users
must procedurally trigger the coverage sampling via the built-in method (see 19.8). The
sample()
predefined method accepts no arguments; however, users may override this by specifying as the
sample()
triggering function a sample method with an argument list (see 19.8.1). If the overridden method
sample()
specifies a list of formal arguments then each call to the method must provide all the actual
sample()
arguments that are not defaulted. If the coverage_event is omitted, the coverage group shall specify the
predefined method.
sample()
Optionally, the option (see 19.7.1) can be used to modify the sampling behavior. When the
strobe strobe
option is not set (the default), a coverage point is sampled the instant the clocking event takes place, as if the
process triggering the event were to call the built-in method. If the clocking event occurs
sample()
multiple times in a time step, the coverage point will also be sampled multiple times. The option
strobe
can be used to specify that coverage points are sampled in the Postponed region, thereby filtering multiple
clocking events so that only one sample per time slot is taken. The option only applies to the
strobe
scheduling of samples triggered by a clocking event. It shall have no effect on procedural calls to the built-in
method.
sample()
As an alternative to a clocking event or a sample method, a coverage group accepts a block event expression
to indicate that the coverage sample is to be triggered by the start or the end of execution of a given named
block, task, function, or class method. Block event expressions that specify the keyword followed by
begin
a hierarchical identifier denoting a named block, task, function, or class method shall be triggered
immediately before the corresponding block, task, function, or method begins executing its first statement.
Block event expressions that specify the keyword followed by a hierarchical identifier denoting a
end
named block, task, function, or class method shall be triggered immediately after the corresponding block,
task, function, or method executes its last statement. Block event expressions that specify the end of
execution shall not be triggered if the block, task, function, or method is disabled.
A covergroup can contain one or more coverage points. A coverage point can cover a variable or an
expression.
Each coverage point includes a set of bins associated with its sampled values or its value transitions. Bins
associated with value sets are referred to as state bins while bins associated with value transitions are
referred to as transition bins. The bins can be explicitly defined by the user or automatically created by the
tool. Coverage points are discussed in detail in 19.5.
555
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
enum { red, green, blue } color;
covergroup g1 @(posedge clk);
c: coverpoint color;
endgroup
The preceding example defines coverage group with a single coverage point associated with variable
g1
color. The value of the variable color is sampled at the indicated clocking event: the positive edge of signal
. Because the coverage point does not explicitly define any bins, the tool automatically creates three
clk
bins, one for each possible value of the enumerated type. Automatic bins are described in 19.5.3.
A coverage group can also specify cross coverage between two or more coverage points or variables. Any
combination of more than two variables or previously declared coverage points is allowed. For example:
enum { red, green, blue } color;
bit [3:0] pixel_adr, pixel_offset, pixel_hue;
covergroup g2 @(posedge clk);
Hue: coverpoint pixel_hue;
Offset: coverpoint pixel_offset;
AxC: cross color, pixel_adr; // cross 2 variables (implicitly declared
// coverpoints)
all: cross color, Hue, Offset; // cross 1 variable and 2 coverpoints
endgroup
This example creates coverage group that includes two coverage points and two cross coverage items.
g2
Explicit coverage points labeled and are defined for variables and
Offset Hue pixel_offset
. SystemVerilog implicitly declares coverage points for variables and in
pixel_hue color pixel_adr
order to track their cross coverage. Implicitly declared coverage points are described in 19.6.
A coverage group can also specify one or more options to control and regulate how coverage data are
structured and collected. Coverage options can be specified for the coverage group as a whole or for specific
items within the coverage group, that is, any of its coverage points or crosses. In general, a coverage option
specified at the covergroup level applies to all of its items unless overridden by them. Coverage options are
described in 19.7.
19.4 Using covergroup in classes
By embedding a coverage group within a class definition, the covergroup provides a simple way to cover a
subset of the class properties. This integration of coverage with classes provides an intuitive and expressive
mechanism for defining the coverage model associated with a class. For example:
In class , defined as follows, members and are covered using an embedded :
xyz m_x m_y covergroup
class xyz;
bit [3:0] m_x;
int m_y;
bit m_z;
covergroup cov1 @m_z; // embedded covergroup
coverpoint m_x;
coverpoint m_y;
endgroup
556
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
function new(); cov1 = new; endfunction
endclass
In this example, data members and of class are sampled on every change of data member .
m_x m_y xyz m_z
A declaration within a class is an embedded covergroup declaration. An embedded
covergroup
declaration declares an anonymous type and an instance variable of the
covergroup covergroup
anonymous type. The covergroup_identifier defines the name of the instance variable. In the preceding
example, a variable (of the anonymous coverage group) is implicitly declared.
cov1
An embedded covergroup can define a coverage model for protected and local class properties without any
changes to the class data encapsulation. Class members can be used in coverpoint expressions or can be used
in other coverage constructs, such as conditional guards or option initialization.
A class can have more than one covergroup. The following example shows two coverage groups in class :
MC
class MC;
logic [3:0] m_x;
local logic m_z;
bit m_e;
covergroup cv1 @(posedge clk); coverpoint m_x; endgroup
covergroup cv2 @m_e ; coverpoint m_z; endgroup
endclass
In , public class member variable is sampled at every positive edge of signal .
covergroup cv1 m_x clk
Local class member is covered by another Each coverage group is sampled by a
m_z covergroup cv2.
different clocking event.
An embedded covergroup variable may only be assigned in the method. An embedded coverage group
new
can be explicitly instantiated in the method. If it is not, then the coverage group is not created and no
new
data will be sampled.
Following is an example of an embedded coverage group that does not have any passed-in arguments and
uses explicit instantiation to synchronize with another object:
class Helper;
int m_ev;
endclass
class MyClass;
Helper m_obj;
int m_a;
covergroup Cov @(m_obj.m_ev);
coverpoint m_a;
endgroup
function new();
m_obj = new;
Cov = new; // Create embedded covergroup after creating m_obj
endfunction
endclass
In this example, is embedded within class , which contains an object of type
covergroup Cov MyClass
class, called . The clocking event for the embedded coverage group refers to data member
Helper m_obj
of . Because the coverage group uses , must be instantiated before .
m_ev m_obj Cov m_obj m_obj Cov
Therefore, the coverage group is instantiated after instantiating in the class constructor. As
Cov m_obj
557
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
shown previously, the instantiation of an embedded coverage group is done by assigning the result of the
operator to the coverage group identifier.
new
The following example shows how arguments passed in to an embedded coverage group can be used to set a
coverage option of the coverage group:
class C1;
bit [7:0] x;
covergroup cv (int arg) @(posedge clk);
option.at_least = arg;
coverpoint x;
endgroup
function new(int p1);
cv = new(p1);
endfunction
endclass
initial begin
C1 obj = new(4);
end
19.5 Defining coverage points
A covergroup can contain one or more coverage points. A coverage point specifies an integral expression
that is to be covered. Each coverage point includes a set of bins associated with the sampled values or value
transitions of the covered expression. The bins can be explicitly defined by the user or automatically created
by SystemVerilog. The syntax for specifying coverage points is given in Syntax19-2. Evaluation of the
coverage point expression (and of its enabling condition, if any) takes place when the covergroup is
iff
sampled. The expression shall be evaluated in a procedural context, and therefore it shall be legal for the
expression to make access through a virtual interface (see 25.9).
cover_point ::= // from A.2.11
[ [ data_type_or_implicit ] cover_point_identifier ] expression [ expression ]
: coverpoint iff( )
bins_or_empty
bins_or_empty ::=
{attribute_instance} { bins_or_options }
{ ; }
|
;
bins_or_options ::=
coverage_option
| [ ] bins_keyword bin_identifier [ [ covergroup_expression ] ]
wildcard [ ] =
covergroup_range_list [ with_covergroup_expression ]
{ } with( )
[ expression ]
iff( )
| [ ] bins_keyword bin_identifier [ [ covergroup_expression ] ]
wildcard [ ] =
cover_point_identifier with_covergroup_expression [ expression ]
with( ) iff( )
| [ ] bins_keyword bin_identifier [ [ covergroup_expression ] ]
wildcard [ ] =
set_covergroup_expression [ expression ]
iff( )
| [ ] bins_keyword bin_identifier [ ] trans_list [ expression ]
wildcard [ ] = iff( )
| bins_keyword bin_identifier [ [ covergroup_expression ] ] [ expression ]
[ ] =default iff( )
| bins_keyword bin_identifier [ expression ]
=defaultsequence iff( )
bins_keyword::= | |
bins illegal_bins ignore_bins
covergroup_range_list ::= covergroup_value_range { covergroup_value_range }
,
558
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
covergroup_value_range ::=
covergroup_expression
| covergroup_expression covergroup_expression 25
[ : ]
with_covergroup_expression ::= covergroup_expression26
set_covergroup_expression ::= covergroup_expression27
covergroup_expression ::= expression28
25) It shall be legal to use the primary in an open_value_range or covergroup_value_range of the form expression
$ [ :
or expression .
$] [$: ]
26) The result of this expression shall be assignment compatible with an integral type.
27) This expression is restricted as described in 19.5.1.2.
28) This expression is restricted as described in 19.5.
Syntax19-2—Coverage point syntax (excerpt from AnnexA)
A coverage point creates a hierarchical scope and can be optionally labeled. If the label is
coverpoint
specified, then it designates the name of the coverage point. This name can be used to add this coverage
point to a cross coverage specification or to access the methods of the coverage point. If the label is omitted
and the coverage point is associated with a single variable, then the variable name becomes the name of the
coverage point. Otherwise, an implementation can generate a name for the coverage point only for the
purposes of coverage reporting, that is, generated names cannot be used within the language.
A data type for the coverpoint may be specified explicitly or implicitly in data_type_or_implicit. In either
case, it shall be understood that a data type is specified for the coverpoint. The data type shall be an integral
type. If a data type is specified, then a cover_point_identifier shall also be specified.
If a data type is specified, then the coverpoint expression shall be assignment compatible with the data type.
Values for the coverpoint shall be of the specified data type and shall be determined as though the
coverpoint expression were assigned to a variable of the specified data type.
If no data type is specified, then the inferred data type for the coverpoint shall be the self-determined type of
the coverpoint expression.
A coverpoint name has limited visibility. An identifier can only refer to a coverpoint in the following
contexts:
— In the coverpoint list of a declaration (see 19.6),
cross
— In a hierarchical name where the prefix specifies the name of a covergroup variable. For example,
where is the name of a covergroup variable and is the name of
cov1.cp.option.weight cov1 cp
a coverpoint declared within the covergroup.
— Following , where the left operand of the scope resolution operator refers to a covergroup. For
::
example, .
covtype :: cp :: type_option.weight
Only constant expressions (see 11.2.1), global and instance constants (for an embedded covergroup, see 19.4
and 8.19), or non-ref arguments to the covergroup are allowed to be used as variables in a
covergroup_expression.
Global and instance constants referenced from a covergroup_expression shall be members of the enclosing
class. The initializers for such instance constants shall appear before the referring covergroup constructor
call in the class constructor. These initializers shall not appear with the covergroup constructor call in the
body of any looping statement (see 12.7) or - , either before or after.
fork join_none
559
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Function calls may participate in a covergroup_expression, but the following semantic restrictions are
imposed:
— Functions shall not contain or non- arguments ( is allowed).
output constref constref
— Functions shall be automatic (or preserve no state information) and have no side effects.
— Functions shall not reference non-constant variables outside the local scope of the function.
— System function calls are restricted to constant system function calls (see 11.2.1).
For example:
covergroup cg ( ref int x , ref int y, input int c);
coverpoint x; // creates coverpoint "x" covering the formal "x"
x: coverpoint y; // INVALID: coverpoint label "x" already exists
b: coverpoint y; // creates coverpoint "b" covering the formal "y"
cx: coverpoint x; // creates coverpoint "cx" covering the formal "x"
option.weight = c; // set weight of "cg" to value of formal "c"
bit [7:0] d: coverpoint y[31:24]; // creates coverpoint "d" covering the
// high order 8 bits of the formal "y"
e: coverpoint x {
option.weight = 2; // set the weight of coverpoint "e"
}
e.option.weight = 2; // INVALID use of "e", also syntax error
cross x, y { // Creates implicit coverpoint "y" covering
// the formal "y". Then creates a cross of
// coverpoints "x", "y"
option.weight = c; // set weight of cross to value of formal "c"
}
b: cross y, x; // INVALID: coverpoint label "b" already exists
endgroup
A coverage point can sample the values that correspond to a particular scheduling region (see Clause4) by
specifying a clocking block signal. Thus, a coverage point that denotes a clocking block signal will sample
the values made available by the clocking block. If the clocking block specifies a skew of , the
#1step
coverage point will sample the signal values from the Preponed region. If the clocking block specifies a
skew of #0, the coverage point will sample the signal values from the Observed region.
The expression within the construct specifies an optional condition that disables coverage for that
iff
. If the guard expression evaluates to false at a sampling point, the coverage point is ignored.
coverpoint
For example:
covergroup g4;
coverpoint s0 iff(!reset);
endgroup
In the preceding example, coverage point is covered only if the value is false.
s0 reset
A coverage point bin associates a name and a count with a set of values or a sequence of value transitions. If
the bin designates a set of values, the count is incremented every time the coverage point matches one of the
values in the set. If the bin designates a sequence of value transitions, the count is incremented every time
the coverage point matches the entire sequence of value transitions.
560
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The bins for a coverage point can be automatically created by SystemVerilog or explicitly defined using the
construct to name each bin. If the bins are not explicitly defined, they are automatically created by
bins
SystemVerilog. The number of automatically created bins can be controlled using the
auto_bin_max
coverage option. Coverage options are described in 19.7.
The specification defines a bin that is associated with none of the defined value bins. The default
default
bin catches the values of the coverage point that do not lie within any of the defined bins. However, the
coverage calculation for a coverage point shall not take into account the coverage captured by the default
bin. The default bin is also excluded from cross coverage (see 19.6). The default is useful for catching
unplanned or invalid values. The form can be used to catch all transitions (or
default sequence
sequences) that do not lie within any of the defined transition bins (see 19.5.2). The
default sequence
specification does not accept multiple transition bins (i.e., the notation is not allowed). A or
[] default
bin specification cannot be explicitly ignored (see 19.5.5). It shall be an error for bins
defaultsequence
designated as to also specify a or .
ignore_bins default defaultsequence
19.5.1 Specifying bins for values
The construct allows creating a separate bin for each value in the given range list or a single bin for the
bins
entire range of values. To create a separate bin for each value (an array of bins), the square brackets, ,
[]
shall follow the bin name. To create a fixed number of bins for a set of values, a single positive integral
expression can be specified inside the square brackets. The bin name and optional square brackets are
followed by a covergroup_range_list that specifies the set of values associated with the bin. It shall be legal
to use the primary in a covergroup_value_range of the form expression or expression .
$ [ : $ ] [ $ : ]
If a fixed number of bins is specified and that number is smaller than the specified number of values, then
the possible bin values are uniformly distributed among the specified bins. The first N specified values are
assigned to the first bin, the next N specified values are assigned to the next bin, etc. Duplicate values are
retained; thus the same value can be assigned to multiple bins. If the number of values is not divisible by the
number of bins, then the last bin will include the remaining items. For example:
bins fixed [4] = { [1:10], 1, 4, 7 };
The 13 possible values are distributed as follows: <1,2,3>, <4,5,6>, <7,8,9>, <10,1,4,7>. If the number of
bins exceeds the number of values, then some of the bins will be empty.
The expression within the construct at the end of a bin definition provides a per-bin guard condition. If
iff
the expression is false at a sampling point, the count for the bin is not incremented.
bit [9:0] v_a;
covergroup cg @(posedge clk);
coverpoint v_a
{
bins a = { [0:63],65 };
bins b[] = { [127:150],[148:191] }; // note overlapping values
bins c[] = { 200,201,202 };
bins d = { [1000:$] };
bins others[] = default;
}
endgroup
In the preceding example, the first construct associates bin with the values of variable between
bins a v_a
0 and 63 and the value 65. The second construct creates a set of 65 bins , , .
bins b[127] b[128]...b[191]
Likewise, the third construct creates 3 bins: , , and . The fourth construct
bins c[200] c[201] c[202] bins
561
Authorized licensed use limited to: Siemens AG GBS B&SC oSpOyLr iGghMtS ©. D 2o0w1n8lo IaEdEedE o. nA Dll ericgehmtsb erre 0s3e,r2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
associates bin with the values between 1000 and 1023 ( represents the maximum value of ). Every
d $ v_a
value that does not match bins , , , or is added into its own distinct bin.
a b[] c[] d
Generic coverage groups can be written by passing their traits as arguments to the constructor. For example:
covergroup cg (ref int ra, input int low, int high ) @(posedge clk);
coverpoint ra // sample variable passed by reference
{
bins good = { [low : high] };
bins bad[] = default;
}
endgroup
...
int va, vb;
cg c1 = new( va, 0, 50 ); // cover variable va in the range 0 to 50
cg c2 = new( vb, 120, 600 ); // cover variable vb in the range 120 to 600
This example defines a coverage group, , in which the signal to be sampled and the extent of the coverage
cg
bins are specified as arguments. Later, two instances of the coverage group are created; each instance
samples a different signal and covers a different range of values.
19.5.1.1 Coverpoint bin covergroup expressions
with
The clause specifies that only those values in the covergroup_range_list that satisfy the given
with
expression (i.e., for which the expression evaluates to true, as described in 12.4) are included in the bin. In
the expression, the name shall be used to represent the candidate value. The candidate value is of the
item
same type as the coverpoint.
The name of the coverpoint itself may be used in place of the covergroup_range_list to denote all values of
the coverpoint. Only the name of the coverpoint containing the bin being defined shall be allowed; no other
coverpoint names shall be permitted.
Consider the following example:
a: coverpoint x
{
bins mod3[] = {[0:255]} with (item % 3 == 0);
}
This bin definition selects all values from 0 to 255 that are evenly divisible by 3.
coverpoint b
{
bins func[] = b with (myfunc(item));
}
Note the use of the coverpoint name to denote that the with_covergroup_expression will be applied to all
b
values of the coverpoint.
As with array manipulation methods involving (see 7.12), if the expression has side effects, the results
with
are unpredictable.
The clause behaves as if the expression were evaluated for every value in the covergroup_range_list at
with
the time the covergroup instance is constructed. By default, the with_covergroup_expression is applied to
562
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
the set of values in the covergroup_range_list prior to distribution of values to the bins. If the distribution of
values is desired before with_covergroup_expression application, the covergroup
distribute_first
option (see 19.7.1) can be used to achieve this ordering. The result of applying a
with_covergroup_expression shall preserve multiple, equivalent bin items as well as bin order. The intent of
these rules is to allow the use of non-simulation analysis techniques to calculate the bin (for example, formal
symbolic analysis) or for caching of previously calculated results.
19.5.1.2 Coverpoint bin set covergroup expressions
The set_covergroup_expression syntax allows specifying an expression yielding an array of values that
define the bin. Any array whose element type is assignment compatible with the coverpoint type is
permitted, with the exception that associative arrays are not permitted. Identifiers declared within the
covergroup (such as coverpoint identifiers and bin identifiers) are not visible. The expression is evaluated
when the covergroup instance is constructed.
19.5.2 Specifying bins for transitions
The syntax for specifying transition bins (Syntax19-3) accepts a subset of the sequence syntax described in
16.9:
bins_or_options ::= // from A.2.11
coverage_option
| [ ] bins_keyword bin_identifier [ [ covergroup_expression ] ]
wildcard [ ] =
covergroup_range_list [ with_covergroup_expression ]
{ } with( )
[ expression ]
iff( )
| [ ] bins_keyword bin_identifier [ [ covergroup_expression ] ]
wildcard [ ] =
cover_point_identifier with_covergroup_expression [ expression ]
with( ) iff( )
| [ ] bins_keyword bin_identifier [ [ covergroup_expression ] ]
wildcard [ ] =
set_covergroup_expression [ expression ]
iff( )
| [ ] bins_keyword bin_identifier [ ] trans_list [ expression ]
wildcard [ ] = iff( )
...
bins_keyword::= | |
bins illegal_bins ignore_bins
covergroup_range_list ::= covergroup_value_range { covergroup_value_range }
,
trans_list ::= trans_set { trans_set }
( ) ,( )
trans_set ::= trans_range_list { trans_range_list }
=>
trans_range_list ::=
trans_item
| trans_item repeat_range
[* ]
| trans_item repeat_range
[–> ]
| trans_item repeat_range
[= ]
trans_item ::= covergroup_range_list
repeat_range ::=
covergroup_expression
| covergroup_expression covergroup_expression
:
Syntax19-3—Transition bin syntax (excerpt from AnnexA)
A trans_list specifies one or more sets of ordered value transitions of the coverage point. A single value
transition is thus specified as follows:
value1 => value2
563
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
It represents the value of coverage point at two successive sample points, that is, followed by
value1
at the next sample point.
value2
A sequence of transitions is represented as follows:
value1 => value3 => value4 => value5
In this case, is followed by , followed by , and followed by . A sequence
value1 value3 value4 value5
can be of any arbitrary length.
A set of transitions can be specified as follows:
range_list1 => range_list2
This specification expands to transitions between each value in and each value in
range_list1
. For example:
range_list2
1,5 => 6, 7
specifies the following four transitions:
( 1=>6 ), ( 1=>7 ), ( 5=>6 ), ( 5=>7 )
Consecutive repetitions of transitions are specified using:
trans_item [* repeat_range ]
Here, trans_item is repeated for repeat_range times. For example:
3 [* 5]
is the same as
3=>3=>3=>3=>3
An example of a range of repetitions is as follows:
3 [* 3:5]
which is the same as
( 3=>3=>3 ), ( 3=>3=>3=>3 ), ( 3=>3=>3=>3=>3 )
The goto repetition is specified using: trans_item repeat_range . The required number of occurrences
[-> ]
of a particular value is specified by the repeat_range. Any number of sample points can occur before the first
occurrence of the specified value and any number of sample points can occur between each occurrence of
the specified value. The transition following the goto repetition must immediately follow the last occurrence
of the repetition. For example:
3 [-> 3]
is the same as
...=>3...=>3...=>3
where the dots ( ) represent any transition that does not contain the value 3.
...
564
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A goto repetition followed by an additional value is represented as follows:
1 => 3 [ -> 3] => 5
is the same as
1...=>3...=>3...=>3 =>5
The nonconsecutive repetition is specified using: trans_item repeat_range . The required number of
[= ]
occurrences of a particular value is specified by the repeat_range. Any number of sample points can occur
before the first occurrence of the specified value and any number of sample points can occur between each
occurrence of the specified value. The transition following the nonconsecutive repetition may occur after
any number of sample points so long as the repetition value does not occur again.
For example:
3 [= 2]
is the same as
...=>3...=>3
A nonconsecutive repetition followed by an additional value is represented as follows:
1 => 3 [=2] => 6
is the same as
1...=>3...=>3...=>6
A trans_list specifies one or more sets of ordered value transitions of the coverage point. If the sequence of
value transitions of the coverage point matches any complete sequence in the trans_list, the coverage count
of the corresponding bin is incremented. For example:
bit [4:1] v_a;
covergroup cg @(posedge clk);
coverpoint v_a
{
bins sa = (4 => 5 => 6), ([7:9],10=>11,12);
bins sb[] = (4=> 5 => 6), ([7:9],10=>11,12);
bins sc = (12 => 3 [-> 1]);
bins allother = default sequence ;
}
endgroup
The preceding example defines three transition coverage bins. The first construct associates the
bins
following sequences with bin : 4=>5=>6, or 7=>11, 8=>11, 9=>11, 10=>11, 7=>12, 8=>12, 9=>12,
sa
10=>12. The second construct associates an individual bin with each of the above sequences:
bins
. The third bins construct associates the unbounded sequence
sb[4=>5=>6], ..., sb[10=>12]
with bin . The bin is incremented when none of the coverpoint’s other
12=>...=>3 sc allother
nondefault sequence transition bins increments, and none of the coverpoint’s previously pending transition
bins remains pending. For example, consider the following sequence of sampled values:
4 5 7 11 8 12 2 2 3
565
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.