IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The conventions for arguments are the same as for any other procedural subroutine calls, such as the use of
default arguments.
A constructor may be declared as a or method (see 8.18). A constructor shall not be
local protected
declared as a (see 8.10) or method (see 8.20).
static virtual
8.8 Typed constructor calls
class_new19 ::= // from A.2.4
[ class_scope ] [ list_of_arguments ]
new ( )
| expression
new
19) In a shallow copy, the expression shall evaluate to an object handle.
Syntax8-2—Calling a constructor (excerpt from AnnexA)
Uses of described in earlier parts of this clause require that the type of the object to be constructed
new
matches the assignment target’s type. An alternative form of constructor invocation, the typed constructor
call, adds class_scope immediately before the keyword, specifying the constructed object’s type
new
independently of the assignment target. The specified type shall be assignment compatible with the target.
The following example illustrates a typed constructor call. The keyword is described in 8.13. The
extends
concept of a superclass type is described in 8.15.
class C; . . . endclass
class D extends C; . . . endclass
C c = D::new; // variable c of superclass type C now references
// a newly constructed object of type D
NOTE—The effect of this typed constructor call is as if a temporary variable of type had been declared, constructed,
D
and then copied to variable , as in this example fragment:
c
D d = new;
C c = d;
A typed constructor call shall create and initialize a new object of the specified type. Creation and
initialization of the new object shall proceed exactly as it would for an ordinary constructor as described in
8.7. Arguments may be passed to a typed constructor call if appropriate, just as for an ordinary constructor.
If the type of object to be constructed is a parameterized class, as described in 8.25, the specified type may
have parameter specializations. The following example, continuing the previous example, illustrates a typed
constructor call for a parameterized class and also illustrates how arguments may be passed to the
constructor as described in 8.7.
class E #(type T = int) extends C;
T x;
function new(T x_init);
super.new();
x = x_init;
endfunction
endclass
initial begin
176
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
c = E #(.T(byte))::new(.x_init(5));
end
8.9 Static class properties
The previous examples have only declared instance class properties. Each instance of the class (i.e., each
object of type ) has its own copy of each of its eight variables. Sometimes only one version of a
Packet
variable is required to be shared by all instances. These class properties are created using the keyword
. Thus, for example, in the following case, all instances of a class need access to a common file
static
descriptor:
class Packet ;
static integer fileID = $fopen( "data", "r" );
Now, shall be created and initialized once. Thereafter, every object can access the file
fileID Packet
descriptor in the usual way:
Packet p;
c = $fgetc( p.fileID );
The static class properties can be used without creating an object of that type.
8.10 Static methods
Methods can be declared as . A static method is subject to all the class scoping and access rules, but
static
behaves like a regular subroutine that can be called outside the class, even with no class instantiation. A
static method has no access to non-static members (class properties or methods), but it can directly access
static class properties or call static methods of the same class. Access to non-static members or to the special
handle within the body of a static method is illegal and results in a compiler error. Static methods
this
cannot be virtual.
class id;
static int current = 0;
static function int next_id();
next_id = ++current; // OK to access static class property
endfunction
endclass
A static method is different from a task with static lifetime. The former refers to the lifetime of the method
within the class, while the latter refers to the lifetime of the arguments and variables within the task.
class TwoTasks;
static task t1(); ... endtask // static class method with
// automatic variable lifetime
task static t2(); ... endtask // ILLEGAL: non-static class method with
// static variable lifetime
endclass
8.11 This
The keyword is used to unambiguously refer to class properties, value parameters, local value
this
parameters, or methods of the current instance. The keyword denotes a predefined object handle that
this
refers to the object that was used to invoke the subroutine that is used within. The keyword shall
this this
177
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
only be used within non-static class methods, constraints, inlined constraint methods, or covergroups
embedded within classes (see 19.4); otherwise, an error shall be issued. For example, the following
declaration is a common way to write an initialization task:
class Demo ;
integer x;
function new (integer x);
this.x = x;
endfunction
endclass
The is now both a property of the class and an argument to the function . In the function , an
x new new
unqualified reference to shall be resolved by looking at the innermost scope, in this case, the subroutine
x
argument declaration. To access the instance class property, it is qualified with the keyword, to refer to
this
the current instance.
NOTE—In writing methods, members can be qualified with to refer to the current instance, but it is usually
this
unnecessary.
8.12 Assignment, renaming, and copying
Declaring a class variable only creates the name by which the object is known. Thus,
Packet p1;
creates a variable, , that can hold the handle of an object of class , but the initial value of is
p1 Packet p1
. The object does not exist, and does not contain an actual handle, until an instance of type
null p1 Packet
is created:
p1 = new;
Thus, if another variable is declared and assigned the old handle, , to the new one, as in
p1
Packet p2;
p2 = p1;
then there is still only one object, which can be referred to with either the name or . In this example,
p1 p2
was executed only once; therefore, only one object has been created.
new
If, however, the preceding example is rewritten as follows, a copy of shall be made:
p1
Packet p1;
Packet p2;
p1 = new;
p2 = new p1;
The last statement has executing a second time, thus creating a new object , whose class properties
new p2
are copied from . This is known as a shallow copy. All of the variables are copied: integers, strings,
p1
instance handles, etc. Objects, however, are not copied, only their handles; as before, two names for the
same object have been created. This is true even if the class declaration includes the instantiation operator
.
new
It shall be illegal to use a typed constructor call for a shallow copy (see 8.8).
A shallow copy executes in the following manner:
178
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
1) An object of the class type being copied is allocated. This allocation shall not call the object’s con-
structor or execute any variable declaration initialization assignments.
2) All class properties, including the internal states used for randomization and coverage, are copied to
the new object. Object handles are copied; this includes the object handles for covergroup objects
(see Clause19). An exception is made for embedded covergroups (see 19.4). The object handle of
an embedded covergroup shall be set to in the new object. The internal states for
null
randomization include the random number generator (RNG) state, the status of
constraint_mode
constraints, the status of random variables, and the cyclic state of variables (see
rand_mode randc
Clause18).
3) A handle to the newly created object is assigned to the variable on the left-hand side.
NOTE—A shallow copy does not create new coverage objects (covergroup instances). As a result, the properties of the
new object are not covered.
class baseA ;
integer j = 5;
endclass
class B ;
integer i = 1;
baseA a = new;
endclass
class xtndA extends baseA;
rand int x;
constraint cst1 { x < 10; }
endclass
function integer test;
xtndA xtnd1;
baseA base2, base3;
B b1 = new; // Create an object of class B
B b2 = new b1; // Create an object that is a copy of b1
b2.i = 10; // i is changed in b2, but not in b1
b2.a.j = 50; // change a.j, shared by both b1 and b2
test = b1.i; // test is set to 1 (b1.i has not changed)
test = b1.a.j; // test is set to 50 (a.j has changed)
xtnd1 = new; // create a new instance of class xtndA
xtnd1.x = 3;
base2 = xtnd1; // base2 refers to the same object as xtnd1
base3 = new base2; // Creates a shallow copy of xtnd1
endfunction
In the last statement is assigned a shallow copy of . The type of the variable is a handle
base3 base2 base3
to the base class . When the shallow copy is invoked, this variable contains a handle to an instance of
baseA
the extended class . The shallow copy creates a duplicate of the referenced object, resulting in a
xtndA
duplicate instance of the extended class . The handle to this instance is then assigned to the variable
xntdA
.
base3
Several things are noteworthy. First, class properties and instantiated objects can be initialized directly in a
class declaration. Second, the shallow copy does not copy objects. Third, instance qualifications can be
chained as needed to reach into objects or to reach through objects:
b1.a.j // reaches into a, which is a property of b1
p.next.next.next.val // chain through a sequence of handles to get to val
To do a full (deep) copy, where everything (including nested objects) is copied, custom code is typically
needed. For example:
179
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Packet p1 = new;
Packet p2 = new;
p2.copy(p1);
where is a custom method written to copy the object specified as its argument into its
copy(Packet p)
instance.
8.13 Inheritance and subclasses
The previous subclauses defined a class called . This class can be extended so that the packets can be
Packet
chained together into a list. One solution would be to create a new class called that contains
LinkedPacket
a variable of type called .
Packet packet_c
To refer to a class property of , the variable needs to be referenced.
Packet packet_c
class LinkedPacket;
Packet packet_c;
LinkedPacket next;
function LinkedPacket get_next();
get_next = next;
endfunction
endclass
Because is a special form of , a more elegant solution is to extend the class creating
LinkedPacket Packet
a new subclass that inherits the members of the base class. Thus, for example:
class LinkedPacket extends Packet;
LinkedPacket next;
function LinkedPacket get_next();
get_next = next;
endfunction
endclass
Now, all of the methods and class properties of are part of (as if they were defined
Packet LinkedPacket
in ), and has additional class properties and methods.
LinkedPacket LinkedPacket
The methods of the base class can also be overridden to change their definitions.
The mechanism provided by SystemVerilog is called single inheritance, that is, each class is derived from a
single base class.
8.14 Overridden members
Subclass objects are also legal representative objects of their base classes. For example, every
object is a perfectly legal object.
LinkedPacket Packet
The handle of a object can be assigned to a variable:
LinkedPacket Packet
LinkedPacket lp = new;
Packet p = lp;
180
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In this case, references to access the methods and class properties of the class. So, for example, if
p Packet
class properties and methods in are overridden, these overridden members referred to
LinkedPacket
through get the original members in the class. From , and all overridden members in
p Packet p new
are now hidden.
LinkedPacket
class Packet;
integer i = 1;
function integer get();
get = i;
endfunction
endclass
class LinkedPacket extends Packet;
integer i = 2;
function integer get();
get = -i;
endfunction
endclass
LinkedPacket lp = new;
Packet p = lp;
j = p.i; // j = 1, not 2
j = p.get(); // j = 1, not -1 or –2
To call the overridden method via a base class object ( in the example), the method needs to be declared
p
(see 8.20).
virtual
8.15 Super
The keyword is used from within a derived class to refer to members, class value parameters, or local
super
value parameters of the base class. It is necessary to use to access members, value parameters, or
super
local value parameters of a base class when those are overridden by the derived class. An expression using
to access the value parameter or local value parameter is not a constant expression.
super
class Packet; // base class
integer value;
function integer delay();
delay = value * value;
endfunction
endclass
class LinkedPacket extends Packet; // derived class
integer value;
function integer delay();
delay = super.delay()+ value * super.value;
endfunction
endclass
The member, value parameter, or local value parameter can be declared a level up or be inherited by the
class one level up. There is no way to reach higher (for example, is not allowed).
super.super.count
Subclasses (or derived classes) are classes that are extensions of the current class whereas superclasses (base
classes) are classes from which the current class is extended, beginning with the original base class.
181
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A call shall be the first statement executed in the constructor. This is because the superclass
super.new
shall be initialized before the current class and, if the user code does not provide an initialization, the
compiler shall insert a call to automatically.
super.new
8.16 Casting
It is always legal to assign an expression of subclass type to a variable of a class type higher in the
inheritance tree (a superclass or ancestor of the expression type). It shall be illegal to directly assign a
variable of a superclass type to a variable of one of its subclass types. However, may be used to
$cast
assign a superclass handle to a variable of a subclass type provided the superclass handle refers to an object
that is assignment compatible with the subclass variable.
To check whether the assignment is legal, the dynamic cast function is used (see 6.24.2).
$cast
The prototype for is as follows:
$cast
function int $cast( singular dest_var, singular source_exp );
or
task $cast( singular dest_var, singular source_exp );
When is applied to class handles, it succeeds in only three cases:
$cast
1) The source expression and the destination type are assignment compatible, that is, the destination is
the same type or a superclass of the source expression.
2) The type of the source expression is cast compatible with the destination type, that is, either:
— the type of the source expression is a superclass of the destination type, or
— the type of the source expression is an interface class (see 8.26)
and the source is an object that is assignment compatible with the destination type. This type of
assignment requires a run-time check as provided by .
$cast
3) The source expression is the literal constant .
null
In all other situations shall fail, particularly when the source and destination types are not cast
$cast
compatible, even if the source expression evaluates to .
null
When succeeds, it performs the assignment. Otherwise, the error handling is as described in 6.24.2.
$cast
8.17 Chaining constructors
When a subclass is instantiated, the class method is invoked. The first action that takes, before
new() new()
any code defined in the function is evaluated, is to invoke the method of its superclass and so on up
new()
the inheritance hierarchy. Thus, all the constructors are called, in the proper order, beginning with the root
base class and ending with the current class. Class property initialization occurs during this sequence as
described in 8.7.
If the initialization method of the superclass requires arguments, there are two choices: to always supply the
same arguments or to use the keyword. If the arguments are always the same, then they can be
super
specified at the time the class is extended:
class EtherPacket extends Packet(5);
This passes 5 to the routine associated with .
new Packet
A more general approach is to use the keyword, to call the superclass constructor:
super
182
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
function new();
super.new(5);
endfunction
To use this approach, ... shall be the first executable statement in the function .
super.new( ) new
If the arguments are specified at the time the class is extended, the subclass constructor shall not contain a
call. The compiler shall insert a call to automatically, as whenever the
super.new() super.new()
subclass constructor does not contain a call (see 8.15).
super.new()
NOTE 1—Declaring a class constructor as a method makes that class inextensible since the reference to
local
in a subclass would be illegal.
super.new()
NOTE 2—When calling a virtual method from a constructor , the constructor calls the method as described in
new()
8.20. However, users must be aware of the class property initialization sequence as described in 8.7, as properties the
method refers to may not have been initialized, depending on where in the chain of constructors the method was called
from.
8.18 Data hiding and encapsulation
In SystemVerilog, unqualified class properties and methods are public, available to anyone who has access
to the object’s name. Often, it is desirable to restrict access to class properties and methods from outside the
class by hiding their names. This keeps other programmers from relying on a specific implementation, and it
also protects against accidental modifications to class properties that are internal to the class. When all data
become hidden (i.e., being accessed only by public methods), testing and maintenance of the code become
much easier.
Class parameters and class local parameters are also public.
A member identified as is available only to methods inside the class. Further, these local members
local
are not visible within subclasses. Of course, nonlocal methods that access local class properties or methods
can be inherited and work properly as methods of the subclass.
A class property or method has all of the characteristics of a member, except that it can
protected local
be inherited; it is visible to subclasses.
Within a class, a local method or class property of the same class can be referenced, even if it is in a different
instance of the same class. For example:
class Packet;
local integer i;
function integer compare (Packet other);
compare = (this.i == other.i);
endfunction
endclass
A strict interpretation of encapsulation might say that should not be visible inside this packet
other.i
because it is a local class property being referenced from outside its instance. Within the same class,
however, these references are allowed. In this case, shall be compared to , and the result of
this.i other.i
the logical comparison returned.
Class members can be identified as either or ; class properties can be further defined as
local protected
, and methods can be defined as . There is no predefined ordering for specifying these
const virtual
modifiers; however, they can only appear once per member. It shall be an error to define members to be both
and or to duplicate any of the other modifiers.
local protected
183
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
8.19 Constant class properties
Class properties can be made read-only by a declaration like any other SystemVerilog variable.
const
However, because class objects are dynamic objects, class properties allow two forms of read-only
variables: global constants and instance constants.
Global constant class properties include an initial value as part of their declaration. They are similar to other
variables in that they cannot be assigned a value anywhere other than in the declaration.
const
class Jumbo_Packet;
const int max_size = 9 * 1024; // global constant
byte payload [];
function new( int size );
payload = new[ size > max_size ? max_size : size ];
endfunction
endclass
Instance constants do not include an initial value in their declaration, only the qualifier. This type of
const
constant can be assigned a value at run time, but the assignment can only be done once in the corresponding
class constructor.
class Big_Packet;
const int size; // instance constant
byte payload [];
function new();
size = $urandom % 4096; //one assignment in new -> ok
payload = new[ size ];
endfunction
endclass
Typically, global constants are also declared because they are the same for all instances of the class.
static
However, an instance constant cannot be declared because doing so would disallow all assignments
static
in the constructor.
8.20 Virtual methods
A method of a class may be identified with the keyword . Virtual methods are a basic polymorphic
virtual
construct. A virtual method shall override a method in all of its base classes, whereas a non-virtual method
shall only override a method in that class and its descendants. One way to view this is that there is only one
implementation of a virtual method per class hierarchy, and it is always the one in the latest derived class.
Virtual methods provide prototypes for the methods that later override them, i.e., all of the information
generally found on the first line of a method declaration: the encapsulation criteria, the type and number of
arguments, and the return type if it is needed.
Virtual method overrides in subclasses shall have matching argument types, identical argument names,
identical qualifiers, and identical directions to the prototype. The qualifier is optional in the
virtual
derived class method declarations. The return type of a virtual function shall be either:
— a matching type (see 6.22.1)
— or a derived class type
of the return type of the virtual function in the superclass. It is not necessary to have matching default
expressions, but the presence of a default shall match.
184
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 1 illustrates virtual method override.
Example 1:
class BasePacket;
int A = 1;
int B = 2;
function void printA;
$display("BasePacket::A is %d", A);
endfunction : printA
virtual function void printB;
$display("BasePacket::B is %d", B);
endfunction : printB
endclass : BasePacket
class My_Packet extends BasePacket;
int A = 3;
int B = 4;
function void printA;
$display("My_Packet::A is %d", A);
endfunction: printA
virtual function void printB;
$display("My_Packet::B is %d", B);
endfunction : printB
endclass : My_Packet
BasePacket P1 = new;
My_Packet P2 = new;
initial begin
P1.printA; // displays 'BasePacket::A is 1'
P1.printB; // displays 'BasePacket::B is 2'
P1 = P2; // P1 has a handle to a My_packet object
P1.printA; // displays 'BasePacket::A is 1'
P1.printB; // displays 'My_Packet::B is 4' – latest derived method
P2.printA; // displays 'My_Packet::A is 3'
P2.printB; // displays 'My_Packet::B is 4'
end
Example 2 illustrates the use of a derived class type for a virtual function return type and of matching formal
argument types. In the derived class , the virtual function return type is , a derived class type of . The
D D C
formal argument data type is , which is a matching data type of the predefined type .
T int
Example 2:
typedef int T; // T and int are matching data types.
class C;
virtual function C some_method(int a); endfunction
endclass
class D extends C;
virtual function D some_method(T a); endfunction
endclass
class E #(type Y = logic) extends C;
virtual function D some_method(Y a); endfunction
endclass
185
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
E #() v1; // Illegal: type parameter Y resolves to logic, which is not
// a matching type for argument a
E #(int) v2; // Legal: type parameter Y resolves to int
A virtual method may override a non-virtual method, but once a method has been identified as virtual, it
shall remain virtual in any subclass that overrides it. In that case, the keyword may be used in later
virtual
declarations, but is not required.
8.21 Abstract classes and pure virtual methods
A set of classes may be created that can be viewed as all being derived from a common base class. For
example, a common base class of type that sets out the structure of packets, but is incomplete,
BasePacket
would never be constructed. This is characterized as an abstract class. From this abstract base class,
however, a number of useful subclasses may be derived, such as Ethernet packets, token ring packets, GPS
packets, and satellite packets. Each of these packets might look very similar, all needing the same set of
methods, but they could vary significantly in terms of their internal details.
A base class may be characterized as being abstract by identifying it with the keyword :
virtual
virtual class BasePacket;
...
endclass
An object of an abstract class shall not be constructed directly. Its constructor may only be called indirectly
through the chaining of constructor calls originating in an extended non-abstract object.
A virtual method in an abstract class may be declared as a prototype without providing an implementation.
This is called a pure virtual method and shall be indicated with the keyword together with not
pure
providing a method body. An extended subclass may provide an implementation by overriding the pure
virtual method with a virtual method having a method body.
Abstract classes may be extended to further abstract classes, but all pure virtual methods shall have
overridden implementations in order to be extended by a non-abstract class. By having implementations for
all its methods, the class is complete and may now be constructed. Any class may be extended into an
abstract class, and may provide additional or overridden pure virtual methods.
virtual class BasePacket;
pure virtual function integer send(bit[31:0] data); // No implementation
endclass
class EtherPacket extends BasePacket;
virtual function integer send(bit[31:0] data);
// body of the function
...
endfunction
endclass
is now a class that can have an object of its type constructed.
EtherPacket
NOTE—A method without a statement body is still a legal, callable method. For example, if the function was
send
declared as follows, it would have an implementation:
virtual function integer send(bit[31:0] data); // Will return 'x
endfunction
186
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
8.22 Polymorphism: dynamic method lookup
Polymorphism allows the use of a variable of the superclass type to hold subclass objects and to reference
the methods of those subclasses directly from the superclass variable. As an example, assume the base class
for the objects, , defines, as virtual functions, all of the public methods that are to be
Packet BasePacket
generally used by its subclasses. Such methods include , , and . Even though
send receive print
is abstract, it can still be used to declare a variable:
BasePacket
BasePacket packets[100];
Now, instances of various packet objects can be created and put into the array:
EtherPacket ep = new; // extends BasePacket
TokenPacket tp = new; // extends BasePacket
GPSPacket gp = new; // extends EtherPacket
packets[0] = ep;
packets[1] = tp;
packets[2] = gp;
If the data types were, for example, integers, bits, and strings, all of these types could not be stored into a
single array, but with polymorphism, it can be done. In this example, because the methods were declared as
, the appropriate subclass methods can be accessed from the superclass variable, even though the
virtual
compiler did not know—at compile time—what was going to be loaded into it.
For example,
packets[1]
packets[1].send();
shall invoke the method associated with the class. At run time, the system correctly
send TokenPacket
binds the method from the appropriate class.
This is a typical example of polymorphism at work, providing capabilities that are far more powerful than
what is found in a nonobject-oriented framework.
8.23 Class scope resolution operator ::
The class scope resolution operator is used to specify an identifier defined within the scope of a class. It
::
has the following form:
class_type :: { class_type :: } identifier
The left operand of the scope resolution operator shall be a class type name, package name (see 26.2),
::
type name, name, name (see 19.5, 19.6), name, or type
covergroup coverpoint cross typedef
parameter name. When a type name is used, the name shall resolve to a class or covergroup type after
elaboration.
Because classes and other scopes can have the same identifiers, the class scope resolution operator uniquely
identifies a member, a parameter or local parameter of a particular class. In addition to disambiguating class
scope identifiers, the operator also allows access to static members (class properties and methods), class
::
parameters, and class local parameters from outside the class, as well as access to public or protected
elements of a superclass from within the derived classes. A class parameter or local parameter is a public
element of a class. A class scoped parameter or local parameter is a constant expression.
187
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
class Base;
typedef enum {bin,oct,dec,hex} radix;
static task print( radix r, integer n ); ... endtask
endclass
...
Base b = new;
int bin = 123;
b.print( Base::bin, bin ); // Base::bin and bin are different
Base::print( Base::hex, 66 );
In SystemVerilog, the class scope resolution operator applies to all static elements of a class: static class
properties, static methods, typedefs, enumerations, parameters, local parameters, constraints, structures,
unions, and nested class declarations. Class scope resolved expressions can be read (in expressions), written
(in assignments or subroutines calls), or triggered off (in event expressions). A class scope can also be used
as the prefix of a type or a method call.
Like modules, classes are scopes and can nest. Nesting allows hiding of local names and local allocation of
resources. This is often desirable when a new type is needed as part of the implementation of a class.
Declaring types within a class helps prevent name collisions and the cluttering of the outer scope with
symbols that are used only by that class. Type declarations nested inside a class scope are public and can be
accessed outside the class.
class StringList;
class Node; // Nested class for a node in a linked list.
string name;
Node link;
endclass
endclass
class StringTree;
class Node; // Nested class for a node in a binary tree.
string name;
Node left, right;
endclass
endclass
// StringList::Node is different from StringTree::Node
The class scope resolution operator enables the following:
— Access to static public members (methods and class properties) from outside the class hierarchy.
— Access to public or protected class members of a superclass from within the derived classes.
— Access to constraints, type declarations, and enumeration named constants declared inside the class
from outside the class hierarchy or from within derived classes.
— Access to parameters and local parameters declared inside the class from outside the class hierarchy
or from within derived classes.
Nested classes shall have the same access rights as methods do in the containing class. They have full access
rights to and methods and properties of the containing class. Nested classes have
local protected
lexically scoped, unqualified access to the properties and methods, parameters, and local
static
parameters of the containing class. They shall not have implicit access to non-static properties and methods
except through a handle either passed to it or otherwise accessible by it. There is no implicit handle to
this
the outer class. For example:
class Outer;
int outerProp;
local int outerLocalProp;
188
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
static int outerStaticProp;
static local int outerLocalStaticProp;
class Inner;
function void innerMethod(Outer h);
outerStaticProp = 0;
// Legal, same as Outer::outerStaticProp
outerLocalStaticProp = 0;
// Legal, nested classes may access local's in outer class
outerProp = 0;
// Illegal, unqualified access to non-static outer
h.outerProp = 0;
// Legal, qualified access.
h.outerLocalProp = 0;
// Legal, qualified access and locals to outer class allowed.
endfunction
endclass
endclass
The class scope resolution operator has special rules when used with a prefix that is the name of a
parameterized class; see 8.25.1 for details.
8.24 Out-of-block declarations
It is convenient to be able to move method definitions out of the body of the class declaration. This is done
in two steps. First, within the class body, declare the method prototypes, i.e., whether it is a function or task,
any qualifiers ( , , or ), and the full argument specification plus the
local protected virtual extern
qualifier. The qualifier indicates that the body of the method (its implementation) is to be found
extern
outside the declaration. Second, outside the class declaration, declare the full method (e.g., the prototype but
without the qualifiers), and, to tie the method back to its class, qualify the method name with the class name
and a pair of colons, as follows:
class Packet;
Packet next;
function Packet get_next();// single line
get_next = next;
endfunction
// out-of-body (extern) declaration
extern protected virtual function int send(int value);
endclass
function int Packet::send(int value);
// dropped protected virtual, added Packet::
// body of method
...
endfunction
The out-of-block method declaration shall match the prototype declaration exactly, with the following
exceptions:
— The method name is preceded by the class name and the class scope resolution operator.
— A function return type may also require the addition of a class scope in the out-of-block declaration,
as described below.
— A default argument value specified in the prototype may be omitted in the out-of-block declaration.
If a default argument value is specified in the out-of-block declaration, then there shall be a
syntactically identical default argument value specified in the prototype.
189
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
An out-of-block declaration shall be declared in the same scope as the class declaration and shall follow the
class declaration. It shall be an error if more than one out-of-block declaration is provided for a particular
method.
extern
The class scope resolution operator is required in some situations in order to name the return type of a
method with an out-of-block declaration. When the return type of the out-of-block declaration is defined
within the class, the class scope resolution operator shall be used to indicate the internal return type.
Example:
typedef real T;
class C;
typedef int T;
extern function T f();
extern function real f2();
endclass
function C::T C::f(); // the return must use the class scope resolution
// operator, since the type is defined within the
// class
return 1;
endfunction
function real C::f2();
return 1.0;
endfunction
An out-of-block method declaration shall be able to access all declarations of the class in which the
corresponding prototype is declared. Following normal resolution rules, the prototype has access to class
types only if they are declared prior to the prototype. It shall be an error if an identifier referenced in the
prototype does not resolve to the same declaration as the declaration resolved for the corresponding
identifier in the out-of-block method declaration’s header.
Example:
typedef int T;
class C;
extern function void f(T x);
typedef real T;
endclass
function void C::f(T x);
endfunction
In this example, identifier in the prototype for method resolves to the declaration of in the outer scope.
T f T
In the out-of-block declaration for method the identifier resolves to since the out-of-block
f T C::T
declaration has visibility to all types in class . Since the resolution of in the out-of-block declaration does
C T
not match the resolution in the prototype, an error shall be reported.
190
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
8.25 Parameterized classes
It is often useful to define a generic class whose objects can be instantiated to have different array sizes or
data types. This avoids writing similar code for each size or type and allows a single specification to be used
for objects that are fundamentally different and (like a templated class in C++) not interchangeable.
The SystemVerilog parameter mechanism is used to parameterize a class:
class vector #(int size = 1);
bit [size-1:0] a;
endclass
Instances of this class can then be instantiated like modules or interfaces:
vector #(10) vten; // object with vector of size 10
vector #(.size(2)) vtwo; // object with vector of size 2
typedef vector#(4) Vfour; // Class with vector of size 4
This feature is particularly useful when using types as parameters:
class stack #(type T = int);
local T items[];
task push( T a ); ... endtask
task pop( ref T a ); ... endtask
endclass
The preceding class defines a generic stack class, which can be instantiated with any arbitrary type:
stack is; // default: a stack of ints
stack#(bit[1:10]) bs; // a stack of 10-bit vectors
stack#(real) rs; // a stack of real numbers
Any type can be supplied as a parameter, including a user-defined type such as a or .
class struct
The combination of a generic class and the actual parameter values is called a specialization. Each
specialization of a class has a separate set of member variables (this is consistent with C++
static
templated classes). To share static member variables among several class specializations, they shall be
placed in a nonparameterized base class.
class vector #(int size = 1);
bit [size-1:0] a;
static int count = 0;
function void disp_count();
$display( "count: %d of size %d", count, size );
endfunction
endclass
The variable in the preceding example can only be accessed by the corresponding
count disp_count
method. Each specialization of the class has its own unique copy of .
vector count
A specialization is the combination of a specific generic class with a unique set of parameters. Two sets of
parameters shall be unique unless all parameters are the same, as defined by the following rules:
a) A parameter is a type parameter and the two types are matching types.
b) A parameter is a value parameter and both their type and their value are the same.
191
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
All matching specializations of a particular generic class shall represent the same type. The set of matching
specializations of a generic class is defined by the context of the class declaration. Because generic classes
in a package are visible throughout the system, all matching specializations of a package generic class are
the same type. In other contexts, such as modules or programs, each instance of the scope containing the
generic class declaration creates a unique generic class, thus defining a new set of matching specializations.
A generic class is not a type; only a concrete specialization represents a type. In the preceding example, the
class vector becomes a concrete type only when it has had parameters applied to it, for example:
typedef vector my_vector; // use default size of 1
vector#(6) vx; // use size 6
To avoid having to repeat the specialization either in the declaration or to create parameters of that type, a
should be used:
typedef
typedef vector#(4) Vfour;
typedef stack#(Vfour) Stack4;
Stack4 s1, s2; // declare objects of type Stack4
A parameterized class can extend another parameterized class. For example:
class C #(type T = bit); ... endclass // base class
class D1 #(type P = real) extends C; // T is bit (the default)
class D2 #(type P = real) extends C #(integer); // T is integer
class D3 #(type P = real) extends C #(P); // T is P
class D4 #(type P = C#(real)) extends P; // for default, T is real
Class extends the base class using the base class’s default type ( ) parameter. Class extends the
D1 C bit D2
base class using an parameter. Class extends the base class using the parameterized type ( )
C integer D3 C P
with which the extended class is parameterized. Class extends the base class specified by the type
D4
parameter .
P
When a type parameter or typedef name is used as a base class, as in class above, the name shall resolve
D4
to a class type after elaboration.
The default specialization of a parameterized class is the specialization of the parameterized class with an
empty parameter override list. For a parameterized class , the default specialization is . Other than as
C C#()
the prefix of the scope resolution operator, use of the unadorned name of a parameterized class shall denote
the default specialization of the class. Not all parameterized classes have a default specialization since it is
legal for a class to not provide parameter defaults. In that case all specializations shall override at least those
parameters with no defaults.
Example:
class C #(int p = 1);
...
endclass
class D #(int p);
...
endclass
C obj; // legal; equivalent to "C#() obj";
D obj; // illegal; D has no default specialization
192
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
8.25.1 Class scope resolution operator for parameterized classes
Use of the class scope resolution operator with a prefix that is the unadorned name of a parameterized class
(see 8.25) shall be restricted to use within the scope of the named parameterized class and within its out-of-
block declarations (see 8.24). In such cases, the unadorned name of the parameterized class does not denote
the default specialization but is used to unambiguously refer to members of the parameterized class. When
referring to the default specialization as the prefix to the class scope resolution operator, the explicit default
specialization form of shall be used.
#()
Outside the context of a parameterized class or its out-of-block declarations, the class scope resolution
operator may be used to access any of the class parameters. In such a context, the explicit specialization
form shall be used; the unadorned name of the parameterized class shall be illegal. The explicit
specialization form may denote a specific parameter or the default specialization form. The class scope
resolution operator may access value as well as type parameters that are either local or parameters to the
class.
Example:
class C #(int p = 1);
parameter int q = 5; // local parameter
static task t;
int p;
int x = C::p; // C::p disambiguates p
// C::p is not p in the default specialization
endtask
endclass
int x = C::p; // illegal; C:: is not permitted in this context
int y = C#()::p; // legal; refers to parameter p in the default
// specialization of C
typedef C T; // T is a default specialization, not an alias to
// the name "C"
int z = T::p; // legal; T::p refers to p in the default specialization
int v = C#(3)::p; // legal; parameter p in the specialization of C#(3)
int w = C#()::q; // legal; refers to the local parameter
T obj = new();
int u = obj.q; // legal; refers to the local parameter
bit arr[obj.q]; // illegal: local parameter is not a constant expression
In the context of a parameterized class method out-of-block declaration, use of the class scope resolution
operator shall be a reference to the name as though it was made inside the parameterized class; no
specialization is implied.
Example:
class C #(int p = 1, type T = int);
extern static function T f();
endclass
function C::T C::f();
return p + C::p;
endfunction
initial $display("%0d %0d", C#()::f(),C#(5)::f());// output is "2 10"
193
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
8.26 Interface classes
A set of classes may be created that can be viewed as all having a common set of behaviors. Such a common
set of behaviors may be created using interface classes. An interface class makes it unnecessary for related
classes to share a common abstract superclass or for that superclass to contain all method definitions needed
by all subclasses. A non-interface class can be declared as implementing one or more interface classes. This
creates a requirement for the non-interface class to provide implementations for a set of methods that shall
satisfy the requirements of a virtual method override (see 8.20).
An shall only contain pure virtual methods (see 8.21), type declarations (see 6.18), and
interfaceclass
parameter declarations (see 6.20, 8.25). Constraint blocks, covergroups, and nested classes (see 8.23) shall
not be allowed in an interface class. An interface class shall not be nested within another class. An interface
class can inherit from one or more interface classes through the keyword, meaning that it inherits
extends
all the member types, pure virtual methods and parameters of the interface classes it extends, except for any
member types and parameters that it may hide. In the case of multiple inheritance, name conflicts may occur
that must be resolved (see 8.26.6).
Classes can implement one or more interface classes through the keyword. No member types
implements
or parameters are inherited through the keyword. A subclass implicitly implements all of the
implements
interface classes implemented by its superclass. In the following example, class implicitly implements
C
interface class and has all of the requirements and capabilities as if it explicitly implemented interface
A
class :
A
interface class A;
endclass
class B implements A;
endclass
class C extends B;
endclass
Each pure virtual method from an interface class shall have a virtual method implementation in order to be
implemented by a non-abstract class. When an interface class is implemented by a class, the required
implementations of interface class methods may be provided by inherited virtual method implementations.
A shall define or inherit a method prototype or method
virtual class pure virtual virtual
implementation for each method prototype in each implemented . The
pure virtual interface class
keyword shall be used unless the virtual method is inherited.
virtual
A variable whose declared type is an interface class type may have as its value a reference to any instance of
a class that implements the specified interface class (see 8.22). It is not sufficient that a class provides
implementations for all the pure virtual methods of an interface class; the class or one of its superclasses
shall be declared to implement the interface class through the keyword, or else the class does
implements
not implement the interface class.
The following is a simple example of interface classes.
interface class PutImp#(type PUT_T = logic);
pure virtual function void put(PUT_T a);
endclass
interface class GetImp#(type GET_T = logic);
pure virtual function GET_T get();
endclass
194
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
class Fifo#(type T = logic, int DEPTH=1) implements PutImp#(T), GetImp#(T);
T myFifo [$:DEPTH-1];
virtual function void put(T a);
myFifo.push_back(a);
endfunction
virtual function T get();
get = myFifo.pop_front();
endfunction
endclass
class Stack#(type T = logic, int DEPTH=1) implements PutImp#(T), GetImp#(T);
T myFifo [$:DEPTH-1];
virtual function void put(T a);
myFifo.push_front(a);
endfunction
virtual function T get();
get = myFifo.pop_front();
endfunction
endclass
The example has two interface classes, and , which contain prototype pure virtual methods
PutImp GetImp
and . The and classes use the keyword to implement the and
put get Fifo Stack implements PutImp
interface classes and they provide implementations for and . These classes therefore share
GetImp put get
common behaviors without sharing a common implementation.
8.26.1 Interface class syntax
interface_class_declaration ::= // from A.1.2
class_identifier [ parameter_port_list ]
interfaceclass
[ interface_class_type { interface_class_type } ]
extends , ;
{ interface_class_item }
[ class_identifier]
endclass :
interface_class_item ::=
type_declaration
| { attribute_instance } interface_class_method
| local_parameter_declaration
;
| parameter_declaration7
;
|
;
interface_class_method ::=
method_prototype
purevirtual ;
7) In a parameter_declaration that is a class_item, the keyword shall be a synonym for the
parameter
keyword.
localparam
Syntax8-3—Class syntax (excerpt from AnnexA)
8.26.2 Extends versus implements
Conceptually is a mechanism to add to or modify the behavior of a superclass while
extends implements
is a requirement to provide implementations for the pure virtual methods in an interface class. When a class
is extended, all members of the class are inherited into the subclass. When an interface class is implemented,
nothing is inherited.
195
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
An interface class may extend, but not implement, one or more interface classes, meaning that the interface
subclass inherits members from multiple interface classes and may add additional member types, pure
virtual method prototypes, and parameters. A class or virtual class may implement, but not extend, one or
more interface classes. Because virtual classes are abstract, they are not required to fully define the methods
from their implemented classes (see 8.26.7). The following highlights these differences:
— An interface class
• may extend zero or more interface classes
• may not implement an interface class
• may not extend a class or virtual class
• may not implement a class or virtual class
— A class or virtual class
• may not extend an interface class
• may implement zero or more interface classes
• may extend at most one other class or virtual class
• may not implement a class or virtual class
• may simultaneously extend a class and implement interface classes
In the following example, a class is both extending a base class and implementing two interface classes:
interface class PutImp#(type PUT_T = logic);
pure virtual function void put(PUT_T a);
endclass
interface class GetImp#(type GET_T = logic);
pure virtual function GET_T get();
endclass
class MyQueue #(type T = logic, int DEPTH = 1);
T PipeQueue[$:DEPTH-1];
virtual function void deleteQ();
PipeQueue.delete();
endfunction
endclass
class Fifo #(type T = logic, int DEPTH = 1)
extends MyQueue#(T, DEPTH)
implements PutImp#(T), GetImp#(T);
virtual function void put(T a);
PipeQueue.push_back(a);
endfunction
virtual function T get();
get = PipeQueue.pop_front();
endfunction
endclass
In this example, the property and method are inherited in the class. In addition
PipeQueue deleteQ Fifo
the class is also implementing the and interface classes so it shall provide
Fifo PutImp GetImp
implementations for the and methods, respectively.
put get
The following example demonstrates that multiple types can be parameterized in the class definition and the
resolved types used in the implemented classes and .
PutImp GetImp
virtual class XFifo#(type T_in = logic, type T_out = logic, int DEPTH = 1)
extends MyQueue#(T_out)
implements PutImp#(T_in), GetImp#(T_out);
196
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
pure virtual function T_out translate(T_in a);
virtual function void put(T_in a);
PipeQueue.push_back(translate(a));
endfunction
virtual function T_out get();
get = PipeQueue.pop_front();
endfunction
endclass
An inherited virtual method can provide the implementation for a method of an implemented interface class.
Here is an example:
interface class IntfClass;
pure virtual function bit funcBase();
pure virtual function bit funcExt();
endclass
class BaseClass;
virtual function bit funcBase();
return (1);
endfunction
endclass
class ExtClass extends BaseClass implements IntfClass;
virtual function bit funcExt();
return (0);
endfunction
endclass
fulfills its requirement to implement by providing an implementation of
ExtClass IntfClass funcExt
and by inheriting an implementation of from .
funcBase BaseClass
An inherited non-virtual method does not provide an implementation for a method of an implemented
interface class.
interface class IntfClass;
pure virtual function void f();
endclass
class BaseClass;
function void f();
$display("Called BaseClass::f()");
endfunction
endclass
class ExtClass extends BaseClass implements IntfClass;
virtual function void f();
$display("Called ExtClass::f()");
endfunction
endclass
The non-virtual function in does not fulfill the requirement to implement . The
f() BaseClass IntfClass
implementation of in simultaneously hides the of and fulfills the
f() ExtClass f() BaseClass
requirement to implement .
IntfClass
197
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
8.26.3 Type access
Parameters and typedefs within an interface class are inherited by extending interface classes, but are not
inherited by implementing interface classes. All parameters and typedefs within an interface class are static
and can be accessed through the class scope resolution operator (see 8.23). Accessing parameters through
::
an interface class handle has the same restrictions as accessing parameters through a class handle (see 8.5).
Example 1: Types and parameter declarations are inherited by .
extends
interface class IntfA #(type T1 = logic);
typedef T1[1:0] T2;
pure virtual function T2 funcA();
endclass : IntfA
interface class IntfB #(type T = bit) extends IntfA #(T);
pure virtual function T2 funcB(); // legal, type T2 is inherited
endclass : IntfB
Example 2: Type and parameter declarations are not inherited by and must be specified with
implements
the class scope resolution operator.
interface class IntfC;
typedef enum {ONE, TWO, THREE} t1_t;
pure virtual function t1_t funcC();
endclass : IntfC
class ClassA implements IntfC;
t1_t t1_i; // error, t1_t is not inherited from IntfC
virtual function IntfC::t1_t funcC(); // correct
return (IntfC::ONE); // correct
endfunction : funcC
endclass : ClassA
8.26.4 Type usage restrictions
A class shall not implement a type parameter, nor shall an interface class extend a type parameter, even if the
type parameter resolves to an interface class. The following examples illustrate this restriction and are
illegal:
class Fifo #(type T = PutImp) implements T;
virtual class Fifo #(type T = PutImp) implements T;
interface class Fifo #(type T = PutImp) extends T;
A class shall not implement a forward typedef for an interface class. An interface class shall not extend from
a forward typedef of an interface class. An interface class shall be declared before it is implemented or
extended.
typedef interface class IntfD;
class ClassB implements IntfD #(bit); // illegal
virtual function bit[1:0] funcD();
endclass : ClassB
// This interface class declaration must be declared before ClassB
interface class IntfD #(type T1 = logic);
typedef T1[1:0] T2;
pure virtual function T2 funcD();
198
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
endclass : IntfD
8.26.5 Casting and object reference assignment
It shall be legal to assign an object handle to a variable of an interface class type that the object implements.
class Fifo #(type T = int) implements PutImp#(T), GetImp#(T);
endclass
Fifo#(int) fifo_obj = new;
PutImp#(int) put_ref = fifo_obj;
It shall be legal to dynamically cast between interface class variables if the actual class handle is valid to
assign to the destination.
GetImp#(int) get_ref;
Fifo#(int) fifo_obj = new;
PutImp#(int) put_ref = fifo_obj;
$cast(get_ref, put_ref);
In the preceding, is an instance of that implements . It shall also be
put_ref Fifo#(int) GetImp#(int)
legal to cast from an object handle to an interface class type handle if the actual object implements the
interface class type.
$cast(fifo_obj, put_ref); // legal
$cast(put_ref, fifo_obj); // legal, but casting is not required
Like abstract classes, an object of an interface class type shall not be constructed.
put_ref = new(); // illegal
Casting from a source interface class handle that is is handled in the same manner as casting from a
null
source class handle that is (see 8.16).
null
8.26.6 Name conflicts and resolution
When a class implements multiple interface classes, or when an extends multiple
interface class
interface classes, identifiers are merged from different name spaces into a single name space. When this
occurs, it is possible that the same identifier name from multiple name spaces may be simultaneously visible
in a single name space creating a name conflict that must be resolved.
8.26.6.1 Method name conflict resolution
It is possible that an interface class may inherit multiple methods, or a class may be required through
to provide an implementation of multiple methods, where these methods have the same name.
implements
This is a method name conflict. A method name conflict shall be resolved with a single method prototype or
implementation that simultaneously provides an implementation for all pure virtual methods of the same
name of any implemented interface class. That method prototype or implementation must also be a valid
virtual method override (see 8.20) for any inherited method of the same name.
Example:
interface class IntfBase1;
pure virtual function bit funcBase();
endclass
interface class IntfBase2;
199
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
pure virtual function bit funcBase();
endclass
virtual class ClassBase;
pure virtual function bit funcBase();
endclass
class ClassExt extends ClassBase implements IntfBase1, IntfBase2;
virtual function bit funcBase();
return (0);
endfunction
endclass
Class provides an implementation of that overrides the pure virtual method prototype
ClassExt funcBase
from and simultaneously provides an implementation for from both and
ClassBase funcBase IntfBase1
.
IntfBase2
There are cases in which a method name conflict cannot be resolved.
Example:
interface class IntfBaseA;
pure virtual function bit funcBase();
endclass
interface class IntfBaseB;
pure virtual function string funcBase();
endclass
class ClassA implements IntfBaseA, IntfBaseB;
virtual function bit funcBase();
return (0);
endfunction
endclass
In this case, is prototyped in both and but with different return types,
funcBase IntfBaseA IntfBaseB
and respectively. Although the implementation of is a valid override of
bit string funcBase
, it is not simultaneously a valid override of the prototype of
IntfBaseA::funcBase IntfBaseB::
so an error shall occur.
funcBase,
8.26.6.2 Parameter and type declaration inheritance conflicts and resolution
Interface classes may inherit parameters and type declarations from multiple interface classes. A name
collision will occur if the same name is inherited from different interface classes. The subclass shall provide
parameter and/or type declarations that override all such name collisions.
Example:
interface class PutImp#(type T = logic);
pure virtual function void put(T a);
endclass
interface class GetImp#(type T = logic);
pure virtual function T get();
endclass
interface class PutGetIntf#(type TYPE = logic)
200
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
extends PutImp#(TYPE), GetImp#(TYPE);
typedef TYPE T;
endclass
In the preceding example, the parameter is inherited from both and . A conflict occurs
T PutImp GetImp
despite the fact that matches and is never used by .
PutImp::T GetImp::T PutGetIntf PutGetIntf
overrides with a type definition to resolve the conflict.
T
8.26.6.3 Diamond relationship
A diamond relationship occurs if an interface class is implemented by the same class or inherited by the
same interface class in multiple ways. In the case of a diamond relationship, only one copy of the symbols
from any single interface class will be merged so as to avoid a name conflict. For example:
interface class IntfBase;
parameter SIZE = 64;
endclass
interface class IntfExt1 extends IntfBase;
pure virtual function bit funcExt1();
endclass
interface class IntfExt2 extends IntfBase;
pure virtual function bit funcExt2();
endclass
interface class IntfExt3 extends IntfExt1, IntfExt2;
endclass
In the preceding example, the class inherits the parameter from and .
IntfExt3 SIZE IntfExt1 IntfExt2
Since these parameters originate from the same interface class, , only one copy of shall be
IntfBase SIZE
inherited into so it shall not be considered a conflict.
IntfExt3
Each unique parameterization of a parameterized interface class is an interface class specialization. Each
interface class specialization is considered as though it is a unique interface class type. Therefore, there is no
diamond relationship if different specializations of the same parameterized interface class are inherited by
the same interface class or implemented by the same class. As a result, method name conflicts as described
in 8.26.6.1 and parameter and type declaration name conflicts as described in 8.26.6.2 may occur. For
example:
interface class IntfBase #(type T = int);
pure virtual function bit funcBase();
endclass
interface class IntfExt1 extends IntfBase#(bit);
pure virtual function bit funcExt1();
endclass
interface class IntfExt2 extends IntfBase#(logic);
pure virtual function bit funcExt2();
endclass
interface class IntfFinal extends IntfExt1, IntfExt2;
typedef bit T; // Override the conflicting identifier name
pure virtual function bit funcBase();
endclass
201
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In the preceding example, there are two different parameterizations of the interface class . Each of
IntfBase
these parameterizations of is a specialization; therefore there is no diamond relationship and
IntfBase
there are conflicts of the parameter and method that must be resolved.
T funcBase
8.26.7 Partial implementation
It is possible to create classes that are not fully defined and that take advantage of interface classes through
the use of virtual classes (see 8.21). Because virtual classes do not have to fully define their implementation,
they are free to partially define their methods. The following is an example of a partially implemented
virtual class.
interface class IntfClass;
pure virtual function bit funcA();
pure virtual function bit funcB();
endclass
// Partial implementation of IntfClass
virtual class ClassA implements IntfClass;
virtual function bit funcA();
return (1);
endfunction
pure virtual function bit funcB();
endclass
// Complete implementation of IntfClass
class ClassB extends ClassA;
virtual function bit funcB();
return (1);
endfunction
endclass
It shall be illegal to use an interface class to partially define a virtual class without fulfilling the interface
class prototype requirements. In other words, when an interface class is implemented by a virtual class, the
virtual class must do one of the following for each interface class method prototype:
— Provide a method implementation
— Re-declare the method prototype with the qualifier
pure
In the preceding example fully defines , but re-declares the prototype .
ClassA funcA funcB
8.26.8 Method default argument values
Method declarations within interface classes may have default argument values. The default expression shall
be a constant expression and is evaluated in the scope containing the subroutine declaration. The value of the
constant expression shall be the same for all the classes that implement the method. See 13.5.3 for more
information.
8.26.9 Constraint blocks, covergroups, and randomization
Constraint blocks and covergroups shall not be declared in interface classes.
A method call shall be legal with interface class handles. While in-line constraints shall also be
randomize
legal, interface classes cannot contain any data meaning that in-line constraints will only be able to express
conditions related to state variables and are therefore of very limited utility. Use of and
rand_mode
shall not be legal as a consequence of the name resolution rules and the fact that
constraint_mode
interface classes are not permitted to contain data members.
202
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Interface classes contain two built-in empty virtual methods and
pre_randomize() post_randomize()
that are automatically called before and after randomization. These methods can be overridden. As a special
case, and shall not cause method name conflicts.
pre_randomize() post_randomize()
8.27 Typedef class
Sometimes a class variable needs to be declared before the class itself has been declared; for example, if two
classes each need a handle to the other. When, in the course of processing the declaration for the first class,
the compiler encounters the reference to the second class, that reference is undefined and the compiler flags
it as an error.
This is resolved using to provide a forward declaration for the second class:
typedef
typedef class C2; // C2 is declared to be of type class
class C1;
C2 c;
endclass
class C2;
C1 c;
endclass
In this example, is declared to be of type , a fact that is reinforced later in the source code. The
C2 class
construct always creates a type and does not require a declaration for that purpose (as in
class typedef
…).
typedef class
In the preceding example, the keyword in the statement is not necessary and
class typedef class C2;
is used only for documentation purposes. The statement is equivalent and shall work the
typedef C2;
same way.
As with other forward typedefs as described in 6.18, the actual class definition of a forward class declaration
shall be resolved within the same local scope or generate block.
A forward to a class may refer to a class with a parameter port list.
typedef
Example:
typedef class C ;
module top ;
C#(1, real) v2 ; // positional parameter override
C#(.p(2), .T(real)) v3 ; // named parameter override
endmodule
class C #(parameter p = 2, type T = int);
endclass
8.28 Classes and structures
On the surface, it might appear that and provide equivalent functionality, and only one of
class struct
them is needed. However, that is not true; differs from in the following three fundamental
class struct
ways:
a) SystemVerilog structs are strictly static objects; they are created either in a static memory location
(global or module scope) or on the stack of an automatic task. Conversely, SystemVerilog objects
(i.e., class instances) are exclusively dynamic; their declaration does not create the object. Creating
an object is done by calling .
new
203
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
b) SystemVerilog objects are implemented using handles, thereby providing C-like pointer
functionality. But SystemVerilog disallows casting handles onto other data types; thus,
SystemVerilog handles do not have the risks associated with C pointers.
c) SystemVerilog objects form the basis of an Object-Oriented data abstraction that provides true
polymorphism. Class inheritance, abstract classes, and dynamic casting are powerful mechanisms,
which go way beyond the mere encapsulation mechanism provided by structs.
8.29 Memory management
Memory for objects, strings, and dynamic and associative arrays is allocated dynamically. When objects are
created, SystemVerilog allocates more memory. When an object is no longer needed, SystemVerilog
automatically reclaims the memory, making it available for reuse. The automatic memory management
system is an integral part of SystemVerilog. Without automatic memory management, SystemVerilog’s
multithreaded, reentrant environment creates many opportunities for users to run into problems. A manual
memory management system, such as the one provided by C’s and , would not be sufficient.
malloc free
Consider the following example:
myClass obj = new;
fork
task1( obj );
task2( obj );
join_none
In this example, the main process (the one that forks off the two tasks) does not know when the two
processes might be done using the object . Similarly, neither nor knows when any of the
obj task1 task2
other two processes will no longer be using the object . It is evident from this simple example that no
obj
single process has enough information to determine when it is safe to free the object. The only two options
available to the user are as follows:
— Play it safe and never reclaim the object, or
— Add some form of reference count that can be used to determine when it might be safe to reclaim the
object.
Adopting the first option can cause the system to quickly run out of memory. The second option places a
large burden on users, who, in addition to managing their testbench, must also manage the memory using
less than ideal schemes. To avoid these shortcomings, SystemVerilog manages all dynamic memory
automatically.
Users do not need to worry about dangling references, premature deallocation, or memory leaks. The system
shall automatically reclaim any object that is no longer being used. In the preceding example, all that users
do is assign to all the variables referencing handle when they no longer need it. An object shall
null obj
not be reclaimed while there are outstanding references to that object in any active scope, or pending
nonblocking assignments to non-static members of that object.
204
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
9. Processes
9.1 General
This clause describes the following:
— Structured procedures (initial procedures, always procedures, final procedures)
— Block statements (begin-end sequential blocks, fork-join parallel blocks)
— Timing control (delays, events, waits, intra-assignment)
— Process threads and process control
9.2 Structured procedures
All structured procedures in SystemVerilog are specified within one of the following constructs:
— initial procedure, denoted with the keyword (see 9.2.1)
initial
— always procedure, denoted with the keywords:
• (see 9.2.2.1)
always
• (see 9.2.2.2)
always_comb
• (see 9.2.2.3)
always_latch
• (see 9.2.2.4)
always_ff
— final procedure, denoted with the keyword (see 9.2.3)
final
— Task
— Function
The syntax for these structured procedures is shown in Syntax9-1.
initial_construct ::= statement_or_null // from A.6.2
initial
always_construct ::= always_keyword statement
always_keyword ::= | | |
always always_comb always_latch always_ff
final_construct ::= function_statement
final
function_declaration ::= [ lifetime ] function_body_declaration // from A.2.6
function
task_declaration ::= [ lifetime ] task_body_declaration // from A.2.7
task
Syntax9-1—Syntax for structured procedures (excerpt from AnnexA)
The initial and always procedures are enabled at the beginning of a simulation. The initial procedure shall
execute only once, and its activity shall cease when the statement has finished. In contrast, an always
procedure shall execute repeatedly, and its activity shall cease only when the simulation is terminated.
There shall be no implied order of execution between initial and always procedures. The initial procedures
need not be scheduled and executed before the always procedures. There shall be no limit to the number of
initial and always procedures that can be defined in a module. See 6.8 for the order of variable initialization
relative to the execution of procedures.
The final procedures are enabled at the end of simulation time and execute only once.
Tasks and functions are procedures that are enabled from one or more places in other procedures. Tasks and
functions are described in Clause13.
205
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In addition to these structured procedures, SystemVerilog contains other procedural contexts, such as
coverage point expressions (19.5), assertion sequence match items (16.10, 16.11), and action blocks (16.14).
SystemVerilog has the following types of control flow within a procedure:
— Selection, loops, and jumps (see Clause12)
— Subroutine calls (see Clause13)
— Sequential and parallel blocks (see 9.3)
— Timing control (see 9.4)
— Process control (see 9.5 through 9.7)
9.2.1 Initial procedures
An procedure shall execute only once, and its activity shall cease when the statement has finished.
initial
The following example illustrates use of an initial procedure for initialization of variables at the start of
simulation.
initial begin
a = 0; // initialize a
for (int index = 0; index < size; index++)
memory[index] = 0; // initialize memory word
end
Another typical usage of the initial procedure is specification of waveform descriptions that execute once to
provide stimulus to the main part of the circuit being simulated.
initial begin
inputs = 'b000000; // initialize at time zero
#10 inputs = 'b011001; // first pattern
#10 inputs = 'b011011; // second pattern
#10 inputs = 'b011000; // third pattern
#10 inputs = 'b001000; // last pattern
end
9.2.2 Always procedures
There are four forms of always procedures: , , , and . All
always always_comb always_latch always_ff
forms of always procedures repeat continuously throughout the duration of the simulation.
9.2.2.1 General purpose always procedure
The keyword represents a general purpose always procedure, which can be used to represent
always
repetitive behavior such as clock oscillators. The construct can also be used with proper timing controls to
represent combinational, latched, and sequential hardware behavior.
The general purpose procedure, because of its looping nature, is only useful when used in
always
conjunction with some form of timing control. If an procedure has no control for simulation time to
always
advance, it will create a simulation deadlock condition.
The following code, for example, creates a zero-delay infinite loop:
always areg = ~areg;
206
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Providing a timing control to the preceding code creates a potentially useful description as shown in the
following:
always #half_period areg = ~areg;
9.2.2.2 Combinational logic always_comb procedure
SystemVerilog provides a special procedure for modeling combinational logic behavior. For
always_comb
example:
always_comb
a = b & c;
always_comb
d <= #1ns b & c;
The procedure provides functionality that is different from the general purpose
always_comb always
procedure, as follows:
— There is an inferred sensitivity list that includes the expressions defined in 9.2.2.2.1.
— The variables written on the left-hand side of assignments shall not be written to by any other
process. However, multiple assignments made to independent elements of a variable are allowed as
long as their longest static prefixes do not overlap (see 11.5.3). For example, an unpacked structure
or array can have one bit assigned by an procedure and another bit assigned
always_comb
continuously or by another procedure, etc. See 6.5 for more details.
always_comb
— The procedure is automatically triggered once at time zero, after all and
initial always
procedures have been started so that the outputs of the procedure are consistent with the inputs.
Software tools should perform additional checks to warn if the behavior within an procedure
always_comb
does not represent combinational logic, such as if latched behavior can be inferred.
9.2.2.2.1 Implicit always_comb sensitivities
The implicit sensitivity list of an includes the expansions of the longest static prefix of each
always_comb
variable or select expression that is read within the block or within any function called within the block with
the following exceptions:
a) Any expansion of a variable declared within the block or within any function called within the block
b) Any expression that is also written within the block or within any function called within the block
For the definition of the longest static prefix, see 11.5.3.
Hierarchical function calls and function calls from packages are analyzed as normal functions, as are calls to
static method functions referenced with the class scope resolution operator (see 8.23). References to class
objects and method calls of class objects do not add anything to the sensitivity list of an ,
always_comb
except for any contributions from argument expressions passed to these method calls.
Task calls are allowed in an , but the contents of the tasks do not add anything to the
always_comb
sensitivity list.
NOTE—A task that does not consume time may be replaced by a void function so that the contents will be analyzed for
sensitivity.
An expression used in an immediate assertion (see 16.3) within the procedure, or in any function called
within the procedure, contributes to the implicit sensitivity list of an as if that expression
always_comb
were used as a condition of an statement. Expressions used in assertion action blocks do not contribute to
if
207
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
the implicit sensitivity list of an . In the following example, the shall trigger
always_comb always_comb
whenever , or change.
b c e
always_comb
begin
a = b & c;
A1:assert (a != e) else if (!disable_error) $error("failed");
end
9.2.2.2.2 always_comb compared to always @*
The SystemVerilog procedure differs from (see 9.4.2.2) in the following ways:
always_comb always@*
— automatically executes once at time zero, whereas waits until a change
always_comb always @*
occurs on a signal in the inferred sensitivity list.
— is sensitive to changes within the contents of a function, whereas is only
always_comb always@*
sensitive to changes to the arguments of a function.
— Variables on the left-hand side of assignments within an procedure, including
always_comb
variables from the contents of a called function, shall not be written to by any other processes,
whereas permits multiple processes to write to the same variable.
always@*
— Statements in an shall not include those that block, have blocking timing or event
always_comb
controls, or fork-join statements.
— is sensitive to expressions in immediate assertions within the procedure and within
always_comb
the contents of a function called in the procedure, whereas is sensitive to expressions in
always@*
immediate assertions within the procedure only.
9.2.2.3 Latched logic always_latch procedure
SystemVerilog also provides a special procedure for modeling latched logic behavior. For
always_latch
example:
always_latch
if(ck) q <= d;
The construct is identical to the construct except that software tools should
always_latch always_comb
perform additional checks and warn if the behavior in an construct does not represent
always_latch
latched logic, whereas in an construct, tools should check and warn if the behavior does not
always_comb
represent combinational logic. All statements in 9.2.2.2 shall apply to .
always_latch
9.2.2.4 Sequential logic always_ff procedure
The procedure can be used to model synthesizable sequential logic behavior. For example:
always_ff
always_ff @(posedge clock iff reset == 0 or posedge reset) begin
r1 <= reset ? 0 : r2 + 1;
...
end
The procedure imposes the restriction that it contains one and only one event control and no
always_ff
blocking timing controls. Variables on the left-hand side of assignments within an procedure,
always_ff
including variables from the contents of a called function, shall not be written to by any other process.
Software tools should perform additional checks to warn if the behavior within an procedure
always_ff
does not represent sequential logic.
208
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
9.2.3 Final procedures
The procedure is like an procedure, defining a procedural block of statements, except that
final initial
it occurs at the end of simulation time and executes without delays. A procedure is typically used to
final
display statistical information about the simulation.
The only statements allowed inside a procedure are those permitted inside a function declaration, so
final
that they execute within a single simulation cycle. Unlike an procedure, the procedure does
initial final
not execute as a separate process; instead, it executes in zero time, as a series of function calls from a single
process. All procedures shall execute in an arbitrary order. No remaining scheduled events shall
final
execute after all final procedures have executed.
A procedure executes when simulation ends due to an explicit or implicit call to .
final $finish
final
begin
$display("Number of cycles executed %d",$time/period);
$display("Final PC = %h",PC);
end
Execution of , , or from within a
$finish tf_dofinish() vpi_control(vpiFinish,...) final
procedure shall cause the simulation to end immediately. A procedure can only trigger once in a
final
simulation.
A procedure shall execute before any PLI callbacks that indicate the end of simulation.
final
SystemVerilog procedures execute in an arbitrary but deterministic sequential order. This is possible
final
because procedures are limited to the legal set of statements allowed for functions.
final
NOTE—SystemVerilog does not specify the ordering in which final procedures are executed, but implementations
should define rules that preserve the ordering between runs. This helps keep the output log file stable because
final
procedures are mainly used for displaying statistics.
9.3 Block statements
Block statements are a means of grouping statements together so that they act syntactically like a single
statement. There are two types of blocks, as follows:
— Sequential block, also called begin-end block
— Parallel block, also called fork-join block
The sequential block shall be delimited by the keywords and . The procedural statements in a
begin end
sequential block shall be executed sequentially in the given order.
The parallel block shall be delimited by the keywords and , , or . The
fork join join_any join_none
procedural statements in a parallel block shall be executed concurrently.
9.3.1 Sequential blocks
A sequential block shall have the following characteristics:
— Statements shall be executed in sequence, one after another.
— Delay values for each statement shall be treated relative to the simulation time of the execution of
the previous statement.
— Control shall pass out of the block after the last statement executes.
209
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Syntax9-2 gives the formal syntax for a sequential block.
seq_block ::= // from A.6.3
[ block_identifier ] { block_item_declaration } { statement_or_null }
begin :
[ block_identifier ]
end :
block_item_declaration ::= // from A.2.8
{ attribute_instance } data_declaration
| { attribute_instance } local_parameter_declaration
;
| { attribute_instance } parameter_declaration
;
| { attribute_instance } let_declaration
Syntax9-2—Syntax for sequential block (excerpt from AnnexA)
Example 1: A sequential block enables the following two assignments to have a deterministic result:
begin
areg = breg;
creg = areg; // creg stores the value of breg
end
The first assignment is performed, and is updated before control passes to the second assignment.
areg
Example 2: An event control (see 9.4.2) can be used in a sequential block to separate the two assignments in
time:
begin
areg = breg;
@(posedge clock) creg = areg; // assignment delayed until
end // posedge on clock
Example 3: The following example shows how the combination of the sequential block and delay control
can be used to specify a time-sequenced waveform:
parameter d = 50; // d declared as a parameter and
logic [7:0] r; // r declared as an 8-bit variable
begin // a waveform controlled by sequential delays
#d r = 'h35;
#d r = 'hE2;
#d r = 'h00;
#d r = 'hF7;
end
9.3.2 Parallel blocks
The fork-join parallel block construct enables the creation of concurrent processes from each of its parallel
statements. A parallel block shall have the following characteristics:
— Statements shall execute concurrently.
— Delay values for each statement shall be considered relative to the simulation time of entering the
block.
— Delay control can be used to provide time-ordering for assignments.
— Control shall pass out of the block when the last time-ordered statement executes based on the type
of join keyword.
210
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Has restricted usage inside function calls (see 13.4).
Syntax9-3 gives the formal syntax for a parallel block.
par_block ::= // from A.6.3
[ block_identifier ] { block_item_declaration } { statement_or_null }
fork :
join_keyword [ block_identifier ]
:
join_keyword ::= | |
join join_any join_none
block_item_declaration ::= // from A.2.8
{ attribute_instance } data_declaration
| { attribute_instance } local_parameter_declaration
;
| { attribute_instance } parameter_declaration
;
| { attribute_instance } let_declaration
Syntax9-3—Syntax for parallel block (excerpt from AnnexA)
One or more statements can be specified; each statement shall execute as a concurrent process. The timing
controls in a fork-join block do not have to be ordered sequentially in time.
The following example codes the waveform description shown in Example 3 of 9.3.1 by using a parallel
block instead of a sequential block. The waveform produced on the variable is exactly the same for both
implementations.
fork
#50 r = 'h35;
#100 r = 'hE2;
#150 r = 'h00;
#200 r = 'hF7;
join
SystemVerilog provides three choices for specifying when the parent (forking) process resumes execution,
which are summarized in Table9-1.
Table9-1—fork-join control options
Option Description
The parent process blocks until all the processes spawned by this fork complete.
join
The parent process blocks until any one of the processes spawned by this fork completes.
join_any
The parent process continues to execute concurrently with all the processes spawned by the
join_none
fork. The spawned processes do not start executing until the parent thread executes a blocking
statement or terminates.
When defining a fork-join block, encapsulating the entire fork within a begin-end block causes the entire
block to execute as a single process, with each statement executing sequentially.
fork
begin
statement1; // one process with 2 statements
statement2;
end
join
211
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In the following example, two processes are forked. The first one waits for 20ns and the second one waits
for the named event to be triggered. Because the keyword is specified, the parent process shall
eventA join
block until the two processes complete, i.e., until 20ns have elapsed and has been triggered.
eventA
fork
begin
$display( "First Block\n" );
# 20ns;
end
begin
$display( "Second Block\n" );
@eventA;
end
join
A statement within the context of a fork-join block is illegal and shall result in a compilation error.
return
For example:
task wait_20;
fork
# 20;
return ; // Illegal: cannot return; task lives in another process
join_none
endtask
Variables declared in the block_item_declaration of a fork-join block shall be initialized to their
initialization value expression whenever execution enters their scope and before any processes are spawned.
Within a or block, it shall be illegal to refer to formal arguments
fork-join_any fork-join_none
passed by reference other than in the initialization value expressions of variables declared in a
block_item_declaration of the fork. These variables are useful in processes spawned by looping constructs
to store unique, per-iteration data. For example:
initial
for( int j = 1; j <= 3; ++j )
fork
automatic int k = j; // local copy, k, for each value of j
#k $write( "%0d", k );
begin
automatic int m = j; // the value of m is undetermined
...
end
join_none
The preceding example generates the output 123.
9.3.3 Statement block start and finish times
Both sequential and parallel blocks have the notion of a start and finish time. For sequential blocks, the start
time is when the first statement is executed, and the finish time is when the last statement has been executed.
For parallel blocks, the start time is the same for all the statements, and the finish time is controlled by the
type of join construct used (see 9.3.2, Table9-1).
Sequential and parallel blocks can be embedded within each other, allowing complex control structures to be
expressed easily and with a high degree of structure. When blocks are embedded within each other, the
timing of when a block starts and finishes is important. Execution shall not continue to the statement
212
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
following a block until the finish time for the block has been reached, that is, until the block has completely
finished executing.
Example 1: The following example shows the statements from the example in 9.3.2 written in the reverse
order and still producing the same waveform.
fork
#200 r = 'hF7;
#150 r = 'h00;
#100 r = 'hE2;
#50 r = 'h35;
join
Example 2: When an assignment is to be made after two separate events have occurred, known as the joining
of events, a block can be useful.
fork-join
begin
fork
@Aevent;
@Bevent;
join
areg = breg;
end
The two events can occur in any order (or even at the same simulation time), the block will
fork-join
complete once both events have occurred, and the assignment will be made. In contrast, if the
fork-join
block was a block and the occurred before the , then the block would be
begin-end Bevent Aevent
waiting for the next .
Bevent
Example 3: This example shows two sequential blocks, each of which will execute when its controlling
event occurs. Because the event controls are within a block, they execute in parallel, and the
fork-join
sequential blocks can, therefore, also execute in parallel.
fork
@enable_a
begin
#ta wa = 0;
#ta wa = 1;
#ta wa = 0;
end
@enable_b
begin
#tb wb = 1;
#tb wb = 0;
#tb wb = 1;
end
join
9.3.4 Block names
Both sequential and parallel blocks can be named by adding after the keywords
: name_of_block begin
or . A named block creates a new hierarchy scope. The naming of blocks serves the following
fork
purposes:
— It allows local variables, parameters, and named events to be referenced hierarchically, using the
block name.
— It allows the block to be referenced in statements such as the statement (see 9.6.2).
disable
213
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
An unnamed block creates a new hierarchy scope only if it directly contains a block item declaration, such
as a variable declaration or a type declaration. This hierarchy scope is unnamed and the items declared in it
cannot be hierarchically referenced (see 6.21).
All variables shall be static; that is, a unique location exists for all variables, and leaving or entering blocks
shall not affect the values stored in them.
The block names give a means of uniquely identifying all variables at any simulation time.
A matching block name may be specified after the block , , , or keyword,
end join join_any join_none
preceded by a colon. This can help document which or , , or is associated
end join join_any join_none
with which or when there are nested blocks. A name at the end of the block is not required. It
begin fork
shall be an error if the name at the end is different from the block name at the beginning.
begin: blockB // block name after the begin or fork
...
end: blockB
Similarly, a matching block name may be specified after the following block end keywords, preceded by a
colon:
— (see 17.2)
endchecker
— (see 8.3)
endclass
— (see 14.3)
endclocking
— (see 33.4)
endconfig
— (see 13.4)
endfunction
— (see 19.2)
endgroup
— (see 25.3)
endinterface
— (see 23.2.1)
endmodule
— (see 26.2)
endpackage
— (see 29.3)
endprimitive
— (see 24.3)
endprogram
— (see 16.2)
endproperty
— (see 16.8)
endsequence
— (see 13.3)
endtask
A matching block name may also follow the keyword at the end of a generate block (see 27.3). A name
end
at the end of the block is not required. It shall be an error if the name at the end is different from the block
name at the beginning.
9.3.5 Statement labels
A label can be specified before any procedural statement (any non-declaration statement that can appear
inside a begin-end block), as in C. A statement label is used to identify a single statement. The label name is
specified before the statement, followed by a colon.
labelA: statement
A begin-end or fork-join block is considered a statement and can have a statement label before the block.
Specifying a statement label before a or keyword is equivalent to specifying a block name after
begin fork
the keyword, and a matching block name may be specified after the block , , , or
end join join_any
keyword. For example:
join_none
214
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
labelB: fork // label before the begin or fork
...
join_none : labelB
It shall be illegal to have both a label before a or and a block name after the or . A
begin fork begin fork
label cannot appear before the , , , or , as these keywords do not form a
end join join_any join_none
statement.
A statement label on a loop, or on a loop with variables declared as part of the
foreach for
for_initialization, names the implicit block created by the loop. For other types of statements, a statement
label creates a named begin-end block around the statement and creates a new hierarchy scope.
A label may also be specified before a generate begin-end block (see 27.3).
A label may also be specified before a concurrent assertion (see 16.5).
A statement with a label can be disabled using a statement. Disabling a statement shall have the
disable
same behavior as disabling a named block. See 9.6.2 on statements and process control.
disable
9.4 Procedural timing controls
SystemVerilog has two types of explicit timing control over when procedural statements can occur. The first
type is a delay control, in which an expression specifies the time duration between initially encountering the
statement and when the statement actually executes. The delay expression can be a dynamic function of the
state of the circuit, or it can be a simple number that separates statement executions in time. The delay
control is an important feature when specifying stimulus waveform descriptions. It is described in 9.4.1 and
9.4.5.
The second type of timing control is the event expression, which allows statement execution to be delayed
until the occurrence of some simulation event occurring in a procedure executing concurrently with this
procedure. A simulation event can be a change of value on a net or variable (an implicit event) or the
occurrence of an explicitly named event that is triggered from other procedures (an explicit event). Most
often, an event control is a positive or negative edge on a clock signal. Event control is discussed in 9.4.2
through 9.4.5.
The procedural statements encountered so far all execute without advancing simulation time. Simulation
time can advance by one of the following three methods:
— A delay control, which is introduced by the symbol #
— An event control, which is introduced by the symbol @
— The wait statement, which operates like a combination of the event control and the while loop
The three procedural timing control methods are discussed in 9.4.1 through 9.4.5. Syntax9-4 shows the
syntax of timing control in procedural statements.
procedural_timing_control_statement ::= // from A.6.5
procedural_timing_control statement_or_null
delay_or_event_control ::=
delay_control
| event_control
| expression event_control
repeat( )
215
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
delay_control ::=
delay_value
#
| mintypmax_expression
# ( )
event_control ::=
hierarchical_event_identifier
@
| event_expression
@ ( )
|
@*
|
@ (*)
| ps_or_hierarchical_sequence_identifier
@
event_expression31 ::=
[ edge_identifier ] expression [ expression ]
iff
| sequence_instance [ expression ]
iff
| event_expression event_expression
or
| event_expression event_expression
,
| event_expression
( )
procedural_timing_control ::=
delay_control
| event_control
| cycle_delay
...
wait_statement ::=
expression statement_or_null
wait ( )
|
wait fork ;
| hierarchical_identifier { hierarchical_identifier } action_block
wait_order( , )
edge_identifier ::= | | // from A.7.4
posedge negedge edge
31) Parentheses are required when an event expression that contains comma-separated event expressions is passed as an
actual argument using positional binding.
Syntax9-4—Delay and event control syntax (excerpt from AnnexA)
The gate and net delays also advance simulation time, as discussed in Clause28.
9.4.1 Delay control
A procedural statement following the delay control shall be delayed in its execution with respect to the
procedural statement preceding the delay control by the specified delay. If the delay expression evaluates to
an unknown or high-impedance value, it shall be interpreted as zero delay. If the delay expression evaluates
to a negative value, it shall be interpreted as a two’s-complement unsigned integer of the same size as a time
variable. Specify parameters are permitted in the delay expression. They can be overridden by SDF
annotation, in which case the expression is reevaluated.
Example 1: The following example delays the execution of the assignment by 10 time units:
#10 rega = regb;
Example 2: The next three examples provide an expression following the number sign (#). Execution of the
assignment is delayed by the amount of simulation time specified by the value of the expression.
#d rega = regb; // d is defined as a parameter
#((d+e)/2) rega = regb; // delay is average of d and e
#regr regr = regr + 1; // delay is the value in regr
216
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
9.4.2 Event control
The execution of a procedural statement can be synchronized with a value change on a net or variable or the
occurrence of a declared event. The value changes on nets and variables can be used as events to trigger
theexecution of a statement. This is known as detecting an implicit event. The event can also be based on
the direction of the change, that is, toward the value 1 ( ) or toward the value 0 ( ). The
posedge negedge
behavior of posedge and negedge events is shown in Table9-2 and can be described as follows:
— A negedge shall be detected on the transition from 1 to , , or 0, and from or to 0
x z x z
— A posedge shall be detected on the transition from 0 to , , or 1, and from or to 1
x z x z
Table9-2—Detecting posedge and negedge
To
From
0 1 x z
0 No edge posedge posedge posedge
1 negedge No edge negedge negedge
x negedge posedge No edge No edge
z negedge posedge No edge No edge
In addition to and , a third edge event, , indicates a change towards either 1 or 0.
posedge negedge edge
More precisely, the behavior of an edge event can be described as:
— An edge shall be detected whenever negedge or posedge is detected.
An implicit event shall be detected on any change in the value of the expression. An edge event shall be
detected only on the LSB of the expression. A change of value in any operand of the expression without a
change in the result of the expression shall not be detected as an event.
The following example shows illustrations of edge-controlled statements:
@r rega = regb; // controlled by any value change in the reg r
@(posedge clock) rega = regb; // controlled by posedge on clock
forever @(negedge clock) rega = regb; // controlled by negedge on clock
forever @(edge clock) rega = regb; // controlled by edge on clock
If the expression denotes a block or (see Clause14), the event control operator
clocking input inout
uses the synchronous values, that is, the values sampled by the clocking event. The expression can also
denote a block name (with no edge qualifier) to be triggered by the clocking event.
clocking
A variable used with the event control can be any one of the integral data types (see 6.11.1) or string. The
variable can be either a simple variable or a argument (variable passed by reference); it can be a
ref
member of an array, associative array, or object (class instance) of the aforementioned types.
Event expressions shall return singular values. Aggregate types can be used in an expression provided the
expression reduces to a singular value. The object members or aggregate elements can be any type as long as
the result of the expression is a singular value.
If the event expression is a reference to a simple object handle or chandle variable, an event is created when
a write to that variable is not equal to its previous value.
217
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Nonvirtual methods of an object and built-in methods or system functions for an aggregate type are allowed
in event control expressions as long as the type of the return value is singular and the method is defined as a
function, not a task.
Changing the value of object data members, aggregate elements, or the size of a dynamically sized array
referenced by a method or function shall cause the event expression to be reevaluated. An implementation
can cause the event expression to be reevaluated when changing the value or size even if the members are
not referenced by the method or function.
real AOR[]; // dynamic array of reals
byte stream[$]; // queue of bytes
initial wait(AOR.size() > 0) ....; // waits for array to be allocated
initial wait($bits(stream) > 60)...; // waits for total number of bits
// in stream greater than 60
Packet p = new; // Packet 1 -- Packet is defined in 8.2
Packet q = new; // Packet 2
initial fork
@(p.status); // Wait for status in Packet 1 to change
@p; // Wait for a change to handle p
# 10 p = q; // triggers @p.
// @(p.status) now waits for status in Packet 2 to change,
// if not already different from Packet 1
join
9.4.2.1 Event OR operator
The logical OR of any number of events can be expressed so that the occurrence of any one of the events
triggers the execution of the procedural statement that follows it. The keyword or a comma character ( )
or ,
is used as an event logical OR operator. A combination of these can be used in the same event expression.
Comma-separated sensitivity lists shall be synonymous to -separated sensitivity lists.
or
The next two examples show the logical or of two and three events, respectively:
@(trig or enable) rega = regb; // controlled by trig or enable
@(posedge clk_a or posedge clk_b or trig) rega = regb;
The following examples show the use of the comma ( ) as an event logical operator:
, or
always @(a, b, c, d, e)
always @(posedge clk, negedge rstn)
always @(a or b, c, d or e)
9.4.2.2 Implicit event_expression list
An incomplete event_expression list of an event control is a common source of bugs in register transfer level
(RTL) simulations. The implicit event_expression, , is a convenient shorthand that eliminates these
@*
problems by adding all nets and variables that are read by the statement (which can be a statement group) of
a procedural_timing_ control_statement to the event_expression.
NOTE—The procedure (see 9.2.2.2) is preferred over using the implicit event_expression list when
always_comb @*
used at the beginning of an always procedure as a sensitivity list. See 9.2.2.2.2 for a comparison of and
always_comb
.
@*
218
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reicgehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
All net and variable identifiers that appear in the statement will be automatically added to the event
expression with the following exceptions:
— Identifiers that only appear in wait or event expressions.
— Identifiers that only appear as a hierarchical_variable_identifier in the variable_lvalue of the
left-hand side of assignments.
Nets and variables that appear on the right-hand side of assignments, in subroutine calls, in case and
conditional expressions, as an index variable on the left-hand side of assignments, or as variables in case
item expressions shall all be included by these rules.
Example 1:
always @(*) // equivalent to @(a or b or c or d or f)
y = (a & b) | (c & d) | myfunction(f);
Example 2:
always @* begin // equivalent to @(a or b or c or d or tmp1 or tmp2)
tmp1 = a & b;
tmp2 = c & d;
y = tmp1 | tmp2;
end
Example 3:
always @* begin // equivalent to @(b)
@(i) kid = b; // i is not added to @*
end
Example 4:
always @* begin // equivalent to @(a or b or c or d)
x = a ^ b;
@* // equivalent to @(c or d)
x = c ^ d;
end
Example 5:
always @* begin // same as @(a or en)
y = 8'hff;
y[a] = !en;
end
Example 6:
always @* begin // same as @(state or go or ws)
next = 4'b0;
case (1'b1)
state[IDLE]: if (go) next[READ] = 1'b1;
else next[IDLE] = 1'b1;
state[READ]: next[DLY ] = 1'b1;
state[DLY ]: if (!ws) next[DONE] = 1'b1;
else next[READ] = 1'b1;
state[DONE]: next[IDLE] = 1'b1;
endcase
end
219
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
9.4.2.3 Conditional event controls
The event control can have an qualifier.
@ iff
module latch (output logic [31:0] y, input [31:0] a, input enable);
always @(a iff enable == 1)
y <= a; //latch is in transparent mode
endmodule
The event expression only triggers if the expression after the is true (as defined in 12.4), in this case
iff
when is equal to 1. This type of expression is evaluated when changes and not when
enable a enable
changes. Also, in similar event expressions of this type, has precedence over . This can be made
iff or
clearer by the use of parentheses.
9.4.2.4 Sequence events
A sequence instance can be used in event expressions to control the execution of procedural statements
based on the successful match of the sequence. This allows the end point of a named sequence (see 16.7) to
trigger multiple actions in other processes. Syntax16-3 and Syntax16-5 describe the syntax for declaring
named sequences and sequence instances. A sequence instance can be used directly in an event expression,
as shown in Syntax9-4.
When a sequence instance is specified in an event expression, the process executing the event control shall
block until the specified sequence reaches its end point. A process resumes execution following the
Observed region in which the end point is detected.
An example of using a sequence as an event control follows:
sequence abc;
@(posedge clk) a ##1 b ##1 c;
endsequence
program test;
initial begin
@ abc $display( "Saw a-b-c" );
L1 : ...
end
endprogram
In the preceding example, when the named sequence reaches its end point, the procedure in
abc initial
the program block is unblocked, then displays the string , and continues execution with
test "Saw a-b-c"
the statement labeled . In this case, the end of the sequence acts as the trigger to unblock the event.
L1
A sequence used in an event control is instantiated (as if by an assert property statement); the event control is
used to synchronize to the end of the sequence, regardless of its start time. Arguments to these sequences
shall be static; automatic variables used as sequence arguments shall result in an error.
9.4.3 Level-sensitive event control
The execution of a procedural statement can also be delayed until a condition becomes true. This is
accomplished using the wait statement, which is a special form of event control. The nature of the wait
statement is level-sensitive, as opposed to basic event control (specified by the character), which is edge-
@
sensitive.
220
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The wait statement shall evaluate a condition; and, if it is not true (as defined in 12.4), the procedural
statements following the wait statement shall remain blocked until that condition becomes true before
continuing. The wait statement has the form given in Syntax9-5.
wait_statement ::= // from A.6.5
expression statement_or_null
wait ( )
|
wait fork ;
| hierarchical_identifier { hierarchical_identifier } action_block
wait_order( , )
Syntax9-5—Syntax for wait statement (excerpt from AnnexA)
The following example shows the use of the wait statement to accomplish level-sensitive event control:
begin
wait (!enable) #10 a = b;
#10 c = d;
end
If the value of is 1 when the block is entered, the wait statement will delay the evaluation of the next
enable
statement ( ) until the value of changes to 0. If is already 0 when the begin-end
#10 a = b; enable enable
block is entered, then the assignment “ ” is evaluated after a delay of 10 and no additional delay
a = b;
occurs.
See also 9.6 on process control.
9.4.4 Level-sensitive sequence controls
The execution of procedural code can be delayed until a sequence termination status is true. This is
accomplished using the level-sensitive statement in conjunction with the built-in method that returns
wait
the current end status of a named sequence: .
triggered
The sequence method evaluates to true ( ) if the given sequence has reached its end point
triggered 1'b1
(see 16.7) at that particular point in time (in the current time step) and false ( ) otherwise. The triggered
1'b0
status of a sequence is set during the Observed region and persists through the remainder of the time step
(i.e., until simulation time advances).
For example:
sequence abc;
@(posedge clk) a ##1 b ##1 c;
endsequence
sequence de;
@(negedge clk) d ##[2:5] e;
endsequence
program check;
initial begin
wait( abc.triggered || de.triggered );
if( abc.triggered )
$display( "abc succeeded" );
if( de.triggered )
$display( "de succeeded" );
L2 : ...
221
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
end
endprogram
In the preceding example, the procedure in program waits for the end point of either
initial check
sequence or sequence . When either condition evaluates to true, the statement unblocks the
abc de wait
process, displays the sequences that caused the process to unblock, and then continues to execute the
statement labeled .
L2
See 16.9.11and 16.13.6 for a definition of sequence methods.
9.4.5 Intra-assignment timing controls
The delay and event control constructs previously described precede a statement and delay its execution. In
contrast, intra-assignment delay and event controls are contained within an assignment statement and
modify the flow of activity in a different way. This subclause describes the purpose of intra-assignment
timing controls and the repeat timing control that can be used in intra-assignment delays.
An intra-assignment delay or event control shall delay the assignment of the new value to the left-hand side,
but the right-hand expression shall be evaluated before the delay, instead of after the delay. The syntax for
intra-assignment delay and event control is given in Syntax9-6.
blocking_assignment ::= // from A.6.2
variable_lvalue delay_or_event_control expression
=
| ...
nonblocking_assignment ::=
variable_lvalue [ delay_or_event_control ] expression
<=
Syntax9-6—Syntax for intra-assignment delay and event control (excerpt from AnnexA)
The delay_or_event_control syntax is shown in Syntax9-4 in 9.4.
The intra-assignment delay and event control can be applied to both blocking assignments and nonblocking
assignments. The repeat event control shall specify an intra-assignment delay of a specified number of
occurrences of an event. If the repeat count literal, or signed variable holding the repeat count, is less than or
equal to 0 at the time of evaluation, the assignment occurs as if there is no repeat construct.
For example:
repeat (3) @ (event_expression)
// will execute event_expression three times
repeat (-3) @ (event_expression)
// will not execute event_expression.
repeat (a) @ (event_expression)
// if a is assigned -3, it will execute the event_expression if a is
// declared as an unsigned variable, but not if a is signed
This construct is convenient when events have to be synchronized with counts of clock signals.
Table9-3 illustrates the philosophy of intra-assignment timing controls by showing the code that could
accomplish the same timing effect without using intra-assignment timing.
222
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v2e02d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table9-3—Intra-assignment timing control equivalence
Intra-assignment timing control
With intra-assignment construct Without intra-assignment construct
begin
a = #5 b; temp = b;
#5 a = temp;
end
begin
a = @(posedge clk) b; temp = b;
@(posedge clk) a = temp;
end
begin
a = repeat(3) @(posedge clk) b; temp = b;
@(posedge clk);
@(posedge clk);
@(posedge clk) a = temp;
end
The next three examples use the fork-join behavioral construct. All statements between the keywords
fork
and execute concurrently. This construct is described in more detail in 9.3.2.
join
The following example shows a race condition that could be prevented by using intra-assignment timing
control:
fork
#5 a = b;
#5 b = a;
join
The code in this example samples and sets the values of both and at the same simulation time, thereby
a b
creating a race condition. The intra-assignment form of timing control used in the next example prevents this
race condition.
fork // data swap
a = #5 b;
b = #5 a;
join
Intra-assignment timing control works because the intra-assignment delay causes the values of and to be
a b
evaluated before the delay and causes the assignments to be made after the delay.
Intra-assignment waiting for events is also effective. In the following example, the right-hand expressions
are evaluated when the assignment statements are encountered, but the assignments are delayed until the
rising edge of the clock signal:
fork // data shift
a = @(posedge clk) b;
b = @(posedge clk) c;
join
223
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The following is an example of a repeat event control as the intra-assignment delay of a nonblocking
assignment:
a <= repeat(5) @(posedge clk) data;
Figure9-1 illustrates the activities that result from this event control.
repeat
data is evaluated
clk
data
a
Figure9-1—Intra-assignment repeat event control utilizing a clock edge
In this example, the value of is evaluated when the assignment is encountered. After five occurrences
data
of , is assigned the value of .
posedge clk a data
The following is an example of a repeat event control as the intra-assignment delay of a procedural
assignment:
a = repeat(num) @(clk) data;
In this example, the value of is evaluated when the assignment is encountered. After the number of
data
transitions of equals the value of , is assigned the value of .
clk num a data
The following is an example of a repeat event control with expressions containing operations to specify both
the number of event occurrences and the event that is counted:
a <= repeat(a+b) @(posedge phi1 or negedge phi2) data;
In this example, the value of is evaluated when the assignment is encountered. After the sum of the
data
positive edges of and the negative edges of equals the sum of and , is assigned the value of
phi1 phi2 a b a
. Even if and occurred at the same simulation time, each will be
data posedge phi1 negedge phi2
detected and counted separately.
If and refer to the same signal, then the preceding assignment can be simplified as:
phi1 phi2
a <= repeat(a+b) @(edge phi1) data;
9.5 Process execution threads
SystemVerilog creates a thread of execution for the following:
— Each procedure
initial
— Each procedure
final
— Each , , , and procedure
always always_comb always_latch always_ff
224
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Each parallel statement in a (or or ) statement group
fork-join join_any join_none
— Each dynamic process
Each continuous assignment can also be considered its own thread (see 10.3).
9.6 Process control
SystemVerilog provides constructs that allow one process to terminate or wait for the completion of other
processes. The construct waits for the completion of processes. The construct stops the
waitfork disable
execution of all activity within a named block or task, without regard to parent-child relationship (a child
process can terminate execution of a parent or one process can terminate execution of an unrelated process).
The construct stops the execution of processes, but with consideration of parent-child
disable fork
relationships.
The process control statements have the syntax form shown in Syntax9-7.
wait_statement ::= // from A.6.5
expression statement_or_null
wait ( )
|
wait fork ;
| hierarchical_identifier { hierarchical_identifier } action_block
wait_order( , )
disable_statement ::=
hierarchical_task_identifier
disable ;
| hierarchical_block_identifier
disable ;
|
disable fork ;
Syntax9-7—Syntax for process control statements (excerpt from AnnexA)
9.6.1 Wait fork statement
The statement blocks process execution flow until all immediate child subprocesses (processes
waitfork
created by the current process, excluding their descendants) have completed their execution.
The syntax for is as follows:
waitfork
// from A.6.5
wait fork;
Specifying causes the calling process to block until all its immediate child subprocesses have
wait fork
completed.
Simulation automatically terminates when there is no further activity of any kind. Simulation also
automatically terminates when all its program blocks finish executing (i.e, they reach the end of their
execute block), regardless of the status of any child processes (see 24.7). The statement allows a
waitfork
program block to wait for the completion of all its concurrent threads before exiting.
In the following example, two immediate child processes ( and ) are spawned before calling
child1 child2
the task . In the task , three more immediate child processes ( , , and
do_test do_test child3 child4
) and two descendant processes ( and ) are spawned. Next, two more
child5 descendant1 descendant2
immediate child processes ( and ) are spawned by the function . The
child6 child7 do_sequence wait
statement blocks the execution flow of the task until all seven immediate child processes
fork do_test
complete before returning to its caller. The statement does not directly depend on the
wait fork
descendant processes spawned by .
child5
225
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
initial begin : test
fork
child1();
child2();
join_none
do_test();
end : test
task do_test();
fork
child3();
child4();
fork : child5 // nested fork-join_none is a child process
descendant1();
descendant2();
join_none
join_none
do_sequence();
wait fork; // block until child1 ... child7 complete
endtask
function void do_sequence();
fork
child6();
child7();
join_none
endfunction
9.6.2 Disable statement
The disable statement provides the ability to terminate the activity associated with concurrently active
processes, while maintaining the structured nature of procedural descriptions. The disable statement gives a
mechanism for terminating a task before it executes all its statements, breaking from a looping statement, or
skipping statements in order to continue with another iteration of a looping statement. It is useful for
handling exception conditions such as hardware interrupts and global resets. The disable statement can also
be used to terminate execution of a labeled statement, including a deferred assertion (see 16.4) or a
procedural concurrent assertion (see 16.14.6).
The disable statement shall terminate the activity of a task or a named block. Execution shall resume at the
statement following the block or following the task-enabling statement. All activities enabled within the
named block or task shall be terminated as well. If task enable statements are nested (that is, one task enables
another, and that one enables yet another), then disabling a task within the chain shall disable all tasks
downward on the chain. If a task is enabled more than once, then disabling such a task shall disable all
activations of the task.
The results of the following activities that can be initiated by a task are not specified if the task is disabled:
— Results of output and inout arguments
— Scheduled, but not executed, nonblocking assignments
— Procedural continuous assignments (assign and force statements)
The disable statement can be used within blocks and tasks to disable the particular block or task containing
the disable statement. The disable statement can be used to disable named blocks within a function, but
cannot be used to disable functions. In cases where a disable statement within a function disables a block or
a task that called the function, the behavior is undefined. Disabling an automatic task or a block inside an
automatic task proceeds as for regular tasks for all concurrent executions of the task.
226
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 1: This example illustrates how a block disables itself.
begin : block_name
rega = regb;
disable block_name;
regc = rega; // this assignment will never execute
end
Example 2: This example shows the disable statement being used within a named block in a manner similar
to a forward goto. The next statement executed after the disable statement is the one following the named
block.
begin : block_name
...
...
if (a == 0)
disable block_name;
...
end // end of named block
// continue with code following named block
...
Example 3: This example illustrates using the disable construct to terminate execution of a named block that
does not contain the disable statement. If the block is currently executing, this causes control to jump to the
statement immediately after the block. If the block is a loop body, it acts like a (see 12.8). If the
continue
block is not currently executing, the disable has no effect.
module m (...);
always
begin : always1
...
t1: task1( ); // task call
...
end
...
always
begin
...
disable m.always1; // exit always1, which will exit task1,
// if it was currently executing
end
endmodule
Example 4: This example shows the disable statement being used as an early return from a task.
SystemVerilog also has from a task, which shall terminate execution of the process in which the
return
return is executed (see 12.8). However, a task disabling itself using a disable statement is not a shorthand for
the return statement. If is applied to a task, all currently active executions of the task are disabled.
disable
task proc_a;
begin
...
...
if (a == 0)
disable proc_a; // return if true
...
...
227
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLr igGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reicgehmtsb erer s0e3,r2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
end
endtask
Example 5: This example shows the disable statement being used in an equivalent way to the two statements
and (see 12.8). The example illustrates control code that would allow a named block to
continue break
execute until a loop counter reaches iterations or until the variable is set to the value of . The named
n a b
block contains the code that executes until , at which point the
outer_block a == b disable
statement terminates execution of that block. The named block contains the
outer_block; inner_block
code that executes for each iteration of the loop. Each time this code executes the
for
statement, the block terminates, and execution passes to the next
disable inner_block; inner_block
iteration of the loop. For each iteration of the block, a set of statements executes if
for inner_block
. Another set of statements executes if .
(a != 0) (a! = b)
begin : outer_block
for (i = 0; i < n; i = i+1) begin : inner_block
@clk
if (a == 0) // "continue" loop
disable inner_block ;
... // statements
... // statements
@clk
if (a == b) // "break" from loop
disable outer_block;
... // statements
... // statements
end
end
NOTE—The C-like and statements (see 12.8) may be a more intuitive way to code the preceding
break continue
example.
Example 6: This example shows the disable statement being used to disable concurrently a sequence of
timing controls and the task named when the event occurs. The example shows a fork-join
action reset
block within which are a named sequential block ( ) and a disable statement that waits for
event_expr
occurrence of the event . The sequential block and the wait for execute in parallel. The
reset reset
block waits for one occurrence of event and three occurrences of event . When these
event_expr ev1 trig
four events have happened, plus a delay of time units, the task executes. When the event
d action reset
occurs, regardless of events within the sequential block, the fork-join block terminates—including the task
.
action
fork
begin : event_expr
@ev1;
repeat (3) @trig;
#d action (areg, breg);
end
@reset disable event_expr;
join
Example 7: The next example is a behavioral description of a retriggerable monostable. The named event
restarts the monostable time period. If continues to occur within 250 time units, then
retrig retrig q
will remain at 1.
always begin : monostable
#250 q = 0;
end
always @retrig begin
228
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
disable monostable;
q = 1;
end
9.6.3 Disable fork statement
The statement terminates all active descendants (subprocesses) of the calling process.
disablefork
The syntax for is as follows:
disablefork
// from A.6.5
disable fork;
The statement terminates all descendants of the calling process as well as the descendants of
disablefork
the process’s descendants. In other words, if any of the child processes have descendants of their own, the
statement shall terminate them as well.
disablefork
In the following example, the task spawns three versions of a task that wait for a particular
get_first
device (1, 7, or 13). The task waits for a particular device to become ready and then returns
wait_device
the device’s address. When the first device becomes available, the task shall resume execution
get_first
and proceed to kill the outstanding processes.
wait_device
task get_first( output int adr );
fork
wait_device( 1, adr );
wait_device( 7, adr );
wait_device( 13, adr );
join_any
disable fork;
endtask
The construct terminates a process when applied to the named block or statement being executed
disable
by the process. The statement differs from in that considers the
disable fork disable disable fork
dynamic parent-child relationship of the processes, whereas uses the static, syntactical information
disable
of the disabled block. Thus, shall end all processes executing a particular block, whether the
disable
processes were forked by the calling thread or not, while shall end only the processes that
disable fork
were spawned by the calling thread.
9.7 Fine-grain process control
A process is a built-in class that allows one process to access and control another process once it has started.
Users can declare variables of type process and safely pass them through tasks or incorporate them into other
objects. The prototype for the process class is as follows:
class process;
typedef enum { FINISHED, RUNNING, WAITING, SUSPENDED, KILLED } state;
static function process self();
function state status();
function void kill();
task await();
function void suspend();
function void resume();
function void srandom( int seed );
function string get_randstate();
function void set_randstate( string state );
endclass
229
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Objects of type process are created internally when processes are spawned. Users cannot create objects of
type process; attempts to call shall not create a new process and shall instead result in an error. The
new
process class cannot be extended. Attempts to extend it shall result in a compilation error. Objects of type
process are unique; they become available for reuse once the underlying process terminates and all
references to the object are discarded.
The function returns a handle to the current process, that is, a handle to the process making the call.
self()
The function returns the process status, as defined by the state enumeration:
status()
— means the process terminated normally.
FINISHED
— means the process is currently running (not in a blocking statement).
RUNNING
— means the process is waiting in a blocking statement.
WAITING
— means the process is stopped awaiting a resume.
SUSPENDED
— means the process was forcibly killed (via kill or disable).
KILLED
The function terminates the given process and all its subprocesses, that is, processes spawned using
kill()
statements by the process being killed. If the process to be terminated is not blocked waiting on some
fork
other condition, such as an event, expression, or a delay, then the process shall be terminated at some
wait
unspecified time in the current time step.
The task allows one process to wait for the completion of another process. It shall be an error to
await()
call this task on the current process, i.e., a process cannot wait for its own completion.
The function allows a process to suspend either its own execution or that of another process. If
suspend()
the process to be suspended is not blocked waiting on some other condition, such as an event,
wait
expression, or a delay, then the process shall be suspended at some unspecified time in the current time step.
Calling this method more than once, on the same (suspended) process, has no effect.
The function restarts a previously suspended process. Calling on a process that was
resume() resume
suspended while blocked on another condition shall resensitize the process to the event expression or to wait
for the wait condition to become true or for the delay to expire. If the wait condition is now true or the
original delay has transpired, the process is scheduled onto the Active or Reactive region to continue its
execution in the current time step. Calling on a process that suspends itself causes the process to
resume
continue to execute at the statement following the call to suspend.
The methods , , , and shall be restricted to a process created by an
kill() await() suspend() resume()
initial procedure, always procedure, or fork block from one of those procedures.
The following example starts an arbitrary number of processes, as specified by the task argument N. Next,
the task waits for the last process to start executing and then waits for the first process to terminate. At that
point, the parent process forcibly terminates all forked processes that have not yet completed.
task automatic do_n_way( int N );
process job[] = new [N];
foreach (job[j])
fork
automatic int k = j;
begin job[k] = process::self(); ... ; end
join_none
foreach (job[j]) // wait for all processes to start
wait( job[j] != null );
230
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
job[1].await(); // wait for first process to finish
foreach (job[j]) begin
if ( job[j].status != process::FINISHED )
job[j].kill();
end
endtask
231
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
10. Assignment statements
10.1 General
This clause describes the following:
— Continuous assignments
— Procedural blocking and nonblocking assignments
— Procedural continuous assignments (assign, deassign, force, release)
— Net aliasing
10.2 Overview
The assignment is the basic mechanism for placing values into nets and variables. There are two basic forms
of assignments, as follows:
— The continuous assignment, which assigns values to nets or variables
— The procedural assignment, which assigns values to variables
Continuous assignments drive nets or variables in a manner similar to the way gates drive nets or variables.
The expression on the right-hand side can be thought of as a combinational circuit that drives the net or
variable continuously. In contrast, procedural assignments put values in variables. The assignment does not
have duration; instead, the variable holds the value of the assignment until the next procedural assignment to
that variable.
There are two additional forms of assignments, / and / , which are called
assigndeassign forcerelease
procedural continuous assignments, described in 10.6.
An assignment consists of two parts, a left-hand side and a right-hand side, separated by the equals ( )
=
character; or, in the case of nonblocking procedural assignment, the less-than-equals ( ) character pair.
<=
The right-hand side can be any expression that evaluates to a value. The left-hand side indicates the net or
variable to which the right-hand side value is to be assigned. The left-hand side can take one of the forms
given in Table10-1, depending on whether the assignment is a continuous assignment or a procedural
assignment.
Table10-1—Legal left-hand forms in assignment statements
Statement type Left-hand side
Continuous assignment Net or variable (vector or scalar)
Constant bit-select of a vector net or packed variable
Constant part-select of a vector net or packed variable
Concatenation or nested concatenation of any of the above left-hand sides
Procedural assignment Variable (vector or scalar)
Bit-select of a packed variable
Part-select of a packed variable
Memory word
Array
Array element select
Array slice
Concatenation or nested concatenation of any of the above left-hand sides
232
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
SystemVerilog also allows a time unit to be specified in the assignment statement, as follows:
#1ns r = a;
r = #1ns a;
r <= #1ns a;
assign #2.5ns sum = a + b;
10.3 Continuous assignments
Continuous assignments shall drive values onto nets or variables, both vector (packed) and scalar. This
assignment shall occur whenever the value of the right-hand side changes. Continuous assignments provide
a way to model combinational logic without specifying an interconnection of gates. Instead, the model
specifies the logical expression that drives the net or variable.
There are two forms of continuous assignments: net declaration assignments (see 10.3.1) and continuous
assign statements (see 10.3.2).
The syntax for continuous assignments is given in Syntax10-1.
net_declaration12 ::= // from A.2.1.3
net_type [ drive_strength | charge_strength ] [ | ]
vectored scalared
data_type_or_implicit [ delay3 ] list_of_net_decl_assignments
;
| net_type_identifier [ delay_control ]
list_of_net_decl_assignments
;
| implicit_data_type [ delay_value ]
interconnect #
net_identifier { unpacked_dimension }
[ net_identifier { unpacked_dimension }]
, ;
list_of_net_decl_assignments ::= net_decl_assignment { net_decl_assignment } // from A.2.3
,
net_decl_assignment ::= net_identifier { unpacked_dimension } [ expression ] // from A.2.4
=
continuous_assign ::= // from A.6.1
[ drive_strength ] [ delay3 ] list_of_net_assignments
assign ;
| [ delay_control ] list_of_variable_assignments
assign ;
list_of_net_assignments ::= net_assignment { net_assignment }
,
list_of_variable_assignments ::= variable_assignment { variable_assignment }
,
net_assignment ::= net_lvalue expression
=
12) A charge strength shall only be used with the keyword. When the or keyword is
trireg vectored scalared
used, there shall be at least one packed dimension.
Syntax10-1—Syntax for continuous assignment (excerpt from AnnexA)
10.3.1 The net declaration assignment
The net declaration assignment allows a continuous assignment to be placed on a net in the same statement
that declares the net.
The following is an example of the net declaration form of a continuous assignment:
wire (strong1, pull0) mynet = enable;
233
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Because a net can be declared only once, only one net declaration assignment can be made for a particular
net. This contrasts with the continuous assignment statement; one net can receive multiple assignments of
the continuous assignment form.
An net (see 6.6.8) shall not have a net declaration assignment.
interconnect
10.3.2 The continuous assignment statement
The continuous assignment statement shall place a continuous assignment on a net or variable data type. The
net may be explicitly declared or may inherit an implicit declaration in accordance with the implicit
declaration rules defined in 6.10. Variables shall be explicitly declared prior to the continuous assignment
statement.
Assignments on nets or variables shall be continuous and automatic. In other words, whenever an operand in
the right-hand expression changes value, the whole right-hand side shall be evaluated. If the new value is
different from the previous value, then the new value shall be assigned to the left-hand side.
Nets can be driven by multiple continuous assignments or by a mixture of primitive outputs, module outputs,
and continuous assignments. Variables can only be driven by one continuous assignment or by one primitive
output or module output. It shall be an error for a variable driven by a continuous assignment or output to
have an initializer in the declaration or any procedural assignment. See also 6.5.
A continuous assignment to an atomic net shall not drive part of the net; the entire value shall be
nettype
driven. Thus the left-hand side of a continuous assignment to a net of a user-defined shall not
nettype
contain any indexing or select operations into the data type of the .
nettype
Example 1: The following is an example of a continuous assignment to a net that has been previously
declared:
wire mynet ;
assign (strong1, pull0) mynet = enable;
Example 2: The following is an example of the use of a continuous assignment to model a 4-bit adder with
carry. The assignment could not be specified directly in the declaration of the nets because it requires a
concatenation on the left-hand side.
module adder (sum_out, carry_out, carry_in, ina, inb);
output [3:0] sum_out;
output carry_out;
input [3:0] ina, inb;
input carry_in;
wire carry_out, carry_in;
wire [3:0] sum_out, ina, inb;
assign {carry_out, sum_out} = ina + inb + carry_in;
endmodule
Example 3: The following example describes a module with one 16-bit output bus. It selects between one of
four input busses and connects the selected bus to the output bus.
module select_bus(busout, bus0, bus1, bus2, bus3, enable, s);
parameter n = 16;
parameter Zee = 16'bz;
output [1:n] busout;
234
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
input [1:n] bus0, bus1, bus2, bus3;
input enable;
input [1:2] s;
tri [1:n] data; // net declaration
// net declaration with continuous assignment
tri [1:n] busout = enable ? data : Zee;
// assignment statement with four continuous assignments
assign
data = (s == 0) ? bus0 : Zee,
data = (s == 1) ? bus1 : Zee,
data = (s == 2) ? bus2 : Zee,
data = (s == 3) ? bus3 : Zee;
endmodule
The following sequence of events is experienced during simulation of this example:
a) The value of , a bus selector input variable, is checked in the statement. Based on the value
s assign
of , the net receives the data from one of the four input buses.
s data
b) The setting of net triggers the continuous assignment in the net declaration for . If
data busout
is set, the contents of are assigned to ; if enable is 0, the contents of are
enable data busout Zee
assigned to busout.
10.3.3 Continuous assignment delays
A delay given to a continuous assignment shall specify the time duration between a right-hand operand
value change and the assignment made to the left-hand side. If the left-hand references a scalar net, then the
delay shall be treated in the same way as for gate delays; that is, different delays can be given for the output
rising, falling, and changing to high impedance (see 28.16).
If the left-hand references a vector net, then up to three delays can be applied. The following rules determine
which delay controls the assignment:
— If the right-hand side makes a transition from nonzero to zero, then the falling delay shall be used.
— If the right-hand side makes a transition to , then the turn-off delay shall be used.
z
— For all other cases, the rising delay shall be used.
If the left-hand side references a net of a user-defined or an array of such nets, then only a single
nettype
delay may be applied. The specific delay is used when any change occurs to the value of the net.
Specifying the delay in a continuous assignment that is part of the net declaration shall be treated differently
from specifying a net delay and then making a continuous assignment to the net. A delay value can be
applied to a net in a net declaration, as in the following example:
wire #10 wireA;
This syntax, called a net delay, means that any value change that is to be applied to by some other
wireA
statement shall be delayed for ten time units before it takes effect. When there is a continuous assignment in
a declaration, the delay is part of the continuous assignment and is not a net delay. Thus, it shall not be added
to the delay of other drivers on the net. Furthermore, if the assignment is to a vector net, then the rising and
falling delays shall not be applied to the individual bits if the assignment is included in the declaration.
In situations where a right-hand operand changes before a previous change has had time to propagate to the
left-hand side, then the following steps are taken:
235
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
a) The value of the right-hand expression is evaluated.
b) If this right-hand side value differs from the value currently scheduled to propagate to the left-hand
side, then the currently scheduled propagation event is descheduled.
c) If the new right-hand side value equals the current left-hand side value, no event is scheduled.
d) If the new right-hand side value differs from the current left-hand side value, a delay is calculated in
the standard way using the current value of the left-hand side, the newly calculated value of the
right-hand side, and the delays indicated on the statement; a new propagation event is then sched-
uled to occur delay time units in the future.
10.3.4 Continuous assignment strengths
The driving strength of a continuous assignment can be specified by the user. This applies only to
assignments to scalar nets, except for nets of types and .
supply0 supply1
Continuous assignments driving strengths can be specified either in a net declaration or in a stand-alone
assignment, using the keyword. The strength specification, if provided, shall immediately follow
assign
the keyword (either the keyword for the net type or ) and precede any delay specified. Whenever the
assign
continuous assignment drives the net, the strength of the value shall be simulated as specified.
A drive strength specification shall contain one strength value that applies when the value being assigned to
the net is 1 and a second strength value that applies when the assigned value is 0. The following keywords
shall specify the strength value for an assignment of 1:
supply1 strong1 pull1 weak1 highz1
The following keywords shall specify the strength value for an assignment of 0:
supply0 strong0 pull0 weak0 highz0
The order of the two strength specifications shall be arbitrary. The following two rules shall constrain the
use of drive strength specifications:
— The strength specifications ( , ) and ( , ) shall be treated as illegal
highz1 highz0 highz0 highz1
constructs.
— If drive strength is not specified, it shall default to , ).
(strong1 strong0
10.4 Procedural assignments
Procedural assignments occur within procedures such as , (see 9.2), , and
always initial task function
(see Clause13) and can be thought of as “triggered” assignments. The trigger occurs when the flow of
execution in the simulation reaches an assignment within a procedure. Reaching the assignment can be
controlled by conditional statements. Event controls, delay controls, statements, statements, and
if case
looping statements can all be used to control whether assignments are evaluated. Clause12 gives details and
examples.
The right-hand side of a procedural assignment can be any expression that evaluates to a value, however the
variable type on the left-hand side may restrict what is a legal expression on the right-hand side. The left-
hand side shall be a variable that receives the assignment from the right-hand side. The left-hand side of a
procedural assignment can take one of the following forms:
— Singular variables, as described in 6.4
— Aggregate variables, as described in Clause7
— Bit-selects, part-selects, and slices of packed arrays
— Slices of unpacked arrays
236
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
SystemVerilog contains the following three types of procedural assignment statements:
— Blocking procedural assignment statements (see 10.4.1)
— Nonblocking procedural assignment statements (see 10.4.2)
— Assignment operators (see 11.4.1)
Blocking and nonblocking procedural assignment statements specify different procedural flows in
sequential blocks.
10.4.1 Blocking procedural assignments
A blocking procedural assignment statement shall be executed before the execution of the statements that
follow it in a sequential block (see 9.3.1). A blocking procedural assignment statement shall not prevent the
execution of statements that follow it in a parallel block (see 9.3.2).
The syntax for a blocking procedural assignment is given in Syntax10-2.
blocking_assignment ::= // from A.6.3
variable_lvalue delay_or_event_control expression
=
| nonrange_variable_lvalue dynamic_array_new
=
| [ implicit_class_handle | class_scope | package_scope ] hierarchical_variable_identifier
.
select class_new
=
| operator_assignment
operator_assignment ::= variable_lvalue assignment_operator expression
assignment_operator ::=
| | | | | | | | | | | |
= += -= *= /= %= &= |= ^= <<= >>= <<<= >>>=
Syntax10-2—Blocking assignment syntax (excerpt from AnnexA)
In this syntax, variable_lvalue is a data type that is valid for a procedural assignment statement, is the
=
assignment operator, and delay_or_event_control is the optional intra-assignment timing control (see 9.4.5).
The expression is the right-hand side value that shall be assigned to the left-hand side. If variable_lvalue
requires an evaluation, it shall be evaluated at the time specified by the intra-assignment timing control. The
order of evaluation of the variable_lvalue and the expression on the right-hand side is undefined if a timing
control is not specified. See 4.9.3.
The assignment operator used by blocking procedural assignments is also used by procedural continuous
=
assignments and continuous assignments.
The following examples show blocking procedural assignments:
rega = 0;
rega[3] = 1; // a bit-select
rega[3:5] = 7; // a part-select
mema[address] = 8'hff; // assignment to a mem element
{carry, acc} = rega + regb; // a concatenation
Additional assignment operators, such as , are described in 11.4.1.
+=
237
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
10.4.2 Nonblocking procedural assignments
The nonblocking procedural assignment allows assignment scheduling without blocking the procedural
flow. The nonblocking procedural assignment statement can be used whenever several variable assignments
within the same time step can be made without regard to order or dependence upon each other.
It shall be illegal to make nonblocking assignments to automatic variables.
The syntax for a nonblocking procedural assignment is given in Syntax10-3.
nonblocking_assignment ::= variable_lvalue [ delay_or_event_control ] expression // from A.6.3
<=
Syntax10-3—Nonblocking assignment syntax (excerpt from AnnexA)
In this syntax, variable_lvalue is a data type that is valid for a procedural assignment statement, is the
<=
nonblocking assignment operator, and delay_or_event_control is the optional intra-assignment timing
control (see 9.4.5). If variable_lvalue requires an evaluation, such as an index expression, class handle, or
virtual interface reference, it shall be evaluated at the same time as the expression on the right-hand side.
The order of evaluation of the variable_lvalue and the expression on the right-hand side is undefined (see
4.9.4).
The nonblocking assignment operator is the same operator as the less-than-or-equal-to relational operator.
The interpretation shall be decided from the context in which appears. When is used in an expression,
<= <=
it shall be interpreted as a relational operator; and when it is used in a nonblocking procedural assignment, it
shall be interpreted as an assignment operator.
The nonblocking procedural assignments shall be evaluated in two steps as discussed in Clause4. These two
steps are shown in the following example:
Example 1:
module evaluates (out); Step 1: At posedge c , the simulator Nonblocking
evaluates the right-hand sides of
output out; assignment
the nonblocking assignments and
logic a, b, c; schedules
schedules the assignments of the
new values at the end of the change at
initial begin nonblocking assign update events time 5
a = 0; NBA region (see 4.5).
a = 0
b = 1;
c = 0; Step 2: When the simulator activates the b = 1
end nonblocking assign update events,
the simulator updates the left-hand
assignment
always c = #5 ~c; side of each nonblocking
values
assignment statement.
always @(posedge c) begin a = 1
a <= b; // evaluates, schedules,
b = 0
b <= a; // and executes in two steps
end
endmodule
At the end of the time step means that the nonblocking assignments are the last assignments executed in a
time step—with one exception. Nonblocking assignment events can create blocking assignment events.
These blocking assignment events shall be processed after the scheduled nonblocking events.
238
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Unlike an event or delay control for blocking assignments, the nonblocking assignment does not block the
procedural flow. The nonblocking assignment evaluates and schedules the assignment, but it does not block
the execution of subsequent statements in a begin-end block.
Example 2:
module nonblock1; scheduled
logic a, b, c, d, e, f; changes at
time 2
// blocking assignments
initial begin e = 0
a = #10 1; // a will be assigned 1 at time 10
b = #2 0; // b will be assigned 0 at time 12 scheduled
c = #4 1; // c will be assigned 1 at time 16 changes at
end time 4
f = 1
// nonblocking assignments
initial begin
d <= #10 1; // d will be assigned 1 at time 10 scheduled
e <= #2 0; // e will be assigned 0 at time 2 changes at
f <= #4 1; // f will be assigned 1 at time 4 time 10
end
d = 1
endmodule
As shown in the previous example, the simulator evaluates and schedules assignments for the end of the
current time step and can perform swapping operations with the nonblocking procedural assignments.
Example 3:
module nonblock2; Step 1: The simulator evaluates the right-hand
logic a, b; side of the nonblocking assignments
initial begin
and schedules the assignments for the
end of the current time step.
a = 0;
b = 1;
Step 2: At the end of the current time step, the
a <= b; // evaluates, schedules,
simulator updates the left-hand side of
b <= a; // and executes in two steps each nonblocking assignment
end statement.
initial begin assignment
$monitor ($time, ,"a = %b b = %b", a, b); values
#100 $finish;
end a = 1
endmodule
b = 0
The order of the execution of distinct nonblocking assignments to a given variable shall be preserved. In
other words, if there is clear ordering of the execution of a set of nonblocking assignments, then the order of
the resulting updates of the destination of the nonblocking assignments shall be the same as the ordering of
the execution (see 4.6).
Example 4:
module multiple;
logic a;
239
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
initial a = 1;
// The assigned value of the variable is determinate
initial begin
a <= #4 0; // schedules a = 0 at time 4
a <= #4 1; // schedules a = 1 at time 4
end // At time 4, a = 1
endmodule
If the simulator executes two procedural blocks concurrently and if these procedural blocks contain
nonblocking assignment operators to the same variable, the final value of that variable is indeterminate. For
example, the value of variable is indeterminate in the following example:
a
Example 5:
module multiple2;
logic a;
initial a = 1;
initial a <= #4 0; // schedules 0 at time 4
initial a <= #4 1; // schedules 1 at time 4
// At time 4, a = ??
// The assigned value of the variable is indeterminate
endmodule
The fact that two nonblocking assignments targeting the same variable are in different blocks is not by itself
sufficient to make the order of assignments to a variable indeterminate. For example, the value of variable
a
at the end of time cycle 16 is determinate in the following example:
Example 6:
module multiple3;
logic a;
initial #8 a <= #8 1; // executed at time 8;
// schedules an update of 1 at time 16
initial #12 a <= #4 0; // executed at time 12;
// schedules an update of 0 at time 16
// Because it is determinate that the update of a to the value 1
// is scheduled before the update of a to the value 0,
// then it is determinate that a will have the value 0
// at the end of time slot 16.
endmodule
The following example shows how the value of is assigned to and how the assignments are
i[0] r1
scheduled to occur after each time delay:
Example 7:
module multiple4;
logic r1;
logic [2:0] i;
initial begin
// makes assignments to r1 without cancelling previous assignments
240
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
for (i = 0; i <= 5; i++)
r1 <= # (i*10) i[0];
end
endmodule
r1
0 10 20 30 40 50
10.5 Variable declaration assignment (variable initialization)
Unlike nets, a variable cannot have an implicit continuous assignment as part of its declaration. An
assignment as part of the declaration of a variable is a variable initialization, not a continuous assignment.
The variable declaration assignment is a special case of procedural assignment as it assigns a value to a
variable. It allows an initial value to be placed in a variable in the same statement that declares the variable
(see 6.8). The assignment does not have duration; instead, the variable holds the value until the next
assignment to that variable.
For example:
wire w = vara & varb; // net with a continuous assignment
logic v = consta & constb; // variable with initialization
Setting the initial value of a static variable as part of the variable declaration (including static class
members) shall occur before any initial or always procedures are started. See also 6.21.
10.6 Procedural continuous assignments
The procedural continuous assignments (using keywords and ) are procedural statements
assign force
that allow expressions to be driven continuously onto variables or nets. The syntax for these statements is
given in Syntax10-4.
procedural_continuous_assignment ::= // from A.6.2
variable_assignment
assign
| variable_lvalue
deassign
| variable_assignment
force
| net_assignment
force
| variable_lvalue
release
| net_lvalue
release
variable_assignment ::= variable_lvalue expression
=
net_assignment ::= net_lvalue expression // from A.6.1
=
Syntax10-4—Syntax for procedural continuous assignments (excerpt from AnnexA)
241
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The right-hand side of an procedural continuous assignment or a statement can be an
assign force
expression. This shall be treated just as a continuous assignment; that is, if any variable on the right-hand
side of the assignment changes, the assignment shall be reevaluated while the assign or force is in effect. For
example:
force a = b + f(c) ;
Here, if changes or changes, will be forced to the new value of the expression .
b c a b+f(c)
10.6.1 The assign and deassign procedural statements
The procedural continuous assignment statement shall override all procedural assignments to a
assign
variable. The procedural statement shall end a procedural continuous assignment to a variable.
deassign
The value of the variable shall remain the same until the variable is assigned a new value through a
procedural assignment or a procedural continuous assignment. The assign and deassign procedural
statements allow, for example, modeling of asynchronous clear/preset on a D-type edge-triggered flip-flop,
where the clock is inhibited when the clear or preset is active.
The left-hand side of the assignment in the assign statement shall be a singular variable reference or a
concatenation of variables. It shall not be a bit-select or a part-select of a variable.
If the keyword is applied to a variable for which there is already a procedural continuous
assign
assignment, then this new procedural continuous assignment shall deassign the variable before making the
new procedural continuous assignment.
The following example shows a use of the assign and deassign procedural statements in a behavioral
description of a D-type flip-flop with preset and clear inputs:
module dff (q, d, clear, preset, clock);
output q;
input d, clear, preset, clock;
logic q;
always @(clear or preset)
if (!clear)
assign q = 0;
else if (!preset)
assign q = 1;
else
deassign q;
always @(posedge clock)
q = d;
endmodule
If either or is low, then the output will be held continuously to the appropriate constant
clear preset q
value, and a positive edge on the will not affect . When both the and are high, then
clock q clear preset
is deassigned.
q
NOTE—The procedural assign and deassign constructs are under consideration for deprecation. See AnnexC.
10.6.2 The force and release procedural statements
Another form of procedural continuous assignment is provided by the and procedural
force release
statements. These statements have a similar effect to the - pair, but a force can be applied
assign deassign
to nets as well as to variables. The left-hand side of the assignment can be a reference to a singular variable,
242
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
a net, a constant bit-select of a vector net, a constant part-select of a vector net, or a concatenation of these. It
shall not be a bit-select or a part-select of a variable or of a net with a user-defined . A or
nettype force
statement shall not be applied to a variable that is being assigned by a mixture of continuous and
release
procedural assignments.
A statement to a variable shall override a procedural assignment, continuous assignment or an
force
procedural continuous assignment to the variable until a procedural statement is executed
assign release
on the variable. When released, then if the variable is not driven by a continuous assignment and does not
currently have an active procedural continuous assignment, the variable shall not immediately
assign
change value and shall maintain its current value until the next procedural assignment to the variable is
executed. Releasing a variable that is driven by a continuous assignment or currently has an active
assign
procedural continuous assignment shall reestablish that assignment and schedule a reevaluation in the
continuous assignment’s scheduling region.
A procedural statement on a net shall override all drivers of the net—gate outputs, module outputs,
force
and continuous assignments—until a procedural statement is executed on the net. When released,
release
the net shall immediately be assigned the value determined by the drivers of the net.
For example:
module test;
logic a, b, c, d;
wire e;
and and1 (e, a, b, c);
initial begin
$monitor("%d d=%b,e=%b", $stime, d, e);
assign d = a & b & c;
a = 1;
b = 0;
c = 1;
#10;
force d = (a | b | c);
force e = (a | b | c);
#10;
release d;
release e;
#10 $finish;
end
endmodule
Results:
0 d=0,e=0
10 d=1,e=1
20 d=0,e=0
In this example, an gate instance, , is “patched” to act like an gate by a procedural
and and1 or force
statement that forces its output to the value of its ORed inputs, and an procedural statement of
assign
ANDed values is “patched” to act like an assign statement of ORed values.
10.7 Assignment extension and truncation
The size of the left-hand side of an assignment forms the context for the right-hand expression.
243
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The following are the steps for evaluating an assignment:
— Determine the size of the left-hand side and right-hand side by the standard expression size
determination rules (see 11.8.1).
— When the right-hand side evaluates to fewer bits than the left-hand side, the right-hand side value is
padded to the size of the left-hand side. If the right-hand side is unsigned, it is padded according to
the rules specified in 11.6.1. If the right-hand side is signed, it is sign-extended.
— If the left-hand side is smaller than the right-hand side, truncation shall occur, as described in the
following paragraphs.
If the width of the right-hand expression is larger than the width of the left-hand side in an assignment, the
MSBs of the right-hand expression shall be discarded to match the size of the left-hand side.
Implementations can, but are not required to, warn or report any errors related to assignment size mismatch
or truncation. Size casting can be used to indicate explicit intent to change the size (see 6.24.1). Truncating
the sign bit of a signed expression may change the sign of the result.
Some examples of assignment truncation follow.
Example 1:
logic [5:0] a;
logic signed [4:0] b;
initial begin
a = 8'hff; // After the assignment, a = 6'h3f
b = 8'hff; // After the assignment, b = 5'h1f
end
Example 2:
logic [0:5] a;
logic signed [0:4] b, c;
initial begin
a = 8'sh8f; // After the assignment, a = 6'h0f
b = 8'sh8f; // After the assignment, b = 5'h0f
c = -113; // After the assignment, c = 15
// 1000_1111 = (-'h71 = -113) truncates to ('h0F = 15)
end
Example 3:
logic [7:0] a;
logic signed [7:0] b;
logic signed [5:0] c, d;
initial begin
a = 8'hff;
c = a; // After the assignment, c = 6'h3f
b = -113;
d = b; // After the assignment, d = 6'h0f
end
10.8 Assignment-like contexts
An assignment-like context is as follows:
244
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— A continuous or procedural assignment
— For a parameter with an explicit type declaration:
• A parameter value assignment in a module, interface, program, or class
• A parameter value override in the instantiation of a module, interface, or program
• A parameter value override in the instantiation of a class or in the left-hand side of a class scope
resolution operator
— A port connection to an input or output port of a module, interface, or program
— The passing of a value to a subroutine input, output, or inout port
— A return statement in a function
— A tagged union expression
— For an expression that is used as the right-hand value in an assignment-like context:
• If a parenthesized expression, then the expression within the parentheses
• If a mintypmax expression, then the colon-separated expressions
• If a conditional operator expression, then the second and third operand
— A nondefault correspondence between an expression in an assignment pattern and a field or element
in a data object or data value
No other contexts shall be considered assignment-like contexts. In particular, none of the following shall be
considered assignment-like contexts:
— A static cast
— A default correspondence between an expression in an assignment pattern and a field or element in a
data object or data value
— A port expression in a module, interface, or program declaration
— The passing of a value to a subroutine port
ref
— A port connection to an or port of a module, interface, or program
inout ref
10.9 Assignment patterns
Assignment patterns are used for assignments to describe patterns of assignments to structure fields and
array elements.
An assignment pattern specifies a correspondence between a collection of expressions and the fields and
elements in a data object or data value. An assignment pattern has no self-determined data type, but can be
used as one of the sides in an assignment-like context (see 10.8) when the other side has a self-determined
data type. An assignment pattern is built from braces, keys, and expressions and is prefixed with an
apostrophe. For example:
var int A[N] = '{default:1};
var integer i = '{31:1, 23:1, 15:1, 8:1, default:0};
typedef struct {real r, th;} C;
var C x = '{th:PI/2.0, r:1.0};
var real y [0:1] = '{0.0, 1.1}, z [0:9] = '{default: 3.1416};
A positional notation without keys can also be used. For example:
var int B[4] = '{a, b, c, d};
var C y = '{1.0, PI/2.0};
'{a, b, c, d} = B;
245
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
When an assignment pattern is used as the left-hand side of an assignment-like context, the positional
notation shall be required; and each member expression shall have a bit-stream data type that is assignment
compatible with and has the same number of bits as the data type of the corresponding element on the right-
hand side.
The assignment pattern syntax is listed in Syntax10-5.
assignment_pattern ::= // from A.6.7.1
expression { expression }
'{ , }
| structure_pattern_key expression { structure_pattern_key expression }
'{ : , : }
| array_pattern_key expression { array_pattern_key expression }
'{ : , : }
| constant_expression expression { expression }
'{ { , }}
structure_pattern_key ::= member_identifier | assignment_pattern_key
array_pattern_key ::= constant_expression | assignment_pattern_key
assignment_pattern_key ::= simple_type |
default
assignment_pattern_expression ::=
[ assignment_pattern_expression_type ] assignment_pattern
assignment_pattern_expression_type ::=
ps_type_identifier
| ps_parameter_identifier
| integer_atom_type
|type_reference
constant_assignment_pattern_expression32 ::= assignment_pattern_expression
32) In a constant_assignment_pattern_expression, all member expressions shall be constant expressions.
Syntax10-5—Assignment patterns syntax (excerpt from AnnexA)
An assignment pattern can be used to construct or deconstruct a structure or array by prefixing the pattern
with the name of a data type to form an assignment pattern expression. Unlike an assignment pattern, an
assignment pattern expression has a self-determined data type and is not restricted to being one of the sides
in an assignment-like context. When an assignment pattern expression is used in a right-hand expression, it
shall yield the value that a variable of the data type would hold if it were initialized using the assignment
pattern.
typedef logic [1:0] [3:0] T;
shortint'({T'{1,2}, T'{3,4}}) // yields 16'sh1234
When an assignment pattern expression is used in a left-hand expression, the positional notation shall be
required; and each member expression shall have a bit-stream data type that is assignment compatible with
and has the same number of bits as the corresponding element in the data type of the assignment pattern
expression. If the right-hand expression has a self-determined data type, then it shall be assignment
compatible with and have the same number of bits as the data type of the assignment pattern expression.
typedef byte U[3];
var U A = '{1, 2, 3};
var byte a, b, c;
U'{a, b, c} = A;
U'{c, a, b} = '{a+1, b+1, c+1};
246
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
An assignment pattern expression shall not be used in a port expression in a module, interface, or program
declaration.
10.9.1 Array assignment patterns
Concatenation braces are used to construct and deconstruct simple bit vectors. A similar syntax is used to
support the construction and deconstruction of arrays. The expressions shall match element for element, and
the braces shall match the array dimensions. Each expression item shall be evaluated in the context of an
assignment to the type of the corresponding element in the array. In other words, the following examples are
not required to cause size warnings:
bit unpackedbits [1:0] = '{1,1}; // no size warning required as
// bit can be set to 1
int unpackedints [1:0] = '{1'b1, 1'b1}; // no size warning required as
// int can be set to 1'b1
A syntax resembling replications (see 11.4.12.1) can be used in array assignment patterns as well. Each
replication shall represent an entire single dimension.
unpackedbits = '{2 {y}} ; // same as '{y, y}
int n[1:2][1:3] = '{2{'{3{y}}}}; // same as '{'{y,y,y},'{y,y,y}}
SystemVerilog determines the context of the braces when used in the context of an assignment.
It can sometimes be useful to set array elements to a value without having to keep track of how many
members there are. This can be done with the keyword:
default
initial unpackedints = '{default:2}; // sets elements to 2
For arrays of structures, it is useful to specify one or more matching type keys, as described under structure
assignment patterns following in 10.9.2.
struct {int a; time b;} abkey[1:0];
abkey = '{'{a:1, b:2ns}, '{int:5, time:$time}};
The matching rules are as follows:
— An specifies an explicit value for a keyed element index. The value is evaluated in
index:value
the context of an assignment to the indexed element and shall be castable to its type. It shall be an
error to specify the same index more than once in a single array pattern expression.
— For , if the element or subarray type of the array matches this type, then each element
type:value
or subarray that has not already been set by an index key above shall be set to the value. The value
shall be castable to the array element or subarray type. Otherwise, if the array is multidimensional,
then there is a recursive descent into each subarray of the array using the rules in this subclause and
the type and default keys. Otherwise, if the array is an array of structures, there is a recursive descent
into each element of the array using the rules for structure assignment patterns and the type and
default keys. If more than one type matches the same element, the last value shall be used.
— The applies to elements or subarrays that are not matched by either index or type
default:value
key. If the type of the element or subarray is a simple bit vector type, matches the self-determined
type of the value, or is not an array or structure type, then the value is evaluated in the context of
each assignment to an element or subarray by the default and shall be castable to the type of the
element or subarray; otherwise, an error is generated. For unmatched subarrays, the type and default
specifiers are applied recursively according to the rules in this subclause to each of its elements or
subarrays. For unmatched structure elements, the type and default keys are applied to the element
according to the rules for structures.
247
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Every element shall be covered by one of these rules.
If the type key, default key, or replication operator is used on an expression with side effects, the number of
times that expression evaluates is undefined.
10.9.2 Structure assignment patterns
A structure can be constructed and deconstructed with a structure assignment pattern built from member
expressions using braces and commas, with the members in declaration order. Replication operators can be
used to set the values for the exact number of members. Each member expression shall be evaluated in the
context of an assignment to the type of the corresponding member in the structure. It can also be built with
the names of the members.
module mod1;
typedef struct {
int x;
int y;
} st;
st s1;
int k = 1;
initial begin
#1 s1 = '{1, 2+k}; // by position
#1 $display( s1.x, s1.y);
#1 s1 = '{x:2, y:3+k}; // by name
#1 $display( s1.x, s1.y);
#1 $finish;
end
endmodule
It can sometimes be useful to set structure members to a value without having to keep track of how many
members there are or what the names are. This can be done with the keyword:
default
initial s1 = '{default:2}; // sets x and y to 2
The or syntax can also be used:
'{member:value} '{data_type: default_value}
ab abkey[1:0] = '{'{a:1, b:1.0}, '{int:2, shortreal:2.0}};
Use of the keyword applies to members in nested structures or elements in unpacked arrays in
default
structures.
struct {
int A;
struct {
int B, C;
} BC1, BC2;
} ABC, DEF;
ABC = '{A:1, BC1:'{B:2, C:3}, BC2:'{B:4,C:5}};
DEF = '{default:10};
To deal with the problem of members of different types, a type can be used as the key. This overrides the
default for members of that type:
248
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
typedef struct {
logic [7:0] a;
bit b;
bit signed [31:0] c;
string s;
} sa;
sa s2;
initial s2 = '{int:1, default:0, string:""}; // set all to 0 except the
// array of bits to 1 and
// string to ""
Similarly, an individual member can be set to override the general default and the type default:
initial #10 s2 = '{default:'1, s : ""}; // set all to 1 except s to ""
SystemVerilog determines the context of the braces when used in the context of an assignment.
The matching rules are as follows:
— A specifies an explicit value for a named member of the structure. The named
member:value
member shall be at the top level of the structure; a member with the same name in some level of
substructure shall not be set. The value shall be castable to the member type and is evaluated in the
context of an assignment to the named member; otherwise, an error is generated.
— The specifies an explicit value for each field in the structure whose type matches the
type:value
type (see 6.22.1) and has not been set by a field name key above. If the same type key is mentioned
more than once, the last value is used. The value is evaluated in the context of an assignment to the
matching type.
— The applies to members that are not matched by either member name or type key.
default:value
If the member type is a simple bit vector type, matches the self-determined type of the value, or is
not an array or structure type, then the value is evaluated in the context of each assignment to a
member by the default and shall be castable to the member type; otherwise, an error is generated.
For unmatched structure members, the type and default specifiers are applied recursively according
to the rules in this subclause to each member of the substructure. For unmatched array members, the
type and default keys are applied to the array according to the rules for arrays.
Every member shall be covered by one of these rules.
If the type key, default key, or replication operator is used on an expression with side effects, the number of
times that expression evaluates is undefined.
10.10 Unpacked array concatenation
Unpacked array concatenation provides a flexible way to compose an unpacked array value from a
collection of elements and arrays. An unpacked array concatenation may appear as the source expression in
an assignment-like context and shall not appear in any other context. The target of such assignment-like
context shall be an array whose slowest-varying dimension is an unpacked fixed-size, queue, or dynamic
dimension. A target of any other type (including associative array) shall be illegal.
An unpacked array concatenation shall be written as a comma-separated list, enclosed in braces, of zero or
more items. If the list has zero items, then the concatenation shall denote an array value with no elements.
Otherwise, each item shall represent one or more elements of the resulting array value, interpreted as
follows:
249
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— An item whose self-determined type is assignment compatible with the element type of the target
array shall represent a single element
— An item whose self-determined type is an unpacked array whose slowest-varying dimension’s
element type is assignment compatible with the element type of the target array shall represent as
many elements as exist in that item, arranged in the same left-to-right order as they would appear in
the array item itself
— An item of any other type, or an item that has no self-determined type, shall be illegal except that the
literal value shall be legal if the target array’s elements are of event, class, interface class,
null
chandle or virtual interface type
The elements thus represented shall be arranged in left-to-right order to form the resulting array. It shall be
an error if the size of the resulting array differs from the number of elements in a fixed-size target. If the size
exceeds the maximum number of elements of a bounded queue, then elements beyond the upper bound of
the target shall be ignored and a warning shall be issued.
10.10.1 Unpacked array concatenations compared with array assignment patterns
Array assignment patterns have the advantage that they can be used to create assignment pattern expressions
of self-determined type by prefixing the pattern with a type name. Furthermore, items in an assignment
pattern can be replicated using syntax, such as , and can be defaulted using the
'{ n{element} }
syntax. However, every element item in an array assignment pattern must be of the same type as
default:
the element type of the target array. By contrast, unpacked array concatenations forbid replication,
defaulting, and explicit typing, but they offer the additional flexibility of composing an array value from an
arbitrary mix of elements and arrays. In some simple cases both forms can have the same effect, as in the
following example:
int A3[1:3];
A3 = {1, 2, 3}; // unpacked array concatenation: A3[1]=1, A3[2]=2, A3[3]=3
A3 = '{1, 2, 3}; // array assignment pattern: A3[1]=1, A3[2]=2, A3[3]=3
The next examples illustrate some differences between the two forms:
typedef int AI3[1:3];
AI3 A3;
int A9[1:9];
A3 = '{1, 2, 3};
A9 = '{3{A3}}; // illegal, A3 is wrong element type
A9 = '{A3, 4, 5, 6, 7, 8, 9}; // illegal, A3 is wrong element type
A9 = {A3, 4, 5, A3, 6}; // legal, gives A9='{1,2,3,4,5,1,2,3,6}
A9 = '{9{1}}; // legal, gives A9='{1,1,1,1,1,1,1,1,1}
A9 = {9{1}}; // illegal, no replication in unpacked
// array concatenation
A9 = {A3, {4,5,6,7,8,9} }; // illegal, {...} is not self-determined here
A9 = {A3, '{4,5,6,7,8,9} }; // illegal, '{...} is not self-determined
A9 = {A3, 4, AI3'{5, 6, 7}, 8, 9}; // legal, A9='{1,2,3,4,5,6,7,8,9}
Unpacked array concatenation is especially useful for writing values of queue type, as shown in the
examples in 7.10.4.
10.10.2 Relationship with other constructs that use concatenation syntax
Concatenation syntax with braces can be used in other SystemVerilog constructs, including vector
concatenation and string concatenation. These forms of concatenation are expressions of self-determined
type, unlike unpacked array concatenation that does not have a self-determined type and that must appear as
250
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
the source expression in an assignment-like context. If concatenation braces appear in an assignment-like
context with an unpacked array target, they unambiguously act as unpacked array concatenation and must
conform to the rules given in 10.10. Otherwise, they form a vector or string concatenation according to the
rules given in 11.4.12. The following examples illustrate how the same expression can have different
meanings in different contexts without ambiguity.
string S, hello;
string SA[2];
byte B;
byte BA[2];
hello = "hello";
S = {hello, " world"}; // string concatenation: "hello world"
SA = {hello, " world"}; // array concatenation:
// SA[0]="hello", SA[1]=" world"
B = {4'h6, 4'hf}; // vector concatenation: B=8'h6f
BA = {4'h6, 4'hf}; // array concatenation: BA[0]=8'h06, BA[1]=8'h0f
10.10.3 Nesting of unpacked array concatenations
Each item of an unpacked array concatenation shall have a self-determined type (see 10.10), but a complete
unpacked array concatenation has no self-determined type. Consequently it shall be illegal for an unpacked
array concatenation to appear as an item in another unpacked array concatenation. This rule makes it
possible for a vector or string concatenation to appear as an item in an unpacked array concatenation without
ambiguity, as illustrated in the following example.
string S1, S2;
typedef string T_SQ[$];
T_SQ SQ;
S1 = "S1";
S2 = "S2";
SQ = '{"element 0", "element 1"}; // assignment pattern, two strings
SQ = {S1, SQ, {"element 3 is ", S2} };
In the last line of the preceding example, the outer pair of braces encloses an unpacked array concatenation
whereas the inner pair of braces encloses a string concatenation, so that the resulting queue of strings is
'{"S1", "element 0", "element 1", "element 3 is S2"}
Alternatively the third item in the unpacked array concatenation could instead represent an array of strings,
if it were written as an assignment pattern expression. The unpacked array concatenation would still be valid
in this case, but now it would treat its third item as an array of two strings, each forming one element of the
resulting array:
SQ = {S1, SQ, T_SQ'{"element 3 is ", S2} };
// result: '{"S1", "element 0", "element 1", "element 3 is ", "S2"}
With the exception of items, each item of an assignment pattern or an assignment pattern
default:
expression is in an assignment-like context (see 10.9). Consequently an unpacked array concatenation may
appear as a non-default item in an assignment pattern. The following example uses a two-dimensional queue
to build a jagged array of arrays of int, using both an assignment pattern expression and unpacked array
concatenations to represent the subarrays:
251
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
typedef int T_QI[$];
T_QI jagged_array[$] = '{ {1}, T_QI'{2,3,4}, {5,6} };
// jagged_array[0][0] = 1 -- jagged_array[0] is a queue of 1 int
// jagged_array[1][0] = 2 -- jagged_array[1] is a queue of 3 ints
// jagged_array[1][1] = 3
// jagged_array[1][2] = 4
// jagged_array[2][0] = 5 -- jagged_array[2] is a queue of 2 ints
// jagged_array[2][1] = 6
10.11 Net aliasing
An alias statement declares multiple names for the same physical net, or bits within a net. The syntax for an
alias statement is as follows:
net_alias ::= net_lvalue net_lvalue { net_lvalue } // from A.6.1
alias = = ;
net_lvalue ::= // from A.8.5
ps_or_hierarchical_net_identifier constant_select
| net_lvalue { net_lvalue }
{ , }
| [ assignment_pattern_expression_type ] assignment_pattern_net_lvalue
Syntax10-6—Syntax for net aliasing (excerpt from AnnexA)
The continuous statement is a unidirectional assignment and can incorporate a delay and strength
assign
change. To model a bidirectional short-circuit connection, it is necessary to use the statement. The
alias
members of an alias list are signals whose bits share the same physical nets. The following example
implements a byte order swapping between bus and bus :
A B
module byte_swap (inout wire [31:0] A, inout wire [31:0] B);
alias {A[7:0],A[15:8],A[23:16],A[31:24]} = B;
endmodule
This example strips out the LSB and MSB from a 4-byte bus:
module byte_rip (inout wire [31:0] W, inout wire [7:0] LSB, MSB);
alias W[7:0] = LSB;
alias W[31:24] = MSB;
endmodule
The bit overlay rules are the same as for a packed union with the same member types: each member shall be
the same size, and connectivity is independent of the simulation host. The nets connected with an
alias
statement shall be type compatible, that is, they have to be of the same net type. For example, it is illegal to
connect a net to a net with an statement. This rule is stricter than the rule applied to nets
wand wor alias
joining at ports because the scope of an alias is limited and such connections are more likely to be a design
error. Variables and hierarchical references cannot be used in statements. Any violation of these rules
alias
shall be considered a fatal error.
The same nets can appear in multiple statements. The effects are cumulative. The following two
alias
examples are equivalent. In either case, and share the same wires.
low12[11:4] high12[7:0]
252
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
module overlap(inout wire [15:0] bus16, inout wire [11:0] low12, high12);
alias bus16[11:0] = low12;
alias bus16[15:4] = high12;
endmodule
module overlap(inout wire [15:0] bus16, inout wire [11:0] low12, high12);
alias bus16 = {high12, low12[3:0]};
alias high12[7:0] = low12[11:4];
endmodule
To avoid errors in specification, it is not allowed to specify an alias from an individual signal to itself or to
specify a given alias more than once. The following version of the preceding code would be illegal because
the top 4 bits and bottom 4 bits are the same in both statements:
alias bus16 = {high12[11:8], low12};
alias bus16 = {high12, low12[3:0]};
This alternative is also illegal because the bits of are being aliased to itself:
bus16
alias bus16 = {high12, bus16[3:0]} = {bus16[15:12], low12};
statements can appear anywhere module instance statements can appear. If an identifier that has not
alias
been declared as a data type appears in an statement, then an implicit net is assumed, following the
alias
same rules as implicit nets for a module instance. The following example uses along with the
alias
automatic name binding to connect pins on cells from different libraries to create a standard macro:
module lib1_dff(Reset, Clk, Data, Q, Q_Bar);
...
endmodule
module lib2_dff(reset, clock, data, q, qbar);
...
endmodule
module lib3_dff(RST, CLK, D, Q, Q_);
...
endmodule
module my_dff(rst, clk, d, q, q_bar); // wrapper cell
input rst, clk, d;
output q, q_bar;
alias rst = Reset = reset = RST;
alias clk = Clk = clock = CLK;
alias d = Data = data = D;
alias q = Q;
alias Q_ = q_bar = Q_Bar = qbar;
`LIB_DFF my_dff (.*); // LIB_DFF is any of lib1_dff, lib2_dff or lib3_dff
endmodule
Using a net in an statement does not modify its syntactic behavior in other statements. Aliasing is
alias
performed at elaboration time and cannot be undone.
253
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
11. Operators and expressions
11.1 General
This clause describes the following:
— Expression semantics
— Operations on expressions
— Operator precedence
— Operand size extension rules
— Signed and unsigned operation rules
— Bit and part-select operations and longest static prefix
— Bit-stream operations
11.2 Overview
This clause describes the operators and operands available in SystemVerilog and how to use them to form
expressions.
An expression is a construct that combines operands with operators to produce a result that is a function of
the values of the operands and the semantic meaning of the operator. Any legal operand, such as a net bit-
select, without any operator is considered an expression. Wherever a value is needed in a SystemVerilog
statement, an expression can be used.
An operand can be one of the following:
— Constant literal number, including real literals
— String literal
— Parameter, including local and specify parameters
— Parameter bit-select or part-select, including local and specify parameters
— Net (see 6.7)
— Net bit-select or part-select
— Variable (see 6.8)
— Variable bit-select or part-select
— Structure, either packed or unpacked
— Structure member
— Packed structure bit-select or part-select
— Union, packed, unpacked, or tagged
— Union member
— Packed union bit-select or part-select
— Array, either packed or unpacked
— Packed array bit-select, part-select, element, or slice
— Unpacked array element bit-select or part-select, element, or slice
— A call to a user-defined function, system-defined function, or method that returns any of the above
254
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
11.2.1 Constant expressions
Some statement constructs require an expression to be a constant expression. The operands of a constant
expression consist of constant numbers, strings, parameters, constant bit-selects and part-selects of
parameters, constant function calls (see 13.4.3), and constant system function calls only. Constant
expressions can use any of the operators defined in Table11-1.
Constant system function calls are calls to certain built-in system functions where the arguments meet
conditions outlined in this subclause. When used in constant expressions, these function calls shall be
evaluated at elaboration time. The system functions that may be used in constant system function calls are
pure functions, i.e., those whose value depends only on their input arguments and that have no side effects.
Certain built-in system functions where the arguments are constant expressions are constant system function
calls. Specifically, these are the conversion system functions listed in 20.5, the mathematical system
functions listed in 20.8, and the bit vector system functions listed in 20.9.
The data query system functions listed in 20.6 and the array query system functions listed in 20.7 are
normally also constant system function calls even when their arguments are not constant. See those
subclauses for the conditions under which these query system function calls are considered to be constant
expressions.
11.2.2 Aggregate expressions
Unpacked structure and array data objects, as well as unpacked structure and array constructors, can all be
used as aggregate expressions. A multi-element slice of an unpacked array can also be used as an aggregate
expression.
Aggregate expressions can be copied in an assignment, through a port, or as an argument to a subroutine.
Aggregate expressions can also be compared with equality or inequality operators.
If the two operands of a comparison operator are aggregate expressions, they shall be of equivalent type as
defined in 6.22.2. Assignment compatibility of aggregate expressions is defined in 6.22.3 and, for arrays, in
7.6.
11.3 Operators
The symbols for the SystemVerilog operators are similar to those in the C programming language.
Syntax11-1 and Table11-1 list these operators.
assignment_operator ::= // from A.6.2
| | | | | | | | | | | |
= += -= *= /= %= &= |= ^= <<= >>= <<<= >>>=
conditional_expression ::= // from A.8.3
cond_predicate { attribute_instance } expression expression
? :
unary_operator ::= // from A.8.6
| | | | | | | | | |
+ - ! ~ & ~& | ~| ^ ~^ ^~
binary_operator ::=
| | | | | | | | | | | | |
+ - * / % == != === !== ==? !=? && || **
| | | | | | | | | | | | |
< <= > >= & | ^ ^~ ~^ >> << >>> <<<
| |
-> <->
inc_or_dec_operator ::= |
++ --
stream_operator ::= | // from A.8.1
>> <<
Syntax11-1—Operator syntax (excerpt from AnnexA)
255
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table11-1—Operators and data types
Operator token Name Operand data types
Binary assignment operator Any
=
Binary arithmetic assignment operators Integral, ,
+= -= /= *= real shortreal
%= Binary arithmetic modulus assignment operator Integral
Binary bitwise assignment operators Integral
&= |= ^=
>>= <<= Binary logical shift assignment operators Integral
>>>= <<<= Binary arithmetic shift assignment operators Integral
Conditional operator Any
?:
Unary arithmetic operators Integral, ,
+ - real shortreal
Unary logical negation operator Integral, ,
! real shortreal
Unary logical reduction operators Integral
~ & ~& | ~| ^
~^ ^~
Binary arithmetic operators Integral, ,
+ - * / ** real shortreal
% Binary arithmetic modulus operator Integral
Binary bitwise operators Integral
& | ^ ^~ ~^
>> << Binary logical shift operators Integral
>>> <<< Binary arithmetic shift operators Integral
Binary logical operators Integral, ,
&& || real shortreal
> < >
– –
Binary relational operators Integral, ,
< <= > >= real shortreal
Binary case equality operators Any except and
=== !== real
shortreal
Binary logical equality operators Any
== !=
Binary wildcard equality operators Integral
==? !=?
Unary increment, decrement operators Integral, ,
++ -- real shortreal
Binary set membership operator Singular for the left operand
inside
a Binary distribution operator Integral
dist
Concatenation, replication operators Integral
{} {{}}
<< >> Stream operators Integral
{ {}} { {}}
aThe operator is described in 16.14.2 and 18.5.4.
dist
11.3.1 Operators with real operands
Table11-1 shows what operators may be applied to real operands.
The result of using logical or relational operators or the operator on real operands shall be a
inside
single-bit scalar value.
256
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For other operators, if any operand, except before the ? in the conditional operator, is , the result is
real
. Otherwise, if any operand, except before the ? in the conditional operator, is , the result is
real shortreal
.
shortreal
Real operands can also be used in the following expressions:
str.realval // structure or union member
realarray[intval] // array element
See 6.12.1 for more information on use of real numbers.
11.3.2 Operator precedence
Operator precedence and associativity are listed in Table11-2. The highest precedence is listed first.
Table11-2—Operator precedence and associativity
Operator Associativity Precedence
Left Highest
() [] :: .
(unary)
+ - ! ~ & ~& | ~| ^ ~^ ^~ ++ --
Left
**
Left
* / %
(binary) Left
+ -
Left
<< >> <<< >>>
Left
< <= > >= inside dist
Left
== != === !== ==? !=?
(binary) Left
&
(binary) Left
^ ~^ ^~
(binary) Left
|
Left
&&
Left
||
(conditional operator) Right
?:
< > Right
–> –
None
= += -= *= /= %= &= ^= |=
<<= >>= <<<= >>>= := :/ <=
Concatenation Lowest
{} {{}}
Operators shown on the same row in Table11-2 shall have the same precedence. Rows are arranged in order
of decreasing precedence for the operators. For example, *, /, and % all have the same precedence, which is
higher than that of the binary + and – operators.
All operators shall associate left to right with the exception of the conditional ( ), implication ( ), and
?: ->
equivalence ( ) operators, which shall associate right to left. Associativity refers to the order in which the
<->
operators having the same precedence are evaluated. Thus, in the following example, is added to , and
B A
then is subtracted from the result of .
C A+B
257
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A + B - C
When operators differ in precedence, the operators with higher precedence shall associate first. In the
following example, is divided by (division has higher precedence than addition), and then the result is
B C
added to .
A
A + B / C
Parentheses can be used to change the operator precedence.
(A + B) / C // not the same as A + B / C
11.3.3 Using integer literals in expressions
Integer literals can be used as operands in expressions. An integer literal can be expressed as the following:
— An unsized, unbased integer (e.g., )
12
— An unsized, based integer (e.g., , )
'd12 'sd12
— A sized, based integer (e.g., , )
16'd12 16'sd12
See 5.7.1 for integer literal syntax.
A negative value for an integer with no base specifier shall be interpreted differently from an integer with a
base specifier. An integer with no base specifier shall be interpreted as a signed value in two’s-complement
form. An integer with an unsigned base specifier shall be interpreted as an unsigned value.
The following example shows four ways to write the expression “minus 12 divided by 3.” Note that and
-12
both evaluate to the same two’s-complement bit pattern, but, in an expression, the loses its
-'d12 -'d12
identity as a signed negative number.
int IntA;
IntA = -12 / 3; // The result is -4
IntA = -'d 12 / 3; // The result is 1431655761
IntA = -'sd 12 / 3; // The result is -4
IntA = -4'sd 12 / 3; // -4'sd12 is the negative of the 4-bit
// quantity 1100, which is -4. -(-4) = 4
// The result is 1
11.3.4 Operations on logic (4-state) and bit (2-state) types
Operators may be applied to 2-state values or to a mixture of 2-state and 4-state values. The result is the
same as if all values were treated as 4-state values. In most cases, if all operands are 2-state, the result is in
the 2-state value set. The only exceptions involve operators that produce an result for operands in the
x
2-state value set (e.g., division by zero).
int n = 8, zero = 0;
int res = 'b01xz | n; // res gets 'b11xz coerced to int, or 'b1100
int sum = n + n; // sum gets 16 coerced to int, or 16
int sumx = 'x + n; // sumx gets 'x coerced to int, or 0
int div2 = n/zero + n; // div2 gets 'x coerced to int, or 0
integer div4 = n/zero + n; // div4 gets 'x
258
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
11.3.5 Operator expression short circuiting
The operators shall follow the associativity rules while evaluating an expression as described in 11.3.2.
Some operators ( , , , and ) shall use short-circuit evaluation; in other words, some of their
&& || -> ?:
operand expressions shall not be evaluated if their value is not required to determine the final value of the
operation. The detailed short-circuiting behavior of each of these operators is described in its corresponding
subclause (11.4.7 and 11.4.11). All other operators shall not use short-circuit evaluation—all of their
operand expressions are always evaluated. When short circuiting occurs, any side effects or runtime errors
that would have occurred due to evaluation of the short-circuited operand expression shall not occur.
For example:
logic regA, regB, regC, result ;
function logic myFunc(logic x);
...
endfunction
result = regA & (regB | myFunc(regC)) ;
Even if is known to be zero, the subexpression ( ) will be evaluated and any
regA regB | myFunc(regC)
side effects caused by calling will occur.
myFunc(regC)
Note that implementations are free to optimize by omitting evaluation of subexpressions as long as the
simulation behavior (including side effects) is as if the standard rules were followed.
11.3.6 Assignment within an expression
An expression can include a blocking assignment, provided it does not have a timing control. These
blocking assignments shall be enclosed in parentheses to avoid common mistakes such as using for
a=b
or using for .
a==b a|=b a!=b
if ((a=b)) b = (a+=1);
a = (b = (c = 5));
The semantics of such an assignment expression is that of a function that evaluates the right-hand side, casts
the right-hand side to the left-hand data type, stacks it, updates the left-hand side, and returns the stacked
value. The data type of the value that is returned is the data type of the left-hand side. If the left-hand side is
a concatenation, then the data type of the value that is returned shall be an unsigned integral data type whose
bit length is the sum of the length of its operands.
It shall be illegal to include an assignment operator in an event expression, in an expression within a
procedural continuous assignment, or in an expression that is not within a procedural statement.
11.4 Operator descriptions
11.4.1 Assignment operators
In addition to the simple assignment operator, =, SystemVerilog includes the C assignment operators and
special bitwise assignment operators: , , , , , , , , , , , and . An
+= -= *= /= %= &= |= ^= <<= >>= <<<= >>>=
assignment operator is semantically equivalent to a blocking assignment, with the exception that any
left-hand index expression is only evaluated once. For example:
a[i]+=2; // same as a[i] = a[i] +2;
259
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
11.4.2 Increment and decrement operators
SystemVerilog includes the C increment and decrement assignment operators , , , and .
++i --i i++ i--
These do not need parentheses when used in expressions. These increment and decrement assignment
operators behave as blocking assignments.
The ordering of assignment operations relative to any other operation within an expression is undefined. An
implementation can warn whenever a variable is both written and read-or-written within an integral
expression or in other contexts where an implementation cannot guarantee order of evaluation. For example:
i = 10;
j = i++ + (i = i - 1);
After execution, the value of can be 18, 19, or 20 depending upon the relative ordering of the increment
j
and the assignment statements.
The increment and decrement operators, when applied to real operands, increment or decrement the operand
by 1.0.
11.4.3 Arithmetic operators
The binary arithmetic operators are given in Table11-3.
Table11-3—Arithmetic operators defined
a + b a plus b
a b a minus b
-
a * b a multiplied by b (or a times b)
a / b a divided by b
a % b a modulo b
a ** b a to the power of b
The integer division shall truncate any fractional part toward zero. For the division or modulus operators, if
the second operand is a zero, then the entire result value shall be . The modulus operator (for example,
x
) gives the remainder when the first operand is divided by the second and thus is zero when divides
a % b b
exactly. The result of a modulus operation shall take the sign of the first operand.
a
If either operand of the power operator is real, then the result type shall be real (see 11.3.1). The result of the
power operator is unspecified if the first operand is zero and the second operand is nonpositive or if the first
operand is negative and the second operand is not an integral value.
If neither operand of the power operator is real, then the result type shall be determined as outlined in 11.6.1
and 11.8.1. The result value is if the first operand is zero and the second operand is negative. The result
'x
value is 1 if the second operand is zero.
In all cases, the second operand of the power operator shall be treated as self-determined.
These statements are illustrated in Table11-4.
260
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table11-4—Power operator rules
op1 is op1 is op1 is op1 is op1 is
negative < 1 1 zero 1 positive > 1
- -
op1 ** op2 op2 is odd > 1 0 1 op1 ** op2
op2 is positive - -
op2 is even > 1
-
op2 is zero 1 1 1 1 1
0 op2 is odd > 1 'x 1 0
op2 is negative - -
op2 is even > 1
-
The unary arithmetic operators shall take precedence over the binary operators. The unary operators are
given in Table11-5.
Table11-5—Unary operators defined
m Unary plus m (same as m)
+
m Unary minus m
-
For the arithmetic operators, if any operand bit value is the unknown value x or the high-impedance value ,
z
then the entire result value shall be .
x
Table11-6 gives examples of some modulus and power operations.
Table11-6—Examples of modulus and power operators
Expression Result Comments
10 % 3 1 10/3 yields a remainder of 1.
11 % 3 2 11/3 yields a remainder of 2.
12 % 3 0 12/3 yields no remainder.
–10 % 3 –1 The result takes the sign of the first operand.
11 % –3 2 The result takes the sign of the first operand.
–4'd12 % 3 1 –4'd12 is seen as a large positive number that leaves a remainder of 1 when divided by 3.
3 ** 2 9 3  3
2 ** 3 8 2  2  2
2 ** 0 1 Anything to the zero exponent is 1.
0 ** 0 1 Zero to the zero exponent is also 1.
2.0 ** –3'sb1 0.5 2.0 is real, giving real reciprocal.
2 ** –3 'sb1 0 2 ** –1 = 1/2. Integer division truncates to zero.
0 ** –1 'x 0 ** –1 = 1/0. Integer division by zero is 'x.
9 ** 0.5 3.0 Real square root.
261
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table11-6—Examples of modulus and power operators (continued)
Expression Result Comments
9.0 ** (1/2) 1.0 Integer division truncates exponent to zero.
–3.0 ** 2.0 9.0 Defined because real 2.0 is still integral value.
11.4.3.1 Arithmetic expressions with unsigned and signed types
Nets and variables can be explicitly declared as unsigned or signed. The , , , ,
byte shortint int integer
and data types are signed by default. Other data types are unsigned by default.
longint
A value assigned to an unsigned variable or net shall be treated as an unsigned value. A value assigned to a
signed variable or net shall be treated as signed. Signed values, except for those assigned to real variables,
shall use a two’s-complement representation. Values assigned to real variables shall use a floating-point
representation. Conversions between signed and unsigned values shall keep the same bit representation;
only the interpretation changes.
Table11-7 lists how arithmetic operators interpret each data type.
Table11-7—Data type interpretation by arithmetic operators
Data type Interpretation
Unsigned net Unsigned
Signed net Signed, two’s-complement
Unsigned variable Unsigned
Signed variable Signed, two’s-complement
Real variable Signed, floating point
The following example shows various ways to divide “minus twelve by three”—using and
integer logic
variables in expressions.
integer intS;
var logic [15:0] U;
var logic signed [15:0] S;
intS = -4'd12;
U = intS / 3; // expression result is -4,
// intS is an integer data type, U is 65532
U = -4'd12; // U is 65524
intS = U / 3; // expression result is 21841,
// U is a logic data type
intS = -4'd12 / 3; // expression result is 1431655761.
// -4'd12 is effectively a 32-bit logic data type
U = -12 / 3; // expression result is -4, -12 is effectively
// an integer data type. U is 65532
S = -12 / 3; // expression result is -4. S is a signed logic
262
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
S = -4'sd12 / 3; // expression result is 1. -4'sd12 is actually 4.
// The rules for integer division yield 4/3==1
11.4.4 Relational operators
Table11-8 lists and defines the relational operators.
Table11-8—Definitions of relational operators
a<b alessthanb
a>b agreaterthanb
a<=b alessthanorequaltob
a>=b agreaterthanorequaltob
An expression using these relational operators shall yield the scalar value 0 if the specified relation is false
or the value 1 if it is true. If either operand of a relational operator contains an unknown ( ) or
x
high-impedance ( ) value, then the result shall be a 1-bit unknown value ( ).
z x
When one or both operands of a relational expression are unsigned, the expression shall be interpreted as a
comparison between unsigned values. If the operands are of unequal bit lengths, the smaller operand shall be
zero-extended to the size of the larger operand.
When both operands are signed, the expression shall be interpreted as a comparison between signed values.
If the operands are of unequal bit lengths, the smaller operand shall be sign-extended to the size of the larger
operand. See 11.8.2 for more information.
If either operand is a real operand, then the other operand shall be converted to an equivalent real value and
the expression shall be interpreted as a comparison between real values.
All the relational operators shall have the same precedence. Relational operators shall have lower
precedence than arithmetic operators.
The following examples illustrate the implications of this precedence rule:
a < b - 1 // this expression is the same as
a < (b - 1) // this expression, but . . .
b - (1 < a) // this one is not the same as
b - 1 < a // this expression
When evaluates, the relational expression evaluates first, and then either zero or one is
b - (1 < a)
subtracted from . When evaluates, the value of operand is reduced by one and then
b b - 1 < a b
compared with .
a
11.4.5 Equality operators
The equality operators shall rank lower in precedence than the relational operators. Table11-9 lists and
defines the equality operators.
263
Authorized licensed use limited to: Siemens AG GBSC Bo&pSyr iSgOhtL ©G M20S1. 8D IoEwEnElo.a Adlel dr igohn tDs erecesmerbveerd 0.3,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table11-9—Definitions of equality operators
a===b aequaltob,including and
x z
a!==b anotequaltob,including and
x z
a ==b aequaltob,resultcan beunknown
a !=b anotequaltob,resultcan beunknown
All four equality operators shall have the same precedence. These four operators compare operands bit for
bit. As with the relational operators, the result shall be 0 if comparison fails and 1 if it succeeds.
When one or both operands are unsigned, the expression shall be interpreted as a comparison between
unsigned values. If the operands are of unequal bit lengths, the smaller operand shall be zero-extended to the
size of the larger operand.
When both operands are signed, the expression shall be interpreted as a comparison between signed values.
If the operands are of unequal bit lengths, the smaller operand shall be sign-extended to the size of the larger
operand. See 11.8.2 for more information.
If either operand is a real operand, then the other operand shall be converted to an equivalent real value, and
the expression shall be interpreted as a comparison between real values.
The logical equality (or case equality) operator is a legal operation if either operand is a class handle or the
literal , and one of the operands is assignment compatible with the other. The logical equality (or case
null
equality) operator is a legal operation if either operand is a or the literal . In both cases, the
chandle null
operator compares the values of the class handles, interface class handles, or chandles.
For the logical equality and logical inequality operators ( and ), if, due to unknown or high-impedance
== !=
bits in the operands, the relation is ambiguous, then the result shall be a 1-bit unknown value ( ).
x
For the case equality and case inequality operators ( and ), the comparison shall be done just as it is
=== !==
in the procedural case statement (see 12.5). Bits that are or shall be included in the comparison and shall
x z
match for the result to be considered equal. The result of these operators shall always be a known value,
either 1 or 0.
11.4.6 Wildcard equality operators
The wildcard equality operators shall have the same precedence as the equality operators. Table11-10 lists
and defines the wildcard equality operators.
Table11-10—Wildcard equality and wildcard inequality operators
Operator Usage Description
a equals b, and values in b act as wildcards
==? a ==? b X Z
a does not equal b, and values in b act as wildcards
!=? a !=? b X Z
The wildcard equality operator ( ) and inequality operator ( ) treat and values in a given bit
==? !=? X Z
position of their right operand as a wildcard. and values in the left operand are not treated as wildcards.
X Z
264
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A wildcard bit matches any bit value (0, 1, , or ) in the corresponding bit of the left operand being
Z X
compared against it. Any other bits are compared as for the logical equality and logical inequality operators.
These operators compare operands bit for bit and return a 1-bit self-determined result. If the operands to the
wildcard equality/inequality are of unequal bit length, the operands are extended in the same manner as for
the logical equality/inequality operators. If the relation is true, the operator yields a 1. If the relation is false,
it yields a 0. If the relation is unknown, it yields .
X
The different types of equality (and inequality) operators in SystemVerilog behave differently when their
operands contain unknown values ( or ). The and operators may result in if any of their operands
X Z == != x
contains an or . The and operators explicitly check for 4-state values; therefore, and values
X Z === !== X Z
shall either match or mismatch, never resulting in . The and operators may result in if the left
X ==? !=? X
operand contains an or that is not being compared with a wildcard in the right operand.
x Z
The wildcard equality operator is equivalent to the logical equality operator if its operands are class handles,
interface class handles, chandles or the literal .
null
11.4.7 Logical operators
The operators logical AND ( ), logical OR ( ), logical implication ( ), and logical equivalence ( )
&& || -> <->
are logical connectives. The result of the evaluation of a logical operation shall be 1 (defined as true),
0(defined as false), or, if the result is ambiguous, the unknown value ( ). The precedence of is greater
x &&
than that of , and both are lower than relational and equality operators. The precedence of and is at
|| -> <->
the same level, the binding of operands between the two operations is governed by associativity (right), both
are lower than other logical operators and the conditional operator.
The logical implication is logically equivalent to
expression1 –> expression2
, and the logical equivalence is
(!expression1 || expression2) expression1 <–> expression2
logically equivalent to .
((expression1 –> expression2) && (expression2 –> expression1))
Each of the two operands of the logical equivalence operator shall be evaluated exactly once.
The unary logical negation operator ) converts a nonzero or true operand into 0 and a zero or false
(!
operand into 1. An ambiguous truth value remains as .
x
Example 1: If variable holds the integer value 237 and holds the value zero, then the following
alpha beta
examples perform as described:
regA = alpha && beta; // regA is set to 0
regB = alpha || beta; // regB is set to 1
Example 2: The following expression performs a logical and of three subexpressions without needing any
parentheses:
a < size-1 && b != c && index != lastone
However, it is recommended for readability purposes that parentheses be used to show very clearly the
precedence intended, as in the following rewrite of this example:
(a < size-1) && (b != c) && (index != lastone)
Example 3: A common use of is in constructions like the following:
!
if (!inword)
265
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In some cases, the preceding construct makes more sense to someone reading the code than this equivalent
construct:
if (inword == 0)
The and operators shall use short circuit evaluation as follows:
&& ||
— The first operand expression shall always be evaluated.
— For , if the first operand value is logically false then the second operand shall not be evaluated.
&&
— For , if the first operand value is logically true then the second operand shall not be evaluated.
||
11.4.8 Bitwise operators
The bitwise operators shall perform bitwise manipulations on the operands; that is, the operator shall
combine a bit in one operand with its corresponding bit in the other operand to calculate 1 bit for the result.
Table11-11 through Table11-15 show the results for each possible calculation.
Table11-11—Bitwise binary AND operator
& 0 1 x z
0 0 0 0 0
1 0 1 x x
x 0 x x x
z 0 x x x
Table11-12—Bitwise binary OR operator
| 0 1 x z
0 0 1 x x
1 1 1 1 1
x x 1 x x
z x 1 x x
266
Authorized licensed use limited to: SiCeompyernigsh t A©G 2 0G18B ISE EBE&. ASl l SrigOhLts GreMseSrv.e dD.ownloaded on December 03,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table11-13—Bitwise binary exclusive OR operator
^ 0 1 x z
0 0 1 x x
1 1 0 x x
x x x x x
z x x x x
Table11-14—Bitwise binary exclusive NOR operator
^~
0 1 x z
~^
0 1 0 x x
1 0 1 x x
x x x x x
z x x x x
Table11-15—Bitwise unary negation operator
~
0 1
1 0
x x
z x
11.4.9 Reduction operators
The unary reduction operators shall perform a bitwise operation on a single operand to produce a single-bit
result. For reduction AND, reduction OR, and reduction XOR operators, the first step of the operation shall
apply the operator between the first bit of the operand and the second using Table11-16 through
Table11-18. The second and subsequent steps shall apply the operator between the 1-bit result of the prior
step and the next bit of the operand using the same logic table. For reduction NAND, reduction NOR, and
reduction XNOR operators, the result shall be computed by inverting the result of the reduction AND,
reduction OR, and reduction XOR operation, respectively.
267
A u t h o r i z e d l i c e n s e d u sCeop yrligihtm © i20t1e8 IdEE Et. Aoll: rig hSts ireesemrveed.n s A G G B S B & S S O L G M S . D o w n l o a d e d o n D e c e m b e r 0 3 , 2 0 2 5 a t 0 5 : 4 4 : 4 9 U T C f r o m I E E E X p l o r e . R e s t r i c t i o n s a p p l y .

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table11-16—Reduction unary AND operator
& 0 1 x z
0 0 0 0 0
1 0 1 x x
x 0 x x x
z 0 x x x
Table11-17—Reduction unary OR operator
| 0 1 x z
0 0 1 x x
1 1 1 1 1
x x 1 x x
z x 1 x x
Table11-18—Reduction unary exclusive OR operator
^ 0 1 x z
0 0 1 x x
1 1 0 x x
x x x x x
z x x x x
For example, Table11-19 shows the results of applying reduction operators on different operands.
Table11-19—Results of unary reduction operations
Operand & ~& | ~| ^ ~^ Comments
4'b0000 0 1 0 1 0 1 No bits set
4'b1111 1 0 1 0 0 1 All bits set
4'b0110 0 1 1 0 0 1 Even number of bits set
4'b1000 0 1 1 0 1 0 Odd number of bits set
268
Authorized licensed use limited toC:o pSyriieghmt ©e n20s1 8A IGEE EG. BASll r igBh&tsS re sSeOrveLd .GMS. Downloaded on December 03,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
11.4.10 Shift operators
There are two types of shift operators: the logical shift operators, and , and the arithmetic shift
<< >>
operators, and . The left shift operators, and , shall shift their left operand to the left by the
<<< >>> << <<<
number of bit positions given by the right operand. In both cases, the vacated bit positions shall be filled
with zeros. The right shift operators, and , shall shift their left operand to the right by the number of
>> >>>
bit positions given by the right operand. The logical right shift shall fill the vacated bit positions with zeros.
The arithmetic right shift shall fill the vacated bit positions with zeros if the result type is unsigned. It shall
fill the vacated bit positions with the value of the most significant (i.e., sign) bit of the left operand if the
result type is signed. If the right operand has an or value, then the result shall be unknown. The right
x z
operand is always treated as an unsigned number and has no effect on the signedness of the result. The result
signedness is determined by the left-hand operand and the remainder of the expression, as outlined in 11.8.1.
Example 1: In this example, the variable is assigned the binary value , which is shifted to
result 0100 0001
the left two positions and zero-filled.
module shift;
logic [3:0] start, result;
initial begin
start = 1;
result = (start << 2);
end
endmodule
Example 2: In this example, the variable is assigned the binary value , which is shifted to
result 1110 1000
the right two positions and sign-filled.
module ashift;
logic signed [3:0] start, result;
initial begin
start = 4'b1000;
result = (start >>> 2);
end
endmodule
11.4.11 Conditional operator
The conditional operator shall be right associative and shall be constructed using three operands separated
by two operators in the format given in Syntax11-2.
conditional_expression ::= // from A.8.3
cond_predicate { attribute_instance } expression expression
? :
cond_predicate ::= // from A.6.6
expression_or_cond_pattern { expression_or_cond_pattern }
&&&
expression_or_cond_pattern ::=
expression | cond_pattern
cond_pattern ::= expression pattern
matches
Syntax11-2—Conditional operator syntax (excerpt from AnnexA)
This subclause describes the traditional notation where cond_predicate is just a single expression.
SystemVerilog also allows cond_predicate to perform pattern matching, which is described in 12.6.
269
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If cond_predicate is true, the operator returns the value of the first expression without evaluating the second
expression; if false, it returns the value of the second expression without evaluating the first expression. If
cond_predicate evaluates to an ambiguous value ( or ), then both the first expression and the second
x z
expression shall be evaluated, and compared for logical equivalence as described in 11.4.5. If that
comparison is true (1), the operator shall return either the first or second expression. Otherwise the operator
returns a result based on the data types of the expressions.
When both the first and second expressions are of integral types, if the cond_predicate evaluates to an
ambiguous value and the expressions are not logically equivalent, their results shall be combined bit by bit
using Table11-20 to calculate the final result. The first and second expressions are extended to the same
width, as described in 11.6.1 and 11.8.2.
Table11-20—Ambiguous condition results for conditional operator
?: 0 1 x z
0 0 x x x
1 x 1 x x
x x x x x
z x x x x
The following example of a three-state output bus illustrates a common use of the conditional operator:
wire [15:0] busa = drive_busa ? data : 16'bz;
The bus called is driven onto when is . If is unknown, then an
data busa drive_busa 1 drive_busa
unknown value is driven onto . Otherwise, is not driven.
busa busa
The conditional operator can be used with nonintegral types (see 6.11.1) and aggregate expressions (see
11.2.2) using the following rules:
— If both the first expression and second expression are of integral types, the operation proceeds as
defined.
— If both expressions are , then the resulting type is . If one expression is and the other
real real real
expression is or integral, the other expression is cast to , and the resulting type is
shortreal real
. If one expression is and the other expression is integral, the integral expression is
real shortreal
cast to , and the resulting type is .
shortreal shortreal
— Otherwise, if the first expression or second expression is an integral type and the opposing
expression can be implicitly cast to an integral type, the cast is made and proceeds as defined.
— If the first expression or second expression is a class or interface class data type, the condition
expression is legal in the following cases:
a) If both first expression and second expression are the literal value , the result of the entire
null
conditional expression is as if the expression were the literal .
null
b) Else, if either first expression or second expression is the literal , the resulting type is the
null
type of the non-null expression.
c) Else, if the first expression is assignment compatible with the second expression, the resulting
type is the type of the second expression,
d) Else, if the second expression is assignment compatible with the first expression, the resulting
type is the type of the first expression,
270
Authorized licensed use limited to: SCieompyeringsht A© G20 G18B ISEE BE.& ASll rSigOhtLs rGesMerSve. dD. ownloaded on December 03,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
e) Else, if the first expression and second expression are of a class type deriving from a common
base class type, the resulting type is the closest common inherited class type.
In the preceding cases, the resulting value is the value of the first expression if the condition
evaluates to true or the value of the second expression if the condition evaluates to false.
— For all other cases, the type of the first expression and second expression shall be equivalent (see
6.22.2).
For nonintegral and aggregate expressions, if cond_predicate evaluates to an ambiguous value and the
expressions are not logically equivalent, then:
— For aggregate array data types, except associative arrays, where both expressions contain the same
number of elements their results shall be combined element by element. If the elements match, the
element shall be returned. If they do not match, then the value specified in Table7-1 for that
element’s type shall be returned.
— For all other data types, the value specified in Table7-1 for the resulting type as defined previously
shall be returned.
11.4.12 Concatenation operators
A concatenation is the result of the joining together of bits resulting from one or more expressions. The
concatenation shall be expressed using the brace characters and , with commas separating the expressions
{ }
within.
Unsized constant numbers shall not be allowed in concatenations. This is because the size of each operand in
the concatenation is needed to calculate the complete size of the concatenation.
The following example concatenates four expressions:
{a, b[3:0], w, 3'b101}
The preceding example is equivalent to the following example:
{a, b[3], b[2], b[1], b[0], w, 1'b1, 1'b0, 1'b1}
The concatenation is treated as a packed vector of bits. It can be used on the left-hand side of an assignment
or in an expression.
logic log1, log2, log3;
{log1, log2, log3} = 3'b111;
{log1, log2, log3} = {1'b1, 1'b1, 1'b1}; // same effect as 3'b111
One or more bits of a concatenation can be selected as if the concatenation were a packed array with the
range . Such a select shall not be legal as a net_lvalue, variable_lvalue, or in any equivalent use,
[n-1:0]
such as on the left-hand side of an assignment. For example:
byte a, b ;
bit [1:0] c ;
c = {a + b}[1:0]; // 2 lsb's of sum of a and b
A concatenation is not the same as a structure literal (see 5.10) or an array literal (see 5.11). Concatenations
are enclosed in just braces ( ), whereas structure and array literals are enclosed in braces that begin with
{ }
an apostrophe ( ).
'{ }
271
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
11.4.12.1 Replication operator
A replication operator (also called a multiple concatenation) is expressed by a concatenation preceded by a
non-negative, non- , and non- constant expression, called a replication constant, enclosed together within
x z
brace characters. A replication indicates a joining together of that many copies of the concatenation. Unlike
regular concatenations, expressions containing replications shall not appear on the left-hand side of an
assignment and shall not be connected to or ports.
output inout
This example replicates four times.
w
{4{w}} // yields the same value as {w, w, w, w}
The following examples show illegal replications:
{1'bz{1'b0}} // illegal
{1'bx{1'b0}} // illegal
The next example illustrates a replication nested within a concatenation:
{b, {3{a, b}}} // yields the same value as {b, a, b, a, b, a, b}
A replication operation may have a replication constant with a value of zero. This is useful in parameterized
code. A replication with a zero replication constant is considered to have a size of zero and is ignored. Such
a replication shall appear only within a concatenation in which at least one of the operands of the
concatenation has a positive size.
For example:
parameter P = 32;
// The following is legal for all P from 1 to 32
assign b[31:0] = { {32-P{1'b1}}, a[P-1:0] } ;
// The following is illegal for P=32 because the zero
// replication appears alone within a concatenation
assign c[31:0] = { {{32-P{1'b1}}}, a[P-1:0] }
// The following is illegal for P=32
initial
$displayb({32-P{1'b1}}, a[P-1:0]);
When a replication expression is evaluated, the operands shall be evaluated exactly once, even if the
replication constant is zero. For example:
result = {4{func(w)}} ;
would be computed as
y = func(w) ;
result = {y, y, y, y} ;
272
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
11.4.12.2 String concatenation
A concatenation of data objects of type is allowed. In general, if any of the operands is of the data
string
type , the concatenation is treated as a string, and all other arguments are implicitly converted to the
string
data type (as described in 6.16). String concatenation is not allowed on the left-hand side of an
string
assignment, only as an expression.
string hello = "hello";
string s;
s = { hello, " ", "world" };
$display( "%s\n", s ); // displays 'hello world'
s = { s, " and goodbye" };
$display( "%s\n", s ); // displays 'hello world and goodbye'
The replication operator form of braces can also be used with data objects of type . In the case of
string
string replication, a non-constant multiplier is allowed.
int n = 3;
string s = {n { "boo " }};
$display( "%s\n", s ); // displays 'boo boo boo '
Unlike bit concatenation, the result of a string concatenation or replication is not truncated. Instead, the
destination variable (of type ) is resized to accommodate the resulting string.
string
11.4.13 Set membership operator
SystemVerilog supports singular value sets and set membership operators.
The syntax for the set membership operator is as follows:
inside_expression ::= expression open_range_list // from A.8.3
inside{ }
Syntax11-3—Inside expression syntax (excerpt from AnnexA)
The expression on the left-hand side of the operator is any singular expression.
inside
The set-membership open_range_list on the right-hand side of the inside operator is a comma-separated list
of expressions or ranges. If an expression in the list is an unpacked array, its elements are traversed by
descending into the array until reaching a singular value. The members of the set are scanned until a match is
found and the operation returns . Values can be repeated; therefore, values and value ranges can
1'b1
overlap. The order of evaluation of the expressions and ranges is nondeterministic.
int a, b, c;
if ( a inside {b, c} ) ...
int array [$] = '{3,4,5};
if ( ex inside {1, 2, array} ) ... // same as { 1, 2, 3, 4, 5}
The operator uses the equality ( ) operator on nonintegral expressions to perform the
inside ==
comparison. If no match is found, the operator returns . Integral expressions use the wildcard
inside 1'b0
equality ( ) operator so that an or bit in a value in the set is treated as a do-not-care in that bit position
==? x z
(see 11.4.6). As with wildcard equality, an or in the expression on the left-hand side of the inside
x z
operator is not treated as a do-not-care.
logic [2:0] val;
273
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
while ( val inside {3'b1?1} ) ... // matches 3'b101, 3'b111, 3'b1x1, 3'b1z1
If no match is found, but some of the comparisons result in x, the inside operator shall return . The
1'bx
return value is effectively the or reduction of all the comparisons in the set with the expression on the
left-hand side.
wire r;
assign r=3'bz11 inside {3'b1?1, 3'b011}; // r = 1'bx
A range can be specified with a low and high bound enclosed by square braces and separated by a colon
[ ]
( ), as in . A bound specified by shall represent the lowest or highest value
: [low_bound:high_bound] $
for the type of the expression on the left-hand side. A match is found if the expression on the left-hand side
is inclusively within the range. When specifying a range, the expressions shall be of a singular type for
which the relation operators ( , ) are defined. If the bound to the left of the colon is greater than the
<= >=
bound to the right, the range is empty and contains no values.
For example:
bit ba = a inside { [16:23], [32:47] };
string I;
if (I inside {["a rock":"hard place"]}) ...
// I between "a rock" and a "hard place"
11.4.14 Streaming operators (pack/unpack)
The bit-stream casting described in 6.24.3 is most useful when the conversion operation can be easily
expressed using only a type cast and the specific ordering of the bit stream is not important. Sometimes,
however, a stream that matches a particular machine organization is required. The streaming operators
perform packing of bit-stream types (see 6.24.3) into a sequence of bits in a user-specified order. When used
in the left-hand side, the streaming operators perform the reverse operation, i.e., unpack a stream of bits into
one or more variables.
If the data being packed contains any 4-state types, the result of a pack operation is a 4-state stream;
otherwise, the result of a pack is a 2-state stream. In the remainder of this subclause, the word bit, without
other qualification, denotes either a 2-state or a 4-state bit as required by this paragraph.
The syntax of the bit-stream concatenation is as follows:
streaming_concatenation ::= stream_operator [ slice_size ] stream_concatenation // from A.8.1
{ }
stream_operator ::= |
>> <<
slice_size ::= simple_type | constant_expression
stream_concatenation ::= stream_expression { stream_expression }
{ , }
stream_expression ::= expression [ array_range_expression ]
with[ ]
array_range_expression ::=
expression
| expression expression
:
| expression expression
+:
| expression expression
-:
primary ::= // from A.8.4
...
| streaming_concatenation
Syntax11-4—Streaming concatenation syntax (excerpt from AnnexA)
274
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A streaming_concatenation (as specified in Syntax11-4) shall be used either as the target of an assignment,
or as the source of an assignment, or as the operand of a bit-stream cast, or as a stream_expression in another
streaming_concatenation. Use of streaming_concatenation as the target of an assignment, and the
associated unpack operation, is described in 11.4.14.3.
It shall be an error to use a streaming_concatenation as an operand in an expression without first casting it to
a bit-stream type. When a streaming_concatenation is used as the source of an assignment, the target of that
assignment shall be either a data object of bit-stream type or a streaming_concatenation.
If the target is a data object of bit-stream type, the stream created by the source streaming_concatenation
shall first be widened if necessary to left-align it in the target, as follows:
— If the target represents a fixed-size variable that is narrower (has fewer bits) than the stream, an error
shall be generated.
— If the target represents a fixed-size variable that is wider than the stream, the stream shall be
widened to match it by filling with zero bits on the right.
— If the target represents a dynamically sized variable, such as a queue or dynamic array, the variable
shall first be resized so that it has the smallest number of elements that make it as wide as or wider
than the stream. If the resized variable is wider than the stream, the stream shall then be widened to
match it by filling with zero bits on the right.
The stream, widened if necessary as described previously, shall then be implicitly cast to the type of the
target.
The pack operation performed by a streaming_concatenation is described in two steps for convenience, but
the intermediate result between the two steps is never visible and therefore tools are free to implement it in
any way that yields the same overall result. First, all integral data in the stream_expressions are
concatenated into a single stream of bits, similarly to bit-stream casting (as described in 6.24.3) but with
fewer restrictions. Second, the resulting stream may be re-ordered in a manner specified by the
stream_operator and slice_size. These two steps are described in more detail in 11.4.14.1 and 11.4.14.2.
11.4.14.1 Concatenation of stream_expressions
Each stream_expression within the stream_concatenation, starting with the leftmost and proceeding from
left to right through the comma-separated list of stream_expressions, is converted to a bit-stream and
appended to a packed array (stream) of bits, the generic stream, by recursively applying the following
procedure:
if the expression is a streaming_concatenation or it is of any bit-stream type,
it shall be cast to a packed array of bit using a bit-stream cast, including casting 2-state to
4-state if necessary, and that packed array shall then be appended to the right-hand end of the
generic stream;
elseif the expression is an unpacked array (i.e., a queue, dynamic array, associative array, or fixed-size
unpacked array)
this procedure shall be applied in turn to each element of the array. An associative array is
processed in index-sorted order. Other unpacked arrays are processed in the order in which
they would be traversed by a loop (see 12.7.3) having exactly one index variable;
foreach
elseif the expression is of a struct type
this procedure shall be applied in turn to each element of the struct, in declaration order;
elseif the expression is of an untagged union type
this procedure shall be applied to the first-declared member of the union;
275
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.