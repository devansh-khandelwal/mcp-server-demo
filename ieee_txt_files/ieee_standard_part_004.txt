IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
elseif the expression is a null class handle
the expression shall be skipped (not streamed), and a warning may be issued;
elseif the expression is a non-null class handle
this procedure shall be applied in turn to each data member of the referenced object, and not
the handle itself. Class members shall be streamed in declaration order. Extended class
members shall be streamed after members of their base class. The result of streaming an
object hierarchy that contains cycles shall be undefined, and an error may be issued. It shall
be illegal to stream a class handle with local or protected members if those members would
not be accessible at the point of the streaming operator;
else
the expression shall be skipped (not streamed), and an error shall be issued.
In the preceding description, the phrase skipped (not streamed) means that the expression in question is not
appended to the stream, and operation of the procedure then proceeds with the next item in turn.
Implementations are not required to continue the procedure after issuing an error.
11.4.14.2 Re-ordering of the generic stream
The stream resulting from the operation described in 11.4.14.1 is then re-ordered by slicing it into blocks
and then re-ordering those blocks.
The slice_size determines the size of each block, measured in bits. If a slice_size is not specified, the default
is 1. If specified, it may be a constant integral expression or a simple type. If a type is used, the block size
shall be the number of bits in that type. If a constant integral expression is used, it shall be an error for the
value of the expression to be zero or negative.
The stream_operator or determines the order in which blocks of data are streamed: causes blocks
<< >> >>
of data to be streamed in left-to-right order, while causes blocks of data to be streamed in right-to-left
<<
order. Left-to-right streaming using shall cause the slice_size to be ignored and no re-ordering performed.
>>
Right-to-left streaming using shall reverse the order of blocks in the stream, preserving the order of bits
<<
within each block. For right-to-left streaming using , the stream is sliced into blocks with the specified
<<
number of bits, starting with the right-most bit. If as a result of slicing the last (left-most) block has fewer
bits than the block size, the last block has the size of the remaining bits; there is no padding or truncation.
For example:
int j = { "A", "B", "C", "D" };
{ >> {j}} // generates stream "A" "B" "C" "D"
{ << byte {j}} // generates stream "D" "C" "B" "A" (little endian)
{ << 16 {j}} // generates stream "C" "D" "A" "B"
{ << { 8'b0011_0101 }} // generates stream 'b1010_1100 (bit reverse)
{ << 4 { 6'b11_0101 }} // generates stream 'b0101_11
{ >> 4 { 6'b11_0101 }} // generates stream 'b1101_01 (same)
{ << 2 { { << { 4'b1101 }} }} // generates stream 'b1110
11.4.14.3 Streaming concatenation as an assignment target (unpack)
When a streaming_concatenation appears as the target of an assignment, the streaming operators perform
the reverse operation; i.e., to unpack a stream of bits into one or more variables. The source expression shall
be of bit-stream type, or the result of another streaming_concatenation. If the source expression contains
more bits than are needed, the appropriate number of bits shall be consumed from its left (most significant)
end. However, if more bits are needed than are provided by the source expression, an error shall be
generated.
Unpacking a 4-state stream into a 2-state target is done by casting to a 2-state type, and vice versa. Null
handles are skipped by both the pack and unpack operations; therefore, the unpack operation shall not create
276
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
class objects. If a particular object hierarchy is to be reconstructed from a stream, the object hierarchy into
which the stream is to be unpacked must be created before the streaming operator is applied. The unpack
operation shall only modify explicitly declared properties; it will not modify implicitly declared properties
such as random modes (see Clause18).
For example:
int a, b, c;
logic [10:0] up [3:0];
logic [11:1] p1, p2, p3, p4;
bit [96:1] y = {>>{ a, b, c }}; // OK: pack a, b, c
int j = {>>{ a, b, c }}; // error: j is 32 bits < 96 bits
bit [99:0] d = {>>{ a, b, c }}; // OK: d is padded with 4 bits
{>>{ a, b, c }} = 23'b1; // error: too few bits in stream
{>>{ a, b, c }} = 96'b1; // OK: unpack a = 0, b = 0, c = 1
{>>{ a, b, c }} = 100'b11111; // OK: unpack a = 0, b = 0, c = 1
// 96 MSBs unpacked, 4 LSBs truncated
{ >> {p1, p2, p3, p4}} = up; // OK: unpack p1 = up[3], p2 = up[2],
// p3 = up[1], p4 = up[0]
11.4.14.4 Streaming dynamically sized data
If the unpack operation includes unbounded dynamically sized types, the process is greedy (as in a cast): the
first dynamically sized item is resized to accept all the available data (excluding subsequent fixed-size
items) in the stream; any remaining dynamically sized items are left empty. This mechanism is sufficient to
unpack a packet-sized stream that contains only one dynamically sized data item. However, when the stream
contains multiple variable-size data packets, or each data packet contains more than one variable-size data
item, or the size of the data to be unpacked is stored in the middle of the stream, this mechanism can become
cumbersome and error-prone. To overcome these problems, the unpack operation allows a expression
with
to explicitly specify the extent of a variable-size field within the unpack operation.
The syntax of the expression is as follows:
with
stream_expression ::= expression [ array_range_expression ] // from A.8.1
with[ ]
array_range_expression ::=
expression
| expression expression
:
| expression expression
+:
| expression expression
-:
Syntax11-5—With expression syntax (excerpt from AnnexA)
The array range expression within the construct shall be of integral type and evaluate to values that lie
with
within the bounds of a fixed-size array or to positive values for dynamic arrays or queues. The expression
before the can be any one-dimensional unpacked array (including a queue). The expression within the
with
is evaluated immediately before its corresponding array is streamed (i.e., packed or unpacked). Thus,
with
the expression can refer to data that are unpacked by the same operator but before the array. If the expression
refers to variables that are unpacked after the corresponding array (to the right of the array), then the
expression is evaluated using the previous values of the variables.
When used within the context of an unpack operation and the array is a variable-size array, it shall be resized
to accommodate the range expression. If the array is a fixed-size array and the range expression evaluates to
a range outside the extent of the array, only the range that lies within the array is unpacked and an error is
generated. If the range expression evaluates to a range smaller than the extent of the array (fixed or variable
277
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
size), only the specified items are unpacked into the designated array locations; the remainder of the array is
unmodified.
When used within the context of a pack (on the right-hand side), it behaves the same as an array slice. The
specified number of array items are packed into the stream. If the range expression evaluates to a range
smaller than the extent of the array, only the specified array items are streamed. If the range expression
evaluates to a range greater than the extent of the array size, the entire array is streamed, and the remaining
items are generated using the nonexistent array entry value (as described in Table7-1 in 7.4.6) for the given
array.
For example, the following code uses streaming operators to model a packet transfer over a byte stream that
uses little-endian encoding:
byte stream[$]; // byte stream
class Packet;
rand int header;
rand int len;
rand byte payload[];
int crc;
constraint G { len > 1; payload.size == len ; }
function void post_randomize; crc = payload.sum; endfunction
endclass
...
send: begin // Create random packet and transmit
byte q[$];
Packet p = new;
void'(p.randomize());
q = {<< byte{p.header, p.len, p.payload, p.crc}}; // pack
stream = {stream, q}; // append to stream
end
...
receive: begin // Receive packet, unpack, and remove
byte q[$];
Packet p = new;
{<< byte{ p.header, p.len, p.payload with [0 +: p.len], p.crc }} = stream;
stream = stream[ $bits(p) / 8 : $ ]; // remove packet
end
In the preceding example, the pack operation could have been written as either:
q = {<<byte{p.header, p.len, p.payload with [0 +: p.len], p.crc}};
or
q = {<<byte{p.header, p.len, p.payload with [0 : p.len-1], p.crc}};
or
q = {<<byte{p}};
The result in this case would be the same because is the size of as specified by the
p.len p.payload
constraint.
278
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
11.5 Operands
There are several types of operands that can be specified in expressions. The simplest type is a reference to a
net, variable, or parameter in its complete form; that is, just the name of the net, variable, or parameter is
given. In this case, all of the bits making up the net, variable, or parameter value shall be used as the
operand.
If a single bit of a vector net, vector variable, packed array, packed structure or parameter is required, then a
bit-select operand shall be used. A part-select operand shall be used to reference a group of adjacent bits in a
vector net, vector variable, packed array, packed structure, or parameter.
An unpacked array element can be referenced as an operand.
A concatenation of other operands (including nested concatenations) can be specified as an operand.
A function call is an operand.
Each of the types of operands mentioned previously is an example of a simple operand. An operand is
simple if it is not parenthesized and is a primary as defined in A.8.4. In the following example, the
expressions and are operands, but are not simple operands.
1'b1 - 2'b00 (1'b1 + 1'b1)
1'b1 - 2'b00 + (1'b1 + 1'b1)
11.5.1 Vector bit-select and part-select addressing
Bit-selects extract a particular bit from a vector, packed array, packed structure, parameter, or concatenation.
The bit can be addressed using an expression that shall be evaluated in a self-determined context. If the bit-
select address is invalid (it is out of bounds or has one or more or bits), then the value returned by the
x z
reference shall be for 4-state and 0 for 2-state values. A bit-select or part-select of a scalar, or of a real
x
variable or real parameter, shall be illegal.
Several contiguous bits can be addressed and are known as part-selects. There are two types of part-selects:
a non-indexed part-select and an indexed part-select. A non-indexed part-select is given with the following
syntax:
vect[msb_expr:lsb_expr]
Both msb_expr and lsb_expr shall be constant integer expressions. Each of these expressions shall be
evaluated in a self-determined context. The first expression shall address a more significant bit than the
second expression.
An indexed part-select is given with the following syntax:
logic [15:0] down_vect;
logic [0:15] up_vect;
down_vect[lsb_base_expr +: width_expr]
up_vect[msb_base_expr +: width_expr]
down_vect[msb_base_expr -: width_expr]
up_vect[lsb_base_expr -: width_expr]
The msb_base_expr and lsb_base_expr shall be integer expressions, and the width_expr shall be a positive
constant integer expression. Each of these expressions shall be evaluated in a self-determined context. The
lsb_base_expr and msb_base_expr can vary at run time. The first two examples select bits starting at the
279
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
base and ascending the bit range. The number of bits selected is equal to the width expression. The second
two examples select bits starting at the base and descending the bit range.
A constant bit-select is a bit-select whose position is constant. A constant part-select is a part-select whose
position and width are both constant. The width of a part-select is always constant. Thus, a non-indexed
part-select is always a constant part-select, and an indexed part-select is a constant part-select if its base is a
constant value as well as its width.
A part-select that addresses a range of bits that are completely out of the address bounds of the vector,
packed array, packed structure, parameter or concatenation, or a part-select that is or shall yield the value
x z
when read and shall have no effect on the data stored when written. Part-selects that are partially out of
x
range shall, when read, return for the bits that are out of range and shall, when written, only affect the bits
x
that are in range.
For example:
logic [31: 0] a_vect;
logic [0 :31] b_vect;
logic [63: 0] dword;
integer sel;
a_vect[ 0 +: 8] // == a_vect[ 7 : 0]
a_vect[15 -: 8] // == a_vect[15 : 8]
b_vect[ 0 +: 8] // == b_vect[0 : 7]
b_vect[15 -: 8] // == b_vect[8 :15]
dword[8*sel +: 8] // variable part-select with fixed width
The following example specifies the single bit of vector that is addressed by the operand :
acc index
acc[index]
The actual bit that is accessed by an address is, in part, determined by the declaration of . For instance,
acc
each of the declarations of shown in the next example causes a particular value of to access a
acc index
different bit:
logic [15:0] acc;
logic [2:17] acc;
The next example and the bullet items that follow it illustrate the principles of bit addressing. The code
declares an 8-bit variable called and initializes it to a value of 4. The list describes how the separate
vect
bits of that vector can be addressed.
logic [7:0] vect;
vect = 4; // fills vect with the pattern 00000100
// msb is bit 7, lsb is bit 0
— If the value of is 2, then returns
addr vect[addr] 1.
— If the value of is out of bounds, then returns
addr vect[addr] x.
— If is 0, 1, or 3 through 7, returns
addr vect[addr] 0.
— returns the bits
vect[3:0] 0100.
— returns the bits
vect[5:1] 00010.
— expression that returns x returns
vect[ ] x.
280
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— expression that returns z returns
vect[ ] x.
— If any bit of is or , then the value of is
addr x z addr x.
NOTE 1—Part-select indices that evaluate to or may be flagged as a compile time error.
x z
NOTE 2—Bit-select or part-select indices that are outside the declared range may be flagged as a compile time error.
11.5.2 Array and memory addressing
Declaration of arrays and memories (one-dimensional arrays of , , or ) are discussed in 7.4.
reg logic bit
This subclause discusses array addressing.
The following example declares a memory of 1024 8-bit words:
logic [7:0] mem_name[0:1023];
The syntax for a memory address shall consist of the name of the memory and an expression for the address,
specified with the following format:
mem_name[addr_expr]
The addr_expr can be any integer expression; therefore, memory indirections can be specified in a single
expression. The next example illustrates memory indirection:
mem_name[mem_name[3]]
In this example, addresses word three of the memory called . The value at word
mem_name[3] mem_name
three is the index into that is used by the memory address . As with
mem_name mem_name[mem_name[3]]
bit-selects, the address bounds given in the declaration of the memory determine the effect of the address
expression. If the address is invalid (it is out of bounds or has one or more or bits), then the value of the
x z
reference shall be as described in 7.4.6.
The next example declares an array of 256-by-256 8-bit elements and an array 256-by-256-by-8 1-bit
elements:
logic [7:0] twod_array[0:255][0:255];
wire threed_array[0:255][0:255][0:7];
The syntax for access to the array shall consist of the name of the memory or array and an integer expression
for each addressed dimension:
twod_array[addr_expr][addr_expr]
threed_array[addr_expr][addr_expr][addr_expr]
As before, the can be any integer expression. The array accesses a whole 8-bit
addr_expr twod_array
vector, while the array accesses a single bit of the three-dimensional array.
threed_array
To express bit-selects or part-selects of array elements, the desired word shall first be selected by supplying
an address for each dimension. Once selected, bit-selects and part-selects shall be addressed in the same
manner as net and variable bit-selects and part-selects (see 11.5.1).
For example:
twod_array[14][1][3:0] // access lower 4 bits of word
twod_array[1][3][6] // access bit 6 of word
twod_array[1][3][sel] // use variable bit-select
threed_array[14][1][3:0] // Illegal
281
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
11.5.3 Longest static prefix
Informally, the longest static prefix of a select is the longest part of the select for which an analysis tool has
known values following elaboration. This concept is used when describing implicit sensitivity lists (see
9.2.2.2) and when describing error conditions for drivers of logic ports (see 6.5). The remainder of this
subclause defines what constitutes the “longest static prefix” of a select.
A field select is defined as a hierarchical name where the right-hand side of the last “.” hierarchy separator
identifies a field of a variable whose type is a or declaration. The field select prefix is
struct union
defined to be the left-hand side of the final “.” hierarchy separator in a field select.
An indexing select is a single indexing operation. The indexing select prefix is either an identifier or, in the
case of a multidimensional select, another indexing select. Array selects, bit-selects, part-selects, and
indexed part-selects are examples of indexing selects.
The definition of a static prefix is recursive and is defined as follows:
— An identifier is a static prefix.
— A hierarchical reference to an object is a static prefix.
— A package reference to net or variable is a static prefix.
— A field select is a static prefix if the field select prefix is a static prefix.
— An indexing select is a static prefix if the indexing select prefix is a static prefix and the select
expression is a constant expression.
The definition of the longest static prefix is defined as follows:
— An identifier that is not the field select prefix or indexing select prefix of an expression that is a
static prefix.
— A field select that is not the field select prefix or indexing select prefix of an expression that is a
static prefix.
— An indexing select that is not the field select prefix or indexing select prefix of an expression that is
a static prefix.
Examples:
localparam p = 7;
reg [7:0] m [5:1][5:1];
integer i;
m[1][i] // longest static prefix is m[1]
m[p][1] // longest static prefix is m[p][1]
m[i][1] // longest static prefix is m
11.6 Expression bit lengths
The number of bits of an expression is determined by the operands and the context. Casting can be used to
set the size context of an intermediate value (see 6.24).
Controlling the number of bits that are used in expression evaluations is important if consistent results are to
be achieved. Some situations have a simple solution; for example, if a bitwise AND operation is specified on
two 16-bit variables, then the result is a 16-bit value. However, in some situations, it is not obvious how
many bits are used to evaluate an expression or what size the result should be.
282
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For example, should an arithmetic add of two 16-bit values perform the evaluation using 16 bits, or should
the evaluation use 17 bits in order to allow for a possible carry overflow? The answer depends on the type of
device being modeled and whether that device handles carry overflow.
SystemVerilog uses the bit length of the operands to determine how many bits to use while evaluating an
expression. The bit length rules are given in 11.6.1. In the case of the addition operator, the bit length of the
largest operand, including the left-hand side of an assignment, shall be used.
For example:
logic [15:0] a, b; // 16-bit variables
logic [15:0] sumA; // 16-bit variable
logic [16:0] sumB; // 17-bit variable
sumA = a + b; // expression evaluates using 16 bits
sumB = a + b; // expression evaluates using 17 bits
11.6.1 Rules for expression bit lengths
The rules governing the expression bit lengths have been formulated so that most practical situations have a
natural solution.
The number of bits of an expression (known as the size of the expression) shall be determined by the
operands involved in the expression and the context in which the expression is given.
A self-determined expression is one where the bit length of the expression is solely determined by the
expression itself—for example, an expression representing a delay value.
A context-determined expression is one where the bit length of the expression is determined by the bit length
of the expression and by the fact that it is part of another expression. For example, the bit size of the
right-hand expression of an assignment depends on itself and the size of the left-hand side.
Table11-21 shows how the form of an expression shall determine the bit lengths of the results of the
expression. In Table11-21, , , and represent expressions of an operand, and represents the bit
i j k L(i)
length of the operand represented by .
i
Table11-21—Bit lengths resulting from self-determined expressions
Expression Bitlength Comments
Unsized constant number Same as integer
Sized constant number As given
i op j, where op is: max(L(i),L(j))
+ - * / % & | ^ ^~ ~^
op i, where op is: L(i)
+ - ~
i op j, where op is: 1 bit Operands are sized to max(L(i),L(j))
=== !== == != > >= < <=
i op j, where op is: 1 bit All operands are self-determined
&& || –> <->
op i, where op is: 1 bit All operands are self-determined
& ~& | ~| ^ ~^ ^~ !
283
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table11-21—Bit lengths resulting from self-determined expressions (continued)
Expression Bitlength Comments
i op j, where op is: L(i) j is self-determined
>> << ** >>> <<<
i j k max(L(j),L(k)) i is self-determined
? :
i j L(i)+..+L(j) All operands are self-determined
{,...,}
i j k i  (L(j)+..+L(k)) All operands are self-determined
{{,.., }}
Multiplication may be performed without losing any overflow bits by assigning the result to something wide
enough to hold it.
11.6.2 Example of expression bit-length problem
During the evaluation of an expression, interim results shall take the size of the largest operand (in case of an
assignment, this also includes the left-hand side). Care has to be taken to prevent loss of a significant bit
during expression evaluation. The following example describes how the bit lengths of the operands could
result in the loss of a significant bit.
Given the following declarations:
logic [15:0] a, b, answer; // 16-bit variables
the intent is to evaluate the expression
answer = (a + b) >> 1; // will not work properly
where and are to be added, which can result in an overflow, and then shifted right by 1 bit to preserve
a b
the carry bit in the 16-bit answer.
A problem arises, however, because all operands in the expression are of a 16-bit width. Therefore, the
expression produces an interim result that is only 16 bits wide, thus losing the carry bit before the
(a + b)
evaluation performs the 1-bit right shift operation.
The solution is to force the expression to evaluate using at least 17 bits. For example, adding an
(a + b)
integer value of to the expression will cause the evaluation to be performed using the bit size of integers.
0
The following example will produce the intended result:
answer = (a + b + 0) >> 1; // will work correctly
In the following example:
module bitlength();
logic [3:0] a, b, c;
logic [4:0] d;
initial begin
a = 9;
b = 8;
c = 1;
$display("answer = %b", c ? (a&b) : d);
end
endmodule
284
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
the statement will display
$display
answer = 01000
By itself, the expression would have the bit length 4, but because it is in the context of the conditional
a&b
expression, which uses the maximum bit length, the expression actually has length 5, the length of .
a&b d
11.6.3 Example of self-determined expressions
logic [3:0] a;
logic [5:0] b;
logic [15:0] c;
initial begin
a = 4'hF;
b = 6'hA;
$display("a*b=%h", a*b); // expression size is self-determined
c = {a**b}; // expression a**b is self-determined
// due to concatenation operator {}
$display("a**b=%h", c);
c = a**b; // expression size is determined by c
$display("c=%h", c);
end
Simulator output for this example:
a*b=16 // 'h96 was truncated to 'h16 since expression size is 6
a**b=1 // expression size is 4 bits (size of a)
c=ac61 // expression size is 16 bits (size of c)
11.7 Signed expressions
Controlling the sign of an expression is important if consistent results are to be achieved. 11.8.1 outlines the
rules that determine if an expression is signed or unsigned.
The cast operator can be used to change either the signedness or type of an expression (see 6.24.1). In
addition to the cast operator, the and system functions are available for casting the
$signed $unsigned
signedness of expressions. These functions shall evaluate the input expression and return a one-dimensional
packed array with the same number of bits and value of the input expression and the signedness defined by
the function.
—returned value is signed
$signed
—returned value is unsigned
$unsigned
For example:
logic [7:0] regA, regB;
logic signed [7:0] regS;
regA = $unsigned(-4); // regA = 8'b11111100
regB = $unsigned(-4'sd4); // regB = 8'b00001100
regS = $signed (4'b1100); // regS = -4
regA = unsigned'(-4); // regA = 8'b11111100
regS = signed'(4'b1100); // regS = -4
285
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
regS = regA + regB; // will do unsigned addition
regS = byte'(regA) + byte'(regB); // will do signed addition
regS = signed'(regA) + signed'(regB); // will do signed addition
regS = $signed(regA) + $signed(regB); // will do signed addition
11.8 Expression evaluation rules
11.8.1 Rules for expression types
The following are the rules for determining the resulting type of an expression:
— Expression type depends only on the operands. It does not depend on the left-hand side (if any).
— Decimal numbers are signed.
— Based numbers are unsigned, except where the notation is used in the base specifier (as in
s
).
4'sd12
— Bit-select results are unsigned, regardless of the operands.
— Part-select results are unsigned, regardless of the operands even if the part-select specifies the entire
vector.
logic [15:0] a;
logic signed [7:0] b;
initial
a = b[7:0]; // b[7:0] is unsigned and therefore zero-extended
— Concatenate results are unsigned, regardless of the operands.
— Comparison and reduction operator results are unsigned, regardless of the operands.
— Reals converted to integers by type coercion are signed
— The sign and size of any self-determined operand are determined by the operand itself and
independent of the remainder of the expression.
— For non-self-determined operands, the following rules apply:
• If any operand is real, the result is real.
• If any operand is unsigned, the result is unsigned, regardless of the operator.
• If all operands are signed, the result will be signed, regardless of operator, except when specified
otherwise.
11.8.2 Steps for evaluating an expression
The following are the steps for evaluating an expression:
— Determine the expression size based upon the standard rules of expression size determination.
— Determine the sign of the expression using the rules outlined in 11.8.1.
— Propagate the type and size of the expression (or self-determined subexpression) back down to the
context-determined operands of the expression. In general, any context-determined operand of an
operator shall be the same type and size as the result of the operator. However, there are two
exceptions:
• If the result type of the operator is real and if it has a context-determined operand that is not real,
that operand shall be treated as if it were self-determined and then converted to real just before
the operator is applied.
• The relational and equality operators have operands that are neither fully self-determined nor
fully context-determined. The operands shall affect each other as if they were context-determined
286
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
operands with a result type and size (maximum of the two operand sizes) determined from them.
However, the actual result type shall always be 1 bit unsigned. The type and size of the operand
shall be independent of the rest of the expression and vice versa.
— When propagation reaches a simple operand as defined in 11.5, then that operand shall be converted
to the propagated type and size. If the operand shall be extended, then it shall be sign-extended only
if the propagated type is signed.
11.8.3 Steps for evaluating an assignment
The following are the steps for evaluating an assignment:
— Determine the size of the right-hand side by the standard assignment size determination rules (see
11.6).
— If needed, extend the size of the right-hand side, performing sign extension if, and only if, the type
of the right-hand side is signed.
11.8.4 Handling X and Z in signed expressions
If a signed operand is to be resized to a larger signed width and the value of the sign bit is , the resulting
x
value shall be bit-filled with . If the sign bit of the value is , then the resulting value shall be bit-filled
x z
with . If any bit of a signed value is or , then any nonlogical operation involving the value shall result
z x z
in the entire resultant value being an and the type consistent with the expression’s type.
x
11.9 Tagged union expressions and member access
expression ::= // from A.8.3
...
| tagged_union_expression
tagged_union_expression ::=
member_identifier [ expression ]
tagged
Syntax11-6—Tagged union syntax (excerpt from AnnexA)
A tagged union expression (packed or unpacked) is expressed using the keyword followed by a
tagged
tagged union member identifier, followed by an expression representing the corresponding member value.
For members the member value expression is omitted.
void
Example:
typedef union tagged {
void Invalid;
int Valid;
} VInt;
VInt vi1, vi2;
vi1 = tagged Valid (23+34); // Create Valid int
vi2 = tagged Invalid; // Create an Invalid value
In the following tagged union expressions, the expressions in braces are structure assignment patterns (see
10.9.2).
287
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
typedef union tagged {
struct {
bit [4:0] reg1, reg2, regd;
} Add;
union tagged {
bit [9:0] JmpU;
struct {
bit [1:0] cc;
bit [9:0] addr;
} JmpC;
} Jmp;
} Instr;
Instr i1, i2;
// Create an Add instruction with its 3 register fields
i1 = ( e
? tagged Add '{ e1, 4, ed }; // struct members by position
: tagged Add '{ reg2:e2, regd:3, reg1:19 });// by name (order irrelevant)
// Create a Jump instruction, with "unconditional" sub-opcode
i1 = tagged Jmp (tagged JmpU 239);
// Create a Jump instruction, with "conditional" sub-opcode
i2 = tagged Jmp (tagged JmpC '{ 2, 83 }); // inner struct by position
i2 = tagged Jmp (tagged JmpC '{ cc:2, addr:83 }); // by name
The type of a tagged union expression shall be known from its context (e.g., it is used in the right-hand side
of an assignment to a variable whose type is known, or it has a cast, or it is used inside another expression
from which its type is known). The expression evaluates to a tagged union value of that type. The tagged
union expression can be completely type-checked statically; the only member names allowed after the
keyword are the member names for the expression type, and the member expression shall have the
tagged
corresponding member type.
An uninitialized variable of tagged union type shall be undefined. This includes the tag bits. A variable of
tagged union type can be initialized with a tagged union expression provided the member value expression is
a legal initializer for the member type.
Members of tagged unions can be read or assigned using the usual dot notation. Such accesses are
completely type-checked, i.e., the value read or assigned shall be consistent with the current tag. In general,
this can require a run-time check. An attempt to read or assign a value whose type is inconsistent with the
tag results in a run-time error.
All of the following examples are legal only if the instruction variable currently has tag :
i1 Add
x = i1.Add.reg1;
i1.Add = '{19, 4, 3};
i1.Add.reg2 = 4;
11.10 String literal expressions
This subclause discusses operations on string literals (see 5.9) and string literals stored in bit vectors and
other packed types. SystemVerilog also has string variables, which store strings differently than vectors. The
data type has several special built-in methods for manipulating strings. See 6.16 for a discussion of
string
the data type and associated methods.
string
288
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
String literal operands shall be treated as constant numbers consisting of a sequence of 8-bit ASCII codes,
one per character. Any SystemVerilog operator can manipulate string literal operands. The operator shall
behave as though the entire string were a single numeric value.
When a vector is larger than required to hold the string literal value being assigned, the contents after the
assignment shall be padded on the left with zeros. This is consistent with the padding that occurs during
assignment of nonstring unsigned values.
The following example declares a vector variable large enough to hold 14 characters and assigns a value to
it. The example then manipulates the stored value using the concatenation operator.
module string_test;
bit [8*14:1] stringvar;
initial begin
stringvar = "Hello world";
$display("%s is stored as %h", stringvar, stringvar);
stringvar = {stringvar,"!!!"};
$display("%s is stored as %h", stringvar, stringvar);
end
endmodule
The result of simulating the preceding description is as follows:
Hello world is stored as 00000048656c6c6f20776f726c64
Hello world!!! is stored as 48656c6c6f20776f726c64212121
11.10.1 String literal operations
SystemVerilog operators support the common string operations copy, concatenate, and compare for string
literals and string literals stored in vectors. Copy is provided by simple assignment. Concatenation is
provided by the concatenation operator. Comparison is provided by the equality operators.
When manipulating string literal values in vectors, the vectors should be at least bits (where is the
8*n n
number of ASCII characters) in order to preserve the 8-bit ASCII code.
11.10.2 String literal value padding and potential problems
When string literals are assigned to vectors, the values stored shall be padded on the left with zeros. Padding
can affect the results of comparison and concatenation operations. The comparison and concatenation
operators shall not distinguish between zeros resulting from padding and the original string characters (
\0,
ASCII ).
NUL
The following example illustrates the potential problem:
bit [8*10:1] s1, s2;
initial begin
s1 = "Hello";
s2 = " world!";
if ({s1,s2} == "Hello world!")
$display("strings are equal");
end
The comparison in this example fails because during the assignment the variables and are padded as
s1 s2
illustrated in the next example:
289
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
s1 = 000000000048656c6c6f
s2 = 00000020776f726c6421
The concatenation of and includes the zero padding, resulting in the following value:
s1 s2
000000000048656c6c6f00000020776f726c6421
Because the string literal contains no zero padding, the comparison fails, as shown in the
“Hello world!”
following example:
s1 s2
000000000048656c6c6f00000020776f726c6421
48656c6c6f20776f726c6421
"Hello" " world!"
This comparison yields a result of zero, which represents false.
11.10.3 Empty string literal handling
The empty string literal ( ) shall be considered equivalent to the ASCII NUL ( ), which has a value
"" "\0"
zero ( ), which is different from a string .
0 "0"
11.11 Minimum, typical, and maximum delay expressions
SystemVerilog delay expressions can be specified as three expressions separated by colons and enclosed by
parentheses. This is intended to represent minimum, typical, and maximum values—in that order. The
syntax is given in Syntax11-7.
mintypmax_expression ::= // from A.8.3
expression
| expression expression expression
: :
constant_mintypmax_expression ::=
constant_expression
| constant_expression constant_expression constant_expression
: :
expression ::=
primary
| unary_operator { attribute_instance } primary
| inc_or_dec_expression
| operator_assignment
( )
| expression binary_operator { attribute_instance } expression
| conditional_expression
| inside_expression
| tagged_union_expression
constant_expression ::=
constant_primary
| unary_operator { attribute_instance } constant_primary
290
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| constant_expression binary_operator { attribute_instance } constant_expression
| constant_expression { attribute_instance } constant_expression constant_expression
? :
constant_primary ::= // from A.8.4
primary_literal
| ps_parameter_identifier constant_select
| specparam_identifier [ constant_range_expression ]
[ ]
| genvar_identifier39
| formal_port_identifier constant_select
| [ package_scope | class_scope ] enum_identifier
| constant_concatenation [ constant_range_expression ]
[ ]
| constant_multiple_concatenation [ constant_range_expression ]
[ ]
| constant_function_call
| constant_let_expression
| constant_mintypmax_expression
( )
| constant_cast
| constant_assignment_pattern_expression
| type_reference40
|
null
primary_literal ::= number | time_literal | unbased_unsized_literal | string_literal
39) A genvar_identifier shall be legal in a constant_primary only within a genvar_expression.
40) It shall be legal to use a type_reference constant_primary as the casting_type in a static cast. It shall be illegal for a
type_reference constant_primary to be used with any operators except the equality/inequality and case equality/
inequality operators.
Syntax11-7—Syntax for min:typ:max expression (excerpt from AnnexA)
SystemVerilog models typically specify three values for delay expressions. The three values allow a design
to be tested with minimum, typical, or maximum delay values, known as a min:typ:max expression.
Values expressed in min:typ:max format can be used in expressions. The min:typ:max format can be used
wherever expressions can appear.
Example 1: This example shows an expression that defines a single triplet of delay values. The minimum
value is the sum of ; the typical value is ; the maximum value is , as follows:
a+d b+e c+f
(a:b:c) + (d:e:f)
Example 2: The next example shows a typical expression that is used to specify min:typ:max format values:
val - (32'd 50: 32'd 75: 32'd 100)
11.12 Let construct
let_declaration ::= // from A.2.12
let_identifier [ [ let_port_list ] ] expression
let ( ) = ;
let_identifier ::=
identifier
let_port_list ::=
let_port_item { let_port_item}
,
291
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
let_port_item ::=
{ attribute_instance } let_formal_type formal_port_identifier { variable_dimension } [ expression ]
=
let_formal_type ::=
data_type_or_implicit
|
untyped
let_expression ::=
[ package_scope ] let_identifier [ [ let_list_of_arguments ] ]
( )
let_list_of_arguments ::=
[ let_actual_arg ] { [ let_actual_arg ] } { identifier [ let_actual_arg ] }
, ,. ( )
| identifier [ let_actual_arg ] { identifier [ let_actual_arg ] }
. ( ) ,. ( )
let_actual_arg ::=
expression
Syntax11-8—Let syntax (excerpt from AnnexA)
A declaration defines a template expression (a body), customized by its ports. A construct may
let let let
be instantiated in other expressions.
declarations can be used for customization and can replace the text macros in many cases. The
let let
construct is safer because it has a local scope, while the scope of compiler directives is global within the
compilation unit. Including declarations in packages (see Clause26) is a natural way to implement a
let
well-structured customization for the design code.
Example 1:
package pex_gen9_common_expressions;
let valid_arb(request, valid, override) = |(request & valid) || override;
...
endpackage
module my_checker;
import pex_gen9_common_expressions::*;
logic a, b;
wire [1:0] req;
wire [1:0] vld;
logic ovr;
...
if (valid_arb(.request(req), .valid(vld), .override(ovr))) begin
...
end
...
endmodule
Example 2:
let mult(x, y) = ($bits(x) + $bits(y))'(x * y);
Just as properties and sequences serve as templates for concurrent assertions (see 16.5), the construct
let
can serve this purpose for immediate assertions. For example:
let at_least_two(sig, rst = 1'b0) = rst || ($countones(sig) >= 2);
logic [15:0] sig1;
logic [3:0] sig2;
292
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
always_comb begin
q1: assert (at_least_two(sig1));
q2: assert (at_least_two(~sig2));
end
Another intended use of is to provide shortcuts for identifiers or subexpressions. For example:
let
task write_value;
input logic [31:0] addr;
input logic [31:0] value;
...
endtask
...
let addr = top.block1.unit1.base + top.block1.unit2.displ;
...
write_value(addr, 0);
The formal arguments may optionally be typed and also may have optional default values. If a formal
argument of a is typed, then the type shall be or one of the types allowed in 16.6. The following
let event
rules apply to typed formal arguments and their corresponding actual arguments, including default actual
arguments declared in a :
let
1) If the formal argument is of type , then the actual argument shall be an event_expression and
event
each reference to the formal argument shall be in a place where an event_expression may be written.
2) Otherwise, the self-determined result type of the actual argument shall be cast compatible (see
6.22.4) with the type of the formal argument. The actual argument shall be cast to the type of the
formal argument before being substituted for a reference to the formal argument in the rewriting
algorithm (see F.4).
Variables used in a that are not formal arguments to the are resolved according to the scoping rules
let let
from the scope in which the is declared. In the scope of declaration, a body shall be defined before
let let
it is used. No hierarchical references to declarations are allowed.
let
The body gets expanded with the actual arguments by replacing the formal arguments with the actual
let
arguments. Semantic checks are performed to verify that the expanded body with the actual arguments
let
is legal. The result of the substitution is enclosed in parentheses (...) so as to preserve the priority of
evaluation of the body. Recursive instantiations are not permitted.
let let
A body may contain sampled value function calls (see 16.9.3 and 16.9.4). Their clock, if not explicitly
let
specified, is inferred in the instantiation context in the same way as if the functions were used directly in the
instantiation context. It shall be an error if the clock is required, but cannot be inferred in the instantiation
context.
A may be declared in any of the following:
let
— A module
— An interface
— A program
— A checker
— A clocking block
— A package
— A compilation-unit scope
— A generate block
293
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— A sequential or parallel block
— A subroutine
Examples:
a) with arguments and without arguments
let
module m;
logic clk, a, b;
logic p, q, r;
// let with formal arguments and default value on y
let eq(x, y = b) = x == y;
// without parameters, binds to a, b above
let tmp = a && b;
...
a1: assert property (@(posedge clk) eq(p,q));
always_comb begin
a2: assert (eq(r)); // use default for y
a3: assert (tmp);
end
endmodule : m
The effective code after expanding expressions:
let
module m;
bit clk, a, b;
logic p, q, r;
// let eq(x, y = b) = x == y;
// let tmp = a && b;
...
a1: assert property (@(posedge clk) (m.p == m.q));
always_comb begin
a2: assert ((m.r == m.b)); // use default for y
a3: assert ((m.a && m.b));
end
endmodule : m
b) Declarative context binding of arguments
let
module top;
logic x = 1'b1;
logic a, b;
let y = x;
...
always_comb begin
// y binds to preceding definition of x
// in the declarative context of let
bit x = 1'b0;
b = a | y;
end
endmodule : top
The effective code after expanding expressions:
let
module top;
bit x = 1'b1;
bit a;
// let y = x;
294
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
...
always_comb begin
// y binds to preceding definition of x
// in the declarative context of let
bit x = 1'b0;
b = a | (top.x);
end
endmodule : top
c) Sequences (and properties) with in structural context (see 16.8)
let
module top;
logic a, b;
let x = a || b;
sequence s;
x ##1 b;
endsequence : s
...
endmodule : top
The effective code after expanding expressions:
let
module top;
logic a, b;
// let x = a || b;
sequence s;
(top.a || top.b) ##1 b;
endsequence : s
...
endmodule : top
d) declared in a block
let generate
module m(...);
wire a, b;
wire [2:0] c;
wire [2:0] d;
wire e;
...
for (genvar i = 0; i < 3; i++) begin : L0
if (i !=1) begin : L1
let my_let(x) = !x || b && c[i];
s1: assign d[2 – i] = my_let(a)); // OK
end : L1
end : L0
s2: assign e = L0[0].L1.my_let(a)); // Illegal
endmodule : m
Statement becomes two statements and , the first of them being
s1 L0[0].L1.s1 L0[2].L1.s1
assign d[2] = (!m.a || m.b && m.c[0]);
and the second one being
assign d[0] = (!m.a || m.b && m.c[2]);
Statement is illegal since it references the expression hierarchically, while hierarchical
s2 let
references to expressions are not allowed.
let
e) with typed arguments
let
module m(input clock);
295
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
logic [15:0] a, b;
logic c, d;
typedef bit [15:0] bits;
...
let ones_match(bits x, y) = x == y;
let same(logic x, y) = x === y;
always_comb
a1: assert(ones_match(a, b));
property toggles(bit x, y);
same(x, y) |=> !same(x, y);
endproperty
a2: assert property (@(posedge clock) toggles(c, d));
endmodule : m
In this example the expression checks that both arguments have bits set to 1 at the
let ones_match
same position. Because of the explicit specification of the formal arguments to be of the 2-state type
bit
in the declaration, all argument bits having unknown logic value or a high-impedance value become
let
0, and therefore the comparison captures the match of the bits set to 1. The expression same tests for
let
the case equality (see 11.4.6) of its operands. When instantiated in the property its actual
toggles
arguments will be of type . The effective code after expanding expressions:
bit let
module m(input clock);
logic [15:0] a, b;
logic c, d;
typedef bit [15:0] bits;
...
// let ones_match(bits x, y) = x == y;
// let same(logic x, y) = x === y;
always_comb
a1:assert((bits'(a) == bits'(b)));
property toggles(bit x, y);
(logic'(x) === logic'(y)) |=> ! (logic'(x) === logic'(y));
endproperty
a2: assert property (@(posedge clock) toggles(c, d));
endmodule : m
f) Sampled value functions in
let
module m(input clock);
logic a;
let p1(x) = $past(x);
let p2(x) = $past(x,,,@(posedge clock));
let s(x) = $sampled(x);
always_comb begin
a1: assert(p1(a));
a2: assert(p2(a));
a3: assert(s(a));
end
a4: assert property(@(posedge clock) p1(a));
...
endmodule : m
296
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The effective code after expanding expressions:
let
module m(input clock);
logic a;
// let p1(x) = $past(x);
// let p2(x) = $past(x,,,@(posedge clock));
// let s(x) = $sampled(x);
always_comb begin
a1: assert(($past(a))); // Illegal: no clock can be inferred
a2: assert(($past(a,,,@(posedge clock))));
a3: assert(($sampled (a)));
end
a4: assert property(@(posedge clock)($past(a))); // @(posedge clock)
// is inferred
...
endmodule : m
297
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
12. Procedural programming statements
12.1 General
This clause describes the following:
— Selection statements (if–else, case, casez, casex, unique, unique0, priority)
— Loop statements (for, repeat, foreach, while, do...while, forever)
— Jump statements (break, continue, return)
12.2 Overview
Procedural programming statements shall be contained within any of the following constructs:
— Procedural blocks that automatically activate, introduced with one of the keywords:
•
initial
• always
•
always_comb
• always_latch
•
always_ff
•
final
See Clause9 for a description of each type of procedural block.
— Procedural blocks that activate when called, introduced with one of the keywords:
•
task
•
function
See Clause13 for a description of tasks and functions.
Procedural programming statements include the following:
— Selection statements (see 12.4 and 12.5)
— Loop statements (see 12.7)
— Jump statements (see 12.8)
— Sequential and parallel blocks (see 9.3)
— Timing controls (see 9.4)
— Process control (see 9.5 through 9.7)
— Procedural assignments (see 10.4 through 10.9)
— Subroutine calls (see Clause13)
12.3 Syntax
The syntax for procedural statements is as follows in Syntax12-1:
statement_or_null ::= // from A.6.4
statement
| { attribute_instance }
;
statement ::= [ block_identifier ] { attribute_instance } statement_item
:
statement_item ::=
blocking_assignment
;
298
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| nonblocking_assignment
;
| procedural_continuous_assignment
;
| case_statement
| conditional_statement
| inc_or_dec_expression
;
| subroutine_call_statement
| disable_statement
| event_trigger
| loop_statement
| jump_statement
| par_block
| procedural_timing_control_statement
| seq_block
| wait_statement
| procedural_assertion_statement
| clocking_drive
;
| randsequence_statement
| randcase_statement
| expect_property_statement
Syntax12-1—Procedural statement syntax (excerpt from AnnexA)
12.4 Conditional if–else statement
The conditional statement (or if–else statement) is used to make a decision about whether a statement is
executed. Formally, the syntax is given in Syntax12-2.
conditional_statement ::= // from A.6.6
[ unique_priority ] cond_predicate statement_or_null
if( )
{ cond_predicate statement_or_null }
elseif( )
[ statement_or_null ]
else
unique_priority ::= | |
unique unique0 priority
cond_predicate ::=
expression_or_cond_pattern { expression_or_cond_pattern }
&&&
expression_or_cond_pattern ::=
expression | cond_pattern
cond_pattern ::= expression pattern
matches
Syntax12-2—Syntax for if–else statement (excerpt from AnnexA)
If the cond_predicate expression evaluates to true (that is, has a nonzero known value), the first statement
shall be executed. If it evaluates to false (that is, has a zero value or the value is or ), the first
x z
statementshall not execute. If there is an else statement and the cond_predicate expression is false, the else
statement shall be executed.
Because the numeric value of the expression is tested for being zero, certain shortcuts are possible. For
if
example, the following two statements express the same logic:
if (expression)
if (expression != 0)
299
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Because the part of an if–else is optional, there can be confusion when an is omitted from a
else else
nested sequence. This is resolved by always associating the else with the closest previous if that lacks an
if
else. In the following example, the else goes with the inner , as shown by indentation.
if
if (index > 0)
if (rega > regb)
result = rega;
else // else applies to preceding if
result = regb;
If that association is not desired, a begin-end block statement shall be used to force the proper association, as
in the following example:
if (index > 0)
begin
if (rega > regb)
result = rega;
end
else result = regb;
12.4.1 if–else–if construct
The if–else construct can be chained.
if (expression) statement;
else if (expression) statement;
else if (expression) statement;
else statement;
This sequence of if–else statements (known as an if–else–if construct) is the most general way of writing a
multiway decision. The expressions shall be evaluated in order. If any expression is true, the statement
associated with it shall be executed, and this shall terminate the whole chain. Each statement is either a
single statement or a block of statements.
The last else of the if–else–if construct handles the none-of-the-above or default case where none of the
other conditions were satisfied. Sometimes there is no explicit action for the default. In that case, the trailing
else statement can be omitted, or it can be used for error checking to catch an unexpected condition.
The following module fragment uses the if–else statement to test the variable to decide whether one
index
of three variables has to be added to the memory address and which increment is to be added
modify_segn
to the variable.
index
// declare variables and parameters
logic [31:0] instruction,
segment_area[255:0];
logic [7:0] index;
logic [5:0] modify_seg1,
modify_seg2,
modify_seg3;
parameter
segment1 = 0, inc_seg1 = 1,
segment2 = 20, inc_seg2 = 2,
segment3 = 64, inc_seg3 = 4,
data = 128;
// test the index variable
if (index < segment2) begin
300
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
instruction = segment_area [index + modify_seg1];
index = index + inc_seg1;
end
else if (index < segment3) begin
instruction = segment_area [index + modify_seg2];
index = index + inc_seg2;
end
else if (index < data) begin
instruction = segment_area [index + modify_seg3];
index = index + inc_seg3;
end
else
instruction = segment_area [index];
12.4.2 unique-if, unique0-if, and priority-if
The keywords , , and can be used before an to perform certain violation
unique unique0 priority if
checks.
If the keywords or are used, a violation report shall be issued if no condition matches
unique priority
unless there is an explicit . For example:
else
unique if ((a==0) || (a==1)) $display("0 or 1");
else if (a == 2) $display("2");
else if (a == 4) $display("4"); // values 3,5,6,7 cause a violation report
priority if (a[2:1]==0) $display("0 or 1");
else if (a[2] == 0) $display("2 or 3");
else $display("4 to 7"); // covers all other possible values,
// so no violation report
If the keyword is used, there shall be no violation if no condition is matched. For example:
unique0
unique0 if ((a==0) || (a==1)) $display("0 or 1");
else if (a == 2) $display("2");
else if (a == 4) $display("4"); // values 3,5,6,7
// cause no violation report
Unique-if and unique0-if assert that there is no overlap in a series of if–else–if conditions, i.e., they are
mutually exclusive and hence it is safe for the conditions to be evaluated in parallel.
In unique-if and unique0-if, the conditions may be evaluated and compared in any order. The
implementation shall continue the evaluations and comparisons after finding a true condition. A unique-if or
unique0-if is violated if more than one condition is found true. The implementation shall issue a violation
report and execute the statement associated with the true condition that appears first in the statement, but
if
not the statements associated with other true conditions.
After finding a uniqueness violation, the implementation is not required to continue evaluating and
comparing additional conditions. The implementation is not required to try more than one order of
evaluations and comparisons of conditions. The presence of side effects in conditions may cause
nondeterministic results.
A priority-if indicates that a series of if–else–if conditions shall be evaluated in the order listed. In the
preceding example, if the variable had a value of 0, it would satisfy both the first and second conditions,
a
requiring priority logic.
301
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The , , and keywords apply to the entire series of if–else–if conditions. In the
unique unique0 priority
preceding examples, it would have been illegal to insert any of these keywords after any of the occurrences
of . To nest another statement within such a series of conditions, a begin-end block should be used.
else if
12.4.2.1 Violation reports generated by unique-if, unique0-if, and priority-if constructs
The descriptions in 12.4.2 mention several cases in which a violation report shall be generated by unique-if,
unique0-if, or priority-if statements. These violation checks shall be immune to false violation reports due to
zero-delay glitches in the active region set (see 3.4.1).
A unique, unique0, or priority violation check is evaluated at the time the statement is executed, but
violation reporting is deferred until the Observed region of the current time step (see 4.4). The violation
reporting can be controlled by using assertion control system tasks (see 20.12).
Once a violation is detected, a pending violation report is scheduled in the Observed region of the current
time step. It is scheduled on a violation report queue associated with the currently executing process. A
violation report flush point is said to be reached if any of the following conditions are met:
— The procedure, having been suspended earlier due to reaching an event control or wait statement,
resumes execution.
— The procedure was declared by an or statement, and its execution is
always_comb always_latch
resumed due to a transition on one of its dependent signals.
If a violation report flush point is reached in a process, its violation report queue is cleared. Any pending
violation reports are discarded.
In the Observed region of each simulation time step, each pending violation report shall mature or be
confirmed for reporting. Once a report matures, it shall no longer be flushed. A tool-specific violation report
mechanism is then used to report each violation, and the pending violation report is cleared from the
appropriate process violation report queue.
The following is an example of a unique-if that is immune to zero-delay glitches in the active region set:
always_comb begin
not_a = !a;
end
always_comb begin : a1
u1: unique if (a)
z = a | b;
else if (not_a)
z = a | c;
end
In this example, is checking for overlap in the two conditional expressions. When and
uniqueif u1 a
are in a state of 0 and 1, respectively, and transitions to 1, this could be executed while
not_a a uniqueif
and are both true, so the violation check for uniqueness will fail. Since this check is in the active
a not_a
region set, the failure is not immediately reported. After the update to , process will be
not_a a1
rescheduled, which results in a flush of the original violation report. The violation check will now pass, and
no violation will be reported.
Another example shows how looping constructs are likewise immune to zero-delay glitches in the active
region set:
always_comb begin
for (int j = 0; j < 3; j++)
302
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
not_a[j] = !a[j];
end
always_comb begin : a1
for (int j = 0; j < 3; j++)
unique if (a[j])
z[j] = a[j] | b[j];
else if (not_a[j])
z[j] = a[j] | c[j];
end
This example is identical to the previous example but adds loop statements. Each loop iteration
independently checks for a uniqueness violation in the exact same manner as the previous example. Any
iteration in the loop can report a uniqueness violation. If the process is rescheduled, all violations in the
a1
loop are flushed and the entire loop is reevaluated.
12.4.2.2 If statement violation reports and multiple processes
As described in the previous subclauses (see 12.4.2 and 12.4.2.1), violation reports are inherently associated
with the process in which they are executed. This means that a violation check within a task or function may
be executed several times due to the task or function being called by several different processes, and each of
these different process executions is independent. The following example illustrates this situation:
module fsm(...);
function bit f1(bit a, bit not_a, ...)
...
a1: unique if (a)
...
else if (not_a)
...
endfunction
...
always_comb begin : b1
some_stuff = f1(c, d, ...);
...
end
always_comb begin : b2
other_stuff = f1(e, f, ...);
...
end
endmodule
In this case, there are two different processes that may call process : and . Suppose simulation
a1 b1 b2
executes the following scenario in the first passage through the Active region of each time step. Note that
this example refers to three distinct points in simulation time and how glitch resolution is handled for each
specific time step:
a) In time step 1, executes with and , and executes with and .
b1 c=1 d=1 b2 e=1 f=1
In this first time step, since fails independently for processes and , its failure is reported
a1 b1 b2
twice.
b) In time step 2, executes with and , then again with and .
b1 c=1 d=1 c=1 d=0
In this second time step, the failure of in process is flushed when the process is re-triggered,
a1 b1
and since the final execution passes, no failure is reported.
303
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
c) In time step 3, executes with and , then executes with and .
b1 c=1 d=1 b2 e=1 f=0
In this third time step, the failure in process does not see a flush point, so that failure is reported.
b1
In process , the violation check passes, so no failure is reported from that process.
b2
12.5 Case statement
The case statement is a multiway decision statement that tests whether an expression matches one of a
number of other expressions and branches accordingly. The case statement has the syntax shown in
Syntax12-3.
case_statement ::= // from A.6.7
[ unique_priority ] case_keyword case_expression
( )
case_item { case_item }
endcase
| [ unique_priority ] case_keyword case_expression
( )matches
case_pattern_item { case_pattern_item }
endcase
| [ unique_priority ] case_expression
case( )inside
case_inside_item { case_inside_item }
endcase
case_keyword ::= | |
case casez casex
case_expression ::= expression
case_item ::=
case_item_expression { case_item_expression } statement_or_null
, :
| [ ] statement_or_null
default :
case_pattern_item ::=
pattern [ expression ] statement_or_null
&&& :
| [ ] statement_or_null
default :
case_inside_item ::=
open_range_list statement_or_null
:
| [ ] statement_or_null
default :
case_item_expression ::= expression
Syntax12-3—Syntax for case statements (excerpt from AnnexA)
The default statement shall be optional. Use of multiple default statements in one case statement shall be
illegal.
The case_expression and case_item_expressions are not required to be constant expressions.
A simple example of the use of the case statement is the decoding of variable to produce a value for
data
as follows:
result
logic [15:0] data;
logic [9:0] result;
case (data)
16'd0: result = 10'b0111111111;
16'd1: result = 10'b1011111111;
16'd2: result = 10'b1101111111;
16'd3: result = 10'b1110111111;
16'd4: result = 10'b1111011111;
16'd5: result = 10'b1111101111;
304
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
16'd6: result = 10'b1111110111;
16'd7: result = 10'b1111111011;
16'd8: result = 10'b1111111101;
16'd9: result = 10'b1111111110;
default result = 'x;
endcase
The case_expression shall be evaluated exactly once and before any of the case_item_expressions. The
case_item_expressions shall be evaluated and then compared in the exact order in which they appear. If
there is a default case_item, it is ignored during this linear search. During the linear search, if one of the
case_item_expressions matches the case_expression, then the statement associated with that case_item shall
be executed, and the linear search shall terminate. If all comparisons fail and the default item is given, then
the default item statement shall be executed. If the default statement is not given and all of the comparisons
fail, then none of the case_item statements shall be executed.
Apart from syntax, the case statement differs from the multiway if–else–if construct in two important ways:
a) The conditional expressions in the if–else–if construct are more general than comparing one
expression with several others, as in the case statement.
b) The case statement provides a definitive result when there are and values in an expression.
x z
In a case_expression comparison, the comparison only succeeds when each bit matches exactly with respect
to the values , , , and . As a consequence, care is needed in specifying the expressions in the case
0 1 x z
statement. The bit length of all the expressions needs to be equal, so that exact bitwise matching can be
performed. Therefore, the length of all the case_item_expressions, as well as the case_expression, shall be
made equal to the length of the longest case_expression and case_item_expressions. If any of these
expressions is unsigned, then all of them shall be treated as unsigned. If all of these expressions are signed,
then they shall be treated as signed.
The reason for providing a case_expression comparison that handles the and values is that it provides
x z
a mechanism for detecting such values and reducing the pessimism that can be generated by their presence.
Example 1: The following example illustrates the use of a case statement to handle and values
x z
properly:
case (select[1:2])
2'b00: result = 0;
2'b01: result = flaga;
2'b0x,
2'b0z: result = flaga ? 'x : 0;
2'b10: result = flagb;
2'bx0,
2'bz0: result = flagb ? 'x : 0;
default result = 'x;
endcase
In this example, if is 0 and is 0, then even if the value of is or ,
select[1] flaga select[2] x z result
should be 0—which is resolved by the third case_item.
Example 2: The following example shows another way to use a case statement to detect and values:
x z
case (sig)
1'bz: $display("signal is floating");
1'bx: $display("signal is unknown");
default: $display("signal is %b", sig);
endcase
305
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
12.5.1 Case statement with do-not-cares
Two other types of case statements are provided to allow handling of do-not-care conditions in the case
comparisons. One of these treats high-impedance values ( ) as do-not-cares, and the other treats both
z
high-impedance and unknown ( ) values as do-not-cares. These case statements can be used in the same
x
way as the traditional case statement, but they begin with keywords and , respectively.
casez casex
Do-not-care values ( values for , and values for ) in any bit of either the
z casez z x casex
case_expression or the case_items shall be treated as do-not-care conditions during the comparison, and that
bit position shall not be considered.
The syntax of literal numbers allows the use of the question mark in place of in these case
(?) z
statements. This provides a convenient format for specification of do-not-care bits in case statements.
Example 1: The following is an example of the casez statement. It demonstrates an instruction decode,
where values of the MSBs select which task should be called. If the MSB of is a 1, then the task
ir
instruction1 is called, regardless of the values of the other bits of .
ir
logic [7:0] ir;
casez (ir)
8'b1???????: instruction1(ir);
8'b01??????: instruction2(ir);
8'b00010???: instruction3(ir);
8'b000001??: instruction4(ir);
endcase
Example 2: The following is an example of the casex statement. It demonstrates an extreme case of how do-
not-care conditions can be dynamically controlled during simulation. In this example, if
, then the task is called.
r = 8'b01100110 stat2
logic [7:0] r, mask;
mask = 8'bx0x0x0x0;
casex (r ^ mask)
8'b001100xx: stat1;
8'b1100xx00: stat2;
8'b00xx0011: stat3;
8'bxx010100: stat4;
endcase
12.5.2 Constant expression in case statement
A constant expression can be used for the case_expression. The value of the constant expression shall be
compared against the case_item_expressions.
The following example demonstrates the usage by modeling a 3-bit priority encoder:
logic [2:0] encode ;
case (1)
encode[2] : $display("Select Line 2") ;
encode[1] : $display("Select Line 1") ;
encode[0] : $display("Select Line 0") ;
default $display("Error: One of the bits expected ON");
endcase
306
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In this example, the case_expression is a constant expression ( ). The case_items are expressions (bit-
1
selects) and are compared against the constant expression for a match.
12.5.3 unique-case, unique0-case, and priority-case
The , , and keywords can be qualified by , , or keywords to
case casez casex priority unique unique0
perform certain violation checks. These are collectively referred to as a priority-case, unique-case, or
unique0-case. A priority-case shall act on the first match only. Unique-case and unique0-case assert that
there are no overlapping case_items and hence that it is safe for the case_items to be evaluated in parallel.
In unique-case and unique0-case, the case_expression shall be evaluated exactly once and before any of the
case_item_expressions. The case_item_expressions may be evaluated in any order and compared in any
order. The implementation shall continue the evaluations and comparisons after finding a matching
case_item. Unique-case and unique0-case are violated if more than one case_item is found to match the
case_expression. The implementation shall issue a violation report and execute the statement associated
with the matching case_item that appears first in the case statement, but not the statements associated with
other matching case_items.
After finding a uniqueness violation, the implementation is not required to continue evaluating and
comparing additional case_items. It is not a violation of uniqueness for a single case_item to contain more
than one case_item_expression that matches the case_expression. If a case_item_expression matches the
case_expression, the implementation is not required to evaluate additional case_item_expressions in the
same case_item. The implementation is not required to try more than one order of evaluations and
comparisons of case_item_expressions. The presence of side-effects in case_item_expressions may cause
nondeterministic results.
If the case is qualified as priority or unique, the simulator shall issue a violation report if no case_item
matches. A violation report may be issued at compile time if it is possible then to determine the violation. If
it is not possible to determine the violation at compile time, a violation report shall be issued during run
time. If the case is qualified as , the implementation shall not issue a violation report if no
unique0
case_item matches.
NOTE—By specifying or , it is not necessary to code a case to trap unexpected case
unique priority default
values.
Consider the following example:
bit [2:0] a;
unique case(a) // values 3,5,6,7 cause a violation report
0,1: $display("0 or 1");
2: $display("2");
4: $display("4");
endcase
priority casez(a) // values 4,5,6,7 cause a violation report
3'b00?: $display("0 or 1");
3'b0??: $display("2 or 3");
endcase
unique0 case(a) // values 3,5,6,7 do not cause a violation report
0,1: $display("0 or 1");
2: $display("2");
4: $display("4");
endcase
307
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
12.5.3.1 Violation reports generated by unique-case, unique0-case, and priority-case
constructs
The descriptions in 12.5.3 mention several cases in which a violation report shall be generated by unique-
case, unique0-case, or priority-case statements. These violation checks shall be immune to false violation
reports due to zero-delay glitches in the active region set (see 3.4.1). The violation reporting can be
controlled by using assertion control system tasks (see 20.12).
The mechanics of handling zero-delay glitches shall be identical to those used when processing zero-delay
glitches for unique-if, unique0-if, and priority-if constructs (see 12.4.2.1).
The following is an example of a unique-case that is immune to zero-delay glitches in the active region set:
always_comb begin
not_a = !a;
end
always_comb begin : a1
unique case (1'b1)
a : z = b;
not_a : z = c;
endcase
end
In this example the is checking for overlap in the two case_item selects. When and
uniquecase a not_a
are in state 0 and 1, respectively, and transitions to 1, this could be executed while and
a uniquecase a
are both true, so the violation check for uniqueness will fail. But since this violation check is in the
not_a
active region set, the failure is not reported immediately. After the update to , process will be
not_a a1
rescheduled, which results in a flush of the original violation report. The violation check will now pass, and
no violation will be reported.
12.5.3.2 Case statement violation reports and multiple processes
Case violation reports shall behave in the same manner as if violation reports when dealing with multiple
processes (see 12.4.2.2).
12.5.4 Set membership case statement
The keyword can be used after the parenthesized expression to indicate a set membership (see
inside
11.4.13). In a case-inside statement, the case_expression shall be compared with each case_item_expression
(open_range_list) using the set membership inside operator. The operator uses asymmetric
inside
wildcard matching (see 11.4.6). Accordingly, the case_expression shall be the left operand, and each
case_item_expression shall be the right operand. The case_expression and each case_item_expression in
braces shall be evaluated in the order specified by a normal case, unique-case, or priority-case statement. A
case_item shall be matched when the inside operation compares the case_expression to the
case_item_expressions and returns and no match when the operation returns or . If all
1'b1 1'b0 1'bx
comparisons do not match and the default item is given, the default item statement shall be executed.
For example:
logic [2:0] status;
always @(posedge clock)
priority case (status) inside
1, 3 : task1; // matches 'b001 and 'b011
3'b0?0, [4:7]: task2; // matches 'b000 'b010 'b0x0 'b0z0
308
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
// 'b100 'b101 'b110 'b111
endcase // priority case fails all other values including
// 'b00x 'b01x 'bxxx
12.6 Pattern matching conditional statements
Pattern matching provides a visual and succinct notation to compare a value against structures, tagged
unions, and constants and to access their members. Pattern matching can be used with case and if–else
statements and with conditional expressions. Before describing pattern matching in those contexts, the
general concepts are described first.
A pattern is a nesting of tagged union and structure expressions with identifiers, constant expressions (see
11.2.1), and the wildcard pattern “.*” at the leaves. For tagged union patterns, the identifier following the
keyword is a union member name. For members, the nested member pattern is omitted.
tagged void
pattern ::= // from A.6.7.1
variable_identifier
.
|
.*
| constant_expression
| member_identifier [ pattern ]
tagged
| pattern { pattern }
'{ , }
| member_identifier pattern { member_identifier pattern }
'{ : , : }
Syntax12-4—Pattern syntax (excerpt from AnnexA)
A pattern always occurs in a context of known type because it is matched against an expression of known
type. Recursively, its nested patterns also have known type. A constant expression pattern shall be of
integral type. Thus a pattern can always be statically type-checked.
Each pattern introduces a new scope; the extent of this scope is described separately below for case
statements, if–else statements, and conditional expressions. Each pattern identifier is implicitly declared as a
new variable within the pattern’s scope, with the unique type that it shall have based on its position in the
pattern. Pattern identifiers shall be unique in the pattern, i.e., the same identifier cannot be used in more than
one position in a single pattern.
In pattern-matching, the value V of an expression is always matched against a pattern, and static type
checking verifies that V and the pattern have the same type. The result of a pattern match is as follows:
— A 1-bit determined value: 0 (false, or fail) or 1 (true, or succeed). The result cannot be x or z even if
the value and pattern contain such bits.
— If the match succeeds, the pattern identifiers are bound to the corresponding members from V, using
ordinary procedural assignment.
— Each pattern is matched using the following simple recursive rule:
• An identifier pattern always succeeds (matches any value), and the identifier is bound to that
value (using ordinary procedural assignment).
• The wildcard pattern “.*” always succeeds.
• A constant expression pattern succeeds if V is equal to its value.
• A tagged union pattern succeeds if the value has the same tag and, recursively, if the nested
pattern matches the member value of the tagged union.
• A structure pattern succeeds if, recursively, each of the nested member patterns matches the
corresponding member values in V. In structure patterns with named members, the textual order
of members does not matter, and members can be omitted. Omitted members are ignored.
309
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Conceptually, if the value V is seen as a flattened vector of bits, the pattern specifies which bits to match,
with what values they should be matched, and, if the match is successful, which bits to extract and bind to
the pattern identifiers. Matching can be insensitive to and values, as described in the following
x z
individual constructs.
12.6.1 Pattern matching in case statements
In a pattern-matching case statement, the expression in parentheses is followed by the keyword ,
matches
and the statement contains a series of case_pattern_items. The left-hand side of a case item, before the colon
( ), consists of a pattern and, optionally, the operator followed by a Boolean filter expression. The
: &&&
right-hand side of a case item is a statement. Each pattern introduces a new scope, in which its pattern
identifiers are implicitly declared; this scope extends to the optional filter expression and the statement in the
right-hand side of the same case item. Thus different case items can reuse pattern identifiers.
All the patterns are completely statically type-checked. The expression being tested in the pattern-matching
case statement shall have a known type, which is the same as the type of the pattern in each case item.
The expression in parentheses in a pattern-matching case statement shall be evaluated exactly once. Its value
V shall be matched against the left-hand sides of the case items, one at a time, in the exact order given,
ignoring the default case item if any. During this linear search, if a case item is selected, its statement is
executed and the linear search is terminated. If no case item is selected and a default case item is given, then
its statement is executed. If no case item is selected and no default case item is given, no statement is
executed.
For a case item to be selected, the value V shall match the pattern (and the pattern identifiers are assigned the
corresponding member values in V), and then the Boolean filter expression shall evaluate to true (a
determined value other than 0).
Example 1:
typedef union tagged {
void Invalid;
int Valid;
} VInt;
...
VInt v;
...
case (v) matches
tagged Invalid : $display ("v is Invalid");
tagged Valid .n : $display ("v is Valid with value %d", n);
endcase
In the case statement, if currently has the tag, the first pattern is matched. Otherwise, it must
v Invalid
have the tag, and the second pattern is matched. The identifier is bound to the value of the
Valid n Valid
member, and this value is displayed. It is impossible to access the integer member value ( ) when the tag is
n
.
Invalid
Example 2:
typedef union tagged {
struct {
bit [4:0] reg1, reg2, regd;
} Add;
union tagged {
bit [9:0] JmpU;
310
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
struct {
bit [1:0] cc;
bit [9:0] addr;
} JmpC;
} Jmp;
} Instr;
...
Instr instr;
...
case (instr) matches
tagged Add '{.r1, .r2, .rd} &&& (rd != 0) : rf[rd] = rf[r1] + rf[r2];
tagged Jmp .j : case (j) matches
tagged JmpU .a : pc = pc + a;
tagged JmpC '{.c, .a}: if (rf[c]) pc = a;
endcase
endcase
If holds an instruction, the first pattern is matched, and the identifiers , , and are bound
instr Add r1 r2 rd
to the three register fields in the nested structure value. The right-hand statement executes the instruction on
the register file . It is impossible to access these register fields if the tag is . If holds a
rf Jmp instr Jmp
instruction, the second pattern is matched, and the identifier is bound to the nested tagged union value. The
j
inner case statement, in turn, matches this value against and patterns and so on.
JmpU JmpC
Example 3 (same as previous example, but using wildcard and constant patterns to eliminate the
rd = 0
case; in some processors, register 0 is a special “discard” register):
case (instr) matches
tagged Add '{.*, .*, 0} : ; // no op
tagged Add '{.r1, .r2, .rd} : rf[rd] = rf[r1] + rf[r2];
tagged Jmp .j : case (j) matches
tagged JmpU .a : pc = pc + a;
tagged JmpC '{.c, .a} : if (rf[c]) pc = a;
endcase
endcase
Example 4 (same as previous example except that the first inner case statement involves only structures and
constants but no tagged unions):
case (instr) matches
tagged Add s: case (s) matches
'{.*, .*, 0} : ; // no op
'{.r1, .r2, .rd} : rf[rd] = rf[r1] + rf[r2];
endcase
tagged Jmp .j: case (j) matches
tagged JmpU .a : pc = pc + a;
tagged JmpC '{.c, .a} : if (rf[c]) pc = a;
endcase
endcase
Example 5 (same as previous example, but using nested tagged union patterns):
case (instr) matches
tagged Add '{.r1, .r2, .rd} &&& (rd != 0) : rf[rd] = rf[r1] + rf[r2];
tagged Jmp (tagged JmpU .a) : pc = pc + a;
tagged Jmp (tagged JmpC '{.c, .a}) : if (rf[c]) pc = a;
endcase
311
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 6 (same as previous example, with named structure components):
case (instr) matches
tagged Add '{reg2:.r2,regd:.rd,reg1:.r1} &&& (rd != 0):
rf[rd] = rf[r1] + rf[r2];
tagged Jmp (tagged JmpU .a) : pc = pc + a;
tagged Jmp (tagged JmpC '{addr:.a,cc:.c}) : if (rf[c]) pc = a;
endcase
The and keywords can be used instead of , with the same semantics. In other words,
casez casex case
during pattern matching, wherever 2 bits are compared (whether they are tag bits or members), the
casez
form ignores bits, and the form ignores both and bits.
z casex z x
The and qualifiers can also be used. implies that some case item must be
priority unique priority
selected. implies that some case item must be selected and also implies that exactly one case item
unique
will be selected so that they can be evaluated in parallel.
12.6.2 Pattern matching in if statements
The predicate in an if–else statement can be a series of clauses separated with the operator. Each clause
&&&
is either an expression (used as a Boolean filter) or has the form: expression pattern. The clauses
matches
represent a sequential conjunction from left to right (i.e., if any clause fails, the remaining clauses are not
evaluated) and all of them shall succeed for the predicate to be true. Boolean expression clauses are
evaluated as usual. Each pattern introduces a new scope, in which its pattern identifiers are implicitly
declared; this scope extends to the remaining clauses in the predicate and to the corresponding “true” arm of
the if–else statement.
In each e p clause, e and p shall have the same known statically known type. The value of e is
matches
matched against the pattern p as previously described.
Even though the pattern matching clauses always return a defined 1-bit result, the overall result can be
ambiguous because of the Boolean filter expressions in the predicate. The standard semantics of if–else
statements holds, i.e., the first statement is executed if, and only if, the result is a determined value other
than0.
Example 1:
if (e matches (tagged Jmp (tagged JmpC '{cc:.c,addr:.a})))
... // c and a can be used here
else
...
Example 2 (same as previous example, illustrating a sequence of two pattern matches with identifiers bound
in the first pattern used in the second pattern):
if (e matches (tagged Jmp .j) &&&
j matches (tagged JmpC '{cc:.c,addr:.a}))
... // c and a can be used here
else
...
Example 3 (same as first example, but adding a Boolean expression to the sequence of clauses). The idea
expressed is “if is a conditional jump instruction and the condition register is not equal to zero ...”.
e
312
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
if (e matches (tagged Jmp (tagged JmpC '{cc:.c,addr:.a}))
&&& (rf[c] != 0))
... // c and a can be used here
else
...
The and qualifiers can be used even if they use pattern matching.
priority unique
12.6.3 Pattern matching in conditional expressions
A conditional expression ( ) can also use pattern matching, i.e., the predicate can be a
e1 ? e2 : e3 e1
sequence of expressions and “expression pattern” clauses separated with the operator, just
matches &&&
like the predicate of an if–else statement. The clauses represent a sequential conjunction from left to right,
(i.e., if any clause fails, the remaining clauses are not evaluated) and all of them shall succeed for the
predicate to be true. Boolean expression clauses are evaluated as usual. Each pattern introduces a new scope,
in which its pattern identifiers are implicitly declared; this scope extends to the remaining clauses in the
predicate and to the consequent expression .
e2
As described in the previous subclause, can evaluate to true, false, or an ambiguous value. The semantics
e1
of the overall conditional expression is described in 11.4.11, based on these three possible outcomes for .
e1
12.7 Loop statements
SystemVerilog provides six types of looping constructs, as shown in Syntax12-5.
loop_statement ::= // from A.6.8
statement_or_null
forever
| expression statement_or_null
repeat( )
| expression statement_or_null
while( )
| [ for_initialization ] [ expression ] [ for_step ]
for ( ; ; )
statement_or_null
| statement_or_null expression
do while( );
| ps_or_hierarchical_array_identifier loop_variables statement
foreach( [ ])
for_initialization ::=
list_of_variable_assignments
| for_variable_declaration { for_variable_declaration }
,
for_variable_declaration ::=
[ ] data_type variable_identifier expression { variable_identifier expression }14
var = , =
for_step ::= for_step_assignment { for_step_assignment }
,
for_step_assignment ::=
operator_assignment
| inc_or_dec_expression
| function_subroutine_call
loop_variables ::= [ index_variable_identifier ] { [ index_variable_identifier ] }
,
14) When a type_reference is used in a net declaration, it shall be preceded by a net type keyword; and when it is used
in a variable declaration, it shall be preceded by the keyword.
var
Syntax12-5—Loop statement syntax (excerpt from AnnexA)
313
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
12.7.1 The for-loop
The for-loop controls execution of its associated statement(s) by a three-step process, as follows:
a) Unless the optional for_initialization is omitted, executes one or more for_initialization
assignments, which are normally used to initialize a variable that controls the number of times the
loop is executed.
b) Unless the optional expression is omitted, evaluates the expression. If the result is false (as defined
in 12.4), the for-loop shall exit. Otherwise, or if the expression is omitted, the for-loop shall execute
its associated statement(s) and then perform step c). If the expression evaluates to an unknown or
high-impedance value, it shall be treated as zero.
c) Unless the optional for_step is omitted, executes one or more for_step assignments, normally used
to modify the value of the loop-control variable, then repeats step b).
The variables used to control a for-loop can be declared prior to the loop. If loops in two or more parallel
processes use the same loop control variable, there is a potential of one loop modifying the variable while
other loops are still using it.
The variables used to control a for-loop can also be declared within the loop, as part of the for_initialization
assignments. This creates an implicit begin-end block around the loop, containing declarations of the loop
variables with automatic lifetime. This block creates a new hierarchical scope, making the variables local to
the loop scope. The block is unnamed by default, but can be named by adding a statement label (9.3.5) to the
for-loop statement. Thus, other parallel loops cannot inadvertently affect the loop control variable. For
example:
module m;
initial begin
for (int i = 0; i <= 255; i++)
...
end
initial begin
loop2: for (int i = 15; i >= 0; i--)
...
end
endmodule
This is equivalent to the following:
module m;
initial begin
begin
automatic int i;
for (i = 0; i <= 255; i++)
...
end
end
initial begin
begin : loop2
automatic int i;
for (i = 15; i >= 0; i--)
...
end
end
endmodule
314
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Only for-loop statements containing variable declarations as part of the for-initialization assignments create
implicit begin-end blocks around them.
The initial declaration or assignment statement can be one or more comma-separated statements. The step
assignment can also be one or more comma-separated assignment statements, increment or decrement
expressions, or function calls.
for ( int count = 0; count < 3; count++ )
value = value +((a[count]) * (count+1));
for ( int count = 0, done = 0, j = 0; j * count < 125; j++, count++)
$display("Value j = %d\n", j );
In a for-loop initialization, either all or none of the control variables shall be locally declared. In the second
loop of the example above, , , and are all locally declared. The following would be illegal
count done j
because it attempts to locally declare whereas was not locally declared:
y x
for (x = 0, int y = 0; ...)
...
In a for-loop initialization that declares multiple local variables, the initialization expression of a local
variable can use earlier local variables.
for (int i = 0, j = i+offset; i < N; i++,j++)
...
12.7.2 The repeat loop
The repeat-loop executes a statement a fixed number of times. If the expression evaluates to unknown or
high impedance, it shall be treated as zero, and no statement shall be executed.
In the following example of a repeat-loop, add and shift operators implement a multiplier:
parameter size = 8, longsize = 16;
logic [size:1] opa, opb;
logic [longsize:1] result;
begin : mult
logic [longsize:1] shift_opa, shift_opb;
shift_opa = opa;
shift_opb = opb;
result = 0;
repeat (size) begin
if (shift_opb[1])
result = result + shift_opa;
shift_opa = shift_opa << 1;
shift_opb = shift_opb >> 1;
end
end
12.7.3 The foreach-loop
The foreach-loop construct specifies iteration over the elements of an array. Its argument is an identifier that
designates any type of array followed by a comma-separated list of loop variables enclosed in square
brackets. Each loop variable corresponds to one of the dimensions of the array. The foreach-loop is similar
to a repeat-loop that uses the array bounds to specify the repeat count instead of an expression.
315
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Examples:
string words [2] = '{ "hello", "world" };
int prod [1:8] [1:3];
foreach( words [ j ] )
$display( j , words[j] ); // print each index and value
foreach( prod[ k, m ] )
prod[k][m] = k * m; // initialize
The number of loop variables shall not be greater than the number of dimensions of the array variable. Loop
variables may be omitted to indicate no iteration over that dimension of the array, and trailing commas in the
list may also be omitted. As in a for-loop (12.7.1), a foreach-loop creates an implicit begin-end block around
the loop statement, containing declarations of the loop variables with automatic lifetime. This block creates
a new hierarchical scope, making the variables local to the loop scope. The block is unnamed by default, but
can be named by adding a statement label (9.3.5) to the foreach statement. foreach-loop variables are read-
only. The type of each loop variable is implicitly declared to be consistent with the type of array index. It
shall be an error for any loop variable to have the same identifier as the array.
The mapping of loop variables to array indices is determined by the dimension cardinality, as described in
20.7. The foreach-loop arranges for higher cardinality indices to change more rapidly.
// 1 2 3 3 4 1 2 -> Dimension numbers
int A [2][3][4]; bit [3:0][2:1] B [5:1][4];
foreach( A [ i, j, k ] ) ...
foreach( B [ q, r, , s ] ) ...
The first foreach-loop causes to iterate from 0 to 1, from 0 to 2, and from 0 to 3. The second foreach-
i j k
loop causes to iterate from 5 to 1, from 0 to 3, and from 2 to 1 (iteration over the third index is
q r s
skipped).
If the dimensions of a dynamically sized array are changed while iterating over a foreach-loop construct, the
results are undefined and may cause invalid index values to be generated.
Multiple loop variables correspond to nested loops that iterate over the given indices. The nesting of the
loops is determined by the dimension cardinality; outer loops correspond to lower cardinality indices. In the
preceding first example, the outermost loop iterates over , and the innermost loop iterates over .
i k
When loop variables are used in expressions other than as indices to the designated array, they are auto-cast
into a type consistent with the type of index. For fixed-size and dynamic arrays, the auto-cast type is .
int
For associative arrays indexed by a specific index type, the auto-cast type is the same as the index type. To
use different types, an explicit cast can be used.
12.7.4 The while-loop
The while-loop repeatedly executes a statement as long as a control expression is true (as defined in 12.4). If
the expression is not true at the beginning of the execution of the while-loop, the statement shall not be
executed at all.
The following example counts the number of logic 1 values in :
data
begin : count1s
logic [7:0] tempreg;
316
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
count = 0;
tempreg = data;
while (tempreg) begin
if (tempreg[0])
count++;
tempreg >>= 1;
end
end
12.7.5 The do...while-loop
The do...while-loop differs from the while-loop in that a do...while-loop tests its control expression at the
end of the loop. Loops with a test at the end are sometimes useful to save duplication of the loop body.
string s;
if ( map.first( s ) )
do
$display( "%s : %d\n", s, map[ s ] );
while ( map.next( s ) );
The condition can be any expression that can be treated as a Boolean. It is evaluated after the statement.
12.7.6 The forever-loop
The forever-loop repeatedly executes a statement. To avoid a zero-delay infinite loop, which could hang the
simulation event scheduler, the forever loop should only be used in conjunction with the timing controls or
the disable statement. For example:
initial begin
clock1 <= 0;
clock2 <= 0;
fork
forever #10 clock1 = ~clock1;
#5 forever #10 clock2 = ~clock2;
join
end
12.8 Jump statements
jump_statement ::= // from A.6.5
[ expression ]
return ;
|
break ;
|
continue ;
Syntax12-6—Jump statement syntax (excerpt from AnnexA)
SystemVerilog provides the C-like jump statements , , and .
break continue return
break // break out of loop, as in C
continue // skip to end of loop, as in C
return expression // exit from a function
return // exit from a task or void function
317
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The and statements can only be used in a loop. The statement jumps to the end
continue break continue
of the loop and executes the loop control if present. The statement jumps out of the loop.
break
The and statements cannot be used inside a fork-join block to control a loop outside the
continue break
fork-join block.
The statement can only be used in a subroutine. In a function returning a value, the return statement
return
shall have an expression of the correct type.
NOTE—SystemVerilog does not include the C statement.
goto
318
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
13. Tasks and functions (subroutines)
13.1 General
This clause describes the following:
— Task declarations
— Function declarations
— Calling tasks and functions
13.2 Overview
Tasks and functions provide the ability to execute common procedures from several different places in a
description. They also provide a means of breaking up large procedures into smaller ones to make it easier to
read and debug the source descriptions. This clause discusses the differences between tasks and functions,
describes how to define and invoke tasks and functions, and presents examples of each.
Tasks and functions are collectively referred to as subroutines.
The following rules distinguish tasks from functions, with exceptions noted in 13.4.4:
— The statements in the body of a function shall execute in one simulation time unit; a task may
contain time-controlling statements.
— A function cannot enable a task; a task can enable other tasks and functions.
— A nonvoid function shall return a single value; a task or void function shall not return a value.
— A nonvoid function can be used as an operand in an expression; the value of that operand is the
value returned by the function.
For example:
Either a task or a function can be defined to switch bytes in a 16-bit word. The task would return the
switched word in an output argument; therefore, the source code to enable a task called
switch_bytes
could look like the following example:
switch_bytes (old_word, new_word);
The task would take the bytes in , reverse their order, and place the reversed
switch_bytes old_word
bytes in .
new_word
A word-switching function would return the switched word as the return value of the function. Thus, the
function call for the function could look like the following example:
switch_bytes
new_word = switch_bytes (old_word);
13.3 Tasks
A task shall be enabled from a statement that defines the argument values to be passed to the task and the
variables that receive the results. Control shall be passed back to the enabling process after the task has
completed. Thus, if a task has timing controls inside it, then the time of enabling a task can be different from
the time at which the control is returned. A task can enable other tasks, which in turn can enable still other
tasks—with no limit on the number of tasks enabled. Regardless of how many tasks have been enabled,
control shall not return until all enabled tasks have completed.
319
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The syntax for task declarations is as follows in Syntax13-1.
task_declaration ::= [ lifetime ] task_body_declaration // from A.2.7
task
task_body_declaration ::=
[ interface_identifier | class_scope ] task_identifier
. ;
{ tf_item_declaration }
{ statement_or_null }
[ task_identifier ]
endtask :
| [ interface_identifier | class_scope ] task_identifier [ tf_port_list ]
. ( ) ;
{ block_item_declaration }
{ statement_or_null }
[ task_identifier ]
endtask :
tf_item_declaration ::=
block_item_declaration
| tf_port_declaration
tf_port_list ::=
tf_port_item { tf_port_item }
,
tf_port_item23 ::=
{ attribute_instance }
[ tf_port_direction ] [ ] data_type_or_implicit
var
[ port_identifier { variable_dimension } [ expression ] ]
=
tf_port_direction ::= port_direction |
constref
tf_port_declaration ::=
{ attribute_instance } tf_port_direction [ ] data_type_or_implicit list_of_tf_variable_identifiers
var ;
lifetime ::= | // from A.2.1
static automatic
signing ::= | // from A.2.2.1
signed unsigned
data_type_or_implicit ::=
data_type
| implicit_data_type
implicit_data_type ::= [ signing ] { packed_dimension }
23) In a tf_port_item, it shall be illegal to omit the explicit port_identifier except within a function_prototype or
task_prototype.
Syntax13-1—Task syntax (excerpt from AnnexA)
A task declaration has the formal arguments either in parentheses (like ANSI C) or in declarations and
directions.
task mytask1 (output int x, input logic y);
...
endtask
task mytask2;
output x;
input y;
int x;
logic y;
...
endtask
320
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Each formal argument has one of the following directions:
// copy value in at beginning
input
// copy value out at end
output
// copy in at beginning and out at end
inout
// pass reference (see 13.5.2)
ref
There is a default direction of if no direction has been specified. Once a direction is given,
input
subsequent formals default to the same direction. In the following example, the formal arguments and
a b
default to inputs, and and are both outputs:
u v
task mytask3(a, b, output logic [15:0] u, v);
...
endtask
Each formal argument has a data type that can be explicitly declared or inherited from the previous
argument. If the data type is not explicitly declared, then the default data type is if it is the first
logic
argument or if the argument direction is explicitly specified. Otherwise, the data type is inherited from the
previous argument.
An array can be specified as a formal argument to a task. For example:
// the resultant declaration of b is input [3:0][7:0] b[3:0]
task mytask4(input [3:0][7:0] a, b[3:0], output [3:0][7:0] y[1:0]);
...
endtask
Multiple statements can be written between the task declaration and . Statements are executed
endtask
sequentially, the same as if they were enclosed in a .... group. It shall also be legal to have no
begin end
statements at all.
A task exits when the is reached. The statement can be used to exit the task before the
endtask return
keyword.
endtask
A call to a task is also referred to as a task enable (see 13.5 for more details on calling tasks).
Example 1: The following example illustrates the basic structure of a task definition with five arguments:
task my_task;
input a, b;
inout c;
output d, e;
. . . // statements that perform the work of the task
. . .
c = a; // the assignments that initialize result outputs
d = b;
e = c;
endtask
Or using the second form of a task declaration, the task could be defined as follows:
task my_task (input a, b, inout c, output d, e);
. . . // statements that perform the work of the task
. . .
c = a; // the assignments that initialize result variables
d = b;
321
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
e = c;
endtask
The following statement calls the task:
initial
my_task (v, w, x, y, z);
The task call arguments ( , , , , and ) correspond to the arguments ( , , , , and ) defined by the
v w x y z a b c d e
task. At the time of the call, the input and inout type arguments ( , , and ) receive the values passed in ,
a b c v
, and . Thus, execution of the call effectively causes the following assignments:
w x
a = v;
b = w;
c = x;
As part of the processing of the task, the task definition for places the computed result values into
my_task
, , and . When the task completes, the following assignments to return the computed values to the calling
c d e
process are performed:
x = c;
y = d;
z = e;
Example 2: The following example illustrates the use of tasks by describing a traffic light sequencer:
module traffic_lights;
logic clock, red, amber, green;
parameter on = 1, off = 0, red_tics = 350,
amber_tics = 30, green_tics = 200;
// initialize colors
initial red = off;
initial amber = off;
initial green = off;
always begin // sequence to control the lights
red = on; // turn red light on
light(red, red_tics); // and wait.
green = on; // turn green light on
light(green, green_tics); // and wait.
amber = on; // turn amber light on
light(amber, amber_tics); // and wait.
end
// task to wait for 'tics' positive edge clocks
// before turning 'color' light off
task light (output color, input [31:0] tics);
repeat (tics) @ (posedge clock);
color = off; // turn light off.
endtask: light
always begin // waveform for the clock
#100 clock = 0;
#100 clock = 1;
end
endmodule: traffic_lights
322
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
13.3.1 Static and automatic tasks
Tasks defined within a module, interface, program, or package default to being static, with all declared items
being statically allocated. These items shall be shared across all uses of the task executing concurrently.
Tasks can be defined to use automatic storage in the following two ways:
— Explicitly declared using the optional automatic keyword as part of the task declaration.
— Implicitly declared by defining the task within a module, interface, program, or package that is
defined as automatic.
Tasks defined within a class are always automatic (see 8.6).
All items declared inside automatic tasks are allocated dynamically for each invocation. All formal
arguments and local variables are stored on the stack.
Automatic task items cannot be accessed by hierarchical references. Automatic tasks can be invoked through
use of their hierarchical name.
Specific local variables can be declared as within a static task or as within an automatic
automatic static
task.
13.3.2 Task memory usage and concurrent activation
A task may be enabled more than once concurrently. All variables of an automatic task shall be replicated on
each concurrent task invocation to store state specific to that invocation. All variables of a static task shall be
static in that there shall be a single variable corresponding to each declared local variable in a module
instance, regardless of the number of concurrent activations of the task. However, static tasks in different
instances of a module shall have separate storage from each other.
Variables declared in static tasks, including , , and type arguments, shall retain their
input output inout
values between invocations. They shall be initialized to the default initialization value as described in 6.8.
Variables declared in automatic tasks, including type arguments, shall be initialized to the default
output
initialization value whenever execution enters their scope. and type arguments shall be
input inout
initialized to the values passed from the expressions corresponding to these arguments listed in the
task-enabling statements.
Because variables declared in automatic tasks are deallocated at the end of the task invocation, they shall not
be used in certain constructs that might refer to them after that point:
— They shall not be assigned values using nonblocking assignments or procedural continuous
assignments.
— They shall not be referenced by procedural continuous assignments or procedural force statements.
— They shall not be referenced in intra-assignment event controls of nonblocking assignments.
— They shall not be traced with system tasks such as and .
$monitor $dumpvars
13.4 Functions
The primary purpose of a function is to return a value that is to be used in an expression. A void function can
also be used instead of a task to define a subroutine that executes and returns within a single time step. The
rest of this clause explains how to define and use functions.
323
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Functions have restrictions that make certain they return without suspending the process that enables them.
The following rules shall govern their usage, with exceptions noted in 13.4.4:
a) A function shall not contain any time-controlled statements. That is, any statements containing ,
#
, , , , , , or .
## @ fork-join fork-join_any wait wait_order expect
b) A function shall not enable tasks regardless of whether those tasks contain time-controlling
statements.
c) Functions may enable fine-grain process control methods to suspend its own or another process (see
9.7).
The syntax for defining a function is given in Syntax13-2.
function_declaration ::= [ lifetime ] function_body_declaration // from A.2.6
function
function_body_declaration ::=
function_data_type_or_implicit
[ interface_identifier | class_scope ] function_identifier
. ;
{ tf_item_declaration }
{ function_statement_or_null }
[ function_identifier ]
endfunction :
| function_data_type_or_implicit
[ interface_identifier | class_scope ] function_identifier [ tf_port_list ]
. ( );
{ block_item_declaration }
{ function_statement_or_null }
[ function_identifier ]
endfunction :
function_data_type_or_implicit ::=
data_type_or_void
| implicit_data_type
data_type ::= // from A.2.2.1
integer_vector_type [ signing ] { packed_dimension }
| integer_atom_type [ signing ]
| non_integer_type
| struct_union [ [ signing ] ] struct_union_member { struct_union_member }
packed { }
{ packed_dimension }13
| [ enum_base_type ] enum_name_declaration { enum_name_declaration }
enum { , }
{ packed_dimension }
|
string
|
chandle
| [ ] interface_identifier [ parameter_value_assignment ] [ modport_identifier ]
virtual interface .
| [ class_scope | package_scope ] type_identifier { packed_dimension }
| class_type
|
event
| ps_covergroup_identifier
| type_reference14
signing ::= |
signed unsigned
lifetime ::= | // from A.2.1.3
static automatic
13) When a packed dimension is used with the or keyword, the keyword shall also be used.
struct union packed
14) When a type_reference is used in a net declaration, it shall be preceded by a net type keyword; and when it is used
in a variable declaration, it shall be preceded by the keyword.
var
Syntax13-2—Function syntax (excerpt from AnnexA)
324
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
To indicate the return type of a function, its declaration can either include an explicit data_type_or_void or
use an implicit syntax that indicates only the ranges of the packed dimensions and, optionally, the
signedness. When the implicit syntax is used, the return type is the same as if the implicit syntax had been
immediately preceded by the keyword. In particular, the implicit syntax can be empty, in which case
logic
the return type is a scalar. A function can also be , without a return value (see 13.4.1).
logic void
A function declaration has the formal arguments either in parentheses (like ANSI C) or in declarations and
directions, as follows:
function logic [15:0] myfunc1(int x, int y);
...
endfunction
function logic [15:0] myfunc2;
input int x;
input int y;
...
endfunction
Functions can have the same formal arguments as tasks. Function argument directions are as follows:
// copy value in at beginning
input
// copy value out at end
output
// copy in at beginning and out at end
inout
// pass reference (see 13.5.2)
ref
Function declarations default to the formal direction if no direction has been specified. Once a
input
direction is given, subsequent formals default to the same direction. In the following example, the formal
arguments and default to inputs, and and are both outputs:
a b u v
function logic [15:0] myfunc3(int a, int b, output logic [15:0] u, v);
...
endfunction
Each formal argument has a data type that can be explicitly declared or inherited from the previous
argument. If the data type is not explicitly declared, then the default data type is if it is the first
logic
argument or if the argument direction is explicitly specified. Otherwise the data type is inherited from the
previous argument. An array can be specified as a formal argument to a function, for example:
function [3:0][7:0] myfunc4(input [3:0][7:0] a, b[3:0]);
...
endfunction
It shall be illegal to call a function with , , or arguments in an event expression, in an
output inout ref
expression within a procedural continuous assignment, or in an expression that is not within a procedural
statement. However, a function argument shall be legal in this context (see 13.5.2).
constref
Multiple statements can be written between the function header and . Statements are executed
endfunction
sequentially, as if they were enclosed in a group. It is also legal to have no statements at all, in
begin-end
which case the function returns the current value of the implicit variable that has the same name as the
function.
325
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
13.4.1 Return values and void functions
The function definition shall implicitly declare a variable, internal to the function, with the same name as the
function. This variable has the same type as the function return value. Function return values can be
specified in two ways, either by using a statement or by assigning a value to the internal variable
return
with the same name as the function. For example:
function [15:0] myfunc1 (input [7:0] x,y);
myfunc1 = x * y - 1; // return value assigned to function name
endfunction
function [15:0] myfunc2 (input [7:0] x,y);
return x * y - 1; //return value is specified using return statement
endfunction
The statement shall override any value assigned to the function name. When the return statement is
return
used, nonvoid functions shall specify an expression with the return.
A function return can be a structure or union. In this case, a hierarchical name used inside the function and
beginning with the function name is interpreted as a member of the return value. If the function name is used
outside the function, the name indicates the scope of the whole function. If the function name is used within
a hierarchical name, it also indicates the scope of the whole function.
Functions can be declared as type , which do not have a return value. Function calls may be used as
void
expressions unless of type , which are statements:
void
a = b + myfunc1(c, d); // call myfunc1 (defined above) as an expression
myprint(a); // call myprint (defined below) as a statement
function void myprint (int a);
...
endfunction
Functions that return a value may be used in an assignment or an expression. Calling a nonvoid function as
if it has no return value shall be legal, but shall issue a warning. The function can be used as a statement and
the return value discarded without a warning by casting the function call to the type.
void
void'(some_function());
It shall be illegal to declare another object with the same name as the function in the scope where the
function is declared or explicitly imported. It shall also be illegal to declare another object with the same
name as the function inside the function scope.
13.4.2 Static and automatic functions
Functions defined within a module, interface, program, or package default to being static, with all declared
items being statically allocated. These items shall be shared across all uses of the function executing
concurrently.
Functions can be defined to use automatic storage in the following two ways:
— Explicitly declared using the optional automatic keyword as part of the function declaration.
— Implicitly declared by defining the function within a module, interface, program, or package that is
defined as automatic.
326
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Functions defined within a class are always automatic (see 8.6).
An automatic function is reentrant, with all the function declarations allocated dynamically for each
concurrent function call. Automatic function items cannot be accessed by hierarchical references. Automatic
functions can be invoked through the use of their hierarchical name.
Specific local variables can be declared as within a static function or as within an
automatic static
automatic function.
The following example defines a function called that returns an integer value. The
factorial factorial
function is called iteratively and the results are printed.
module tryfact;
// define the function
function automatic integer factorial (input [31:0] operand);
if (operand >= 2)
factorial = factorial (operand - 1) * operand;
else
factorial = 1;
endfunction: factorial
// test the function
integer result;
initial begin
for (int n = 0; n <= 7; n++) begin
result = factorial(n);
$display("%0d factorial=%0d", n, result);
end
end
endmodule: tryfact
The simulation results are as follows:
0 factorial=1
1 factorial=1
2 factorial=2
3 factorial=6
4 factorial=24
5 factorial=120
6 factorial=720
7 factorial=5040
13.4.3 Constant functions
Constant functions are a subset of normal functions that shall meet the following constraints:
— A constant function shall not have output, inout, or ref arguments.
— A void function shall not be a constant function.
— A DPI import function (see 35.2.1) shall not be a constant function.
— A constant function shall not contain a statement that directly schedules an event to execute after the
function has returned.
— A constant function shall not contain any fork constructs.
— Constant functions shall contain no hierarchical references.
327
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Any function invoked within a constant function shall be a constant function local to the current
module.
— It shall be legal to call any system function that is allowed in a constant_expression (see 11.2.1).
This includes and the array query functions. Calls to other system functions shall be illegal.
$bits
— All system task calls within a constant function shall be ignored.
— All parameter values used within the function shall be defined before the use of the invoking
constant function call (i.e., any parameter use in the evaluation of a constant function call constitutes
a use of that parameter at the site of the original constant function call). A constant function may
reference parameters defined in packages or .
$unit
— All identifiers that are not parameters or functions shall be declared locally to the current function.
— If constant functions use any parameter value that is affected directly or indirectly by a
defparam
statement (see 23.10.1), the result shall be undefined. This can produce an error or the constant
function can return an indeterminate value.
— Constant functions shall not be declared inside a generate block (see Clause27).
— Constant functions shall not themselves use constant functions in any context requiring a constant
expression.
— A constant function may have default argument values (see 13.5.3), but any such default argument
value shall be a constant expression.
Constant function calls are used to support the building of complex calculations of values at elaboration time
(see 3.12). A constant function call is a function call of a constant function local to the calling module or
from a package or where the arguments to the function are all constant expressions (see 11.2.1).
$unit
Constant function calls are evaluated at elaboration time. Their execution has no effect on the initial values
of the variables used either at simulation time or among multiple invocations of a function at elaboration
time. In each of these cases, the variables are initialized as they would be for normal simulation.
The following example defines a function called that returns an integer with the value of the ceiling
clogb2
of the log base 2.
module ram_model (address, write, chip_select, data);
parameter data_width = 8;
parameter ram_depth = 256;
localparam addr_width = clogb2(ram_depth);
input [addr_width - 1:0] address;
input write, chip_select;
inout [data_width - 1:0] data;
//define the clogb2 function
function integer clogb2 (input [31:0] value);
value = value - 1;
for (clogb2 = 0; value > 0; clogb2 = clogb2 + 1)
value = value >> 1;
endfunction
logic [data_width - 1:0] data_store[0:ram_depth - 1];
//the rest of the ram model
endmodule: ram_model
An instance of this with parameters assigned is as follows:
ram_model
ram_model #(32,421) ram_a0(a_addr,a_wr,a_cs,a_data);
328
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
13.4.4 Background processes spawned by function calls
Functions shall execute with no delay. Thus, a process calling a function shall return immediately.
Statements that do not block shall be allowed inside a function; specifically, nonblocking assignments, event
triggers, clocking drives, and - constructs shall be allowed inside a function.
fork join_none
Calling a function that tries to schedule an event that cannot become active until after that function returns
shall be allowed provided that the thread calling the function is created by an initial procedure, always
procedure, or fork block from one of those procedures and in a context in which a side effect is allowed.
Implementations shall issue an error either at compile time or run time when these provisions have not been
met.
Within a function, a - construct may contain any statements that are legal within a task.
fork join_none
Examples of a legal and illegal usage of - in a function are shown as follows:
fork join_none
class IntClass;
int a;
endclass
IntClass address=new(), stack=new();
function automatic bit watch_for_zero( IntClass p );
fork
forever @p.a begin
if ( p.a == 0 ) $display (“Unexpected zero”);
end
join_none
return ( p.a == 0 );
endfunction
function bit start_check();
return ( watch_for_zero( address ) | watch_for_zero( stack ) );
endfunction
bit y = watch_for_zero( stack ); // illegal
initial if ( start_check() ) $display ( “OK”); // legal
initial fork
if (start_check() ) $display( “OK too”); // legal
join_none
13.5 Subroutine calls and argument passing
Tasks and void functions are called as statements within procedural blocks (see 9.2). A nonvoid function call
may be an operand within an expression.
The syntax for calling a subroutine as a statement is shown in Syntax13-3:
subroutine_call_statement ::= // from A.6.9
subroutine_call
;
| function_subroutine_call
void ' ( ) ;
subroutine_call ::= // from A.8.2
tf_call
329
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| system_tf_call
| method_call
| [ ] randomize_call
std ::
tf_call37 ::= ps_or_hierarchical_tf_identifier { attribute_instance } [ list_of_arguments ]
( )
list_of_arguments ::=
[ expression ] { [ expression ] } { identifier [ expression ] }
, ,. ( )
| identifier [ expression ] { identifier [ expression ] }
. ( ) ,. ( )
ps_or_hierarchical_tf_identifier ::= // from A.9.3
[ package_scope ] tf_identifier
| hierarchical_tf_identifier
37) It shall be illegal to omit the parentheses in a tf_call unless the subroutine is a task, void function, or class method.
If the subroutine is a nonvoid class function method, it shall be illegal to omit the parentheses if the call is directly
recursive.
Syntax13-3—Task or function call syntax (excerpt from AnnexA)
If an argument in the subroutine is declared as an , then the corresponding expression in the
input
subroutine call can be any expression. The order of evaluation of the expressions in the argument list is
undefined.
If the argument in the subroutine is declared as an or an , then the corresponding expression
output inout
in the subroutine call shall be restricted to an expression that is valid on the left-hand side of a procedural
assignment (see 10.4).
The execution of the subroutine call shall pass input values from the expressions listed in the arguments of
the call. Execution of the return from the subroutine shall pass values from the and type
output inout
arguments to the corresponding variables in the subroutine call.
SystemVerilog provides two means for passing arguments to tasks and functions: by value and by reference.
Arguments can also be bound by name as well as by position. Subroutine arguments can also be given
default values, allowing the call to the subroutine to not pass arguments.
13.5.1 Pass by value
Pass by value is the default mechanism for passing arguments to subroutines. This argument passing
mechanism works by copying each argument into the subroutine area. If the subroutine is automatic, then
the subroutine retains a local copy of the arguments in its stack. If the arguments are changed within the
subroutine, the changes are not visible outside the subroutine. When the arguments are large, it can be
undesirable to copy the arguments. Also, programs sometimes need to share a common piece of data that is
not declared global.
For example, calling the following function copies 1000 bytes each time the call is made.
function automatic int crc( byte packet [1000:1] );
for( int j= 1; j <= 1000; j++ ) begin
crc ^= packet[j];
end
endfunction
330
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
13.5.2 Pass by reference
Arguments passed by reference are not copied into the subroutine area, rather, a reference to the original
argument is passed to the subroutine. The subroutine can then access the argument data via the reference.
Arguments passed by reference shall be matched with equivalent data types (see 6.22.2). No casting shall be
permitted. To indicate argument passing by reference, the argument declaration is preceded by the
ref
keyword. It shall be illegal to use argument passing by reference for subroutines with a lifetime of .
static
The general syntax is as follows:
subroutine( ref type argument );
For example, the preceding example can be written as follows:
function automatic int crc( ref byte packet [1000:1] );
for( int j= 1; j <= 1000; j++ ) begin
crc ^= packet[j];
end
endfunction
As shown in the preceding example, no change other than addition of the keyword is needed. The
ref
compiler knows that is now addressed via a reference, but users do not need to make these
packet
references explicit either in the callee or at the point of the call. In other words, the call to either version of
the function remains the same:
crc
byte packet1[1000:1];
int k = crc( packet1 ); // pass by value or by reference: call is the same
When the argument is passed by reference, both the caller and the subroutine share the same representation
of the argument; therefore, any changes made to the argument, within either the caller or the subroutine,
shall be visible to each other. The semantics of assignments to variables passed by reference is that changes
are seen outside the subroutine immediately (before the subroutine returns).
Only the following shall be legal to pass by reference:
— A variable,
— A class property,
— A member of an unpacked structure, or
— An element of an unpacked array.
Nets and selects into nets shall not be passed by reference.
Because a variable passed by reference may be an automatic variable, a argument shall not be used in
ref
any context forbidden for automatic variables.
Elements of dynamic arrays, queues, and associative arrays that are passed by reference may get removed
from the array or the array may get resized before the called subroutine completes. The specific array
element passed by reference shall continue to exist within the scope of the called subroutines until they
complete. Changes made to the values of array elements by the called subroutine shall not be visible outside
the scope of those subroutines if those array elements were removed from the array before the changes were
made. These references shall be called outdated references.
The following operations on a variable-size array shall cause existing references to elements of that array to
become outdated references:
— A dynamic array is resized with an implicit or explicit .
new[]
— A dynamic array is deleted with the method.
delete()
331
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— The element of an associative array being referenced is deleted with the method.
delete()
— The queue or dynamic array containing the referenced element is updated by assignment.
— The element of a queue being referenced is deleted by a queue method.
Passing an argument by reference is a unique argument-passing qualifier, different from , , or
input output
. Combining with any other directional qualifier shall be illegal. For example, the following
inout ref
declaration results in a compiler error:
task automatic incr( ref input int a );// incorrect: ref cannot be qualified
A argument is similar to an argument except that an argument is copied twice: once from
ref inout inout
the actual into the argument when the subroutine is called and once from the argument into the actual when
the subroutine returns. Passing object handles is no exception and has similar semantics when passed as
ref
or arguments. Thus, a of an object handle allows changes to the object handle (for example,
inout ref
assigning a new object) in addition to modification of the contents of the object.
To protect arguments passed by reference from being modified by a subroutine, the qualifier can be
const
used together with to indicate that the argument, although passed by reference, is a read-only variable.
ref
task automatic show ( const ref byte data [] );
for ( int j = 0; j < data.size ; j++ )
$display( data[j] ); // data can be read but not written
endtask
When the formal argument is declared as a , the subroutine cannot alter the variable, and an
const ref
attempt to do so shall generate a compiler error.
13.5.3 Default argument values
To handle common cases or allow for unused arguments, SystemVerilog allows a subroutine declaration to
specify a default value for each singular argument.
The syntax to declare a default argument in a subroutine is as follows:
subroutine( [ direction ] [ type ] argument = default_expression);
The optional direction can be , , , or .
input inout output ref
The default_expression is evaluated in the scope containing the subroutine declaration each time a call using
the default is made. If the default is not used, the default expression is not evaluated. The use of defaults
shall only be allowed with the ANSI style declarations.
When the subroutine is called, arguments with defaults can be omitted from the call, and the compiler shall
insert their corresponding values. Unspecified (or empty) arguments can be used as placeholders for default
arguments. If an unspecified argument is used for an argument that does not have a default, a compiler error
shall be issued.
task read(int j = 0, int k, int data = 1 );
...
endtask
This example declares a task with two default arguments, and . The task can then be called
read() j data
using various default arguments:
332
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
read( , 5 ); // is equivalent to read( 0, 5, 1 );
read( 2, 5 ); // is equivalent to read( 2, 5, 1 );
read( , 5, ); // is equivalent to read( 0, 5, 1 );
read( , 5, 7 ); // is equivalent to read( 0, 5, 7 );
read( 1, 5, 2 ); // is equivalent to read( 1, 5, 2 );
read( ); // error; k has no default value
read( 1, , 7 ); // error; k has no default value
The following example shows an output argument with a default expression:
module m;
logic a, w;
task t1 (output o = a) ; // default binds to m.a
...
endtask :t1
task t2 (output o = b) ; // illegal, b cannot be resolved
...
endtask :t2
task t3 (inout io = w) ; // default binds to m.w
...
endtask :t1
endmodule :m
module n;
logic a;
initial begin
m.t1(); // same as m.t1(m.a), not m.t1(n.a);
// at end of task, value of t1.o is copied to m.a
m.t3(); // same as m.t3(m.w)
// value of m.w is copied to t3.io at start of task and
// value of t3.io is copied to m.w at end of task
end
endmodule :n
13.5.4 Argument binding by name
SystemVerilog allows arguments to tasks and functions to be bound by name as well as by position. This
allows specifying nonconsecutive default arguments and easily specifying the argument to be passed at the
call. For example:
function int fun( int j = 1, string s = "no" );
...
endfunction
The function can be called as follows:
fun
fun( .j(2), .s("yes") ); // fun( 2, "yes" );
fun( .s("yes") ); // fun( 1, "yes" );
fun( , "yes" ); // fun( 1, "yes" );
fun( .j(2) ); // fun( 2, "no" );
fun( .s("yes"), .j(2) ); // fun( 2, "yes" );
fun( .s(), .j() ); // fun( 1, "no" );
fun( 2 ); // fun( 2, "no" );
fun( ); // fun( 1, "no" );
333
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If the arguments have default values, they are treated like parameters to module instances. If the arguments
do not have a default, then they shall be given, or the compiler shall issue an error.
If both positional and named arguments are specified in a single subroutine call, then all the positional
arguments shall come before the named arguments. Then, using the same example as above:
fun( .s("yes"), 2 ); // illegal
fun( 2, .s("yes") ); // OK
13.5.5 Optional argument list
When a void function or class function method specifies no arguments, the empty parenthesis, , following
()
the subroutine name shall be optional. This is also true for tasks, void functions, and class methods that
require arguments, when all arguments have defaults specified. It shall be illegal to omit the parenthesis in a
directly recursive nonvoid class function method call that is not hierarchically qualified.
13.6 Import and export functions
SystemVerilog provides a direct programming interface (DPI) that allows importing foreign language
subroutines, such as C functions, into SystemVerilog. An imported subroutine is called in the same way as a
SystemVerilog subroutine. SystemVerilog tasks and functions can also be exported to a foreign language.
See Clause35 for details on the DPI.
13.7 Task and function names
Task and function names are resolved following slightly different rules than other references. Even when
used as a simple name, a task or function name follows a modified form of the upwards hierarchical name
resolution rules. This means that “forward” references to a task or function defined later in the same or an
enclosing scope can be resolved. See 23.8.1 for the rules that govern task and function name resolution.
13.8 Parameterized tasks and functions
SystemVerilog provides a way to create parameterized tasks and functions, also known as parameterized
subroutines. A parameterized subroutine allows the user to generically specify or define an implementation.
When using that subroutine one may provide the parameters that fully define its behavior. This allows for
only one definition to be written and maintained instead of multiple subroutines with different array sizes,
data types, and variable widths.
The way to implement parameterized subroutines is through the use of static methods in parameterized
classes (see 8.10 and 8.25). The following generic encoder and decoder example shows how to use static
class methods along with class parameterization to implement parameterized subroutines. The example has
one class with two subroutines that, in this case, share parameterization. The class may be declared virtual in
order to prevent object construction and enforce the strict static usage of the method.
virtual class C#(parameter DECODE_W, parameter ENCODE_W = $clog2(DECODE_W));
static function logic [ENCODE_W-1:0] ENCODER_f
(input logic [DECODE_W-1:0] DecodeIn);
ENCODER_f = '0;
for (int i=0; i<DECODE_W; i++) begin
if(DecodeIn[i]) begin
ENCODER_f = i[ENCODE_W-1:0];
break;
end
334
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
end
endfunction
static function logic [DECODE_W-1:0] DECODER_f
(input logic [ENCODE_W-1:0] EncodeIn);
DECODER_f = '0;
DECODER_f[EncodeIn] = 1'b1;
endfunction
endclass
Class contains two static subroutines, and . Each subroutine is parameterized by
C ENCODER_f DECODER_f
reusing the class parameters and . The default value of parameter is
DECODE_W ENCODE_W ENCODE_W
determined by using the system function (see 20.8.1). These parameters are used within the
$clog2
subroutines to specify the size of the encoder and the size of the decoder.
module top ();
logic [7:0] encoder_in;
logic [2:0] encoder_out;
logic [1:0] decoder_in;
logic [3:0] decoder_out;
// Encoder and Decoder Input Assignments
assign encoder_in = 8'b0100_0000;
assign decoder_in = 2'b11;
// Encoder and Decoder Function calls
assign encoder_out = C#(8)::ENCODER_f(encoder_in);
assign decoder_out = C#(4)::DECODER_f(decoder_in);
initial begin
#50;
$display("Encoder input = %b Encoder output = %b\n",
encoder_in, encoder_out );
$display("Decoder input = %b Decoder output = %b\n",
decoder_in, decoder_out );
end
endmodule
The top level module first defines some intermediate variables used in this example, and then assigns
constant values to the encoder and decoder inputs. The subroutine call of the generic encoder, ,
ENCODER_f
uses the specialized class parameter value of 8 that represents the decoder width value for that specific
instance of the encoder while at the same time passing the input encoded value, . This
encoder_in
expression uses the static class scope resolution operator (see 8.23) to access the encoder subroutine. The
::
expression is assigned to an output variable to hold the result of the operation. The subroutine call for the
generic decoder, , is similar, using the parameter value of 4.
DECODER_f
335
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
14. Clocking blocks
14.1 General
This clause describes the following:
— Clocking block declarations
— Input and output skews
— Clocking block signal events
— Cycle delays
— Synchronous events
— Synchronous drives
14.2 Overview
Module port connections and interfaces can specify the signals or nets through which a testbench
communicates with a device under test (DUT). However, such specification does not explicitly denote any
timing disciplines, synchronization requirements, or clocking paradigms.
The clocking block construct identifies clock signals and captures the timing and synchronization
requirements of the blocks being modeled. A clocking block is defined between the keywords
clocking
and .
endclocking
A clocking block assembles signals that are synchronous to a particular clock and makes their timing
explicit. The clocking block is a key element in a cycle-based methodology, which enables users to write
testbenches at a higher level of abstraction. Rather than focusing on signals and transitions in time, the test
can be defined in terms of cycles and transactions. Depending on the environment, a testbench can contain
one or more clocking blocks, each containing its own clock plus an arbitrary number of signals.
The clocking block separates the timing and synchronization details from the structural, functional, and
procedural elements of a testbench. Thus, the timing for sampling and driving clocking block signals is
implicit and relative to the clocking block’s clock. This enables a set of key operations to be written very
succinctly, without explicitly using clocks or specifying timing. These operations are as follows:
— Synchronous events
— Input sampling
— Synchronous drives
14.3 Clocking block declaration
The syntax for the clocking block is as follows in Syntax14-1.
clocking_declaration ::= // from A.6.11
[ ] [ clocking_identifier ] clocking_event
default clocking ;
{ clocking_item }
[ clocking_identifier ]
endclocking :
| [ clocking_identifier ] clocking_event [ clocking_identifier ]
globalclocking ;endclocking :
clocking_event ::=
identifier
@
| event_expression
@ ( )
336
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
clocking_item ::=
default_skew
default ;
| clocking_direction list_of_clocking_decl_assign
;
| { attribute_instance } assertion_item_declaration
default_skew ::=
clocking_skew
input
| clocking_skew
output
| clocking_skew clocking_skew
input output
clocking_direction ::=
[ clocking_skew ]
input
| [ clocking_skew ]
output
| [ clocking_skew ] [ clocking_skew ]
input output
|
inout
list_of_clocking_decl_assign ::= clocking_decl_assign { clocking_decl_assign }
,
clocking_decl_assign ::= signal_identifier [ expression ]
=
clocking_skew ::=
edge_identifier [ delay_control ]
| delay_control
edge_identifier ::= | | // from A.7.4
posedge negedge edge
delay_control ::= // from A.6.5
delay_value
#
| mintypmax_expression
# ( )
Syntax14-1—Clocking block syntax (excerpt from AnnexA)
The delay_control shall be either a time literal or a constant expression that evaluates to a positive integer
value.
The clocking_identifier specifies the name of the clocking block being declared. Only default clocking
blocks may be unnamed. Declarations in unnamed clocking blocks may not be referenced.
The signal_identifier specifies a signal (a net or variable) in the scope enclosing the clocking block
declaration, and defines a clockvar in the clocking block. The specified signal is called a clocking signal.
Unless a hierarchical expression is used (see 14.5), both the clocking signal and the clockvar names shall be
the same. It shall be illegal for a clocking signal to designate a variable restricted to a procedural block (see
6.21).
The clocking_event designates a particular event to act as the clock for the clocking block. The timing used
to drive and sample all other signals specified in a given clocking block is governed by its clocking event.
See 14.13 and 14.16 for details on the precise timing semantics of sampling and driving clocking signals.
It shall be illegal to write to any clockvar whose clocking_direction is .
input
It shall be illegal to read the value of any clockvar whose clocking_direction is .
output
A clockvar whose clocking_direction is shall behave as if it were two clockvars, one and one
inout input
, having the same name and the same clocking_signal. Reading the value of such an clockvar
output inout
shall be equivalent to reading the corresponding clockvar. Writing to such an clockvar shall
input inout
be equivalent to writing to the corresponding clockvar.
output
337
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The clocking_skew determines how many time units away from the clock event a signal is to be sampled or
driven. Input skews are implicitly negative, that is, they always refer to a time before the clock, whereas
output skews always refer to a time after the clock (see 14.4). When the clocking event specifies a simple
edge, instead of a number, the skew can be specified as the specific edge of the signal. A single skew can be
specified for the entire block by using a clocking item.
default
clocking ck1 @(posedge clk);
default input #1step output negedge; // legal
// outputs driven on the negedge clk
input ... ;
output ... ;
endclocking
clocking ck2 @(clk); // no edge specified!
default input #1step output negedge; // legal
input ... ;
output ... ;
endclocking
The expression assigned to the clockvar specifies that the signal to be associated with the clocking block is
associated with the specified hierarchical expression. For example, a cross-module reference can be used
instead of a local port. See 14.5 for more information.
Example:
clocking bus @(posedge clock1);
default input #10ns output #2ns;
input data, ready, enable = top.mem1.enable;
output negedge ack;
input #1step addr;
endclocking
In the preceding example, the first line declares a clocking block called that is to be clocked on the
bus
positive edge of the signal . The second line specifies that by default all signals in the clocking block
clock1
shall use a input skew and a output skew. The next line adds three input signals to the clocking
10ns 2ns
block: , , and ; the last signal refers to the hierarchical signal . The
data ready enable top.mem1.enable
fourth line adds the signal to the clocking block and overrides the default output skew so that is
ack ack
driven on the negative edge of the clock. The last line adds the signal and overrides the default input
addr
skew so that is sampled one step before the positive edge of the clock.
addr
Unless otherwise specified, the default skew is and the default skew is . A step is a
input 1step output 0
special time unit whose value is defined in 3.14.3. A input skew allows input signals to sample their
1step
steady-state values in the time step immediately before the clock event (i.e., in the preceding Postponed
region).
14.4 Input and output skews
Input (or inout) signals are sampled at the designated clock event. If an input skew is specified, then the
signal is sampled at skew time units before the clock event. Similarly, output (or inout) signals are driven
skew simulation time units after the corresponding clock event. Figure14-1 shows the basic sample and
drive timing for a positive edge clock.
338
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
signal sampled here signal driven here
clock
input skew output skew
Figure14-1—Sample and drive times including skew
with respect to the positive edge of the clock
A skew shall be a constant expression and can be specified as a parameter. If the skew does not specify a
time unit, the current time unit is used. If a number is used, the skew is interpreted using the timescale of the
current scope.
clocking dram @(clk);
input #1ps address;
input #5 output #6 data;
endclocking
An input skew of indicates that the signal is to be sampled at the end of the previous time step. In
1step
other words, the value sampled is always the signal’s last value immediately before the corresponding clock
edge.
NOTE—A clocking block does not eliminate potential races when an event control outside a program block is sensitive
to the same clock as the clocking block and a statement after the event control attempts to read a member of the clocking
block. The race is between reading the old sampled value and the new sampled value.
Inputs with explicit #0 skew shall be sampled at the same time as their corresponding clocking event, but to
avoid races, they are sampled in the Observed region. Likewise, clocking block outputs with no skew (or
explicit #0 skew) shall be driven at the same time as their specified clocking event, in the Re-NBA region.
Skews are declarative constructs; thus, they are semantically very different from the syntactically similar
procedural delay statement. In particular, an explicit #0 skew does not suspend any process, nor does it
execute or sample values in the Inactive region.
14.5 Hierarchical expressions
Any signal in a clocking block can be associated with an arbitrary hierarchical expression. As described in
14.3, a hierarchical expression is introduced by appending an equal sign ( ) followed by the hierarchical
=
expression:
clocking cd1 @(posedge phi1);
input #1step state = top.cpu1.state;
endclocking
However, hierarchical expressions are not limited to simple names or signals in other scopes. They can be
used to declare slices and concatenations (or combinations thereof) of signals in other scopes or in the
current scope.
339
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
clocking mem @(clock);
input instruction = { opcode, regA, regB[3:1] };
endclocking
In a clocking block, any expression assigned to a signal in its declaration shall be an expression that would
be legal in a port connection to a port of appropriate direction. Any expression assigned to a signal in a
clocking or declaration shall be an expression that would be legal for connection to a
input inout
module’s input port. Any expression assigned to a signal in a clocking or declaration shall
output inout
be an expression that would be legal for connection to a module’s output port.
A clocking declaration is not an inout port; it is shorthand for two clocking declarations, one input
inout
and one output, with the same signal. Consequently, such a signal must meet the requirements for both a
clocking input and a clocking output, but it is not required to meet the stricter requirements for connection to
a module’s inout port. In particular, it is acceptable to specify a variable as a clocking inout signal.
14.6 Signals in multiple clocking blocks
The same signals—clock, inputs, inouts, or outputs—can appear in more than one clocking block. When
clocking blocks use the same clock (or clocking expression), they shall share the same synchronization
event, in the same manner as several latches can be controlled by the same clock. Input semantics is
described in 14.13, and output semantics is described in 14.16.
14.7 Clocking block scope and lifetime
A clocking block is both a declaration and an instance of that declaration. A separate instantiation step is not
necessary. Instead, one copy is created for each instance of the block containing the declaration (like an
always procedure). Once declared, the clocking signals are available via the clocking block name and the dot
( ) operator:
.
dom.sig // signal sig in clocking dom
Multiple clocking blocks cannot be nested. They cannot be declared inside functions, tasks, or packages or
outside all declarations in a compilation unit. A clocking block can only be declared inside a module,
interface, checker, or program (see Clause24).
A clocking block has static lifetime and scope local to its enclosing module, interface, or program.
14.8 Multiple clocking blocks example
In this example, a simple test program includes two clocking blocks. The program construct used in this
example is discussed in Clause24.
program test( input phi1, input [15:0] data, output logic write,
input phi2, inout [8:1] cmd, input enable
);
reg [8:1] cmd_reg;
clocking cd1 @(posedge phi1);
input data;
output write;
input state = top.cpu1.state;
endclocking
340
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
clocking cd2 @(posedge phi2);
input #2 output #4ps cmd;
input enable;
endclocking
initial begin
// program begins here
...
// user can access cd1.data , cd2.cmd , etc…
end
assign cmd = enable ? cmd_reg: 'x;
endprogram
The test program can be instantiated and connected to a DUT ( and ).
cpu mem
module top;
logic phi1, phi2;
wire [8:1] cmd; // cannot be logic (two bidirectional drivers)
logic [15:0] data;
test main (phi1, data, write, phi2, cmd, enable);
cpu cpu1 (phi1, data, write);
mem mem1 (phi2, cmd, enable);
endmodule
14.9 Interfaces and clocking blocks
A clocking block encapsulates a set of signals that share a common clock; therefore, specifying a clocking
block using a SystemVerilog (see Clause25) can significantly reduce the amount of code
interface
needed to connect the testbench. Furthermore, because the signal directions in the clocking block within the
testbench are with respect to the testbench and not the design under test, a declaration (see 25.5)
modport
can appropriately describe either direction. A testbench program can be contained within a program, and its
ports can be interfaces that correspond to the signals declared in each clocking block. The interface’s wires
would have the same direction as specified in the clocking block when viewed from the testbench side (i.e.,
) and reversed when viewed from the DUT (i.e., ).
modport test modport dut
For example, the previous example could be rewritten using interfaces as follows:
interface bus_A (input clk);
logic [15:0] data;
logic write;
modport test (input data, output write);
modport dut (output data, input write);
endinterface
interface bus_B (input clk);
logic [8:1] cmd;
logic enable;
modport test (input enable);
modport dut (output enable);
endinterface
program test( bus_A.test a, bus_B.test b );
clocking cd1 @(posedge a.clk);
input data = a.data;
output write = a.write;
341
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
inout state = top.cpu1.state;
endclocking
clocking cd2 @(posedge b.clk);
input #2 output #4ps cmd = b.cmd;
input en = b.enable;
endclocking
initial begin
// program begins here
...
// user can access cd1.data, cd1.write, cd1.state,
// cd2.cmd, and cd2.en
end
endprogram
The test module can be instantiated and connected as before:
module top;
logic phi1, phi2;
bus_A a (phi1);
bus_B b (phi2);
test main (a, b);
cpu cpu1 (a);
mem mem1 (b);
endmodule
14.10 Clocking block events
The clocking event of a clocking block is available directly by using the clocking block name, regardless of
the actual clocking event used to declare the clocking block.
For example:
clocking dram @(posedge phi1);
inout data;
output negedge #1 address;
endclocking
The clocking event of the clocking block can be used to wait for that particular event:
dram
@(dram);
The preceding statement is equivalent to .
@(posedge phi1)
14.11 Cycle delay: ##
The operator can be used to delay execution by a specified number of clocking events or clock cycles.
##
The syntax for the cycle delay statement is as follows in Syntax14-2.
342
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
procedural_timing_control_statement ::= // from A.6.5
procedural_timing_control statement_or_null
procedural_timing_control ::=
...
| cycle_delay
cycle_delay ::= // from A.6.11
integral_number
##
| identifier
##
| expression
## ( )
Syntax14-2—Cycle delay syntax (excerpt from AnnexA)
The expression can be any SystemVerilog expression that evaluates to a positive integer value.
What constitutes a cycle is determined by the default clocking in effect (see 14.12). If no default clocking
has been specified for the current module, interface, checker, or program, then the compiler shall issue an
error.
Example:
##5; // wait 5 cycles (clocking events) using the default clocking
##(j + 1); // wait j+1 cycles (clocking events) using the default clocking
The cycle delay timing control shall wait for the specified number of clocking events. This implies that for a
statement that is executed at a simulation time that is not coincident with the associated clocking event,
##1
the calling process shall be delayed a fraction of the associated clock cycle.
Cycle delays of are treated specially. If a clocking event has not yet occurred in the current time step, a
##0
cycle delay shall suspend the calling process until the clocking event occurs. When a process executes a
##0
cycle delay and the associated clocking event has already occurred in the current time step, the process
##0
shall continue execution without suspension. When used on the right-hand side of a synchronous drive, a
cycle delay shall have no effect, as if it were not present.
##0
Cycle delay timing controls shall not be legal for use in intra-assignment delays in either blocking or
nonblocking assignment statements.
14.12 Default clocking
One clocking block can be specified as the default for all cycle delay operations within a given module,
interface, program, or checker.
The syntax for default clocking specification statement is as follows in Syntax14-3.
module_or_generate_item_declaration ::= // from A.1.4
...
| clocking_identifier
defaultclocking ;
...
checker_or_generate_item_declaration ::= // from A.1.8
...
343
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| clocking_identifier
defaultclocking ;
...
clocking_declaration ::= // from A.6.11
[ ] [ clocking_identifier ] clocking_event
default clocking ;
{ clocking_item }
[ clocking_identifier ]
endclocking :
...
Syntax14-3—Default clocking syntax (excerpt from AnnexA)
The clocking_identifier shall be the name of a clocking block.
Only one default clocking can be specified in a module, interface, program, or checker. Specifying a default
clocking more than once in the same module, interface, program, or checker shall result in a compiler error.
A default clocking is valid only within the scope containing the default clocking specification statement.
This scope includes the module, interface, program, or checker that contains the declaration as well as any
nested modules, interfaces, or checkers. It does not include instantiated modules, interfaces, or checkers.
Example 1: Declaring a clocking as the default:
program test(input logic clk, input logic [15:0] data);
default clocking bus @(posedge clk);
inout data;
endclocking
initial begin
## 5;
if (bus.data == 10)
## 1;
else
...
end
endprogram
Example 2: Assigning an existing clocking to be the default:
module processor ...
clocking busA @(posedge clk1); ... endclocking
clocking busB @(negedge clk2); ... endclocking
module cpu( interface y );
default clocking busA ;
initial begin
## 5; // use busA => (posedge clk1)
...
end
endmodule
endmodule
14.13 Input sampling
All clocking block inputs (input or inout) are sampled at the corresponding clocking event. If the input skew
is not an explicit , then the value sampled corresponds to the signal value at the Postponed region of the
#0
time step skew time units prior to the clocking event (see Figure14-1 in 14.4). If the input skew is an
explicit , then the value sampled corresponds to the signal value in the Observed region. In this case, the
#0
344
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
newly sampled values shall be available for reading at the end of the Observed region processing. If upon
processing the Reactive region, the simulation must process Active events without advancing time (thereby
executing the Observed region more than once), clocking inputs sampled with skew shall not be
#0
resampled unless a new clocking event occurs in the active region set.
NOTE—When the clocking event is triggered by the execution of a program, there is a potential race between the update
of a clocking block input value and programs that read that value without synchronizing with the corresponding clocking
event. This race does not exist when the clocking block event is triggered from within a module.
Upon processing its specified clocking event, a clocking block shall update its sampled values before
triggering the event associated with the clocking block name. This event shall be triggered in the Observed
region. Thus, a process that waits for the clocking block itself is guaranteed to read the updated sampled
values, regardless of the scheduling region in which either the waiting or the triggering processes execute.
For example:
clocking cb @(negedge clk);
input v;
endclocking
always @(cb) $display(cb.v);
always @(negedge clk) $display(cb.v);
The preceding first procedure is guaranteed to display the updated sampled value of signal . In
always v
contrast, the second always exhibits a potential race and may display the old or the newly updated sampled
value.
When an or clockvar appears in any expression its value is the signal’s sampled value; that is,
input inout
the value that the clocking block sampled at the most recent clocking event.
When the same signal is an input to multiple clocking blocks, the semantics is straightforward; each
clocking block samples the corresponding signal with its own clocking event.
14.14 Global clocking
A clocking block may be declared as the global clocking for all or part of the design hierarchy. The main
purpose of global clocking is to specify which clocking event in simulation corresponds to the primary
system clock used in formal verification (see F.3.1). Such a specification may be done for a whole design, or
separately for different subsystems in a design, when there are multiple clocks and building a single global
clocking event is challenging.
The syntax for the global clocking declaration is as follows in Syntax14-4.
clocking_declaration ::= // from A.6.11
...
| [ clocking_identifier ] clocking_event [ clocking_identifier ]
globalclocking ;endclocking :
Syntax14-4—Global clocking syntax (excerpt from AnnexA)
Global clocking may be declared in a module, an interface, a checker, or a program. A given module,
interface, checker, or program shall contain at most one global clocking declaration. Global clocking shall
not be declared in a generate block.
345
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Although more than one global clocking declaration may appear in different parts of the design hierarchy, at
most one global clocking declaration is effective at each point in the elaborated design hierarchy. The
system function shall be used to explicitly refer to the event expression in the effective
$global_clock
global clocking declaration. The effective global clocking declaration for a specific reference is determined
using the following hierarchical lookup rules, which iteratively check the design hierarchy to find the global
clocking declaration closest to the point of reference.
a) Look for a global clocking declaration in the enclosing module, interface, checker, or program
instance scope. If found, the lookup terminates with the result being the event expression of that
global clocking declaration. If not found and the current scope is a top-level hierarchy block (see
3.11), the lookup terminates and shall result in an error. Otherwise, proceed to step b).
b) Look for a global clocking declaration in the parent module, interface, or checker instance scope of
the enclosing instantiation. If found, the lookup terminates with the result being the event expression
of that global clocking declaration. Otherwise, continue up the hierarchy until a global clocking dec-
laration is found or a top-level hierarchy block is reached. If no global clocking declaration is found
and a top-level hierarchy block is reached, the lookup terminates and shall result in an error.
When global clocking is referenced in a sequence declaration, a property declaration, or as an actual
argument to a named sequence instance, a named property instance, or a checker instance, the point of
reference shall be considered after the application of the rewriting algorithms defined in F.4. As a result,
when a property or a sequence declaration is instantiated in an assertion statement, the hierarchical lookup
rules described previously shall be applied from the point of the assertion statement appearance in the source
description, not from the point of the sequence or the property declaration. Similarly, the lookup rules shall
be applied after the substitution of the actual argument in place of the corresponding formal argument inside
the checker body.
The following is an example of a declaration:
globalclocking
module top;
logic clk1, clk2;
global clocking sys @(clk1 or clk2); endclocking
// ...
endmodule
In this example, is declared as the global clocking event and is defined to occur if, and only if, there is a
sys
change of either of two signals, and . Specification of the name in the global clocking
clk1 clk2 sys
declaration is optional since the global clocking event may be referenced by .
$global_clock
In the following example the design hierarchy contains two global clocking declarations. The call to
in resolves to the clocking event . The call to
$global_clock top.sub1.common top.sub1.sub_sys1
in resolves to the clocking event .
$global_clock top.sub2.common top.sub2.sub_sys2
module top;
subsystem1 sub1();
subsystem2 sub2();
endmodule
module subsystem1;
logic subclk1;
global clocking sub_sys1 @(subclk1); endclocking
// ...
common_sub common();
endmodule
module subsystem2;
logic subclk2;
346
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
global clocking sub_sys2 @(subclk2); endclocking
// ...
common_sub common();
endmodule
module common_sub;
always @($global_clock) begin
// ...
end
endmodule
In the following example the property is declared in a module containing a global clocking declaration.
p
However, that global clocking declaration is not effective where the property is instantiated. Similar to the
p
previous example, the call to in resolves to the clocking event
$global_clock top.sub1.checks
, and the call to in resolves to the clocking
top.sub1.sub_sys1 $global_clock top.sub2.checks
event .
top.sub2.sub_sys2
module top;
subsystem1 sub1();
subsystem2 sub2();
endmodule
module subsystem1;
logic subclk1, req, ack;
global clocking sub_sys1 @(subclk1); endclocking
// ...
common_checks checks(req, ack);
endmodule
module subsystem2;
logic subclk2, req, ack;
global clocking sub_sys2 @(subclk2); endclocking
// ...
common_checks checks(req, ack);
endmodule
module another_module;
logic another_clk;
global clocking another_clocking @(another_clk); endclocking
// ...
property p(req, ack);
@($global_clock) req |=> ack;
endproperty
endmodule
checker common_checks(logic req, logic ack);
assert property (another_module.p(req, ack));
endchecker
In the following example, is used in a task. The call to in the task
$global_clock $global_clock
resolves to the clocking event .
another_module.t another_module.another_clocking
module top;
subsystem1 sub1();
subsystem2 sub2();
endmodule
module subsystem1;
347
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
logic subclk1, req, ack;
global clocking sub_sys1 @(subclk1); endclocking
// ...
always another_module.t(req, ack);
endmodule
module subsystem2;
logic subclk2, req, ack;
global clocking sub_sys2 @(subclk2); endclocking
// ...
always another_module.t(req, ack);
endmodule
module another_module;
logic another_clk;
global clocking another_clocking @(another_clk); endclocking
task t(input req, input ack);
@($global_clock);
// ...
endtask
endmodule
The following example demonstrates the usage of in checker arguments. The resolution of
$global_clock
the calls to is performed after the substitution of the actual checker arguments in place of
$global_clock
the corresponding formal arguments, and flattening of the properties in the assertion statements. All calls to
in this example refer to the clocking event .
$global_clock top.check.checker_clocking
module top;
logic a, b, c, clk;
global clocking top_clocking @(clk); endclocking
// ...
property p1(req, ack);
@($global_clock) req |=> ack;
endproperty
property p2(req, ack, interrupt);
@($global_clock) accept_on(interrupt) p1(req, ack);
endproperty
my_checker check(
p2(a, b, c),
@$global_clock a[*1:$] ##1 b);
endmodule
checker my_checker(property p, sequence s);
logic checker_clk;
global clocking checker_clocking @(checker_clk); endclocking
// ...
assert property (p);
cover property (s);
endchecker
NOTE—This is an area of backward incompatibility between this standard and 14.14 of IEEE Std 1800-2009. In the
2009 definition, only one global clocking declaration was allowed in the elaborated design description; it could be
specified in any module, interface, or checker and referenced everywhere in the description. A design conforming to
IEEE Std 1800-2009 could have a global clocking declaration defined in a non-top-level module and use
outside the subhierarchy of that module. Such a design shall not conform to this standard.
$global_clock
348
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
14.15 Synchronous events
Explicit synchronization is done via the event control operator, , which allows a process to wait for a
@
particular signal value change or a clocking event (see 14.10).
The syntax for the synchronization operator is given in 9.4.2.
The expression used with the event control can denote clocking block input ( or ) or a slice
input inout
thereof. Slices can include dynamic indices, which are evaluated once when the expression executes.
@
Following are some examples of synchronization statements:
— Wait for the next change of signal of clocking block
ack_1 ram_bus
@(ram_bus.ack_l);
— Wait for the next clocking event in clocking block
ram_bus
@(ram_bus);
— Wait for the positive edge of the signal
ram_bus.enable
@(posedge ram_bus.enable);
— Wait for the falling edge of the specified 1-bit slice
dom.sign[a]
@(negedge dom.sign[a]);
NOTE—The index is evaluated at run time.
a
— Wait for either the next positive edge of or the next change of , whichever
dom.sig1 dom.sig2
happens first
@(posedge dom.sig1 or dom.sig2);
— Wait for either the negative edge of or the positive edge of , whichever
dom.sig1 dom.sig2
happens first
@(negedge dom.sig1 or posedge dom.sig2);
— Wait for the edge (either the negative edge or the positive edge, whichever happens first) of
.
dom.sig1
@(edge dom.sig1);
Or equivalently
@(negedge dom.sig1 or posedge dom.sig1);
The values used by the synchronization event control are the synchronous values, that is, the values sampled
at the corresponding clocking event.
14.16 Synchronous drives
Clocking block outputs ( or ) are used to drive values onto their corresponding signals, but at
output inout
a specified time. In other words, the corresponding signal changes value at the indicated clocking event as
modified by the output skew.
For zero skew clocking block outputs with no cycle delay, synchronous drives shall schedule new values in
the Re-NBA region of the time step corresponding to the clocking event. For clocking block outputs with
349
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
nonzero skew, or drives with nonzero cycle delay, the corresponding signal shall be scheduled to change
value in the Re-NBA region of a future time step.
For each clocking block output whose target is a net, a driver on that net shall be created. The driver so
created shall have ( , ) drive strength and shall be updated as if by a continuous
strong1 strong0
assignment from a variable inside the clocking block. This implicit variable, which is invisible to user code,
shall be updated in the Re-NBA region by the execution of a synchronous drive to the corresponding
clockvar. The created driver shall be initialized to ; hence, the driver has no influence on its target net
'z
until a synchronous drive is performed to the corresponding clockvar.
The syntax to specify a synchronous drive is similar to an assignment and is shown in Syntax14-5.
statement ::= [ block_identifier ] { attribute_instance } statement_item // from A.6.4
:
statement_item ::=
...
| clocking_drive
;
clocking_drive ::= // from A.6.11
clockvar_expression [ cycle_delay ] expression
<=
cycle_delay ::= expression
##
clockvar ::= hierarchical_identifier
clockvar_expression ::= clockvar select
Syntax14-5—Synchronous drive syntax (excerpt from AnnexA)
The clockvar_expression is a bit-select, slice, or the entire clocking block output whose corresponding
signal is to be driven (concatenation is not allowed):
dom.sig // entire clockvar
dom.sig[2] // bit-select
dom.sig[8:2] // slice
The expression (in the clocking_drive production) can be any valid expression that is assignment compatible
with the type of the corresponding signal.
The optional cycle_delay construct, appearing on the right-hand side of a clocking_drive statement, is
syntactically similar to an intra-assignment delay in a nonblocking assignment. Like a nonblocking intra-
assignment delay, it shall not cause execution of the statement to block. The right-hand side expression shall
be evaluated immediately even when a cycle_delay is present. However, updating of the target signal shall
be postponed for the specified number of cycles of the target clockvar’s clocking block, plus any clocking
output skew specified for that clockvar.
No other form of intra-assignment delay syntax shall be legal in a synchronous drive to a clockvar.
A procedural cycle delay, as described in 14.11, can be used as a prefix to any procedural statement. If a
procedural cycle delay is used as a prefix to a synchronous drive, it shall block for its specified number of
cycles of the default clocking exactly as it would if used as a prefix to any other procedural statement.
350
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Examples:
bus.data[3:0] <= 4'h5; // drive data in Re-NBA region of the current cycle
##1 bus.data <= 8'hz; // wait 1 default clocking cycle, then drive data
##2; bus.data <= 2; // wait 2 default clocking cycles, then drive data
bus.data <= ##2 r; // remember the value of r and then drive
// data 2 (bus) cycles later
bus.data <= #4 r; // error: regular intra-assignment delay not allowed
// in synchronous drives
Regardless of whether the synchronous drive takes effect on the current clocking event or at some future
clocking event as a result of a cycle_delay, the corresponding signal shall be updated at a time after that
clocking event as specified by the output skew.
It is possible for a drive statement to execute at a time that is not coincident with its clocking event. Such
drive statements shall execute without blocking, but shall perform their drive action as if they had executed
at the time of the next clocking event. The expression on the right-hand side of the drive statement shall be
evaluated immediately, but the processing of the drive is delayed until the time of the next clocking event.
For example:
default clocking cb @(posedge clk); // Assume clk has a period of #10 units
output v;
endclocking
initial begin
#3 cb.v <= expr1; // Matures in cycle 1; equivalent to ##1 cb.v <= expr1
end
It shall be an error to write to a clockvar except by using the synchronous drive syntax described in this
subclause. Thus, it is illegal to use any continuous assignment, force statement, or procedural continuous
assignment to write to a clockvar.
14.16.1 Drives and nonblocking assignments
Although synchronous drives use the same operator syntax as nonblocking variable assignments, they are
not the same. One difference is that synchronous drives do not support intra-assignment delay syntax. A key
feature of synchronous drives to inout clockvars is that a drive does not change the clocking block input.
This is because reading the input always yields the last sampled value, and not the driven value.
For example, consider the following code:
clocking cb @(posedge clk);
inout a;
output b;
endclocking
initial begin
cb.a <= c; // The value of a will change in the Re-NBA region
cb.b <= cb.a; // b is assigned the value of a before the change
end
351
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
14.16.2 Driving clocking output signals
When more than one synchronous drive on the same clocking block output (or inout) is scheduled to mature
in the same Re-NBA region of the same time step, the last value is the only value driven onto the output
signal. This is true whether the synchronous drives execute at times coincident with clocking events, or at
times in between clocking events (within the same clock cycle).
For example:
default clocking pe @(posedge clk);
output nibble; // four bit output
endclocking
initial begin
##2;
pe.nibble <= 4'b0101;
pe.nibble <= 4'b0011;
end
The driven value of is , regardless of whether is a variable or a net.
nibble 4'b0011 nibble
It is possible for the scheduling loop described in 4.4 to iterate through the Re-NBA region more than once
in a given time step. If this happens, synchronous drives will cause their associated clocking signal to glitch
(i.e., change value more than once in a time step) if they assign different values to their associated clockvar
in different iterations of the scheduling loop.
In the following example, variable will glitch 1 –> 0 –> 1 at the first posedge of .
a clk
module m;
bit a = 1'b1;
default clocking cb @(posedge clk);
output a;
endclocking
initial begin
## 1;
cb.a <= 1'b0;
@(x); // x is triggered by reactive stimulus running in same time step
cb.a <= 1'b1;
end
endmodule
If a given clocking output is driven by multiple synchronous drives that are scheduled to mature at different
future times due to the use of cycle delay, the drives shall each mature in their corresponding future cycles.
For example:
bit v;
default clocking cb @(posedge clk);
output v;
endclocking
initial begin
##1; // Wait until cycle 1
cb.v <= expr1; // Matures in cycle 1, v is assigned expr1
cb.v <= ##2 expr2; // Matures in cycle 3
#1 cb.v <= ##2 expr3; // Matures in cycle 3
352
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
##1 cb.v <= ##1 expr4; // Matures in cycle 3, v is assigned expr4
end
When the same variable is an output from multiple clocking blocks, the last drive determines the value of the
variable. This allows a single module to model multirate devices, such as a DDR memory, using a different
block to model each active edge. For example:
clocking
reg j;
clocking pe @(posedge clk);
output j;
endclocking
clocking ne @(negedge clk);
output j;
endclocking
The variable is an output from two clocking blocks using different clocking events,
j @(posedge clk)
versus . When driven, the variable shall take on the value most recently assigned by
@(negedge clk) j
either block. A clocking block output only assigns a value to its associated signal in clock cycles
clocking
where a synchronous drive occurs.
With the event, this is equivalent to the following simplified declaration:
edge
reg j;
clocking e @(edge clk);
output j;
endclocking
Multiple clocking block outputs driving a net cause the net to be driven to its resolved signal value. As
described in 14.16, when a clocking block output corresponds to a net, a driver on that net is created. This
semantic model applies to each clocking block output that drives the net. The driving values of all these
driver(s), together with any other drivers on the net, shall be resolved as determined by the net’s type.
It is possible to use a procedural assignment to assign to a signal associated with an output clockvar. When
the associated signal is a variable, the procedural assignment assigns a new value to the variable, and the
variable shall hold that value until another assignment occurs (either from a drive to a clocking block output
or another procedural assignment).
If a synchronous drive and a procedural nonblocking assignment write to the same variable in the same time
step, the writes shall take place in an arbitrary order.
It shall be illegal to write to a variable with a continuous assignment, a procedural continuous assignment, or
a primitive when that variable is associated with an output clockvar.
353
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
15. Interprocess synchronization and communication
15.1 General
This clause describes the following:
— Semaphores
— Mailboxes
— Named events
15.2 Overview
High-level and easy-to-use synchronization and communication mechanisms are essential to control the
kinds of interactions that occur between dynamic processes used to model a complex system or a highly
reactive testbench.
The basic synchronization mechanism is the named event type, along with the event trigger and event
control constructs (i.e., and ). This type of control is limited to static objects. It is adequate for
-> @
synchronization at the hardware level and simple system level, but falls short of the needs of a highly
dynamic, reactive testbench.
SystemVerilog also provides a powerful and easy-to-use set of synchronization and communication
mechanisms that can be created and reclaimed dynamically. This set comprises of a semaphore built-in
class, which can be used for synchronization and mutual exclusion to shared resources, and a mailbox
built-in class, which can be used as a communication channel between processes.
Semaphores and mailboxes are built-in types; nonetheless, they are classes and can be used as base classes
for deriving additional higher level classes. These built-in classes reside in the built-in package (see
std
26.7); thus, they can be redefined by user code in any other scope.
15.3 Semaphores
Conceptually, a semaphore is a bucket. When a semaphore is allocated, a bucket that contains a fixed
number of keys is created. Processes using semaphores must first procure a key from the bucket before they
can continue to execute. If a specific process requires a key, only a fixed number of occurrences of that
process can be in progress simultaneously. All others must wait until a sufficient number of keys is returned
to the bucket. Semaphores are typically used for mutual exclusion, access control to shared resources, and
basic synchronization.
An example of creating a semaphore is as follows:
semaphore smTx;
Semaphore is a built-in class that provides the following methods:
— Create a semaphore with a specified number of keys:
new()
— Obtain one or more keys from the bucket:
get()
— Return one or more keys into the bucket:
put()
— Try to obtain one or more keys without blocking:
try_get()
354
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
15.3.1 New()
Semaphores are created with the method.
new()
The prototype for is as follows:
new()
function new(int keyCount = 0 );
The specifies the number of keys initially allocated to the semaphore bucket. The number of keys
keyCount
in the bucket can increase beyond when more keys are put into the semaphore than are removed.
keyCount
The default value for is 0.
keyCount
The function returns the semaphore handle.
new()
15.3.2 Put()
The semaphore method is used to return keys to a semaphore.
put()
The prototype for is as follows:
put()
function void put(int keyCount = 1);
The specifies the number of keys being returned to the semaphore. The default is 1.
keyCount
When the function is called, the specified number of keys is returned to the semaphore.
semaphore.put()
If a process has been suspended waiting for a key, that process shall execute if enough keys have been
returned.
15.3.3 Get()
The semaphore method is used to procure a specified number of keys from a semaphore.
get()
The prototype for is as follows:
get()
task get(int keyCount = 1);
The specifies the required number of keys to obtain from the semaphore. The default is 1.
keyCount
If the specified number of keys is available, the method returns and execution continues. If the specified
number of keys is not available, the process blocks until the keys become available.
The semaphore waiting queue is first-in first-out (FIFO). This does not guarantee the order in which
processes arrive at the queue, only that their arrival order shall be preserved by the semaphore.
15.3.4 Try_get()
The semaphore method is used to procure a specified number of keys from a semaphore, but
try_get()
without blocking.
The prototype for is as follows:
try_get()
function int try_get(int keyCount = 1);
The specifies the required number of keys to obtain from the semaphore. The default is 1.
keyCount
355
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If the specified number of keys is available, the method returns a positive integer and execution continues. If
the specified number of keys is not available, the method returns 0.
15.4 Mailboxes
A mailbox is a communication mechanism that allows messages to be exchanged between processes. Data
can be sent to a mailbox by one process and retrieved by another.
Conceptually, mailboxes behave like real mailboxes. When a letter is delivered and put into the mailbox, a
person can retrieve the letter (and any data stored within). However, if the letter has not been delivered when
the mailbox is checked, the person must choose whether to wait for the letter or to retrieve the letter on a
subsequent trip to the mailbox. Similarly, SystemVerilog’s mailboxes provide processes to transfer and
retrieve data in a controlled manner. Mailboxes are created as having either a bounded or unbounded queue
size. A bounded mailbox becomes full when it contains the bounded number of messages. A process that
attempts to place a message into a full mailbox shall be suspended until enough room becomes available in
the mailbox queue. Unbounded mailboxes never suspend a thread in a send operation.
An example of creating a mailbox is as follows:
mailbox mbxRcv;
Mailbox is a built-in class that provides the following methods:
— Create a mailbox:
new()
— Place a message in a mailbox:
put()
— Try to place a message in a mailbox without blocking:
try_put()
— Retrieve a message from a mailbox: or
get() peek()
— Try to retrieve a message from a mailbox without blocking: or
try_get() try_peek()
— Retrieve the number of messages in the mailbox:
num()
15.4.1 New()
Mailboxes are created with the method.
new()
The prototype for mailbox is as follows:
new()
function new(int bound = 0);
The function returns the mailbox handle. If the argument is 0, then the mailbox is unbounded
new() bound
(the default) and a operation shall never block. If is nonzero, it represents the size of the
put() bound
mailbox queue.
The bound shall be positive. Negative bounds are illegal and can result in indeterminate behavior, but
implementations can issue a warning.
15.4.2 Num()
The number of messages in a mailbox can be obtained via the method.
num()
The prototype for is as follows:
num()
function int num();
356
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The method returns the number of messages currently in the mailbox.
num()
The returned value should be used with care because it is valid only until the next or is
get() put()
executed on the mailbox. These mailbox operations can be from different processes from the one executing
the method. Therefore, the validity of the returned value depends on the time that the other methods
num()
start and finish.
15.4.3 Put()
The method places a message in a mailbox.
put()
The prototype for is as follows:
put()
task put( singular message);
The is any singular expression, including object handles.
message
The method stores a message in the mailbox in strict FIFO order. If the mailbox was created with a
put()
bounded queue, the process shall be suspended until there is enough room in the queue.
15.4.4 Try_put()
The method attempts to place a message in a mailbox.
try_put()
The prototype for is as follows:
try_put()
function int try_put( singular message);
The is any singular expression, including object handles.
message
The method stores a message in the mailbox in strict FIFO order. This method is meaningful
try_put()
only for bounded mailboxes. If the mailbox is not full, then the specified message is placed in the mailbox,
and the function returns a positive integer. If the mailbox is full, the method returns 0.
15.4.5 Get()
The method retrieves a message from a mailbox.
get()
The prototype for is as follows:
get()
task get( ref singular message );
The can be any singular expression, and it shall be a valid left-hand expression.
message
The method retrieves one message from the mailbox, that is, removes one message from the mailbox
get()
queue. If the mailbox is empty, then the current process blocks until a message is placed in the mailbox. If
the type of the variable is not equivalent to the type of the message in the mailbox, a run-time error
message
is generated.
Nonparameterized mailboxes are typeless (see 15.4.9), that is, a single mailbox can send and receive
different types of data. Thus, in addition to the data being sent (i.e., the message queue), a mailbox
implementation shall maintain the message data type placed by . This is required in order to enable
put()
the run-time type checking.
357
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The mailbox waiting queue is FIFO. This does not guarantee the order in which processes arrive at the
queue, only that their arrival order shall be preserved by the mailbox.
15.4.6 Try_get()
The method attempts to retrieves a message from a mailbox without blocking.
try_get()
The prototype for is as follows:
try_get()
function int try_get( ref singular message );
The can be any singular expression, and it shall be a valid left-hand expression.
message
The method tries to retrieve one message from the mailbox. If the mailbox is empty, then the
try_get()
method returns 0. If the type of the variable is not equivalent to the type of the message in the
message
mailbox, the method returns a negative integer. If a message is available and the message type is equivalent
to the type of the variable, the message is retrieved, and the method returns a positive integer.
message
15.4.7 Peek()
The method copies a message from a mailbox without removing the message from the queue.
peek()
The prototype for is as follows:
peek()
task peek( ref singular message );
The can be any singular expression, and it shall be a valid left-hand expression.
message
The method copies one message from the mailbox without removing the message from the mailbox
peek()
queue. If the mailbox is empty, then the current process blocks until a message is placed in the mailbox. If
the type of the variable is not equivalent to the type of the message in the mailbox, a run-time error
message
is generated.
Calling the method can also cause one message to unblock more than one process. As long as a
peek()
message remains in the mailbox queue, any process blocked in either a or operation shall
peek() get()
become unblocked.
15.4.8 Try_peek()
The method attempts to copy a message from a mailbox without blocking.
try_peek()
The prototype for is as follows:
try_peek()
function int try_peek( ref singular message );
The can be any singular expression, and it shall be a valid left-hand expression.
message
The method tries to copy one message from the mailbox without removing the message from
try_peek()
the mailbox queue. If the mailbox is empty, then the method returns 0. If the type of the variable is
message
not equivalent to the type of the message in the mailbox, the method returns a negative integer. If a message
is available and its type is equivalent to the type of the message variable, the message is copied, and the
method returns a positive integer.
358
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
15.4.9 Parameterized mailboxes
The default mailbox is typeless, that is, a single mailbox can send and receive any type of data. This is a very
powerful mechanism, which, unfortunately, can also result in run-time errors due to type mismatches (types
not equivalent) between a message and the type of the variable used to retrieve the message. Frequently, a
mailbox is used to transfer a particular message type, and, in that case, it is useful to detect type mismatches
at compile time.
Parameterized mailboxes use the same parameter mechanism as parameterized classes (see 8.25), modules,
and interfaces:
mailbox #(type = dynamic_type)
where represents a special type that enables run-time type checking (the default).
dynamic_type
A parameterized mailbox of a specific type is declared by specifying the type:
typedef mailbox #(string) s_mbox;
s_mbox sm = new;
string s;
sm.put( "hello" );
...
sm.get( s ); // s <- "hello"
Parameterized mailboxes provide all the same standard methods as dynamic mailboxes: , ,
num() new()
, , , , , .
get() peek() put() try_get() try_peek() try_put()
The only difference between a generic (dynamic) mailbox and a parameterized mailbox is that for a
parameterized mailbox, the compiler verifies that the calls to , , , , , and
put try_put peek try_peek get
methods use argument types equivalent to the mailbox type so that all type mismatches are caught
try_get
by the compiler and not at run time.
15.5 Named events
An identifier declared as an event data type is called a named event. A named event can be triggered
explicitly. It can be used in an event expression to control the execution of procedural statements in the same
manner as event controls described in 9.4.2. A named event may also be used as a handle assigned from
another named event.
A named event provides a handle to an underlying synchronization object. When a process waits for an
event to be triggered, the process is put on a queue maintained within the synchronization object. Processes
can wait for a named event to be triggered either via the operator or by the use of the construct to
@ wait()
examine their triggered state.
15.5.1 Triggering an event
An event is made to occur by the activation of an event triggering statement with the syntax given in
Syntax15-1.
359
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
event_trigger ::= // from A.6.5
hierarchical_event_identifier
-> ;
| [ delay_or_event_control ] hierarchical_event_identifier
->> ;
Syntax15-1—Event trigger syntax (excerpt from AnnexA)
An event is not made to occur by changing the index of a named event array in an event control expression.
Named events triggered via the operator unblock all processes currently waiting on that event. When
->
triggered, named events behave like a one shot, i.e., the trigger state itself is not observable, only its effect.
This is similar to the way in which an edge can trigger a flip-flop, but the state of the edge cannot be
ascertained, i.e., is illegal.
if (posedge clock)
Nonblocking events are triggered using the operator. The effect of the operator is that the statement
->> ->>
executes without blocking, and it creates a nonblocking assign update event in the time in which the delay
control expires or the event control occurs. The effect of this update event shall be to trigger the referenced
event in the nonblocking assignment region of the simulation cycle.
15.5.2 Waiting for an event
The basic mechanism to wait for an event to be triggered is via the event control operator, .
@
@ hierarchical_event_identifier;
The operator blocks the calling process until the given event is triggered.
@
For a trigger to unblock a process waiting on an event, the waiting process shall execute the statement
@
before the triggering process executes the trigger operator, . If the trigger executes first, then the waiting
->
process remains blocked.
15.5.3 Persistent trigger: triggered built-in method
SystemVerilog can distinguish the event trigger itself, which is instantaneous, from the named event’s
triggered state, which persists throughout the time step (i.e., until simulation time advances). The
built-in method of a named event allows users to examine this state.
triggered
The prototype for the method is as follows:
triggered()
function bit triggered();
The method evaluates to true ( ) if the given event has been triggered in the current time
triggered 1'b1
step and false ( ) otherwise. If the named event is , then the method returns false.
1'b0 null triggered
The method is most useful when used in the context of a construct:
triggered wait
wait ( hierarchical_event_identifier.triggered )
Using this mechanism, an event trigger shall unblock the waiting process whether the executes before
wait
or at the same simulation time as the trigger operation. The method, thus, helps eliminate a
triggered
common race condition that occurs when both the trigger and the happen at the same time. A process
wait
that blocks waiting for an event might or might not unblock, depending on the execution order of the waiting
and triggering processes. However, a process that waits on the triggered state always unblocks, regardless of
the order of execution of the wait and trigger operations.
360
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example:
event done, blast; // declare two new events
event done_too = done; // declare done_too as alias to done
task trigger( event ev );
-> ev;
endtask
...
fork
@ done_too; // wait for done through done_too
#1 trigger( done ); // trigger done through task trigger
join
fork
-> blast;
wait ( blast.triggered );
join
The first fork in the example shows how two event identifiers, and , refer to the same
done done_too
synchronization object and also how an event can be passed to a generic task that triggers the event. In the
example, one process waits for the event via , while the actual triggering is done via the
done_too trigger
task that is passed as an argument.
done
In the second fork, one process can trigger the event before the other process (if the processes in the
blast
- execute in source order) has a chance to execute, and wait for the event. Nonetheless, the second
fork join
process unblocks and the fork terminates. This is because the process waits for the event’s triggered state,
which remains in its triggered state for the duration of the time step.
An event expression or wait condition is only reevaluated on a change to an operand in the expression, such
as the event prefix of the method. This means that the change of the return value of the
triggered
method from to at the end of the current time step will not affect an event control or
triggered 1'b1 1'b0
wait statement waiting on the method.
triggered
15.5.4 Event sequencing: wait_order()
The construct suspends the calling process until all of the specified events are triggered in the
wait_order
given order (left to right) or any of the untriggered events are triggered out of order and thus causes the
operation to fail.
The syntax for the construct is as follows in Syntax15-2.
wait_order
wait_statement ::= // from A.6.5
...
| hierarchical_identifier { hierarchical_identifier } action_block
wait_order( , )
action_block ::=
statement _or_null
| [ statement ] statement
else
Syntax15-2—Wait_order event sequencing syntax (excerpt from AnnexA)
361
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For to succeed, at any point in the sequence, the subsequent events, which shall all be
wait_order
untriggered at this point or the sequence would have already failed, shall be triggered in the prescribed order.
Preceding events are not limited to occur only once. In other words, once an event occurs in the prescribed
order, it can be triggered again without causing the construct to fail.
Only the first event in the list can wait for the persistent event.
triggered
The action taken when the construct fails depends on whether the optional action_block statement (the
else
fail statement) is specified. If it is specified, then the given statement is executed upon failure of the
construct. If the fail statement is not specified, a failure generates a run-time error.
For example:
wait_order( a, b, c);
suspends the current process until events , , and trigger in the order . If the events trigger
a b c a –> b –> c
out of order, a run-time error is generated.
For example:
wait_order( a, b, c ) else $display( "Error: events out of order" );
In this example, the fail statement specifies that, upon failure of the construct, a user message be displayed,
but without an error being generated.
For example:
bit success;
wait_order( a, b, c ) success = 1; else success = 0;
In this example, the completion status is stored in the variable , without an error being generated.
success
15.5.5 Operations on named event variables
An event is a unique data type with several important properties. Named events can be assigned to one
another. When one event is assigned to another, the synchronization queue of the source event is shared by
both the source and the destination event. In this sense, events act as full-fledged variables and not merely as
labels.
15.5.5.1 Merging events
When one event variable is assigned to another, the two become merged. Thus, executing on either event
->
variable affects processes waiting on either event variable.
For example:
event a, b, c;
a = b;
-> c;
-> a; // also triggers b
-> b; // also triggers a
a = c;
b = a;
-> a; // also triggers b and c
-> b; // also triggers a and c
362
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
-> c; // also triggers a and b
When events are merged, the assignment only affects the execution of subsequent event control or wait
operations. If a process is blocked waiting for when another event is assigned to , the
event1 event1
currently waiting process shall never unblock. For example:
fork
T1: forever @ E2;
T2: forever @ E1;
T3: begin
E2 = E1;
forever -> E2;
end
join
This example forks off three concurrent processes. Each process starts at the same time. Thus, at the same
time that processes and are blocked, process assigns event to . As a result, process shall
T1 T2 T3 E1 E2 T1
never unblock because the event is now . To unblock both threads and , the merger of and
E2 E1 T1 T2 E2 E1
must take place before the fork.
15.5.5.2 Reclaiming events
When an event variable is assigned the special value, the association between the event variable and
null
the underlying synchronization queue is broken. When no event variable is associated with an underlying
synchronization queue, the resources of the queue itself become available for reuse.
Triggering a event shall have no effect. The outcome of waiting on a event is undefined, and
null null
implementations can issue a run-time warning.
For example:
event E1 = null;
@ E1; // undefined: might block forever or not at all
wait( E1.triggered ); // undefined
-> E1; // no effect
15.5.5.3 Events comparison
Event variables can be compared against other event variables or the special value . Only the following
null
operators are allowed for comparing event variables:
— Equality ( ) with another event or with
== null
— Inequality ( ) with another event or with
!= null
— Case equality ( ) with another event or with (same semantics as )
=== null ==
— Case inequality ( ) with another event or with (same semantics as )
!== null !=
— Test for a Boolean value that shall be 0 if the event is and 1 otherwise
null
Example:
event E1, E2;
if ( E1 ) // same as if ( E1 != null )
E1 = E2;
if ( E1 == E2 )
$display( "E1 and E2 are the same event" );
363
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
16. Assertions
16.1 General
This clause describes the following:
— Immediate assertions
— Concurrent assertions
— Sequence specifications
— Property specifications
16.2 Overview
An assertion specifies a behavior of the system. Assertions are primarily used to validate the behavior of a
design. In addition, assertions can be used to provide functional coverage and to flag that input stimulus,
which is used for validation, does not conform to assumed requirements.
An assertion appears as an assertion statement that states the verification function to be performed. The
statement shall be of one of the following kinds:
— , to specify the property as an obligation for the design that is to be checked to verify that the
assert
property holds.
— , to specify the property as an assumption for the environment. Simulators check that the
assume
property holds, while formal tools use the information to generate input stimulus.
— , to monitor the property evaluation for coverage.
cover
— , to specify the property as a constraint on formal verification computations. Simulators
restrict
do not check the property.
There are two kinds of assertions: concurrent and immediate.
— Immediate assertions follow simulation event semantics for their execution and are executed like a
statement in a procedural block. Immediate assertions are primarily intended to be used with
simulation. There is no immediate assertion statement.
restrict
— Concurrent assertions are based on clock semantics and use sampled values of their expressions (see
16.5.1). One of the goals of SystemVerilog assertions is to provide a common semantic meaning for
assertions so that they can be used to drive various design and verification tools. Many tools, such as
formal verification tools, evaluate circuit descriptions using cycle-based semantics, which typically
rely on a clock signal or signals to drive the evaluation of the circuit. Any timing or event behavior
between clock edges is abstracted away. Concurrent assertions incorporate this clock semantics.
While this approach generally simplifies the evaluation of a circuit description, there are a number
of scenarios under which this cycle-based evaluation provides different behavior from the standard
event-based evaluation of SystemVerilog.
This clause describes both types of assertions.
16.3 Immediate assertions
The immediate assertion statement is a test of an expression performed when the statement is executed in the
procedural code. The expression is nontemporal and is interpreted the same way as an expression in the
condition of a procedural statement. In other words, if the expression evaluates to , , or , then it is
if X Z 0
interpreted as being false, and the assertion statement is said to fail. Otherwise, the expression is interpreted
as being true, and the assertion statement is said to pass or, equivalently, to succeed.
364
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
There are two modes of immediate assertions, simple immediate assertions and deferred immediate
assertions. In a simple immediate assertion, pass and fail actions take place immediately upon assertion
evaluation. In a deferred immediate assertion, the actions are delayed until later in the time step, providing
some level of protection against unintended multiple executions on transient or “glitch” values. Deferred
immediate assertions are described in detail in 16.4.
The immediate_assertion_statement is a statement_item and can be specified anywhere a procedural
statement is specified. The execution of immediate assertions can be controlled by using assertion control
system tasks (see 20.12).
procedural_assertion_statement ::= // from A.6.10
...
| immediate_assertion_statement
...
immediate_assertion_statement ::=
simple_immediate_assertion_statement
| deferred_immediate_assertion_statement
simple_immediate_assertion_statement ::=
simple_immediate_assert_statement
| simple_immediate_assume_statement
| simple_immediate_cover_statement
simple_immediate_assert_statement ::=
expression action_block
assert( )
simple_immediate_assume_statement ::=
expression action_block
assume( )
simple_immediate_cover_statement ::=
expression statement_or_null
cover( )
deferred_immediate_assertion_item ::= [ block_identifier ] deferred_immediate_assertion_statement
:
deferred_immediate_assertion_statement ::=
deferred_immediate_assert_statement
| deferred_immediate_assume_statement
| deferred_immediate_cover_statement
deferred_immediate_assert_statement ::=
expression action_block
assert#0( )
| expression action_block
assertfinal( )
deferred_immediate_assume_statement ::=
expression action_block
assume#0( )
| expression action_block
assumefinal( )
deferred_immediate_cover_statement ::=
expression statement_or_null
cover#0( )
| expression statement_or_null
coverfinal( )
action_block ::= // from A.6.3
statement _or_null
| [ statement ] statement_or_null
else
Syntax16-1—Immediate assertion syntax (excerpt from AnnexA)
An immediate assertion statement may be an immediate , an immediate , or an immediate
assert assume
.
cover
365
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The immediate statement specifies that its expression is required to hold. Failure of an immediate
assert
statement indicates a violation of the requirement and thus a potential error in the design. If an
assert
statement fails and no clause is specified, the tool shall, by default, call , unless
assert else $error
with 9 (FailOff) is used to suppress the failure.
$assertcontrol control_type
The immediate statement specifies that its expression is assumed to hold. For example, immediate
assume
statements can be used with formal verification tools to specify assumptions on design inputs that
assume
constrain the verification computation. When used in this way, they specify the expected behavior of the
environment of the design as opposed to that of the design itself. In simulation, an immediate assume may
behave as an immediate to verify that the environment behaves as assumed. A simulation tool shall
assert
provide the capability to check the immediate statement in this way.
assume
The action_block of an immediate or statement specifies what actions are taken upon
assert assume
success or failure of the assertion. The statement associated with success is the first statement. It is called the
pass statement and shall be executed if the expression evaluates to true. The pass statement can, for
example, record the number of successes for a coverage log, but can be omitted altogether. If the pass
statement is omitted, then no user-specified action is taken when the assert expression of the immediate
or statement is true. The statement associated with is called the fail statement and
assert assume else
shall be executed if the expression evaluates to false. The statement can also be omitted. The action
else
block shall be enabled to execute immediately after the evaluation of the assert expression of the immediate
or statement. The execution of pass and fail statements can be controlled by using assertion
assert assume
action control tasks. The assertion action control tasks are described in 20.12.
The immediate statement specifies that successful evaluation of its expression is a coverage goal.
cover
Tools shall collect coverage information and report the results at the end of simulation or on demand via an
assertion API (see Clause39). The results of coverage for an immediate statement shall contain the
cover
following:
— Number of times evaluated
— Number of times succeeded
A pass statement for an immediate may be specified in statement_or_null. The pass statement shall
cover
be executed if the expression evaluates to true. The pass statement shall be enabled to execute immediately
after the evaluation of the expression of the immediate .
cover
The optional statement label (identifier and colon) creates a named block around the assertion statement (or
any other statement), and the hierarchical name of the scope can be displayed using the format
%m
specification.
The information about assertion failure can be printed using one of the following severity system tasks in the
action block:
— is a run-time fatal.
$fatal
— is a run-time error.
$error
— is a run-time warning.
$warning
— indicates that the assertion failure carries no specific severity.
$info
The syntax for these severity system tasks is shown in 20.10.
The severity system tasks can be used in assertion pass or fail statements. These tasks shall print the same
tool-specific message when used either in a pass or a fail statement. For example:
assert_f: assert(f) $info("passed"); else $error("failed");
assume_inputs: assume (in_a || in_b) $info("assumption holds");
366
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
else $error("assumption does not hold");
cover_a_and_b: cover (in_a && in_b) $info("in_a && in_b == 1 covered");
For example, a formal verification tool might prove under the assumption
assert_f assume_inputs
expressing the condition that and are not both 0 at the same time. The statement detects
in_a in_b cover
whether and are both simultaneously 1.
in_a in_b
If more than one of these system tasks is included in the action block, then each shall be executed as
specified.
If the severity system task is executed at a time other than when the immediate or fails, the
assert assume
actual failure time of the immediate or can be recorded and displayed programmatically.
assert assume
For example:
time t;
always @(posedge clk)
if (state == REQ)
assert (req1 || req2)
else begin
t = $time;
#5 $error("assert failed at time %0t",t);
end
If the immediate fails at time 10, the error message shall be printed at time 15, but the user-defined
assert
string printed will be “assert failed at time 10.”
Because the fail statement, like the pass statement, is any legal SystemVerilog procedural statement, it can
also be used to signal a failure to another part of the testbench.
assert (myfunc(a,b)) count1 = count + 1; else ->event1;
assert (y == 0) else flag = 1;
16.4 Deferred assertions
immediate_assertion_statement ::= // from A.6.10
...
| deferred_immediate_assertion_statement
deferred_immediate_assertion_item ::= [ block_identifier ] deferred_immediate_assertion_statement
:
deferred_immediate_assertion_statement ::=
deferred_immediate_assert_statement
| deferred_immediate_assume_statement
| deferred_immediate_cover_statement
deferred_immediate_assert_statement ::=
expression action_block
assert#0( )
| expression action_block
assertfinal( )
deferred_immediate_assume_statement ::=
expression action_block
assume#0( )
| expression action_block
assumefinal( )
367
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
deferred_immediate_cover_statement ::=
expression statement_or_null
cover#0( )
| expression statement_or_null
coverfinal( )
Syntax16-2—Deferred immediate assertion syntax (excerpt from AnnexA)
Deferred assertions are a kind of immediate assertion. They can be used to suppress false reports that occur
due to glitching activity on combinational inputs to immediate assertions. Since deferred assertions are a
subset of immediate assertions, the term deferred assertion (often used for brevity) is equivalent to the term
deferred immediate assertion. The term simple immediate assertion refers to an immediate assertion that is
not deferred. In addition, there are two different kinds of deferred assertions: observed deferred immediate
assertions and final deferred immediate assertions.
A deferred assertion is similar to a simple immediate assertion, but with the following key differences:
— Syntax: Deferred assertions use (for an observed deferred assertion) or (for a final
#0 final
deferred assertion) after the verification directive.
— Deferral: Reporting is delayed rather than being reported immediately.
— Action block limitations: Action blocks may only contain a single subroutine call.
— Use outside procedures: A deferred assertion may be used as a module_common_item.
Deferred assertion syntax is similar to simple immediate assertion syntax, with the difference being the
specification of a or after the , , or :
#0 final assert assume cover
assert #0 (expression) action_block
assert final (expression) action_block
As with all immediate assertions, a deferred assertion’s expression is evaluated at the time the deferred
assertion statement is processed. However, in order to facilitate glitch avoidance, the reporting or action
blocks are scheduled at a later point in the current time step.
The pass and fail statements in a deferred assertion’s action_block, if present, shall each consist of a single
subroutine call. The subroutine can be a task, task method, void function, void function method, or system
task. The requirement of a single subroutine call implies that no begin-end block shall surround the pass or
fail statements, as is itself a statement that is not a subroutine call. In the case of a final deferred
begin
assertion, the subroutine shall be one that may be legally called in the Postponed region (see 4.4.2.9). A
subroutine argument may be passed by value as an input or passed by reference as a or .
ref const ref
Actual argument expressions that are passed by value, including function calls, shall be fully evaluated at the
instant the deferred assertion expression is evaluated. It shall be an error to pass automatic or dynamic
variables as actuals to a or formal. The processing of the action block differs between
ref const ref
observed and final deferred assertions as follows:
— For an observed deferred assertion, the subroutine shall be scheduled in the Reactive region. Actual
argument expressions that are passed by reference use or assign the current values of the underlying
variables in the Reactive region.
— For a final deferred assertion, the subroutine shall be scheduled in the Postponed region. Actual
argument expressions that are passed by reference use the current values of the underlying variables
in the Postponed region.
Deferred assertions may also be used outside procedural code, as a module_common_item. This is explained
in more detail in 16.4.3.
In addition to deferred statements, deferred and statements are also defined. Other
assert assume cover
than the deferred evaluation as described in this subclause, these and statements behave the
assume cover
368
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
same way as the simple immediate and statements described in 16.3. A deferred
assume cover assume
will often be useful in cases where a combinational condition is checked in a function, but needs to be used
as an assumption rather than a proof target by formal tools. A deferred cover is useful to avoid crediting tests
for covering a condition that is only met in passing by glitched values.
16.4.1 Deferred assertion reporting
When a deferred assertion passes or fails, the action block is not executed immediately. Instead, the action
block subroutine call (or , if an or fails and no action_block is present) and the
$error assert assume
current values of its input arguments are placed in a deferred assertion report queue associated with the
currently executing process. Such a call is said to be a pending assertion report.
If a deferred assertion flush point (see 16.4.2) is reached in a process, its deferred assertion report queue is
cleared. Any pending assertion reports will not be executed.
In the Observed region of each simulation time step, each pending observed deferred assertion report that
has not been flushed from its queue shall mature, or be confirmed for reporting. Once a report matures, it
may no longer be flushed. Then the associated subroutine call (or , if the assertion fails and no action
$error
block is present) is executed in the Reactive region, and the pending assertion report is cleared from the
appropriate process’s deferred assertion report queue.
Note that if code in the Reactive region modifies signals and causes another pass to the Active region to
occur, this still may create glitching behavior in observed deferred assertions, as the new passage in the
Active region may re-execute some of the deferred assertions with different reported results. In general,
observed deferred assertions prevent glitches due to order of procedural execution, but do not prevent
glitches caused by execution loops between regions that the assignments from the Reactive region may
cause.
In the Postponed region of each simulation time step, each pending final deferred assertion report that has
not been flushed from its queue shall mature. Then the associated subroutine call (or , if the assertion
$error
fails and no action block is present) is scheduled in the same Postponed region, and the pending assertion
report is cleared from the appropriate process’s deferred assertion report queue. Due to their execution in the
non-iterative Postponed region, final deferred assertions are not vulnerable to the potential glitch behavior
previously described for observed deferred assertions.
16.4.2 Deferred assertion flush points
A process is defined to have reached a deferred assertion flush point if any of the following occur:
— The process, having been suspended earlier due to reaching an event control or wait statement,
resumes execution.
— The process was declared by an or , and its execution is resumed due
always_comb always_latch
to a transition on one of its dependent signals.
— The outermost scope of the process is disabled by a statement (see 16.4.4)
disable
The following example shows how deferred assertions might be used to avoid undesired reports of a failure
due to transitional combinational values in a single simulation time step:
assign not_a = !a;
always_comb begin : b1
a1: assert (not_a != a);
a2: assert #0 (not_a != a); // Should pass once values have settled
end
369
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
When changes, a simulator could evaluate assertions and twice—once for the change in and once
a a1 a2 a
for the change in after the evaluation of the continuous assignment. A failure could thus be reported
not_a
during the first execution of . The failure during the first execution of will be scheduled on the
a1 a2
process’s deferred assertion report queue. When changes, the deferred assertion queue is flushed due
not_a
to the activation of , so no failure of will be reported.
b1 a2
This example illustrates the behavior of deferred assertions in the presence of time delays:
always @(a or b) begin : b1
a3: assert #0 (a == b) rptobj.success(0); else rptobj.error(0, a, b);
#1;
a4: assert #0 (a == b) rptobj.success(1); else rptobj.error(1, a, b);
end
In this case, due to the time delay in the middle of the procedure, an Observed region will always be reached
after the execution of and before a flush point. Thus any passes or failures of will always be reported.
a3 a3
For , during cycles where either or changes after it has been executed, failures will be flushed and
a4 a b
never reported. In general, deferred assertions must be used carefully when mixed with time delays.
The following example illustrates a typical use of a deferred statement:
cover
assign a = ...;
assign b = ...;
always_comb begin : b1
c1: cover (b != a);
c2: cover #0 (b != a);
end
In this example, it is important to make sure some test is covering the case where and have different
a b
values. Due to the arbitrary order of the assignments in the simulator, it might be the case that in a cycle
where both variables are being assigned the same value, executes while has been assigned but still
b1 a b
holds its previous value. Thus will be triggered, but this is actually a glitch, and probably not a useful
c1
piece of coverage information. In the case of , this coverage will get added to the deferred report queue,
c2
but when is executed the next time (after has also been assigned its new value), that coverage point will
b1 b
be flushed, and will correctly not get reported as having been covered during that time step.
c2
The next example illustrates a case where, due to short-circuiting (see 11.3.5), the result of a deferred
assertion may not appear at first glance to be consistent with the signal values at the end of a time step.
function f(bit v);
p: assert #0 (v);
...
endfunction
always_comb begin: myblk
a = b || f(c);
end
Suppose, during some time step, the following sequence of events occurs:
— is set to 0 while , and is entered. When is called, assertion has a passing value.
b c==1 myblk f p
— Later in the time step settles at a value of 1, while becomes 0. When the procedure resumes, the
b c
previous execution is flushed. This time, due to short-circuiting, is never evaluated—so the new
f
failing value of assertion is never seen.
p
— In the Reactive region, no passing or failing execution is reported by the simulator on .
p
NOTE—If the bitwise operator, which does not allow short-circuiting, were used instead of in the assignment to ,
| || a
then would be evaluated each time the assignment was reached.
f
370
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The following example illustrates the evaluation of subroutine arguments to deferred assertion action
blocks.
function int error_type (int opcode);
func_assert: assert (opcode < 64) else $display("Opcode error.");
if (opcode < 32)
return (0);
else
return (1);
endfunction
always_comb begin : b1
a1: assert #0 (my_cond) else
$error("Error on operation of type %d\n", error_type(opcode));
a2: assert #0 (my_cond) else
error_type(opcode);
...
end
Suppose block is executed twice in the Active region of a single time step, with , so it
b1 my_cond == 0
fails assertions and both times. Also suppose is 64 the first time it is executed, and 0 the
a1 a2 opcode
second time. The following will occur during simulation:
— Upon each deferred assertion failure, the subroutine arguments of the action block are evaluated,
even though the action block itself is not executed.
• Upon the first failure of , the arguments of are examined. Since the second argument
a1 $error
contains a function call, that function ( , with ) is evaluated.
error_type(opcode) opcode=64
During this function call, fails and displays the message “Opcode error.”
func_assert
• Upon the first failure of , the arguments of are examined. Since its only
a2 error_type
argument is the expression , its value 64 is used and no further evaluation is needed at
opcode
this time.
• The pending reports with are placed on the deferred assertion report queue.
opcode=64
— When block is executed again, the pending reports are flushed from the deferred assertion report
b1
queue.
• Upon the second failure of , function is called with , so assertion
a1 error_type opcode==0
passes.
func_assert
• Upon the second failure of , the value of 0 is used for the expression , and no further
a2 opcode
evaluation is needed at this time.
— When the assertions later mature, the task will be called for , and the function
$error a1
will be called for .
error_type a2
The deferral and flushing prevented a report from the first failure of as expected. But the evaluation of
a1
action block subroutine arguments, which happens every time a pending assertion report is queued, caused a
function to be called upon each failure. In general, users must be cautious about the contents of action blocks
for deferred assertions, since the evaluation of their subroutine arguments on every failure may seem
inconsistent with the deferral in some usages.
The following example illustrates the differences between observed deferred assertions and final deferred
assertions.
module dut(input logic clk, input logic a, input logic b);
logic c;
always_ff @(posedge clk)
c <= b;
a1: assert #0 (!(a & c)) $display("Pass"); else $display("Fail");
371
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
a2: assert final (!(a & c)) $display("Pass"); else $display("Fail");
endmodule
program tb(input logic clk, output logic a, output logic b);
default clocking m @(posedge clk);
default input #0;
default output #0;
output a;
output b;
endclocking
initial begin
a = 1;
b = 0;
##10;
b = 1;
##1;
a = 0;
end
endprogram
module sva_svtb;
bit clk;
logic a, b;
...
dut dut (.*);
tb tb (.*);
endmodule
In the 11th clock cycle, observed deferred assertion will first execute in the Active region, and it will fail
a1
since at this point and are both 1. This pending assertion report will mature in the Observed region, and
a c
the failure report will be scheduled in the Reactive region. However, in the Reactive region of the same time
step, the testbench will set to 0, triggering another execution of the implied block
a always_comb
containing assertion . This time will pass. So both a pass and a fail message will be displayed for
a1 a1 a1
during this time step.
For final deferred assertion , the behavior will be different. As with , a pending assertion report will be
a2 a1
generated when the assertion fails in the Active region. However, when the value of changes in the
a
Reactive region and the assertion's implicit is resumed, this creates a flush point, so this
always_comb
pending report will be flushed. will be executed again with the new value, and the new result will be put
a2
on the deferred assertion report queue. In the Postponed region, this will mature, and the final passing result
of this assertion will be the only one reported.
16.4.3 Deferred assertions outside procedural code
A deferred assertion statement may also appear outside procedural code, in which case it is referred to as a
static deferred assertion. In such cases, it is treated as if it were contained in an procedure.
always_comb
For example:
module m (input a, b);
a1: assert #0 (a == b);
endmodule
This is equivalent to the following:
module m (input a, b);
always_comb begin
372
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
a1: assert #0 (a == b);
end
endmodule
Static deferred assertions in checkers are described in 17.3.
16.4.4 Disabling deferred assertions
The statement shall interact with deferred assertions as follows:
disable
— A specific deferred assertion may be disabled. Any pending assertion reports for that assertion are
cancelled.
— When a is applied to the outermost scope of a procedure that has an active deferred
disable
assertion queue, in addition to normal disable activities (see 9.6.2), the deferred assertion report
queue is flushed and all pending assertion reports on the queue are cleared.
Disabling a task or a non-outermost scope of a procedure does not cause flushing of any pending reports.
The following example illustrates how user code can explicitly flush a pending assertion report. In this case,
failures of are only reported in time steps where does not settle at a value of 1.
a1 bad_val_ok
always @(bad_val or bad_val_ok) begin : b1
a1: assert #0 (bad_val) else $fatal(1, "Sorry");
if (bad_val_ok) begin
disable a1;
end
end
The following example illustrates how user code can explicitly flush all pending assertion reports on the
deferred assertion queue of process :
b2
always @(a or b or c) begin : b2
if (c == 8'hff) begin
a2: assert #0 (a && b);
end else begin
a3: assert #0 (a || b);
end
end
always @(clear_b2) begin : b3
disable b2;
end
16.4.5 Deferred assertions and multiple processes
As described in the previous subclauses, deferred assertions are inherently associated with the process in
which they are executed. This means that a deferred assertion within a function may be executed several
times due to the function being called by several different processes, and each of these different process
executions is independent. The following example illustrates this situation:
module fsm(...);
function bit f (int a, int b)
...
a1: assert #0 (a == b);
...
endfunction
...
373
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
always_comb begin : b1
some_stuff = f(x,y) ? ...
...
end
always_comb begin : b2
other_stuff = f(z,w) ? ...
...
end
endmodule
In this case, there are two different processes that may call assertion : and . Suppose simulation
a1 b1 b2
executes the following scenario in the first passage through the Active region of each time step:
— In time step 1, executes with , and executes with .
b1 x!=y b2 z!=w
— In time step 2, executes with , then again with .
b1 x!=y x==y
— In time step 3, executes with , then executes with .
b1 x!=y b2 z==w
In the first time step, since fails independently for processes and , its failure is reported twice.
a1 b1 b2
In the second time step, the failure of in process is flushed when the process is re-triggered, and since
a1 b1
the final execution passes, no failure is reported.
In the third time step, the failure in process does not see a flush point, so that failure is reported. In
b1
process , the assertion passes, so no failure is reported from that process.
b2
16.5 Concurrent assertions overview
Concurrent assertions describe behavior that spans over time. Unlike immediate assertions, the evaluation
model is based on a clock so that a concurrent assertion is evaluated only at the occurrence of a clock tick.
The term clock tick refers to a time step when a clocking event of a sequence, property, sampled value
function, or assertion statement occurs. Due to the need to verify proper behavior of the system and conform
as closely as possible to cycle-based semantics, the clocking event should be glitch-free and only transition
once during any time step. If the clocking event transitions more than once during a time step, the resulting
behavior is undefined.
Concurrent assertions use the sampled values of their expressions except for disable conditions (see 16.15)
and clocking events. Expression sampling is explained in 16.5.1. Concurrent assertions are evaluated in the
Observed region.
16.5.1 Sampling
Concurrent assertions and several other constructs (such as variables referenced in an procedure
always_ff
in a checker, see 17.5) have special rules for sampling values of their expressions. The value of an
expression sampled in one of these constructs is called a sampled value. In most cases the sampled value of
an expression is its value in the Preponed region. This rule has, however, several important exceptions. The
rest of this subclause provides the formal definition of sampling.
The default sampled value of an expression is defined as follows:
— The default sampled value of a static variable is the value assigned in its declaration, or, in the
absence of such an assignment, it is the default (or uninitialized) value of the corresponding type
(see 6.8, Table6-7).
— The default sampled value of any other variable or net is the default value of the corresponding type
(see 6.8, Table6-7). For example, the default sampled value of variable of type is .
y logic 1'bx
374
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— The default sampled value of the event method (see 15.5.3) and the sequence methods
triggered
and is false ( ) .
triggered matched 1'b0
— The default sampled value of an expression is defined recursively by evaluating the expression using
the default sampled values of its component subexpressions and variables.
A default sampled value is used in the definition of a sampled value of an expression as explained below,
and in the definition of sampled value functions when there is a need to reference a sampled value of an
expression before time zero (see 16.9.3).
The definition of a sampled value of an expression is based on the definition of a sampled value of a
variable. The general rule for variable sampling is as follows:
— The sampled value of a variable in a time slot corresponding to time greater than 0 is the value of
this variable in the Preponed region of this time slot.
— The sampled value of a variable in a time slot corresponding to time 0 is its default sampled value.
This rule has the following exceptions:
— Sampled values of automatic variables (see 16.14.6), local variables (see 16.10), and active free
checker variables (see 17.7.2) are their current values. However,
• When a past or a future value of an active free checker variable is referenced by a sampled value
function (see 16.9.3 and 16.9.4), this value is sampled in the Postponed region of the
corresponding past or future clock tick;
• When a past or a future value of an automatic variable is referenced by a sampled value function,
the current value of the automatic variable is taken instead.
— If a variable is an input variable of a clocking block, the variable shall be sampled by the clocking
block with sampling. Any other type of sampling for the clocking block variable shall result
#1step
in an error. The sampled value of a such variable is the sampled value produced by the clocking
block. This is explained in Clause14.
The sampled value of an expression is defined as follows:
— The sampled value of an expression consisting of a single variable is the sampled value of this
variable.
— The sampled value of a cast expression (see 6.24.1 and 16.14.6) is defined as the current
const
value of its argument. For example, if is a variable, then the sampled value of ' is the
a const(a)
current value of . When a past or a future value of a cast expression is referenced by a
a const
sampled value function, the current value of this expression is taken instead.
— The sampled value of the event method and the sequence methods and
triggered triggered
(see 16.13.6) is defined as the current value returned by the event property or sequence
matched
method. When a past or a future value of an event property or sequence method is referenced by a
sampled value function (see 16.9.3 and 16.9.4), this value is sampled in the Postponed region of the
corresponding past or future clock tick.
— The sampled value of any other expression is defined recursively using the values of its arguments.
For example, the sampled value of an expression , where and are expressions, is the
e1 & e2 e1 e2
bitwise AND of the sampled values of and . In particular, if an expression contains a function
e1 e2
call, to evaluate the sampled value of this expression, the function is called on the sampled values of
its arguments at the time of the expression evaluation. For example, if is a static module variable,
a
is a sequence, and is a function, the sampled value of is the result of the
s f f(a, s.triggered)
application of to the sampled values of and , i.e., to the value of taken from the
f a s.triggered a
Preponed region and to the current value of .
s.triggered
375
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.