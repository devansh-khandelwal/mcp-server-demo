IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
SystemVerilog specify paths:
if (!mode) (sel => zout) = 0;
if (mode) (sel => zout) = 0;
A nonconditional delay between two ports shall annotate to all SystemVerilog specify paths
IOPATH
between those same two ports. In the following example, the rise/fall times of and are annotated
1.3 1.7
to both specify paths:
SDF file:
(IOPATH sel zout (1.3) (1.7))
SystemVerilog specify paths:
if (!mode) (sel => zout) = 0;
if (mode) (sel => zout) = 0;
32.4.2 Mapping of SDF timing check constructs to SystemVerilog
Table32-2 shows which SystemVerilog timing checks are annotated to by each type of SDF timing check.
is the first value of a timing check, is the second value, while indicates no value is annotated.
v1 v2 x
Table32-2—Mapping of SDF timing check constructs to SystemVerilog
SDF timing check Annotated SystemVerilog timing checks
( v1... (v1), (v1,x)
SETUP $setup $setuphold
( v1... (v1), (x,v1)
HOLD $hold $setuphold
( v1 v2... (v1), (v2), (v1,v2)
SETUPHOLD $setup $hold $setuphold
v1... (v1), (v1,x)
(RECOVERY $recovery $recrem
( v1... (v1), (x,v1)
REMOVAL $removal $recrem
( v1 v2... (v1), (v2), (v1,v2)
RECREM $recovery $removal $recrem
( v1... (v1), (v1)
SKEW $skew $timeskew
( v1 v2... (v1,v2)
BIDIRECTSKEW $fullskew
( v1... (v1,x)
WIDTH $width
( v1... (v1)
PERIOD $period
( v1 v2... (v1,v2)
NOCHANGE $nochange
The reference and data signals of timing checks can have logical condition expressions and edges associated
with them. An SDF timing check with no conditions or edges on any of its signals shall match all
corresponding SystemVerilog timing checks regardless of whether conditions are present. In the following
example, the SDF timing check shall annotate to all the SystemVerilog timing checks:
SDF file:
(SETUPHOLD data clk (3) (4))
894
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
SystemVerilog timing checks:
$setuphold (posedge clk &&& mode, data, 1, 1, ntfr);
$setuphold (negedge clk &&& !mode, data, 1, 1, ntfr);
$setuphold (edge clk, data, 1, 1, ntfr);
When conditions and/or edges are associated with the signals in an SDF timing check, then they shall match
those in any corresponding SystemVerilog timing check before annotation shall happen. In the following
example, the SDF timing check shall annotate to the first SystemVerilog timing check, but not the second
and the third:
SDF file:
(SETUPHOLD data (posedge clk) (3) (4))
SystemVerilog timing checks:
// Annotated
$setuphold (posedge clk &&& mode, data, 1, 1, ntfr);
// Not annotated
$setuphold (negedge clk &&& !mode, data, 1, 1, ntfr);
// Not annotated
$setuphold (edge clk, data, 1, 1, ntfr);
Here, the SDF timing check shall not annotate to any of the SystemVerilog timing checks.
SDF file:
(SETUPHOLD data (COND !mode (posedge clk)) (3) (4))
SystemVerilog timing checks:
// Not annotated
$setuphold (posedge clk &&& mode, data, 1, 1, ntfr);
// Not annotated
$setuphold (negedge clk &&& !mode, data, 1, 1, ntfr);
// Not annotated
$setuphold (edge clk, data, 1, 1, ntfr);
32.4.3 SDF annotation of specparams
The SDF construct annotates to specparams. Any expression containing one or more specparams is
LABEL
reevaluated when annotated to from an SDF file.
The following example shows SDF constructs annotating to specparams in a SystemVerilog module.
LABEL
The specparams are used in procedural delays to control when the clock transitions. The SDF
LABEL
construct annotates the values of and , thereby setting the period and duty cycle of the clock.
dhigh dlow
SDF file:
(LABEL
(ABSOLUTE
(dhigh 60)
(dlow 40)))
SystemVerilog file:
module clock(clk);
output clk;
reg clk;
specparam dhigh=0, dlow=0;
initial clk = 0;
895
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
always
begin
#dhigh clk = 1; // Clock remains low for time dlow
// before transitioning to 1
#dlow clk = 0; // Clock remains high for time dhigh
// before transitioning to 0
end
endmodule
The following example shows a specparam in an expression of a specify path. The SDF construct can
LABEL
be used to change the value of the specparam and cause reevaluation of the expression.
specparam cap = 0;
...
specify
(A => Z) = 1.4 * cap + 0.7;
endspecify
32.4.4 SDF annotation of interconnect delays
SDF interconnect delay annotation differs from annotation of other constructs previously described in that
there exists no corresponding SystemVerilog declaration to which to annotate. In SystemVerilog simulation,
interconnect delays are an abstraction that represents the signal propagation delay from an output or inout
module port to an input or inout module port. The construct includes a source, a load, and
INTERCONNECT
delay values, while the and constructs include only a load and delay values. Interconnect
PORT NETDELAY
delays can only be annotated between module ports, never between primitive pins. Table32-3 shows how
the SDF interconnect constructs in the section are annotated.
DELAY
Table32-3—SDF annotation of interconnect delays
SDF construct SystemVerilog annotated structure
( ... Interconnect delay
PORT
( a Interconnect delay
NETDELAY
( ... Interconnect delay
INTERCONNECT
aOnly OVI SDF version 1.0, 2.0, and 2.1 and IEEE SDF version 4.0.
Interconnect delays can be annotated to both single source and multisource nets.
When annotating a construct, the SDF annotator shall search for the port and, if it exists, shall annotate
PORT
an interconnect delay to that port that shall represent the delay from all sources on the net to that port.
When annotating a construct, the SDF annotator shall check to see if it is annotating to a port or a
NETDELAY
net. If it is a port, then the SDF annotator shall annotate an interconnect delay to that port. If it is a net, then
it shall annotate an interconnect delay to all load ports connected to that net. If the port or net has more than
one source, then the delay shall represent the delay from all sources. delays can only be
NETDELAY
annotated to input or inout module ports or to nets.
In the case of multisource nets, unique delays can be annotated between each source/load pair using the
construct. When annotating this construct, the SDF annotator shall find the source port and
INTERCONNECT
the load port; and if both exist, it shall annotate an interconnect delay between the two. If the source port is
not found or if the source port and the load port are not actually on the same net, then a warning is issued,
but the delay to the load port is annotated anyway. If this happens for a load port that is part of a multisource
896
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
net, then the delay is treated as if it were the delay from all source ports, which is the same as the annotation
behavior for a delay. Source ports shall be output or inout ports, while load ports shall be input or inout
PORT
ports.
Interconnect delays share many of the characteristics of specify path delays. The same rules for specify path
delays for filling in missing delays and pulse limits also apply for interconnect delays. Interconnect delays
have 12 transition delays, and unique reject and error pulse limits are associated with each of the 12. An
unlimited number of future schedules are permitted.
In a SystemVerilog module, a reference to an annotated port, wherever it occurs, whether in and
$monitor
statements or in expressions, shall provide the delayed signal value. A reference to the source
$display
shall yield the undelayed signal value, while a reference to the load shall yield the delayed signal value. In
general, references to the signal value hierarchically before the load shall yield the undelayed signal value,
while references to the signal at or hierarchically after the load shall yield the delayed signal value. An
annotation to a hierarchical port shall affect all connected ports at higher or lower hierarchical levels,
depending on the direction of annotation. An annotation from a source port shall be interpreted as being
from all sources hierarchically higher or lower than that source port.
Up-hierarchy annotations shall be properly handled. This situation arises when the load is hierarchically
above the source. The delay to all ports that are hierarchically above the load or that connect to the net at
points hierarchically above the load is the same as the delay to that load.
Down-hierarchy annotation shall also be properly handled. This situation arises when the source is
hierarchically above the load. The delay to the load is interpreted as being from all ports that are at or above
the source or that connect to the net at points hierarchically above the source.
Hierarchically overlapping annotations are permitted. This occurs when annotations to or from the same port
take place at different hierarchical levels and, therefore, do not correspond to the same hierarchical subset of
ports. In the following example, the first statement annotates to all ports of the net that are
INTERCONNECT
at or hierarchically within , while the second annotates to a smaller subset of ports, only those
i53/selmode
at or hierarchically within :
i53/u21/in
(INTERCONNECT i14/u5/out i53/selmode (1.43) (2.17))
(INTERCONNECT i14/u5/out i53/u21/in (1.58) (1.92))
Overlapping annotations can occur in many different ways, particularly on multisource/multiload nets, and
SDF annotation shall properly resolve all the interactions.
32.5 Multiple annotations
SDF annotation is an ordered process. The constructs from the SDF file are annotated in their order of
occurrence. In other words, annotation of an SDF construct can be changed by annotation of a subsequent
construct that either modifies or overwrites it. These do not have to be the
(INCREMENT) (ABSOLUTE)
same construct. The following example first annotates pulse limits to an and then annotates the
IOPATH
entire , thereby overwriting the pulse limits that were just annotated:
IOPATH
(DELAY
(ABSOLUTE
(PATHPULSE A Z (2.1) (3.4))
(IOPATH A Z (3.5) (6.1))
Overwriting the pulse limits can be avoided by using empty parentheses to hold the current values of the
pulse limits:
897
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
(DELAY
(ABSOLUTE
(PATHPULSE A Z (2.1) (3.4))
(IOPATH A Z ((3.5) () ()) ((6.1) () ()) )
The preceding annotation can be simplified into a single statement as follows:
(DELAY
(ABSOLUTE
(IOPATH A Z ((3.5) (2.1) (3.4)) ((6.1) (2.1) (3.4)) )
A annotation followed by an annotation to the same load shall cause only the delay
PORT INTERCONNECT
from the source to be affected. For the following net with three sources and a single load,
INTERCONNECT
the delay from all sources except remains :
i13/out 6
(DELAY
(ABSOLUTE
(PORT i15/in (6))
(INTERCONNECT i13/out i15/in (5))
An annotation followed by a annotation shall cause the annotation to
INTERCONNECT PORT INTERCONNECT
be overwritten. Here, the delays from all sources to the load shall become :
6
(DELAY
(ABSOLUTE
(INTERCONNECT i13/out i15/in (5))
(PORT i15/in (6))
32.6 Multiple SDF files
More than one SDF file can be annotated. Each call to the task annotates the design with
$sdf_annotate
timing information from an SDF file. Annotated values either modify ( ) or overwrite
INCREMENT
( ) values from earlier SDF files. Different regions of a design can be annotated from different
ABSOLUTE
SDF files by specifying the region’s hierarchy scope as the second argument to .
$sdf_annotate
32.7 Pulse limit annotation
For SDF annotation of delays (not timing constraints), the default values annotated for pulse limits shall be
calculated using the percentage settings for the reject and error limits. By default, these limits are , but
100%
they can be modified through invocation options. For example, assuming invocation options have set the
reject limit to and the error limit to , the following SDF construct shall annotate a delay of , a reject
40% 80% 5
limit of , and an error limit of :
2 4
(DELAY
(ABSOLUTE
(IOPATH A Z (5))
Given that the specify path delay was originally , the following annotation results in a delay of and pulse
0 5
limits of :
0
(DELAY
(ABSOLUTE
(IOPATH A Z ((5) () ()) )
898
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annotations in mode can result in pulse limits less than , in which case they shall be adjusted
INCREMENT 0
to . For example, if the specify path pulse limits were both , the following annotation results in a value
0 3 0
for both pulse limits:
(DELAY
(INCREMENT
(IOPATH A Z (() (-4) (-5)) )
There are two SDF constructs that annotate only to pulse limits, and .
PATHPULSE PATHPULSEPERCENT
They do not affect the delay. When sets the pulse limits to values greater than the delay,
PATHPULSE
SystemVerilog shall exhibit the same behavior as if the pulse limits had been set equal to the delay.
32.8 SDF to SystemVerilog delay value mapping
SystemVerilog specify paths and interconnects can have unique delays for up to 12 state transitions (see
30.5.1). All other constructs, such as gate primitives and continuous assignments, can have only three state
transition delays (see 28.16).
For SystemVerilog specify path and interconnect delays, the number of transition delay values provided by
SDF might be less than 12.
Table32-4 shows how fewer than 12 SDF delays are extended to be 12 delays. The SystemVerilog
transition types are shown down the left-hand side, while the number of SDF delays provided is shown
across the top. The SDF values are given the names through .
v1 v12
Table32-4—SDF to SystemVerilog delay value mapping
Number of SDF delay values provided
SystemVerilog
transition
1 value 2 values 3 values 6 values 12 values
0 –> 1 v1 v1 v1 v1 v1
1 –> 0 v1 v2 v2 v2 v2
0 –> z v1 v1 v3 v3 v3
z –> 1 v1 v1 v1 v4 v4
1 –> z v1 v2 v3 v5 v5
z –> 0 v1 v2 v2 v6 v6
0 –> x v1 v1 min(v1,v3) min(v1,v3) v7
x –> 1 v1 v1 v1 max(v1,v4) v8
1 –> x v1 v2 min(v2,v3) min(v2,v5) v9
x –> 0 v1 v2 v2 max(v2,v6) v10
x –> z v1 max(v1,v2) v3 max(v3,v5) v11
z –> x v1 min(v1,v2) min(v1,v2) min(v4,v6) v12
For other delays that can have at most three values, the expansion of less than three SDF delays into three
SystemVerilog delays is covered in Table28-9. More than three SDF delays are reduced to three
SystemVerilog delays by simply ignoring the extra delays. The delay to the -state is created from the
X
minimum of the other three delays.
899
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
32.9 Loading timing data from an SDF file
The syntax for the system task is shown in Syntax32-1.
$sdf_annotate
sdf_annotate_task ::=
sdf_file [ [ module_instance ] [ [ config_file ]
$sdf_annotate ( , , " "
[ [ log_file ] [ [ mtm_spec ] [ [ scale_factors ] [ [ scale_type ] ] ] ] ] ] ] )
, " " , " " , " " , " " ;
Syntax32-1—Syntax for $sdf_annotate system task (not in AnnexA)
The system task reads timing data from an SDF file into a specified region of the design.
$sdf_annotate
sdf_file—is an expression that is a string literal, data type, or an integral data type containing a
string
character string that names the file to be opened.
module_instance—is an optional argument specifying the scope to which to annotate the information in the
SDF file. The SDF annotator uses the hierarchy level of the specified instance for running the annotation.
Array indices are permitted. If the module_instance is not specified, the SDF annotator uses the module
containing the call to the system task as the module_instance for annotation.
$sdf_annotate
config_file—is an optional character string argument providing the name of a configuration file. Information
in this file can be used to provide detailed control over many aspects of annotation.
log_file—is an optional character string argument providing the name of the log file used during SDF
annotation. Each individual annotation of timing data from the SDF file results in an entry in the log file.
mtm_spec—is an optional character string argument specifying which member of the / / triples
mintypmax
shall be annotated. The legal values for this string are described in Table32-5. This overrides any
MTM_SPEC
keywords in the configuration file.
Table32-5—mtm_spec argument
Keyword Description
Annotates the maximum value
MAXIMUM
Annotates the minimum value
MINIMUM
(default) Annotates the value as selected by the simulator
TOOL_CONTROL
Annotates the typical value
TYPICAL
scale_factors—is an optional character string argument specifying the scale factors to be used while
annotating timing values. For example, causes minimum values to be multiplied by
"1.6:1.4:1.2" 1.6,
typical values by , and maximum values by . The default values are . The
1.4 1.2 1.0:1.0:1.0
scale_factors argument overrides any keywords in the configuration file.
SCALE_FACTORS
scale_type—is an optional character string argument specifying how the scale factors should be applied to
the min/typ/max triples. The legal values for this string are shown in Table32-6. This overrides any
keywords in the configuration file.
SCALE_TYPE
900
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table32-6—scale_type argument
Keyword Description
Applies scale factors to maximum value
FROM_MAXIMUM
Applies scale factors to minimum value
FROM_MINIMUM
(default) Applies scale factors to min/typ/max values
FROM_MTM
Applies scale factors to typical value
FROM_TYPICAL
901
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
33. Configuring the contents of a design
33.1 General
This clause describes the following:
— Configuration libraries
— Configuration syntax
— Using libraries and configurations
33.2 Overview
To facilitate both the sharing of SystemVerilog designs between designers and/or design groups and the
repeatability of the exact contents of a given simulation (or other tool) session, the concept of configurations
is used in the SystemVerilog language. A configuration is simply an explicit set of rules to specify the exact
source description to be used to represent each instance in a design. The operation of selecting a source
representation for an instance is referred to as binding the instance.
The following example shows a simple configuration problem:
file top.v file adder.v file adder.vg
module top(); module adder(...); module adder(...);
adder a1(...); // rtl adder // gate-level adder
adder a2(...); // description // description
endmodule ... ...
endmodule endmodule
Consider using the description in for instance in module top and the gate-level
rtl adder adder.v a1
adder description in for instance . In order to specify this particular set of instance bindings
adder.vg a2
and to avoid having to change the source description to specify a new set, a configuration can be used.
config cfg1; // specify rtl adder for top.a1, gate-level adder for top.a2
design rtlLib.top;
default liblist rtlLib;
instance top.a2 liblist gateLib;
endconfig
The elements of a config are explained in subsequent subclauses, but this simple example illustrates some
important points about configs. As evidenced by the – syntax, the config is a design
config endconfig
element, similar to a module, which exists in the SystemVerilog name space. The config contains a set of
rules that are applied when searching for a source description to bind to a particular instance of the design.
A design description starts with a top-level module (or modules) (see 23.3.1). From this module’s source
description, the instantiated modules (or children) are found, then the source descriptions for the module
definitions of these subinstances shall be located, and so on until every instance in the design is mapped to a
source description.
33.2.1 Library notation
A library is a named collection of cells. A cell is a design element (see 3.2), such as a module, primitive,
interface, program, package, or configuration. The cell name shall be the same as the name of the design
element being processed.
902
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In order to map a design element instance to a source description, the concept of a symbolic library, which is
simply a logical collection of design elements, can be used. Syntax33-1 specifies a cell from a given library.
cell_clause ::= [ library_identifier ] cell_identifier // from A.1.5
cell .
Syntax33-1—Syntax for cell (excerpt from AnnexA)
This notation gives a symbolic method of referring to source descriptions; the method of mapping source
descriptions into libraries is shown in greater detail in 33.3.1. The optional extension shall be used
:config
explicitly to refer to a config in the case where a config has the same name as a module/primitive.
For the purposes of this example, suppose the files and (i.e., the RTL descriptions) have
top.v adder.v
been mapped into the library and the file (i.e., the gate-level description of the )
rtlLib adder.vg adder
has been mapped into the library . The actual mechanism for mapping source descriptions to
gateLib
libraries is detailed in 33.3.
33.2.2 Basic configuration elements
The statement in of the first example of 33.2 specifies the top-level module in the
design config cfg1
design and what source description is to be used. In this example, the notation indicates the
rtlLib.top
top-level module description shall be taken from . Because and were mapped to
rtlLib top.v adder.v
this library, the actual description for the module is known to come from .
top.v
The statement coupled with the clause specifies, by default, all subinstances of (i.e.,
default liblist top
and ) shall be taken from , which means the descriptions in and ,
top.a1 top.a2 rtlLib top.v adder.v
which were mapped to this library, shall be used. For a basic design, which can be completely , this can
rtl
be sufficient to specify completely the binding for the entire design. However, here the instance of
top.a2
adder to the gate-level description shall be bound.
The statement specifies, for the particular instance , the source description shall be taken
instance top.a2
from . The instance statement overrides the default rule for this particular instance. Because
gateLib
was mapped to , this statement dictates the gate-level description in be used
adder.vg gateLib adder.vg
for instance .
top.a2
33.3 Libraries
As mentioned in the previous subclause, a library is a logical collection of cells that are mapped to particular
source description files. The symbolic lib cell[ ] notation supports the separate compilation of
. :config
source files by providing a file-system-independent name to refer to source descriptions when instances in a
design are bound. It also allows multiple tools, which can have different invocation use models, to share the
same configuration.
33.3.1 Specifying libraries—the library map file
When parsing a source description file (or files), the parser shall first read the library mapping information
from a predefined file prior to reading any source files. The name of this file and the mechanism for reading
it shall be tool-specific, but all compliant tools shall provide a mechanism to specify one or more library
map files to be used for a particular invocation of the tool. If multiple map files are specified, then they shall
be read in the order in which they are specified.
903
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For the purposes of this discussion, assume the existence of a file named in the current working
lib.map
directory, which is automatically read by the parser prior to parsing any source files specified on the
command line. The syntax for declaring a library in the library map file is shown in Syntax33-2.
library_text ::= { library_description } // from A.1.1
library_description ::=
library_declaration
| include_statement
| config_declaration
|
;
library_declaration ::=
library_identifier file_path_spec { file_path_spec }
library ,
[ file_path_spec { file_path_spec } ]
-incdir , ;
include_statement ::= file_path_spec
include ;
Syntax33-2—Syntax for declaring library in library map file (excerpt from AnnexA)
Library map file details:
1) file_path_spec uses file-system-specific notation to specify an absolute or relative path to a
particular file or set of files. The following shortcuts/wildcards can be used:
single character wildcard (matches any single character)
?
multiple character wildcard (matches any number of characters in a directory/file name)
*
hierarchical wildcard (matches any number of hierarchical directories)
...
specifies the parent directory
..
specifies the directory containing the
. lib.map
Paths that end in shall include all files in the specified directory. Identical to .
/ /*
Paths that do not begin with are relative to the directory in which the current file
/ lib.map
is located.
2) The paths and are identical, and both specify all files with a suffix in the current
./*.v *.v .v
directory.
Any file encountered by the compiler that does not match any library’s file_path_spec shall by default be
compiled into a library named .
work
To perform the library mapping discussed in the example in 33.2, use the following library definitions in the
file:
lib.map
library rtlLib *.v; // matches all files in the current directory with
// a .v suffix
library gateLib ./*.vg; // matches all files in the current directory with
// a .vg suffix
33.3.1.1 File path resolution
If a file name potentially matches multiple file path specifications, the path specifications shall be resolved
in the following order:
a) File path specifications that end with an explicit file name
b) File path specifications that end with a wildcarded file name
c) File path specifications that end with a directory
904
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If a file name matches path specifications in multiple library definitions (after the above resolution rules
have been applied), it shall be an error.
Using these rules with the library definitions in the file, all source files encountered by the parser/
lib.map
compiler can be mapped to a unique library. Once the source descriptions have been mapped to libraries, the
cells defined in those libraries are available for binding.
NOTE—Tool implementers may find it convenient to provide a command-line argument to explicitly specify the library
into which the file being parsed is to be mapped, which shall override any library definitions in the file. If
lib.map
these libraries do not exist in the file, they can only be accessed via an explicit config.
lib.map
If multiple cells with the same name map to the same library, then the last cell encountered shall be written
to the library. This is to support a “separate-compile” use model (see 33.5.3), where it is assumed that
encountering a cell after it has previously been compiled is intended to be a recompiling of the cell. In the
case where multiple modules with the same name are mapped to the same library in a single invocation of
the compiler, then a warning shall be issued.
33.3.2 Using multiple library map files
In addition to specifying library mapping information, a file can also include references to other
lib.map
files. The command is used to insert the entire contents of a library map file in another
lib.map include
file during parsing. The result is as though the contents of the included map file appear in place of the
command.
include
The syntax of a file is limited to library specifications, include statements, and standard
lib.map
SystemVerilog comment syntax. Syntax33-3 shows the syntax for the command.
include
include_statement ::= file_path_spec // from A.1.1
include ;
Syntax33-3—Syntax for include command (excerpt from AnnexA)
If the file path specification, whether in an include or library statement, describes a relative path, it shall be
relative to the location of the file that contains the file path. Library providers shall include a local library
map file in addition to the source contents of the library. Individual users can then simply include the
provider’s library map file in their own map file to gain access to the contents of the provided library.
33.3.3 Mapping source files to libraries
For each cell definition encountered during parsing/compiling, the name of the source file being parsed is
compared to the file path specifications of the library declarations in all of the library map files being used.
The cell is mapped into the library whose file path specification matches the source file name.
33.4 Configurations
As mentioned in the introduction of this clause, a configuration is simply a set of rules to apply when
searching for library cells to which to bind instances.
A configuration may change the binding of a module, primitive, interface, or program instance, but shall not
change the binding of a package.
The syntax for configurations is shown in 33.4.1.
905
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
33.4.1 Basic configuration syntax
The configuration syntax is shown in Syntax33-4.
config_declaration ::= // from A.1.5
config_identifier
config ;
{ local_parameter_declaration }
;
design_statement
{ config_rule_statement }
[ config_identifier ]
endconfig :
design_statement ::= { [ library_identifier ] cell_identifier }
design . ;
config_rule_statement ::=
default_clause liblist_clause
;
| inst_clause liblist_clause
;
| inst_clause use_clause
;
| cell_clause liblist_clause
;
| cell_clause use_clause
;
default_clause ::=
default
inst_clause ::= inst_name
instance
inst_name ::= topmodule_identifier { instance_identifier }
.
cell_clause ::= [ library_identifier ] cell_identifier
cell .
liblist_clause ::= {library_identifier}
liblist
use_clause ::= [ library_identifier ] cell_identifier [ ]
use . : config
| named_parameter_assignment { named_parameter_assignment } [ ]
use , :config
| [ library_identifier ] cell_identifier named_parameter_assignment
use .
{ named_parameter_assignment } [ ]
, :config
Syntax33-4—Syntax for configurations (excerpt from AnnexA)
33.4.1.1 Design statement
The statement names the library and cell of the top-level module or modules in the design hierarchy
design
configured by the config. There shall be one and only one statement, but multiple top-level modules
design
can be listed in the statement. The cell or cells identified cannot be configurations themselves. It is
design
possible the design identified can have the same name as configs, however.
The statement shall appear before any config rule statements in the config.
design
If the library identifier is omitted, then the library that contains the config shall be used to search for the cell.
33.4.1.2 The default clause
The clause selects all instances that do not match a more specific selection clause. The
default use
expansion clause (see 33.4.1.6) cannot be used with a selection clause. For other expansion
default
clauses, there cannot be more than one clause that specifies the expansion clause.
default
For simple design configurations, it might be sufficient to specify a liblist (see 33.4.1.5).
default
906
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
33.4.1.3 The instance clause
The clause is used to specify the specific instance to which the expansion clause shall apply. The
instance
instance name associated with the clause is a SystemVerilog hierarchical name, starting at the
instance
top-level module of the config (i.e., the name of the cell in the statement).
design
33.4.1.4 The cell clause
The selection clause names the cell to which it applies. If the optional library name is specified, then
cell
the selection rule applies to any instance that is bound or is under consideration for being bound to the
selected library and cell. It is an error if a library name is included in a selection clause and the
cell
corresponding expansion clause is a library list expansion clause.
33.4.1.5 The liblist clause
The clause defines an ordered set of libraries to be searched to find the current instance. liblists are
liblist
inherited hierarchically downward as instances are bound. When searching for a cell to bind to the current
unbound instance, and in the absence of an applicable binding expansion clause, the specified library list is
searched in the specified order.
The current library list is selected by the selection clauses. If no library list clause is selected or if the
selected library list is empty, then the library list contains the single name that is the library in which the cell
containing the unbound instance is found (i.e., the parent cell’s library).
33.4.1.6 The use clause
The clause specifies a specific binding for the selected cell. A clause can only be used in
use use
conjunction with an or selection clause. It specifies the exact library and cell to which a
instance cell
selected cell or instance is bound.
The clause has no effect on the current value of the library list. It can be common in practice to specify
use
multiple config rule statements, one of which specifies a binding and the other of which specifies a library
list.
If the lib cell to which the clause refers is a config that has the same name as a module/primitive in the
. use
same library, then the optional suffix can be added to the lib cell to specify the config explicitly.
:config .
If the library name is omitted, the library shall be inherited from the parent cell.
NOTE—The binding statement can create situations where the unbound instance’s module name and the cell name to
which it is bound are different.
33.4.2 Hierarchical configurations
For situations where it is desirable to specify a special set of configuration rules for a subsection of a design,
it is possible to bind a particular instance directly to a configuration using the binding clause:
instance top.a1.c use lib1.c:config;
// bind to the config c in library lib1
that specifies the instance is to be replaced with the design hierarchy specified by the
top.a1.c
configuration . The statement in shall specify the actual binding
lib1.c:config design lib1.c:config
for the instance , and the rules specified in the config shall determine the configuration of all other
top.a1.c
subinstances under .
top.a1.c
907
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
It shall be an error for an instance clause to specify a hierarchical path to an instance that occurs within a
hierarchy specified by another config.
config bot;
design lib1.bot;
default liblist lib1 lib2;
instance bot.a1 liblist lib3;
endconfig
config top;
design lib1.top;
default liblist lib2 lib1;
instance top.bot use lib1.bot:config;
instance top.bot.a1 liblist lib4;
// ERROR - cannot set liblist for top.bot.a1 from this config
endconfig
33.4.3 Setting parameters in configurations
Configurations can be used to override parameters declared within a design, or to apply or override
parameter values for specific instantiations of a design. When a common value is desired for overriding a
number of parameters in a configuration, a localparam can be declared in the configuration.
The following is a list of detailed restrictions regarding setting parameters from a configuration:
— A localparam declared in a configuration must be assigned a value and shall only be set to a literal
value.
— Index expressions in a hierarchical name shall only refer to literals or localparams of the
configuration.
— Parameters identifiers shall be resolved starting in the parent scope of the instance. If a hierarchical
identifier is used, it must be the only term in the expression, e.g., a.b.c + 7 is invalid.
— Parameter identifiers that bind into the parent of the configured instance shall be identifiers that are
legal in a bind statement.
— Hierarchical references cannot include scopes of generate or array of instances.
— A parameter override in a configuration shall not refer to a constant function other than a built-in
constant system function.
— A parameter override from a configuration shall take precedence over a statement when
defparam
both are referencing the same parameter at the same level of hierarchy. In all other conditions,
statements work as defined.
defparam
— Configurations may not use positional parameter notation to override parameters.
The following two code sample modules are used by examples in this subclause. Note that module top
includes an instantiation of adder and does not include any direct parameter modifications.
module adder #(parameter ID = "id",
W = 8,
D = 512)
(...);
...
$display("ID = %s, W = %d, D = %d", ID, W, D);
...
endmodule: adder
908
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 1:
module top (...);
parameter WIDTH = 16;
adder a1 (...);
endmodule
Example 2:
The preceding code, without any parameter overrides on adder , will print the following:
a1
ID = id, W=8, D = 512
A configuration can be used to override a parameter in a module and apply that overridden parameter to
instantiations within that module. The configuration in Example 3 overrides the default value of parameter
in module shown in Example 2. Example 3 then uses parameter to override the parameter
WIDTH top WIDTH
for the instantiation of . (The code for is found in Example 1.)
adder adder
config cfgl;
design rtlLib.top;
instance top use #(.WIDTH(32));
instance top.a1 use #(.W(top.WIDTH));
endconfig
Example 3:
Using configuration above, the in will print the following:
cfg1 $display adder
ID = id, W=32, D = 512
A localparam can be used in a configuration to represent a value sent to multiple instances.
module top4 ();
parameter S = 16;
adder a1 #(.ID("a1"))(...);
adder a2 #(.ID("a2"))(...);
adder a3 #(.ID("a3"))(...);
adder a4 #(.ID("a4"))(...);
endmodule
config cfg2;
localparam S = 24;
design rtlLib.top4;
instance top4.a1 use #(.W(top4.S));
instance top4.a2 use #(.W(S));
endconfig
Example 4:
With configuring module , the in will print the following:
cfg2 top4.a1 $display adder
ID = a1, W=16, D = 512
ID = a2, W=24, D = 512
ID = a3, W=8, D = 512
ID = a4, W=8, D = 512
909
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In Example 4, the override of adder port in is maintained. This example also used the same
ID top4
parameter identifier and localparam identifier in both module and config . There is no conflict in
top4 cfg2
the configuration since the localparam in config is directly accessed in the configuration. When config
cfg2
needs to use parameter in module , parameter has to be referenced via the design name in the
cfg2 S top S
configuration.
A parameter override with empty parentheses will set the parameter back to its default as defined in its
module.
module top5 (...);
parameter WIDTH = 64, DEPTH = 1024, ID = "A1";
adder a1 #(.ID(ID), .W(WIDTH), .D(DEPTH))(...);
endmodule
Example 5:
Using the preceding code, the in will print the following:
$display adder
ID = A1, W=64, D = 1024
config cfg3;
design rtlLib.top5;
instance top5.a1 use #(.W()); // set only parameter W back to its default
endconfig
Example 6:
When the preceding configuration configures module , the in will print the
cfg3 top5.a1 $display adder
following:
ID = A1, W=8, D = 1024
Only parameter is configured to use its default value.
W
All the parameters can be reset to their default values, meaning their initial values prior to any parameter
overrides. This is shown in the following configuration, which uses the module from Example 2.
top
config cfg4;
design rtlLib.top;
instance top.a1 use #(); // set all parameters in instance a1
// back to their defaults
endconfig
Example 7:
This configuration of will print the following:
top.a1
ID = id, W=8, D = 512
When both a configuration and a statement are modifying the same parameter at the same
defparam
hierarchal level, the configuration shall take precedence. The following code adds a level of hierarchy,
which includes statements:
defparam
module test;
...
top8 t(...);
910
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
defparam t.WIDTH = 64;
defparam t.a1.W = 16;
...
endmodule
module top8 (...);
parameter WIDTH = 32;
adder a1 #(.ID("a1")) (...);
adder a2 #(.ID("a2"),.W(WIDTH))(...);
endmodule
module adder #(parameter ID = "id",
W = 8,
D = 512)
(...);
...
$display("ID = %s, W = %d, D = %d", ID, W, D);
...
endmodule
config cfg6;
design rtlLib.test;
instance test.t use #(.WIDTH(48));
endconfig
Example 8:
With configuring module , the in will print the following:
cfg6 top8.a1 $display adder
ID = a1, W=16, D = 512
ID = a2, W=48, D = 512
33.5 Using libraries and configs
This subclause describes potential use models for referencing configs on the command line. It is included for
clarification purposes.
The traditional SystemVerilog simulation use model takes a file-based approach, where the source
descriptions for all cells in the design are specified on the command line for each invocation of the tool.
With the advent of compiled-code simulators, the configuration mechanism shall also support a use model
that allows for the source files to be precompiled and then for the precompiled design objects to be
referenced on the command line. This subclause explains how configurations can be used in both of these
scenarios.
33.5.1 Precompiling in a single-pass use model
The single-pass use model is the traditional use model with which most users are familiar. In this use model,
all of the source description files shall be provided to the simulator via the command line, and only these
source descriptions can be used to bind cell instances in the current design. A precompiling strategy in this
scenario actually parses every cell description provided on the command line and maps it into the library
without regard to whether the cell actually is used in the design. The tool can optionally check to see
whether the cell already exists in the library and, if it is up-to-date (i.e., the source description has not
changed since the last time the cell was compiled), can skip recompiling the cell. After all cells on the
command line have been compiled, then the tool can locate the top-level cell (discussed in 23.3.1) and
proceed down the hierarchy, binding each instance as it is encountered in the hierarchy.
NOTE—With this use model, it is not necessary for library objects to persist from one tool invocation to another
(although for performance considerations it is recommended they do).
911
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
33.5.2 Elaboration-time compiling in a single-pass use model
An alternate strategy that can be used with a single-pass tool is to parse the source files only to find the
top-level module(s), without actually compiling anything into the library during this scanning process. Once
the top-level module(s) has been found, then it can be compiled into the library, and the tool can proceed
down the hierarchy, only compiling the source descriptions necessary to bind the design successfully. Based
on the binding rules in place, only the source files that match the current library specification need to be
parsed to find the current cell’s source description to compile. As with the precompiled single-pass use
model, it is not necessary for library cells to persist from one invocation to another using this strategy.
33.5.3 Precompiling using a separate compilation tool
When using a separate compilation tool, it is essential that library cells persist, and the compiled forms shall,
therefore, exist somewhere in the file system. The exact format and location for holding these compiled
forms shall be vendor- or tool-specific. Using this separate compiler strategy, the source descriptions shall
be parsed and compiled into the library using one or more invocations of the compiler tool. The only
restriction is that all cells in a design shall be precompiled prior to binding the design (typically via an
invocation of a separate tool). Using this strategy, the tool that actually does the binding only needs to be
told the top-level module(s) of the design to be bound, and then it shall use the precompiled form of the cell
description(s) from the library to determine the subinstances and descend hierarchically down the design,
binding each cell as it is located.
33.5.4 Command line considerations
In each of the three preceding strategies, either the binding rules can be specified via a config, or the default
rules (from the library map file) can be used. In the single-pass use models, the config can be specified by
including its source description file on the command line. In the case where the config includes a
design
statement, then the specified cell shall be the top-level module, regardless of the presence of any
uninstantiated cells in the rest of the source files. When using a separate compilation tool, the tool that
actually does the binding only needs to be given the lib.cell specification for the top-level cell(s) and/or the
config to be used. In this strategy, the config itself shall also be precompiled.
33.6 Configuration examples
Consider the following set of source descriptions:
file top.v file adder.v file adder.vg file lib.map
module top(...); module adder(...); module adder(...); library rtlLib top.v;
... ... // rtl ... // gate-level library aLib adder.*;
adder a1(...); m f1(...); m f1(...); library gateLib
adder a2(...); m f2(...); m f2(...); adder.vg;
endmodule endmodule endmodule
module m(...); module m(...); module m(...);
... // rtl ... // rtl ... // gate-level
endmodule endmodule endmodule
All of the examples in this subclause shall assume the , and files get compiled
top.v adder.v adder.vg
with the given file. This yields the following library structure:
lib.map
rtlLib.top // from top.v
rtlLib.m // from top.v
aLib.adder // from adder.v
aLib.m // rtl from adder.v
gateLib.adder // from adder.vg
gateLib.m // from adder.vg
912
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
33.6.1 Default configuration from library map file
With no configuration, the libraries are searched according to the library declaration order in the library map
file. In other words, all instances of module shall use (because is the first library
adder aLib.adder aLib
specified that contains a cell named ), and all instances of module shall use (because
adder m rtlLib.m
is the first library that contains ).
rtlLib m
33.6.2 Using default clause
To always use the definition from file , use the following simple configuration:
m adder.v
config cfg1;
;
design rtlLib.top
default liblist aLib rtlLib;
endconfig
The statement overrides the library search order in the file; therefore, is
defaultliblist lib.map aLib
always searched before . Because the library is not included in the , the
rtlLib gateLib liblist
gate-level descriptions of and shall not be used.
adder m
To use the gate-level representations of and , add to the config as follows:
adder m
config cfg2;
;
design rtlLib.top
default liblist gateLib aLib rtlLib;
endconfig
This shall cause the gate representation always to be taken before the representation, using the module
rtl
definitions for and from . The view of top shall be taken because there is no gate
adder m adder.vg rtl
representation available.
33.6.3 Using cell clause
To modify the config to use the view of and the gate-level representation of from ,
rtl adder m gateLib
use the following:
config cfg3;
;
design rtlLib.top
default liblist aLib rtlLib;
cell m use gateLib.m ;
endconfig
The cell clause selects all cells named and explicitly binds them to the gate representation in .
m gateLib
33.6.4 Using instance clause
To modify the config so the (and its descendants) use the gate representation and the
top.a1 adder
(and its descendants), use the representation from :
top.a2adder rtl aLib
config cfg4
;
design rtlLib.top
default liblist gateLib rtlLib;
instance top.a2 liblist aLib;
endconfig
913
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Because the is inherited, all of the descendants of inherit its from the instance
liblist top.a2 liblist
selection clause.
33.6.5 Using hierarchical config
Now suppose all this work has only been on the adder module by itself and a config that uses the
rtlLib.m
cell for , and the cell for has already been developed. Then, use the following:
f1 gateLib.m f2
config cfg5;
design aLib.adder;
default liblist gateLib aLib;
instance adder.f1 liblist rtlLib;
endconfig
To use this configuration for the instance of and take the full default for
cfg5 top.a2 adder aLibadder
the instance, use the following config:
top.a1
config cfg6;
design rtlLib.top;
default liblist aLib rtlLib;
;
instance top.a2 use work.cfg5:config
endconfig
The binding clause specifies the configuration is to be used to resolve the bindings of
work.cfg5:config
instance and its descendants. It is the statement in config that defines the exact
top.a2 design cfg5
binding for the instance itself. The rest of defines the rules to bind the descendants of
top.a2 cfg5
. Notice the instance clause in is relative to its own top-level module, .
top.a2 cfg5 adder
33.7 Displaying library binding information
It shall be possible to display the actual library binding information for module instances during simulation.
The format specifier or shall print out the binding information for the module
%l %L library.cell
instance containing the display (or other textual output) command. This is similar to the format specifier,
%m
which prints out the hierarchical path name of the module containing it.
It shall also be able to use VPI to display the binding information. The following VPI properties shall exist
for objects of type :
vpiModule
— —the library name into which the module was compiled
vpiLibrary
— —the name of the cell bound to the module instance
vpiCell
— —the name of the config controlling the binding of the module
vpiConfig library.cell
instance
These properties shall be of type, similar to the and properties.
string vpiName vpiFullName
33.8 Library mapping examples
In the absence of a configuration, it is possible to perform basic control of the library searching order when
binding a design.
When a config is used, the config overrides the rules specified in this subclause.
914
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
33.8.1 Using the command line to control library searching
In the absence of a configuration, it shall be necessary for all compliant tools to provide a mechanism of
specifying a library search order on the command line that overrides the default order from the library map
file. This mechanism shall include specification of library names only, with the definitions of these libraries
to be taken from the library map file.
NOTE—It is recommended all compliant tools use “-L <library_name>” to specify this search order.
33.8.2 File path specification examples
For example, given the following set of files:
/proj/lib1/rtl/a.v
/proj/lib2/gates/a.v
/proj/lib1/rtl/b.v
/proj/lib2/gates/b.v
From the , the following absolute are resolved as follows:
/proj library file_path_specs
/proj/lib*/*/a.v = /proj/lib1/rtl/a.v, /proj/lib2/gates/a.v
.../a.v = /proj/lib1/rtl/a.v, /proj/lib2/gates/a.v
/proj/.../b.v = /proj/lib1/rtl/b.v, /proj/lib2/gates/b.v
.../rtl/*.v = /proj/lib1/rtl/a.v, /proj/lib1/rtl/b.v
From the directory, the following relative are resolved as follows:
/proj/lib1 file_path_specs
../lib2/gates/*.v = /proj/lib2/gates/a.v, /proj/lib2/gates/b.v
./rtl/?.v = /proj/lib1/rtl/a.v, /proj/lib1/rtl/b.v
./rtl/ = /proj/lib1/rtl/a.v, /proj/lib1/rtl/b.v
33.8.3 Resolving multiple path specifications
For example:
library lib1 "/proj/lib/foo*.v";
library lib2 "/proj/lib/foo.v";
library lib3 "../lib/";
library lib4 "/proj/lib/*ver.v";
When evaluated from the directory directory, the following source files shall map into the
/proj/tb
specified library:
../lib/foobar.v // Maps to library lib1. Potentially matches lib1 and
// lib3. Because lib1 includes a filename and lib3 only
// specifies a directory, lib1 takes precedence
// (see 33.3.1.1 b)
/proj/lib/foo.v // Maps to library lib2. Takes precedence over lib1 and
// lib3 path specifications (see 33.3.1.1 a)
/proj/lib/bar.v // Maps to library lib3. (see 33.3.1.1 c)
/proj/lib/barver.v // Maps to library lib4. Takes precedence over lib3 path
// specification (see 33.3.1.1 b)
915
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
/proj/lib/foover.v // ERROR, matches lib1 and lib4 (see 33.3.1.1)
/test/tb/tb.v // Maps to library work. Does not match any library
// specification (see 33.3.1)
916
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
34. Protected envelopes
34.1 General
This clause describes the following:
— Processing protected envelopes
— Protect pragma directives
— Protect pragma keywords
34.2 Overview
Protected envelopes specify a region of text that shall be transformed prior to analysis by the source
language processor. These regions of text are structured to provide the source language processor with the
specification of the cryptographic algorithm, key, envelope attributes, and textual design data.
All information that identifies a protected envelope is introduced by the pragma (see 22.11). This
protect
pragma is reserved by this standard for the description of protected envelopes and is the prefix for specifying
the regions and processing specifications for each protected envelope. Additional information is associated
with the pragma by appending pragma expressions. The pragma expressions of the pragma are
protect
evaluated in sequence from left to right. Interpretation of protected envelopes shall not be altered based on
whether the sequence of pragma expressions occurs in a single pragma directive or in a sequence
protect
of pragma directives. In this clause, unless otherwise specified, pragma directives, pragma
protect
keywords, and pragma expressions shall refer to occurrences of pragma directives and their
protect
associated pragma keywords and pragma expressions.
Envelopes may be defined for either of two modes of processing. Encryption envelopes specify the pragma
expressions for encrypting source text regions. An encryption envelope begins in the source text when a
pragma expression is encountered. The end of the encryption envelope occurs at the point where an
begin
pragma expression is encountered. The pragma expression is said to close the envelope and shall be
end end
associated with the most recent pragma expression.
begin
Decryption envelopes specify the pragma expressions for decrypting encrypted text regions. A decryption
envelope begins in the source text when a pragma expression is encountered. The end
begin_protected
of the decryption envelope occurs at the point where an pragma expression is encountered.
end_protected
The pragma expression is said to close the envelope and shall be associated with the most
end_protected
recent that has not already been closed. Decryption envelopes may contain other
begin_protected
envelopes within their enclosed data block. The number of nested decryption envelopes that can be
processed is implementation-specific; however, that number shall be no less than 8. Code that is contained
within a decryption envelope is said to be protected.
Pragma expressions that precede or are designated as envelope keywords.
begin begin_protected
Pragma expressions that follow the / keywords and precede the associated /
beginbegin_protected end
keywords are designated as content keywords. Content keywords are pragma expressions
end_protected
that are within the region of text that is processed during encryption or decryption of a protected envelope.
34.3 Processing protected envelopes
Two modes of processing are defined for protected envelopes. Envelope encryption is the process of
recognizing encryption envelopes in the source text and transforming them into decryption envelopes.
Envelope decryption is the process of recognizing decryption envelopes in the input text and transforming
them into the corresponding cleartext for the compilation step that follows.
917
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Tools that process SystemVerilog source code shall perform envelope decryption for all decryption
envelopes contained in the source text, where the proper key is supplied by the user. Tools that perform
envelope encryption shall only be required to process the protect pragma directives and shall apply no other
interpretation to text that is not part of a protect pragma directive.
34.3.1 Encryption
SystemVerilog tools that provide encryption services shall transform source text containing encryption
envelopes by replacing each encryption envelope with a decryption envelope formed by encrypting the
source text of the encryption envelope according to the specified pragma expressions.
Source text that is not contained in an encryption envelope shall not be modified by the encrypting language
processor, unless otherwise specified.
Decryption envelopes are formed from encryption envelopes by transforming the specified encryption
envelope pragma expressions into decryption envelope pragma expressions and decryption content pragma
expressions. The body of the encryption envelope is encrypted using the specified key, referred to as the
exchange key, and is recorded in the decryption envelope as a .
data_block
Encryption algorithms that use the same key to encrypt cleartext and decrypt the corresponding ciphertext
are said to be symmetric. Algorithms that require different keys to encrypt and decrypt are said to be
asymmetric. This description may be applied to both the algorithm and the key.
Tools that provide encryption services may support session keys to limit exposure to the exchange key that is
specified by the IP author using the encryption envelope pragma expressions. A session key is created in an
unspecified manner to encrypt the data from the encryption envelope. A copy of the session key is encrypted
using the exchange key and is recorded in a in the decryption envelope. Next, the body of the
key_block
encryption envelope is encrypted using the session key and is recorded in the decryption envelope as a
.
data_block
The following example shows the use of the pragma to specify encryption of design data. The
protect
encryption method is a simple substitution cipher where each alphabetic character is replaced with the 13th
character in alphabetic sequence, commonly referred to as “rot13.” Nonalphabetic characters are not
substituted. The following design data contain an encryption envelope that specifies the desired protection.
module secret (a, b);
input a;
output b;
`pragma protect encoding=(enctype="raw")
`pragma protect data_method="x-caesar", data_keyname="rot13", begin
`pragma protect
runtime_license=(library="lic.so",feature="runSecret",entry="chk", match=42)
logic b;
initial
begin
b = 0;
end
always
begin
#5 b = a;
end
`pragma protect end
endmodule // secret
918
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
After encryption processing, the following design data are produced. The decryption envelope is written
with a “raw” encoding to make the substitution encryption directly visible.
NOTE 1—The encoded line beginning is actually one long line, but it wraps over to the following line on the
`centzn
printed page.
module secret (a, b);
input a;
output b;
`pragma protect encoding=(enctype="raw")
`pragma protect data_method="x-caesar", data_keyname="rot13",
begin_protected
`pragma protect encoding=(enctype="raw", bytes=190), data_block
`centzn cebgrpg ehagvzr_yvprafr=(yvoenel="yvp.fb",srngher="ehaFrperg",
ragel="pux",zngpu=42)
ert o;
vavgvny
ortva
o = 0;
raq
nyjnlf
ortva
#5 o = n;
raq
`pragma protect end_protected
`pragma reset protect
endmodule // secret
NOTE 2—Products that include cryptographic algorithms may be subject to government laws and regulations, including
possible restrictions or limitations on transfer or use in many jurisdictions. Users of this standard are advised to seek the
advice of competent counsel to determine all applicable legal and regulatory obligations.
34.3.2 Decryption
SystemVerilog tools that support decrypting compilation shall transform source text containing decryption
envelopes by replacing each decryption envelope with the decrypted source text from the ,
data_block
according to the specified pragma expressions. The substituted text may contain usages of text macros,
which shall be substituted after replacement of the decryption envelope. The substituted text may also
contain decryption envelopes, which shall be decrypted and substituted after replacement of their enclosing
decryption envelope.
34.4 Protect pragma directives
Protected envelopes are lexical regions delimited by pragma directives. The effect of a particular
protect
pragma directive is specified by its pragma expressions. This standard defines the pragma
protect
keyword names listed in Table34-1 for use with the pragma. These pragma keywords are defined
protect
in 34.5 with a specification of how each participates in the encryption and decryption processing modes.
919
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table34-1—protect pragma keywords
Pragma keyword Description
begin Opens a new encryption envelope
end Closes an encryption envelope
begin_protected Opens a new decryption envelope
end_protected Closes a decryption envelope
author Identifies the author of an envelope
author_info Specifies additional author information
encrypt_agent Identifies the encryption service
encrypt_agent_info Specifies additional encryption service information
encoding Specifies the coding scheme for encrypted data
data_keyowner Identifies the owner of the data encryption key
data_method Identifies the data encryption algorithm
data_keyname Specifies the name of the data encryption key
data_public_key Specifies the public key for data encryption
data_decrypt_key Specifies the data session key
data_block Begins an encoded block of encrypted data
digest_keyowner Identifies the owner of the digest encryption key
digest_key_method Identifies the digest encryption algorithm
digest_keyname Specifies the name of the digest encryption key
digest_public_key Specifies the public key for digest encryption
digest_decrypt_key Specifies the digest session key
digest_method Specifies the digest computation algorithm
digest_block Specifies a message digest for data integrity
key_keyowner Identifies the owner of the key encryption key
key_method Specifies the key encryption algorithm
key_keyname Specifies the name of the key encryption key
key_public_key Specifies the public key for key encryption
key_block Begins an encoded block of key data
decrypt_license Specifies licensing constraints on decryption
runtime_license Specifies licensing constraints on simulation
comment Uninterpreted documentation string
reset Resets pragma keyword values to default
viewport Modifies scope of access into decryption envelope
920
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The scope of pragma directives is completely lexical and not associated with any declarative
protect
region or declaration in the source text itself. This lexical scope may cross file boundaries and included files.
In protected envelopes where a specific pragma keyword is absent, the SystemVerilog tool shall use the
default value. SystemVerilog tools that perform encryption should explicitly output all relevant pragma
keywords for each envelope in order to avoid unintended interpretations during decryption. Further
robustness can be achieved by appending a pragma keyword after each envelope.
reset
34.5 Protect pragma keywords
34.5.1 begin
34.5.1.1 Syntax
begin
34.5.1.2 Description
ENCRYPTION INPUT: The pragma expression is used in the input text to indicate to an encrypting
begin
tool the point at which encryption shall begin.
Nesting of pragma blocks shall be an error. There may be -
begin-end begin_protected
blocks containing previously encrypted content inside such a block. They are simply
end_protected
treated as a byte stream and encrypted as if they were text.
ENCRYPTION OUTPUT: The pragma expression is replaced in the encryption output stream by the
begin
pragma expression. Following , all pragma expressions required as
begin_protected begin_protected
encryption output shall be generated prior to the pragma expression. Protected envelopes
end_protected
should be completely self-contained to avoid any undesired interaction when multiple encrypted models
exist in the decryption input stream. The and pragma expressions introduce the
data_block key_block
encrypted data or keys and will always be found within a - envelope.
begin_protected end_protected
All text, including comments and other pragmas, occurring between the pragma expression
protect begin
and the corresponding pragma expression shall, unless otherwise specified, be encrypted and placed in
end
the encryption output stream using the pragma expression. An unspecified length of arbitrary
data_block
comment text may be added by the encrypting tool to the beginning and end of the input text in order to
prevent known text attacks on the encrypted content of the .
data_block
DECRYPTION INPUT: none
34.5.2 end
34.5.2.1 Syntax
end
34.5.2.2 Description
ENCRYPTION INPUT: The pragma expression is used in the input cleartext to indicate the end of the
end
region that shall be encrypted.
ENCRYPTION OUTPUT: The pragma expression is replaced in the encryption output stream by the
end
pragma expression.
end_protected
921
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
DECRYPTION INPUT: none
34.5.3 begin_protected
34.5.3.1 Syntax
begin_protected
34.5.3.2 Description
ENCRYPTION INPUT: When a - block is found in an input file
begin_protected end_protected
during encryption, its contents are treated as input cleartext. This allows a previously encrypted model to be
reencrypted as a portion of a larger model. Any other pragmas inside the -
protect begin_protected
block shall not be interpreted and shall not override pragmas in effect. Nested encryption
end_protected
shall not corrupt pragma values in the current encryption in process.
ENCRYPTION OUTPUT: The pragma expression, and the entire content of the
begin_protected
protected envelope up to the corresponding pragma expression, shall be encrypted into the
end_protect
current as specified by the current method and keys.
data_block
DECRYPTION INPUT: The pragma expression begins a previously encrypted region.
begin_protected
A decrypting tool shall accumulate all the pragma expressions in the block for use in decryption of the
block.
34.5.4 end_protected
34.5.4.1 Syntax
end_protected
34.5.4.2 Description
ENCRYPTION INPUT: This pragma expression indicates the end of a previous block.
begin_protected
This indicates that the block is complete, and subsequent pragma expression values will be accumulated for
the next envelope.
ENCRYPTION OUTPUT: The pragma expression following the corresponding
end_protected
pragma expression shall be encrypted into the current as specified by the
begin_protected data_block
current method and keys.
DECRYPTION INPUT: The pragma expression indicates the end of a set of pragmas that
end_protected
are sufficient to decrypt the current block.
34.5.5 author
34.5.5.1 Syntax
author = <string>
34.5.5.2 Description
ENCRYPTION INPUT: The pragma expression specifies a string that identifies the name of the IP
author
author. It is distinct from the comment pragma expression so that this information can be recognized without
need for parsing of a comment string value.
922
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
ENCRYPTION OUTPUT: If present in the encryption envelope, the pragma expression shall be
author
placed in a pragma directive enclosed within the protected envelope, but shall not be encrypted into the
. Otherwise, it is copied without change into the output stream.
data_block
DECRYPTION INPUT: none
34.5.6 author_info
34.5.6.1 Syntax
author_info = <string>
34.5.6.2 Description
ENCRYPTION INPUT: The pragma expression specifies a string that contains additional
author_info
information provided by the IP author. It is distinct from the comment pragma expression so that this
information can be recognized without need for parsing of a comment string value.
ENCRYPTION OUTPUT: If present in the encryption envelope, the pragma expression
author_info
shall be placed in a pragma directive enclosed within the protected envelope, but shall not be encrypted into
the . Otherwise, it is copied without change into the output stream.
data_block
DECRYPTION INPUT: none
34.5.7 encrypt_agent
34.5.7.1 Syntax
encrypt_agent = <string>
34.5.7.2 Description
ENCRYPTION INPUT: none
ENCRYPTION OUTPUT: The pragma expression specifies a string that identifies the
encrypt_agent
name of the encrypting tool. The encrypting tool shall generate this pragma expression and place it in a
pragma directive enclosed within the protected envelope, but shall not encrypt it into the .
data_block
DECRYPTION INPUT: none
34.5.8 encrypt_agent_info
34.5.8.1 Syntax
encrypt_agent_info = <string>
34.5.8.2 Description
ENCRYPTION INPUT: none
ENCRYPTION OUTPUT: The pragma expression specifies a string that contains
encrypt_agent_info
additional information provided by the encrypting tool. If provided, the pragma
encrypt_agent_info
expression shall be placed within a pragma directive enclosed within the protected envelope, but shall not be
encrypted into the .
data_block
923
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
DECRYPTION INPUT: none
34.5.9 encoding
34.5.9.1 Syntax
encoding = ( enctype = <string> [ , line_length = <number> ]
[ , bytes = <number> ] )
34.5.9.2 Description
ENCRYPTION INPUT: The pragma expression specifies how the ,
encoding data_block
, and content shall be encoded. This encoding allows all binary data produced
digest_block key_block
in the encryption process to be treated as text. If an pragma expression is present in the input
encoding
stream, it specifies how the output shall be encoded.
The following subkeywords are defined for the value of the pragma expression:
encoding
=<string> The method for calculating the encoding. This standard specifies the identifiers
enctype
in Table34-2 as string values for the enctype subkeyword. These identifiers are
associated with their respective encoding algorithms. The required methods are
standard in every implementation. Optional identifiers are implementation-
specific, but are required to use these identifiers for the corresponding encoding
algorithm. Additional identifier values and their corresponding encoding
algorithms are implementation-defined.
Table34-2—Encoding algorithm identifiers
Required/
enctype Encoding algorithm
optional
uuencode Required IEEE Std 1003.1 (uuencode historical algorithm)
base64 Required IETF RFC 2045 [also IEEE Std 1003.1 (uuencode -m)]
quoted-printable Optional IETF RFC 2045
raw Optional Identity transformation; no encoding shall be performed,
and the data may contain nonprintable characters.
=<number>
line_length
The maximum number of characters (after any encoding) in a single line of the
. Insertion of line breaks in the after encryption and
data_block data_block
encoding allows the generated text files to be usable by commonly available text
tools.
=<number> The number of bytes in the original block of data before any encoding or the
bytes
addition of line breaks. This encoding keyword shall be ignored in the encryption
input.
ENCRYPTION OUTPUT: The directive shall be output in each –
encoding begin_protected
block to explicitly specify the encoding used by the encrypt_agent. A tool may choose to
end_protected
encode the data even if no encoding pragma expression was found in the input stream and shall output the
corresponding encoding pragma expression. The tool shall generate an encoding descriptor that specifies in
the bytes keyword the number of bytes in the original block of data.
924
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The , , , , , and
data_block data_public_key data_decrypt_key digest_block key_block
are all encoded using this encoding. If separate encoding is desired for each of these
key_public_key
fields, then multiple pragma expressions can be given in the input stream prior to each of the
encoding
above pragma expressions. The value is added by the encrypting tool for each block that it encrypts.
bytes
DECRYPTION INPUT: During decryption, the directive is used to find the encoding algorithm
encoding
used and the size of actual data.
34.5.10 data_keyowner
34.5.10.1 Syntax
data_keyowner = <string>
34.5.10.2 Description
ENCRYPTION INPUT: The specifies the legal entity or tool that provided the keys used
data_keyowner
for encryption and decryption of the data. This pragma keyword permits use of a third-party key, distinct
from one associated with either or . The value is used by the
author encrypt_agent data_keyowner
encrypting tool to select the key used to encrypt the . The values for ,
data_block data_keyname
, and shall be unique for the specified .
data_decrypt_key data_public_key data_keyowner
ENCRYPTION OUTPUT: The shall be unchanged in the output file, except where a
data_keyowner
digital signature is used, in which case it is encrypted with the and placed in a .
key_method key_block
DECRYPTION INPUT: During decryption, the data_keyowner is combined with the data_keyname or
to determine the appropriate secret/private key to use during decryption of the
data_public_key
.
data_block
34.5.11 data_method
34.5.11.1 Syntax
data_method = <string>
34.5.11.2 Description
ENCRYPTION INPUT: The pragma expression specifies the encryption algorithm that shall
data_method
be used to encrypt subsequent blocks. The encryption method is an identifier that is commonly
begin-end
associated with a specific encryption algorithm. If the specified encryption algorithm uses a cipher-block
chaining (CBC) technique that requires an Initialization Vector (IV), it is recommended that the IV be
randomly generated for each use of the cipher.
This standard specifies the identifiers in Table34-3 as string values for the pragma
data_method
expression. These identifiers are associated with their respective encryption types. The required methods are
standard in every implementation. Optional identifiers are implementation-specific, but are required to use
these identifiers for the corresponding cipher. Additional identifier values and their corresponding ciphers
are implementation-defined.
925
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table34-3—Encryption algorithm identifiers
Required/
Identifier Encryption algorithm
optional
des-cbc Required Data Encryption Standard (DES) in CBC mode, see FIPS46-3.
3des-cbc Optional Triple DES in CBC mode, see FIPS 46-3; ANSI X9.52-1998.
aes128-cbc Optional Advanced Encryption Standard (AES) with 128-bit key, see FIPS197.
aes256-cbc Optional AES in CBC mode, with 256-bit key.
aes192-cbc Optional AES with 192-bit key.
blowfish-cbc Optional Blowfish in CBC mode, see Schneier (Blowfish).
twofish256-cbc Optional Twofish in CBC mode, with 256-bit key, see Schneier (Twofish).
twofish192-cbc Optional Twofish with 192-bit key.
twofish128-cbc Optional Twofish with 128-bit key.
serpent256-cbc Optional Serpent in CBC mode, with 256-bit key, see Anderson, et al.
serpent192-cbc Optional Serpent with 192-bit key.
serpent128-cbc Optional Serpent with 128-bit key.
cast128-cbc Optional CAST-128 in CBC mode, see IETF RFC 2144.
rsa Optional RSA, see IETF RFC 2437.
elgamal Optional ElGamal, see ElGamal.
pgp-rsa Optional OpenPGP RSA key, see IETF RFC 2440.
ENCRYPTION OUTPUT: The shall be unchanged in the output file, except where a digital
data_method
signature is used, in which case it is encrypted with the and placed in a .
key_method key_block
DECRYPTION INPUT: The specifies the algorithm that should be used to decrypt the
data_method
data_block.
34.5.12 data_keyname
34.5.12.1 Syntax
data_keyname = <string>
34.5.12.2 Description
ENCRYPTION INPUT: The pragma expression specifies the name of the key, or key pair,
data_keyname
for an asymmetric encryption algorithm, that should be used to decrypt the . It shall be an error
data_block
to specify a that is not a member of the list of keys known for the given .
data_keyname data_keyowner
ENCRYPTION OUTPUT: When a is provided in the input, it indicates the key that should
data_keyname
be used for encrypting the data. The encrypting tool shall combine this pragma expression with the
and determine the key to use. The itself shall be output as cleartext in the
data_keyname data_keyname
926
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
output file except where a digital envelope is used. For a digital envelope mechanism, the is
data_keyname
encrypted using and / and encoded in the .
key_method key_keynamekey_public_key key_block
DECRYPTION INPUT: The value is combined with the to select a single
data_keyname data_keyowner
key that shall be used to decrypt the from the protected envelope.
data_block
34.5.13 data_public_key
34.5.13.1 Syntax
data_public_key
34.5.13.2 Description
ENCRYPTION INPUT: The pragma expression specifies that the next line of the file
data_public_key
contains the encoded value of the public key to be used to encrypt the data. The encoding is specified by the
pragma expression that is currently in effect. If both and
encoding data_public_key data_keyname
are present, then they shall refer to the same key.
ENCRYPTION OUTPUT: The pragma expression shall be output in each protected
data_public_key
block for which it is used, followed by the encoded value. The and can
data_method data_public_key
be combined to fully specify the required encryption.
DECRYPTION INPUT: The and can be combined with the
data_keyowner data_method
to determine whether the decrypting tool knows the corresponding private key to
data_public_key
decrypt a given . If the decrypting tool can compute the required key, the model can be
data_block
decrypted (if licensing allows it).
34.5.14 data_decrypt_key
34.5.14.1 Syntax
data_decrypt_key
34.5.14.2 Description
ENCRYPTION INPUT: The indicates that the next line contains the encoded value of
data_decrypt_key
the key that will decrypt the . This pragma expression should only be used when digital
data_block
signatures are used. An IP author can generate a key and use it to encrypt the cleartext. This encrypted text is
then stored in the output file as the . Then the and are
data_block data_method data_decrypt_key
encrypted using the and stored in the output file as the contents of the . The
key_method key_block
itself is not reencrypted; only the information about the data key is.
data_block
ENCRYPTION OUTPUT: The is output as part of the encrypted content of the
data_decrypt_key
. The value is encoded as specified by the pragma expression.
key_block encoding
DECRYPTION INPUT: Upon determining that a digital signature was in use for a given protected region,
the decrypting tool shall decrypt the to find the and that in
key_block data_decrypt_key data_method
turn can be used to decrypt the .
data_block
927
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
34.5.15 data_block
34.5.15.1 Syntax
data_block
34.5.15.2 Description
ENCRYPTION INPUT: It shall be an error if a is found in an input file unless it is contained
data_block
within a previously generated – block, in which case it is ignored.
begin_protected end_protected
ENCRYPTION OUTPUT: The pragma expression indicates that a data block begins on the
data_block
next line in the file. The encrypting tool shall take each block, encrypt the contents as specified
begin-end
by the pragma expression, and then encode the block as specified by the pragma
data_block encoding
expression. The resultant text shall be output. If the specifies a CBC encryption algorithm
data_method
that requires an IV, then the IV cipher-block shall be prepended to the encrypted data before encoding is
performed.
DECRYPTION INPUT: The is first read in the encoded form. The encoding shall be reversed,
data_block
and then the block shall be internally decrypted. If the specifies a CBC encryption algorithm
data_method
that requires an IV, then the first cipher-block of the decoded shall be removed for use as the
data_block
IV. The remainder of the shall be internally decrypted.
data_block
34.5.16 digest_keyowner
34.5.16.1 Syntax
digest_keyowner = <string>
34.5.16.2 Description
ENCRYPTION INPUT: The specifies the legal entity or tool that provided the keys
digest_keyowner
used for encryption and decryption of the data. This pragma keyword permits use of a third-party key,
distinct from one associated with either or . The value is used
author encrypt_agent digest_keyowner
by the encrypting tool to select the key used to encrypt the digest_block. The values for ,
digest_keyname
, and shall be unique for the specified .
digest_decrypt_key digest_public_key digest_keyowner
If no is specified in the input, then the default value of shall be the
digest_keyowner digest_keyowner
current value of .
data_keyowner
ENCRYPTION OUTPUT: The shall be unchanged in the output file, except where a
digest_keyowner
digital signature is used, in which case it is encrypted with the and placed in a
digest_key_method
.
digest_key_block
DECRYPTION INPUT: During decryption, the is combined with the
digest_keyowner
or to determine the appropriate secret/private key to use during
digest_keyname digest_public_key
decryption of the .
digest_block
34.5.17 digest_key_method
34.5.17.1 Syntax
digest_key_method = <string>
928
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
34.5.17.2 Description
ENCRYPTION INPUT: The pragma expression indicates the encryption algorithm
digest_key_method
that shall be used to encrypt subsequent contents. The values specified for
digest_block
to identify encryption algorithms are the same as those specified for .
digest_key_method data_method
If no is specified in the input, then the default value of shall
digest_key_method digest_key_method
be the current value of .
data_method
ENCRYPTION OUTPUT: The shall be unchanged in the output file, except where a
digest_key_method
digital signature is used, in which case it is encrypted with the algorithm and uses the key
key_method
found in the .
key_block
DECRYPTION INPUT: The indicates the algorithm that shall be used to decrypt the
digest_key_method
.
digest_block
34.5.18 digest_keyname
34.5.18.1 Syntax
digest_keyname = <string>
34.5.18.2 Description
ENCRYPTION INPUT: The pragma expression provides the name of the key, or key
digest_keyname
pair for an asymmetric encryption algorithm, that shall be used to decrypt the . It shall be an
digest_block
error to specify a that is not a member of the list of keys known for the given
digest_keyname
. If no is specified in the input, then the default value of
digest_keyowner digest_keyname
shall be the current value of .
digest_keyname data_keyname
ENCRYPTION OUTPUT: When a is provided in the input, it indicates the key that shall
digest_keyname
be used for encrypting the data. The encrypting tool shall combine this pragma expression with the
and determine the key to use. The itself shall be output as cleartext
digest_keyowner digest_keyname
in the output file except where a digital envelope is used. For a digital envelope mechanism, the
is encrypted using and / and encoded in
digest_keyname key_method key_keynamekey_public_key
the .
key_block
DECRYPTION INPUT: The value is combined with the to select a
digest_keyname digest_keyowner
single key that shall be used to decrypt the from the protected envelope.
digest_block
34.5.19 digest_public_key
34.5.19.1 Syntax
digest_public_key
34.5.19.2 Description
ENCRYPTION INPUT: The pragma expression indicates that the next line of the
digest_public_key
file contains the encoded value of the public key used to encrypt the digest. The encoding is specified by the
pragma expression that is currently in effect. If both and
encoding digest_public_key
are present, then they shall refer to the same key. If no is
digest_keyname digest_public_key
specified in the input, then the default value of shall be the current value of
digest_public_key
.
data_public_key
929
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
ENCRYPTION OUTPUT: The pragma expression shall be output in each protected
digest_public_key
block for which it is used, followed by the encoded value. The and
digest_key_method
can be combined to fully specify the required encryption.
digest_public_key
DECRYPTION INPUT: The and can be combined with the
digest_keyowner digest_key_method
to determine whether the decrypting tool knows the corresponding private key to
digest_public_key
decrypt a given . If the decrypting tool can compute the required key, the model can be
digest_block
decrypted (if licensing allows it).
34.5.20 digest_decrypt_key
34.5.20.1 Syntax
digest_decrypt_key
34.5.20.2 Description
ENCRYPTION INPUT: The indicates that the next line contains the encoded value
digest_decrypt_key
of the key that will decrypt the . This pragma expression should only be used when digital
digest_block
signatures are used. An IP author can generate a key and use it to encrypt the digest. This encrypted text is
then stored in the output file as the . Then the and
digest_block digest_key_method
are encrypted using the key_method and stored in the output file as the contents of
digest_decrypt_key
the . The itself is not reencrypted; only the information about the digest key is.
key_block digest_block
If no is specified in the input, then the default value of
digest_decrypt_key digest_decrypt_key
shall be the current value of .
data_decrypt_key
ENCRYPTION OUTPUT: The is output as part of the encrypted content of the
digest_decrypt_key
. The value is encoded as specified by the pragma expression.
key_block encoding
DECRYPTION INPUT: Upon determining that a digital signature was in use for a given protected region,
the decrypting tool shall decrypt the to find the and
key_block digest_decrypt_key
that in turn can be used to decrypt the digest block.
digest_key_method
34.5.21 digest_method
34.5.21.1 Syntax
digest_method = <string>
34.5.21.2 Description
ENCRYPTION INPUT: The pragma expression specifies the message digest algorithm
digest_method
that shall be used to generate message digests for subsequent and output. The
data_block key_block
string value is an identifier commonly associated with a specific message digest algorithm.
This standard specifies the values in Table34-4 for the pragma expression. Additional
digest_method
identifier values are implementation-defined.
930
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table34-4—Message digest algorithm identifiers
Required/
Identifier Message digest algorithm
optional
sha1 Required Secure Hash Algorithm 1 (SHA-1), see FIPS 180-2.
md5 Required Message Digest Algorithm 5, see IETF RFC 1321.
md2 Optional Message Digest Algorithm 2, see IETF RFC 1319.
ripemd-160 Optional RIPEMD-160, see ISO/IEC 10118-3:2004.
ENCRYPTION OUTPUT: The shall be unchanged in the output file, except where a
digest_method
digital signature is used, in which case it is encrypted with the and placed in a .
key_method key_block
DECRYPTION INPUT: The indicates the algorithm that shall be used to generate the
digest_method
digest from the .
data_block
34.5.22 digest_block
34.5.22.1 Syntax
digest_block
34.5.22.2 Description
ENCRYPTION INPUT: If a pragma expression is found in an input file (other than in a
digest_block
– block), it shall be treated by the encrypting tool as a request to
begin_protected end_protected
generate a message digest in the output file.
ENCRYPTION OUTPUT: A message digest is used to verify that the encrypted data have not been
modified. The encrypting tool generates the message digest (a fixed-length, computationally unique
identifier corresponding to a set of data) using the algorithm specified by the pragma
digest_method
expression and encrypts the message digest as specified by the pragma keyword
digest_key_method
using the key specified by , , , and
digest_keyname digest_key_keyowner digest_public_key
. If is not specified for the encryption envelope, then the
digest_decrypt_key digest_key_method
current encryption key shall be used. If the , or in its absence the
data_method digest_key_method
current , specifies a CBC encryption algorithm that requires an IV, then the IV cipher-block
data_method
shall be prepended to the encrypted digest before encoding is performed.
This digest shall then be encoded using the current pragma expression and output on the next line
encoding
of the output file following the digest_block pragma expression. A shall be generated for
digest_block
each and that are generated in the encryption process and shall immediately
key_block data_block
follow the or to which it refers.
key_block data_block
DECRYPTION INPUT: In order to authenticate the message, the consuming tool will decrypt the encrypted
data, generate a message digest from the decrypted data, decrypt the message digest in the
digest_block
with the specified key, and compare the two message digests. If the two digests do not match, then either the
or the encrypted data has been altered since the input data was encrypted. The message
digest_block
digest for a or shall be contained in a immediately following the
key_block data_block digest_block
or . If the , or in its absence the current ,
key_block data_block digest_key_method data_method
specifies a CBC encryption algorithm that requires an IV, then the first cipher-block of the decoded
931
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
shall be removed for use as the IV. The remainder of the shall be internally
digest_block digest_block
decrypted.
34.5.23 key_keyowner
34.5.23.1 Syntax
key_keyowner = <string>
34.5.23.2 Description
ENCRYPTION INPUT: The specifies the legal entity or tool that provided the keys used
key_keyowner
for encryption and decryption of the key information. The value of the also has the same
key_keyowner
constraints specified for the values.
data_keyowner
ENCRYPTION OUTPUT: The shall be unchanged in the output file.
key_keyowner
DECRYPTION INPUT: During decryption, the can be combined with the
key_keyowner key_keyname
or to determine the appropriate secret/private key to use during decryption of the
key_public_key
.
key_block
34.5.24 key_method
34.5.24.1 Syntax
key_method = <string>
34.5.24.2 Description
ENCRYPTION INPUT: The pragma expression indicates the encryption algorithm that shall
key_method
be used to encrypt the keys used to encrypt the . The values specified for to
data_block key_method
identify encryption algorithms are the same as those specified for .
data_method
ENCRYPTION OUTPUT: The shall be unchanged in the output file.
key_method
DECRYPTION INPUT: The indicates the algorithm that shall be used to decrypt the
key_method
.
key_block
34.5.25 key_keyname
34.5.25.1 Syntax
key_keyname = <string>
34.5.25.2 Description
ENCRYPTION INPUT: The pragma expression provides the name of the key, or key pair
key_keyname
for an asymmetric encryption algorithm, that shall be used to decrypt the . It shall be an error to
key_block
specify a that is not a member of the list of keys known for the given .
key_keyname key_keyowner
ENCRYPTION OUTPUT: When a is provided in the input, it indicates the key that shall be
key_keyname
used for encrypting the data encryption keys. The encrypting tool shall combine this pragma expression with
the and determine the key to use. The itself shall be output as cleartext in the
key_keyowner key_keyname
output file.
932
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
DECRYPTION INPUT: The value is combined with the to select a single
key_keyname key_keyowner
key that shall be used to decrypt the from the protected envelope.
data_block
34.5.26 key_public_key
34.5.26.1 Syntax
key_public_key
34.5.26.2 Description
ENCRYPTION INPUT: The pragma expression indicates that the next line of the file
key_public_key
contains the encoded value of the public key to be used to encrypt the key data. The encoding is specified by
the pragma expression that is currently in effect. If both a and
encoding key_public_key key_keyname
are present, then they shall refer to the same key.
ENCRYPTION OUTPUT: The pragma expression shall be output in each protected
key_public_key
block for which it is used, followed by the encoded value. The and can be
key_method key_public_key
combined to fully specify the required encryption of data keys.
DECRYPTION INPUT: The and can be combined with the
key_keyowner key_method
to determine whether the decryption tool knows the corresponding private key to decrypt
key_public_key
a given . If the decrypting tool can compute the required key, the data keys can be decrypted.
key_block
34.5.27 key_block
34.5.27.1 Syntax
key_block
34.5.27.2 Description
ENCRYPTION INPUT: It shall be an error if a is found in an input file unless it is contained
key_block
within a previously generated – block, in which case it is ignored.
begin_protected end_protected
ENCRYPTION OUTPUT: The pragma expression indicates that a key block begins on the next
key_block
line in the file. When requested to use a digital signature, the encrypting tool shall take any of the
, , , , and to form a
data_method data_public_key data_keyname data_decrypt_key digest_block
text buffer. This buffer shall then be encrypted with the appropriate , and then the
key_public_key
encrypted region shall be encoded using the pragma expression in effect. The output of this
encoding
encoding shall be generated as the contents of the . If the specifies a CBC
key_block key_method
encryption algorithm that requires an IV, then the IV cipher-block shall be prepended to the encrypted key
before encoding is performed. Note that encrypting keys with a symmetric cipher is not a common use case.
Where more than one pragma expression occurs within a single block, the
key_block begin-end
generated key blocks shall all encode the same data decryption key data. It shall be an error if the data
decryption pragma expressions change value between pragma expressions of a single
key_block
encryption envelope. Multiple key blocks are specified for the purpose of providing alternative decryption
keys for a single decryption envelope.
DECRYPTION INPUT: The is first read in the encoded form, the encoding is reversed, and
key_block
then the block is internally decrypted. The resulting text is then parsed to determine the keys required to
decrypt the . If the specifies a CBC encryption algorithm that requires an IV,
data_block key_method
933
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
then the first cipher-block of the decoded shall be removed for use as the IV. The remainder of
key_block
the decoded shall be internally decrypted.
key_block
34.5.28 decrypt_license
34.5.28.1 Syntax
decrypt_license = ( library = <string> , entry = <string> ,
feature = <string> [, exit = <string>] [, match = <number> ] )
34.5.28.2 Description
ENCRYPTION INPUT: The pragma expression will typically be found inside a
decrypt_license
pair in the original cleartext. This is necessary so that it is encrypted in the output IP that is
begin-end
shipped to the end user.
ENCRYPTION OUTPUT: The is output unchanged in the output description except
decrypt_license
for encryption and encoding of the pragma exactly as other cleartext in the pair. Typically, it
begin-end
will be output in the .
data_block
DECRYPTION INPUT: After encountering a pragma expression in an encrypted
decrypt_license
model, prior to processing the decrypted text, the application shall load the specified library and call the
function, passing it the specified string. The return value of the function shall be
entry feature entry
compared to the value. If the application is licensed to decrypt the model, the returned value shall
match
compare equal to the match value and shall compare nonequal otherwise. If the application is not licensed to
decrypt the model, no decryption shall be performed, and the application shall produce an error message that
includes the return value of the function. If an function is specified, then it shall be called prior
entry exit
to exiting the decrypting application to allow for releasing the license.
NOTE—This mechanism only provides limited security because the end users of the model have the shared library and
could use readily available debuggers to debug the calling sequence of the licensing mechanism. They could then
produce an equivalent library that returns a 0, but avoids the license check.
34.5.29 runtime_license
34.5.29.1 Syntax
runtime_license = ( library = <string> , entry = <string> ,
feature = <string> [ , exit = <string> ] [ , match = <number> ] )
34.5.29.2 Description
ENCRYPTION INPUT: The pragma expression will typically be found inside a
runtime_license
pair in the original cleartext. This is necessary so that it is encrypted in the output IP shipped to
begin-end
the end user.
ENCRYPTION OUTPUT: The is output unchanged in the output description except
runtime_license
for encryption and encoding of the pragma exactly as other cleartext in the pair.
begin-end
DECRYPTION INPUT: After encountering a pragma expression in an encrypted
runtime_license
model, prior to executing, the application shall load the specified library and call the entry function, passing
it the specified string. The return value of the entry function shall be compared to the match value.
feature
If the application is licensed to execute the model, the returned value shall compare equal to the match value
and shall compare nonequal otherwise. If the application is not licensed to execute the model, execution
shall not begin, and the application shall produce an error message that includes the return value of the entry
934
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
function. If an is specified, then it shall be called prior to exiting the executing application to allow for
exit
releasing the license.
NOTE 1—Execution could mean any evaluation of the model, including simulation, layout, or synthesis.
NOTE 2—This mechanism only provides limited security because the end users of the model have the shared library and
could use readily available debuggers to debug the calling sequence of the licensing mechanism. They could then
produce an equivalent library that returns a 0, but avoids the license check. IP authors may wish to implement their own
licensing scheme embedded within the behavior of the model, possibly using PLI and/or system tasks.
34.5.30 comment
34.5.30.1 Syntax
comment = <string>
34.5.30.2 Description
ENCRYPTION INPUT: The pragma expression can be found anywhere in an input file and
comment
indicates that even if this is found inside a block, the value shall be output as a comment in
begin-end
cleartext in the output immediately prior to the .
data_block
This is provided so that comments that may end up being included in other files inside a block
begin-end
can protect themselves from being encrypted. This is important so that critical information such as copyright
notices can be explicitly excluded from encryption.
Because this constitutes known cleartext that would be found inside the , the pragma itself and
data_block
the value should not be included in the encrypted text.
ENCRYPTION OUTPUT: The entire comment including the beginning pragma shall be output in cleartext
immediately prior to the corresponding to the in which the comment was found.
data_block begin-end
DECRYPTION INPUT: none
34.5.31 reset
34.5.31.1 Syntax
reset
34.5.31.2 Description
ENCRYPTION INPUT: The pragma expression is a synonym for a reset pragma directive that
reset
contains in the pragma keyword list. Following the reset, all pragma keywords are
protect protect
restored to their default values.
Because the scope of pragma definitions is lexical and extends from the point of the directive until the end of
the compilation input, if an IP author chooses to put common pragmas such as and
author author_info
at the beginning of a list of files, they should include a pragma at the end of the list of files so that this
reset
information is not unintentionally visible in other files.
ENCRYPTION OUTPUT: none
DECRYPTION INPUT: none
935
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
34.5.32 viewport
34.5.32.1 Syntax
viewport = ( object = <string> , access = <string> )
34.5.32.2 Description
The pragma expression describes objects within the current protected envelope for which access
viewport
shall be permitted by the SystemVerilog tool. The specified object name shall be contained within the
current envelope. The access value is an implementation-specific relaxation of protection.
936
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Part Three:
Application Programming Interfaces
937
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
35. Direct programming interface
35.1 General
This clause describes the following:
— Direct programming interface (DPI) tasks and functions
— DPI layers
— Importing and exporting functions
— Importing and exporting tasks
— Disabling DPI tasks and functions
35.2 Overview
This clause highlights the DPI and provides a detailed description of the SystemVerilog layer of the
interface. The C layer is defined in AnnexH.
DPI is an interface between SystemVerilog and a foreign programming language. It consists of two separate
layers: the SystemVerilog layer and a foreign language layer. Both sides of DPI are fully isolated. Which
programming language is actually used as the foreign language is transparent and irrelevant for the
SystemVerilog side of this interface. Neither the SystemVerilog compiler nor the foreign language compiler
is required to analyze the source code in the other’s language. Different programming languages can be used
and supported with the same intact SystemVerilog layer. For now, however, SystemVerilog defines a
foreign language layer only for the C programming language. See AnnexH for more details.
The motivation for this interface is two-fold. The methodological requirement is that the interface should
allow a heterogeneous system to be built (a design or a testbench) in which some components can be written
in a language (or more languages) other than SystemVerilog, hereinafter called the foreign language. On the
other hand, there is also a practical need for an easy and efficient way to connect existing code, usually
written in C or C++, without the knowledge and the overhead of VPI.
DPI follows the principle of a black box: the specification and the implementation of a component are
clearly separated, and the actual implementation is transparent to the rest of the system. Therefore, the actual
programming language of the implementation is also transparent, although this standard defines only C
linkage semantics. The separation between SystemVerilog code and the foreign language is based on using
functions as the natural encapsulation unit in SystemVerilog. By and large, any function can be treated as a
black box and implemented either in SystemVerilog or in the foreign language in a transparent way, without
changing its calls.
35.2.1 Tasks and functions
DPI allows direct inter-language function calls between the languages on either side of the interface.
Specifically, functions implemented in a foreign language can be called from SystemVerilog; such functions
are referred to as imported functions. SystemVerilog functions that are to be called from a foreign code shall
be specified in export declarations (see 35.7 for more details). DPI allows for passing SystemVerilog data
between the two domains through function arguments and results. There is no intrinsic overhead in this
interface.
It is also possible to perform task enables across the language boundary. Foreign code can call
SystemVerilog tasks, and native SystemVerilog code can call imported tasks. An imported task has the same
semantics as a native SystemVerilog task: it never returns a value, and it can consume simulation time.
938
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
All functions used in DPI are assumed to complete their execution instantly and consume zero simulation
time, just as normal SystemVerilog functions. DPI provides no means of synchronization other than by data
exchange and explicit transfer of control.
Every imported subroutine needs to be declared. A declaration of an imported subroutine is referred to as an
import declaration. Import declarations are very similar to SystemVerilog subroutine declarations. Import
declarations can occur anywhere where SystemVerilog subroutine definitions are permitted. An import
declaration is considered to be a definition of a SystemVerilog subroutine with a foreign language
implementation. The same foreign subroutine can be used to implement multiple SystemVerilog tasks and
functions (this can be a useful way of providing differing default argument values for the same basic
subroutine), but a given SystemVerilog name can only be defined once per scope. Imported subroutines can
have zero or more formal , , and arguments. Imported tasks always return a void value
input output inout
and thus can only be used in statement context. Imported functions can return a result or be defined as void
functions.
DPI is based entirely upon SystemVerilog constructs. The usage of imported functions is identical to the
usage of native SystemVerilog functions. With few exceptions, imported functions and native functions are
mutually exchangeable. Calls of imported functions are indistinguishable from calls of SystemVerilog
functions. This facilitates ease of use and minimizes the learning curve. Similar interchangeable semantics
exist between native SystemVerilog tasks and imported tasks.
35.2.2 Data types
SystemVerilog data types are the sole data types that can cross the boundary between SystemVerilog and a
foreign language in either direction (i.e., when an imported function is called from SystemVerilog code or
an exported SystemVerilog function is called from a foreign code). It is not possible to import the data types
or directly use the type syntax from another language. A rich subset of SystemVerilog data types is allowed
for formal arguments of import and export functions, although with some restrictions and with some
notational extensions. Function result types are restricted to small values, however (see 35.5.5).
Formal arguments of an imported function can be declared as open arrays as specified in 35.5.6.1.
35.2.2.1 Data representation
DPI does not add any constraints on how SystemVerilog-specific data types are actually implemented.
Optimal representation can be platform dependent. The layout of 2- or 4-state packed structures and arrays is
implementation and platform dependent.
The implementation (representation and layout) of 4-state values, structures, and arrays is irrelevant for
SystemVerilog semantics and can only impact the foreign side of the interface.
35.3 Two layers of DPI
DPI consists of two separate layers: the SystemVerilog layer and a foreign language layer. The
SystemVerilog layer does not depend on which programming language is actually used as the foreign
language. Although different programming languages can be supported and used with the intact
SystemVerilog layer, SystemVerilog defines a foreign language layer only for the C programming language.
Nevertheless, SystemVerilog code shall look identical and its semantics shall be unchanged for any foreign
language layer. Different foreign languages can require that the SystemVerilog implementation shall use the
appropriate function call protocol and argument passing and linking mechanisms. This shall be, however,
transparent to SystemVerilog users. SystemVerilog requires only that its implementation shall support C
protocols and linkage.
939
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
35.3.1 DPI SystemVerilog layer
The SystemVerilog side of DPI does not depend on the foreign programming language. In particular, the
actual function call protocol and argument passing mechanisms used in the foreign language are transparent
and irrelevant to SystemVerilog. SystemVerilog code shall look identical regardless of what code the
foreign side of the interface is using. The semantics of the SystemVerilog side of the interface is
independent from the foreign side of the interface.
This clause does not constitute a complete interface specification. It only describes the functionality,
semantics, and syntax of the SystemVerilog layer of the interface. The other half of the interface, the foreign
language layer, defines the actual argument passing mechanism and the methods to access (read/write)
formal arguments from the foreign code. See AnnexH for more details.
35.3.2 DPI foreign language layer
The foreign language layer of the interface (which is transparent to SystemVerilog) shall specify how actual
arguments are passed, how they can be accessed from the foreign code, how SystemVerilog-specific data
types (such as and ) are represented, and how they are translated to and from some
logic packed
predefined C-like types.
The data types allowed for formal arguments and results of imported functions or exported functions are
generally SystemVerilog types (with some restrictions and with notational extensions for open arrays).
Users are responsible for specifying in their foreign code the native types equivalent to the SystemVerilog
types used in imported declarations or export declarations. Software tools, like a SystemVerilog compiler,
can facilitate the mapping of SystemVerilog types onto foreign native types by generating the appropriate
function headers.
The SystemVerilog compiler or simulator shall generate and/or use the function call protocol and argument
passing mechanisms required for the intended foreign language layer. The same SystemVerilog code
(compiled accordingly) shall be usable with different foreign language layers, regardless of the data access
method assumed in a specific layer. AnnexH defines the DPI foreign language layer for the C programming
language.
35.4 Global name space of imported and exported functions
Every subroutine imported to SystemVerilog shall eventually resolve to a global symbol. Similarly, every
subroutine exported from SystemVerilog defines a global symbol. Thus the tasks and functions imported to
and exported from SystemVerilog have their own global name space of linkage names, different from
compilation-unit scope name space. Global names of imported and exported tasks and functions shall be
unique (no overloading is allowed) and shall follow C conventions for naming; specifically, such names
shall start with a letter or underscore, and they can be followed by alphanumeric characters or underscores.
Exported and imported tasks and functions, however, can be declared with local SystemVerilog names.
Import and export declarations allow users to specify a global name for a function in addition to its declared
name. Should a global name clash with a SystemVerilog keyword or a reserved name, it shall take the form
of an escaped identifier. The leading backslash ( ) character and the trailing white space shall be stripped
\
off by the SystemVerilog tool to create the linkage identifier. After this stripping, the linkage identifier so
formed shall comply with the normal rules for C identifier construction. If a global name is not explicitly
given, it shall be the same as the SystemVerilog subroutine name. For example:
export "DPI-C" f_plus = function \f+ ; // "f+" exported as "f_plus"
export "DPI-C" function f; // "f" exported under its own name
import "DPI-C" init_1 = function void \init[1] (); // "init_1" is a linkage name
import "DPI-C" \begin = function void \init[2] (); // "begin" is a linkage name
940
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The same global subroutine can be referred to in multiple import declarations in different scopes or/and with
different SystemVerilog names (see 35.5.4).
Multiple export declarations are allowed with the same c_identifier, explicit or implicit, as long as they are
in different scopes and have the equivalent type signature (as defined in 35.5.4 for imported tasks and
functions). Multiple export declarations with the same c_identifier in the same scope are forbidden.
It is possible to use the deprecated version string syntax in an import or export declaration. This
"DPI"
syntax indicates that the SystemVerilog 2-state and 4-state packed array argument passing convention is to
be used (see H.13). In such cases, all declarations using the same c_identifier shall be declared with the same
DPI version string syntax.
35.5 Imported tasks and functions
The usage of imported functions is similar as for native SystemVerilog functions.
35.5.1 Required properties of imported tasks and functions—semantic constraints
This subclause defines the semantic constraints imposed on imported subroutines. Some semantic
restrictions are shared by all imported subroutines. Other restrictions depend on whether the special
properties (see 35.5.2) or (see 35.5.3) are specified for an imported subroutine. A
pure context
SystemVerilog compiler is not able to verify that those restrictions are observed; and if those restrictions are
not satisfied, the effects of such imported subroutine calls can be unpredictable.
35.5.1.1 Instant completion of imported functions
Imported functions shall complete their execution instantly and consume zero simulation time, similarly to
native functions.
NOTE—Imported tasks can consume time, similar to native SystemVerilog tasks.
35.5.1.2 input, output, and inout arguments
Imported functions can have , , and arguments. The formal arguments shall not
input output inout input
be modified. If such arguments are changed within a function, the changes shall not be visible outside the
function; the actual arguments shall not be changed.
The imported function shall not assume anything about the initial values of formal arguments. The
output
initial values of arguments are undetermined and implementation dependent.
output
The imported function can access the initial value of a formal argument. Changes that the imported
inout
function makes to a formal argument shall be visible outside the function.
inout
35.5.1.3 Special properties pure and context
Special properties can be specified for an imported subroutine as or as (see also 35.5.2 or
pure context
35.5.3).
A function whose result depends solely on the values of its input arguments and with no side effects can be
specified as . This can usually allow for more optimizations and thus can result in improved simulation
pure
performance. Subclause 35.5.2 details the rules that shall be obeyed by functions. An imported task
pure
can never be declared .
pure
941
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
An imported subroutine that is intended to call exported subroutines or to access SystemVerilog data objects
other than its actual arguments (e.g., via VPI calls) shall be specified as . Calls of tasks
context context
and functions are specially instrumented and can impair SystemVerilog compiler optimizations; therefore,
simulation performance can decrease if the property is specified when not necessary. A subroutine
context
not specified as shall not read or write any data objects from SystemVerilog other than its actual
context
arguments. For subroutines not specified as , the effects of calling VPI or exported SystemVerilog
context
subroutines can be unpredictable and can lead to unexpected behavior; such calls can even crash. Subclause
35.5.3 details the restrictions that shall be obeyed by noncontext subroutines.
If neither the nor the attribute is used on an imported subroutine, the subroutine shall not
pure context
access SystemVerilog data objects; however, it can perform side effects such as writing to a file or
manipulating a global variable.
35.5.1.4 Memory management
The memory spaces owned and allocated by the foreign code and SystemVerilog code are disjoined. Each
side is responsible for its own allocated memory. Specifically, an imported function shall not free the
memory allocated by SystemVerilog code (or the SystemVerilog compiler) nor expect SystemVerilog code
to free the memory allocated by the foreign code (or the foreign compiler). This does not exclude scenarios
where foreign code allocates a block of memory and then passes a handle (i.e., a pointer) to that block to
SystemVerilog code, which in turn calls an imported function (e.g., C standard function ) that directly
free
or indirectly frees that block.
NOTE—In this last scenario, a block of memory is allocated and freed in the foreign code, even when the standard
functions and are called directly from SystemVerilog code.
malloc free
35.5.1.5 Reentrancy of imported tasks
A call to an imported task can result in the suspension of the currently executing thread. This occurs when an
imported task calls an exported task, and the exported task executes a delay control, event control, or wait
statement. Thus it is possible for an imported task’s C code to be simultaneously active in multiple execution
threads. Standard reentrancy considerations must be made by the C programmer. Some examples of such
considerations include the use of static variables and ensuring that only thread-safe C standard library calls
(multi-thread safe) are used.
35.5.1.6 C++ exceptions
It is possible to implement DPI imported tasks and functions using C++, as long as C linkage conventions
are observed at the language boundary. If C++ is used, exceptions shall not propagate out of any imported
subroutine. Undefined behavior can result if an exception crosses the language boundary from C++ into
SystemVerilog.
35.5.2 Pure functions
A function call can be eliminated if its result is not needed or if the previous result for the same values
pure
of input arguments is available somehow and can be reused without needing to recalculate. Only nonvoid
functions with no or arguments can be specified as . Functions specified as shall
output inout pure pure
have no side effects whatsoever; their results need to depend solely on the values of their input arguments.
Calls to such functions can be removed by SystemVerilog compiler optimizations or replaced with the
values previously computed for the same values of the input arguments.
Specifically, a function is assumed not to directly or indirectly (i.e., by calling other functions)
pure
perform the following:
— Perform any file operations.
942
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Read or write anything in the broadest possible meaning, including input/output (I/O), environment
variables, objects from the operating system or from the program or other processes, shared
memory, sockets, etc.
— Access any persistent data, like global or static variables.
If a function does not obey the preceding restrictions, SystemVerilog compiler optimizations can lead
pure
to unexpected behavior, due to eliminated calls or incorrect results being used.
35.5.3 Context tasks and functions
Some DPI imported subroutines require that the context of their call be known. It takes special
instrumentation of their call instances to provide such context; for example, an internal variable referring to
the “current instance” might need to be set. To avoid any unnecessary overhead, imported subroutine calls in
SystemVerilog code are not instrumented unless the imported subroutine is specified as .
context
The SystemVerilog context of DPI export tasks and functions must be known when they are called,
including when they are called by imports. When an import invokes the utility prior to calling
svSetScope
the export, it sets the context explicitly. Otherwise, the context will be the context of the instantiated scope
where the import declaration is located. Because imports with diverse instantiated scopes can export the
same subroutine, multiple instances of such an export can exist after elaboration. Prior to any invocations of
, these export instances would have different contexts, which would reflect their imported
svSetScope
caller’s instantiated scope.
A foreign language subroutine supported through some other interface (a VPI callback for example), can
also make a call to or to other DPI scope-related APIs. This foreign language subroutine can
svSetScope
also call an export subroutine declared in a specific instantiated scope by first making a call to .
svSetScope
The behavior of the DPI scope-related APIs and invocation of DPI export subroutines will be simulator
defined and is beyond the scope of the DPI specification.
The concept of call chains is useful for understanding how context works as control weaves in and out of
SystemVerilog and another language through a DPI interface. For the purpose of this description, an inter-
language call is between SystemVerilog and a DPI supported language, or vice versa. An intra-language
call is between SystemVerilog subroutines themselves, or between subroutines in the DPI support language,
i.e., the call does not cross the language boundary.
A DPI import call chain is an inter-language call chain starting from SystemVerilog into a subroutine that is
defined in a DPI supported language. The starting point of the call chain from SystemVerilog is called the
root of the call chain.This call chain can comprise multiple intra-language and inter-language calls between
SystemVerilog and DPI supported language before it unwinds and returns to the calling SystemVerilog
subroutine at the root of the import call chain.
The subroutine in the DPI supported language could make intra-language calls within the language and then
could unwind and return back to the calling SystemVerilog subroutine. Alternatively, the called import
subroutine could make an inter-language call to an export DPI subroutine in the imported caller’s
instantiated scope, or by setting another instantiated scope and calling the export DPI routine in that scope.
The called export DPI subroutine can make intra-language calls in SystemVerilog, or make an inter-
language call to yet another import subroutine or simply return to the calling import subroutine. This nested
invocation of inter-language and intra-language calls is considered a part of a single import call chain.
Another key point to note is that the context property applies to each import subroutine call that is made
from SystemVerilog. This implies that the context property at the root of the DPI import call chain or any
intermediate import call in the call chain is not transitively promoted to subsequent import calls in the DPI
943
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
import call chain. Since a noncontext imported DPI subroutine cannot make a call to a SystemVerilog export
subroutine, the behavior of making any such calls in the DPI import call chain is an error.
The following behavior characterizes context mechanics for imported call chains:
— The following actions determine an import call chain’s context value:
• When a SystemVerilog subroutine calls a DPI context import, a context for the import call chain
is created that is equal to the instantiated scope of the import declaration.
• When a routine in an import call chain invokes with a legal argument, the call
svSetScope
chain’s context is set to the indicated scope.
• When a call from an import call chain to an exported SystemVerilog subroutine finishes and
returns to the chain, the call chain’s context is set equal to its value when the call to the export
was made.
— Detecting when control moves across the language boundary between SystemVerilog and an
imported language is critical for simulators managing DPI context. Therefore, if user code
circumvents unwinding an export call chain back to its import chain caller (e.g., by using C /
setjmp
constructs), the results are undefined.
longjmp
— Whether a specific import subroutine call in the DPI import call chain is context or not is governed
by the context property of the import subroutine to which the call was made. The context property of
a previous import subroutine call in the DPI import call chain is not transitively promoted to all
subsequent import function calls in the call chain.
— The context characteristic of a DPI import call cannot be dynamically changed after the initial call to
the import subroutine in the DPI supported language.
— The context characteristic adheres to the calling chain, not to an individual imported subroutine;
thus, the same imported subroutine can appear in both context and noncontext call chains.
For the sake of simulation performance, an imported subroutine call shall not block SystemVerilog compiler
optimizations. An imported subroutine not specified as shall not access any data objects from
context
SystemVerilog other than its actual arguments. Only the actual arguments can be affected (read or written)
by its call. Therefore, a call of a noncontext subroutine is not a barrier for optimizations. A context imported
subroutine, however, can access (read or write) any SystemVerilog data objects by calling VPI or by calling
an export subroutine. Therefore, a call to a context subroutine is a barrier for SystemVerilog compiler
optimizations.
Only calls of context imported subroutines are properly instrumented and cause conservative optimizations;
therefore, only those subroutines can safely call all subroutines from other APIs, including VPI functions or
exported SystemVerilog subroutines. For imported subroutines not specified as , the effects of
context
calling VPI functions or SystemVerilog subroutines can be unpredictable; and such calls can crash if the
callee requires a context that has not been properly set. However, declaring an imported subroutine
does not automatically make any other simulator interface automatically available. For VPI access
context
(or any other interface access) to be possible, the appropriate implementation-defined mechanism shall still
be used to enable these interface(s). Realize also that DPI calls do not automatically create or provide any
handles or any special environment that can be needed by those other interfaces. It is the user’s
responsibility to create, manage, or otherwise manipulate the required handles or environment(s) needed by
the other interfaces.
Context imported subroutines are always implicitly supplied a scope representing the fully qualified instance
name within which the import declaration was present. This scope defines which exported SystemVerilog
subroutines can be called directly from the imported subroutine; only subroutines defined and exported from
the same scope as the import can be called directly. To call any other exported SystemVerilog subroutines,
the imported subroutine shall first have to modify its current scope, in essence performing the foreign
language equivalent of a SystemVerilog hierarchical subroutine call.
944
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Special DPI utility functions exist that allow imported subroutines to retrieve and operate on their scope. See
AnnexH for more details.
35.5.4 Import declarations
Each imported subroutine shall be declared. Such declaration are referred to as import declarations.
Imported subroutines are similar to SystemVerilog subroutines. Imported subroutines can have zero or more
formal , , and arguments. Imported functions can return a result or be defined as void
input output inout
functions. Imported tasks always return an result as part of the DPI disable protocol and, thus, are
int
declared in foreign code as functions (see 35.8 and 35.9).
int
dpi_import_export ::= // from A.2.6
dpi_spec_string [ dpi_function_import_property ] [ c_identifier ] dpi_function_proto
import = ;
| dpi_spec_string [ dpi_task_import_property ] [ c_identifier ] dpi_task_proto
import = ;
| dpi_spec_string [ c_identifier ] function_identifier
export = function ;
| dpi_spec_string [ c_identifier ] task_identifier
export = task ;
dpi_spec_string ::= |
"DPI-C" "DPI"
dpi_function_import_property ::= |
context pure
dpi_task_import_property ::=
context
dpi_function_proto21,22 ::= function_prototype
dpi_task_proto22 ::= task_prototype
function_prototype ::= data_type_or_void function_identifier [ [ tf_port_list ] ]
function ( )
task_prototype ::= task_identifier [ [ tf_port_list ] ] // from A.2.7
task ( )
21) dpi_function_proto return types are restricted to small values, per 35.5.5.
22) Formals of dpi_function_proto and dpi_task_proto cannot use pass by reference mode and class types cannot be
passed at all; see 35.5.6 for a description of allowed types for DPI formal arguments.
Syntax35-1—DPI import declaration syntax (excerpt from AnnexA)
An import declaration specifies the subroutine name, function result type, and types and directions of formal
arguments. It can also provide optional default values for formal arguments. Formal argument names are
optional unless argument binding by name is needed. An import declaration can also specify an optional
subroutine property. Imported functions can have the properties or ; imported tasks can have
context pure
the property .
context
Because an import declaration is equivalent to defining a subroutine of that name in the SystemVerilog
scope in which the import declaration occurs, and multiple imports of the same subroutine name into the
same scope are forbidden.
NOTE—This declaration scope is particularly important in the case of imported context subroutines (see 35.5.3); for
noncontext imported subroutines the declaration scope has no other implications other than defining the visibility of the
subroutine.
The dpi_spec_string can take values and . is used to indicate that the deprecated
"DPI-C" "DPI" "DPI"
SystemVerilog packed array argument passing semantics is to be used. In this semantics, arguments are
passed in actual simulator representation format rather than in canonical format, as is the case with
.
"DPI-C"
Use of the string shall generate a compile-time warning or error. The tool generated message shall
"DPI"
contain the following information:
945
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— is deprecated and should be replaced with .
"DPI" "DPI-C"
— Use of the string may require changes in the DPI application’s C code.
"DPI-C"
For more information on using deprecated access to packed data, see H.13.
"DPI"
The c_identifier provides the linkage name for this subroutine in the foreign language. If not provided, this
defaults to the same identifier as the SystemVerilog subroutine name. In either case, this linkage name shall
conform to C identifier syntax. An error shall occur if the c_identifier, either directly or indirectly, does not
conform to these rules.
For any given c_identifier (whether explicitly defined with c_identifier or automatically determined from
=
the subroutine name), all declarations, regardless of scope, shall have exactly the same type signature. The
signature includes the return type and the number, order, direction, and types of each and every argument.
The type includes dimensions and bounds of any arrays or array dimensions. The signature also includes the
/ qualifiers that can be associated with an import definition, and it includes the value of the
purecontext
dpi_spec_string.
It is permitted to have multiple declarations of the same imported or exported subroutine in different scopes;
therefore, argument names and default values can vary, provided the type compatibility constraints are met.
A formal argument name is required to separate the packed and the unpacked dimensions of an array.
The qualifier cannot be used in import declarations. The actual implementation of argument passing
ref
depends solely on the foreign language layer and its implementation and shall be transparent to the
SystemVerilog side of the interface.
The following are examples of external declarations:
import "DPI-C" function void myInit();
// from standard math library
import "DPI-C" pure function real sin(real);
// from standard C library: memory management
import "DPI-C" function chandle malloc(int size); // standard C function
import "DPI-C" function void free(chandle ptr); // standard C function
// abstract data structure: queue
import "DPI-C" function chandle newQueue(input string name_of_queue);
// Note the following import uses the same foreign function for
// implementation as the prior import, but has different SystemVerilog name
// and provides a default value for the argument.
import "DPI-C" newQueue=function chandle newAnonQueue(input string s=null);
import "DPI-C" function chandle newElem(bit [15:0]);
import "DPI-C" function void enqueue(chandle queue, chandle elem);
import "DPI-C" function chandle dequeue(chandle queue);
// miscellanea
import "DPI-C" function bit [15:0] getStimulus();
import "DPI-C” context function void processTransaction(chandle elem,
output logic [64:1] arr [0:63]);
import "DPI-C" task checkResults(input string s, bit [511:0] packet);
946
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
35.5.5 Function result
An imported function declaration shall explicitly specify a data type or void for the type of the function’s
return result. Function result types are restricted to small values. The following SystemVerilog data types
are allowed for imported function results:
— , , , , , , , , and
void byte shortint int longint real shortreal chandle string
— Scalar values of type and
bit logic
The same restrictions apply for the result types of exported functions.
35.5.6 Types of formal arguments
A rich subset of SystemVerilog data types is allowed for formal arguments of import and export subroutines.
Generally, C-compatible types, packed types, and user-defined types built of types from these two
categories can be used for formal arguments of DPI subroutines. The set of permitted types is defined
inductively.
The following SystemVerilog types are the only permitted types for formal arguments of import and export
subroutines:
— , , , , , , , , , , and
void byte shortint int longint real shortreal chandle time integer
string
— Scalar values of type and
bit logic
— Packed arrays, structs, and unions composed of types and . Every packed type is
bit logic
eventually equivalent to a packed one-dimensional array. On the foreign language side of the DPI,
all packed types are perceived as packed one-dimensional arrays regardless of their declaration in
the SystemVerilog code.
— Enumeration types interpreted as the type associated with that enumeration
— Types constructed from the supported types with the help of the following constructs:
•
struct
• (packed forms only)
union
• Unpacked array
•
typedef
The following caveats apply for the types permitted in DPI:
— Enumerated data types are not supported directly. Instead, an enumerated data type is interpreted as
the type associated with that enumerated type.
— SystemVerilog does not specify the actual memory representation of packed structures or any
arrays, packed or unpacked. Unpacked structures have an implementation-dependent packing,
normally matching the C compiler.
— In exported DPI subroutines, it is erroneous to declare formal arguments of dynamic array types.
— The actual memory representation of SystemVerilog data types is transparent for SystemVerilog
semantics and irrelevant for SystemVerilog code. It can be relevant for the foreign language code on
the other side of the interface, however; a particular representation of the SystemVerilog data types
can be assumed. This shall not restrict the types of formal arguments of imported subroutines, with
the exception of unpacked arrays. SystemVerilog implementation can restrict which SystemVerilog
unpacked arrays are passed as actual arguments for a formal argument that is a sized array, although
they can be always passed for an unsized (i.e., open) array. Therefore, the correctness of an actual
argument might be implementation dependent. Nevertheless, an open array provides an
implementation-independent solution.
947
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
35.5.6.1 Open arrays
The size of the packed dimension, the unpacked dimension, or both dimensions can remain unspecified;
such cases are referred to as open arrays (or unsized arrays). Open arrays allow the use of generic code to
handle different sizes.
Formal arguments of imported functions can be specified as open arrays. (Exported SystemVerilog
functions cannot have formal arguments specified as open arrays.) A formal argument is an open array when
a range of one or more of its dimensions is unspecified (denoted by using square brackets, ). This is solely
[]
a relaxation of the argument-matching rules. An actual argument shall match the formal one regardless of
the range(s) for its corresponding dimension(s), which facilitates writing generalized code that can handle
SystemVerilog arrays of different sizes.
Although the packed part of an array can have an arbitrary number of sized dimensions, an unsized
dimension shall be the sole packed dimension of a formal argument. This is not very restrictive, because any
packed type is essentially equivalent to a one-dimensional packed array. The number of unpacked
dimensions is not restricted.
If a formal argument has an unsized, packed dimension, it will match any collection of actual argument
packed dimensions. Formal argument unpacked dimensions are matched on a dimension-by-dimension basis
(see 7.7) with each unsized formal dimension matching a corresponding actual dimension of any size.
The following are examples of types of formal arguments (empty square brackets denote open array):
[]
logic
bit [8:1]
bit[]
bit [7:0] array8x10 [1:10] // array8x10 is a formal arg name
logic [31:0] array32xN [] // array32xN is a formal arg name
logic [] arrayNx3 [3:1] // arrayNx3 is a formal arg name
bit [] arrayNxN [] // arrayNxN is a formal arg name
The following is an example of complete import declarations:
import "DPI-C" function void f1(input logic [127:0]);
import "DPI-C" function void f2(logic [127:0] i []); //open array of 128-bit
The following is an example of the use of open arrays for different sizes of actual arguments:
typedef struct {int i; ... } MyType;
import "DPI-C" function void f3(input MyType i [][]);
/* 2-dimensional unsized unpacked array of MyType */
MyType a_10x5 [11:20][6:2];
MyType a_64x8 [64:1][-1:-8];
f3(a_10x5);
f3(a_64x8);
35.6 Calling imported functions
The usage of imported functions is identical to the usage of native SystemVerilog functions. Hence the
usage and syntax for calling imported functions is identical to the usage and syntax of native SystemVerilog
948
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
functions. Specifically, arguments with default values can be omitted from the call; arguments can be bound
by name if all formal arguments are named.
35.6.1 Argument passing
Argument passing for imported functions is ruled by the WYSIWYG principle: What You Specify Is What
You Get (see 35.6.1.1). The evaluation order of formal arguments follows general SystemVerilog rules.
Argument compatibility and coercion rules are the same as for native SystemVerilog functions. If a coercion
is needed, a temporary variable is created and passed as the actual argument. For and
input inout
arguments, the temporary variable is initialized with the value of the actual argument with the appropriate
coercion. For or arguments, the value of the temporary variable is assigned to the actual
output inout
argument with the appropriate conversion. The assignments between a temporary and the actual argument
follow general SystemVerilog rules for assignments and automatic coercion.
On the SystemVerilog side of the interface, the values of actual arguments for formal input arguments of
imported functions shall not be affected by the callee. The initial values of formal output arguments of
imported functions are unspecified (and can be implementation dependent), and the necessary coercions, if
any, are applied as for assignments. Imported functions shall not modify the values of their input arguments.
For the SystemVerilog side of the interface, the semantics of arguments passing is as if arguments are
input
passed by copy-in, arguments are passed by copy-out, and arguments are passed by copy-in,
output inout
copy-out. The terms copy-in and copy-out do not impose the actual implementation; they refer only to
“hypothetical assignment.”
The actual implementation of argument passing is transparent to the SystemVerilog side of the interface. In
particular, it is transparent to SystemVerilog whether an argument is actually passed by value or by
reference. The actual argument passing mechanism is defined in the foreign language layer. See AnnexH
for more details.
35.6.1.1 WYSIWYG principle
The WYSIWYG principle guarantees the types of formal arguments of imported functions: an actual
argument is guaranteed to be of the type specified for the formal argument, with the exception of open arrays
(for which unspecified ranges are statically unknown). Formal arguments, other than open arrays, are fully
defined by import declaration; they shall have ranges of packed or unpacked arrays exactly as specified in
the import declaration. Only the declaration site of the imported function is relevant for such formal
arguments.
Another way to state this is that no compiler (either C or SystemVerilog) can make argument coercions
between a caller’s declared formal and the callee’s declared formals. This is because the callee’s formal
arguments are declared in a different language from the caller’s formal arguments; hence there is no visible
relationship between the two sets of formals. Users are expected to understand all argument relationships
and provide properly matched types on both sides of the interface.
The unsized dimensions of open array formal arguments have the size of the corresponding actual argument
dimensions. A formal’s unsized, unpacked dimensions take on the ranges of the corresponding actual
dimension. A solitary, unsized, packed dimension assumes the linearized, normalized range of the actual’s
packed dimensions (see H.7.6). The unsized ranges of open arrays are determined at a call site; the rest of
the type information is specified at the import declaration.
Therefore, if a formal argument is declared as , then the import declaration specifies that
bit [15:8] b []
the formal argument is an unpacked array of packed bit array with bounds 15 to 8, while the actual argument
used at a particular call site defines the bounds for the unpacked part for that call.
949
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
It is sometimes permissible to pass a dynamic array as an actual argument to an imported DPI subroutine.
The rules for passing dynamic array actual arguments to imported DPI tasks and functions are identical to
the rules for native SystemVerilog tasks and functions. Refer to 7.7 for details on such use of dynamic
arrays.
35.6.2 Value changes for output and inout arguments
The SystemVerilog simulator is responsible for handling value changes for and arguments.
output inout
Such changes shall be detected and handled after control returns from imported functions to SystemVerilog
code.
For and arguments, the value propagation (i.e., value change events) happens as if an actual
output inout
argument was assigned a formal argument immediately after control returns from imported functions. If
there is more than one argument, the order of such assignments and the related value change propagation
follows general SystemVerilog rules.
35.7 Exported functions
DPI allows calling SystemVerilog functions from another language. However, such functions shall adhere to
the same restrictions on argument types and results as imposed on imported functions. It is an error to export
a function that does not satisfy such constraints. Declaring a SystemVerilog function to be exported does not
change its semantics or behavior from the SystemVerilog perspective; there is no effect on SystemVerilog
usage other than making it possible for foreign language tasks and functions in a DPI call-chain to call the
exported function.
SystemVerilog functions that can be called from foreign code need to be specified in declarations.
export
Export declarations are allowed to occur only in the scope in which the function being exported is defined.
Only one export declaration per function is allowed in a given scope.
One important restriction exists. Class member functions cannot be exported, but all other SystemVerilog
functions can be exported.
Similar to import declarations, declarations can define an optional c_identifier to be used in the
export
foreign language when calling an exported function.
dpi_import_export ::= // from A.2.6
...
| dpi_spec_string [ c_identifier ] function_identifier
export = function ;
...
dpi_spec_string ::= |
"DPI-C" "DPI"
Syntax35-2—DPI export declaration syntax (excerpt from AnnexA)
The c_identifier is optional here. It defaults to function_identifier. For rules describing c_identifier, see 35.4.
No two functions in the same SystemVerilog scope can be exported with the same explicit or implicit
c_identifier. The export declaration and the definition of the corresponding SystemVerilog function can
occur in any order. Only one export declaration is permitted per SystemVerilog function, and all export
functions are always context functions.
950
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
35.8 Exported tasks
SystemVerilog allows tasks to be called from a foreign language, similar to functions. Such tasks are termed
exported tasks.
All aspects of exported functions described above in 35.7 apply to exported tasks. This includes legal
declaration scopes as well as usage of the optional c_identifier.
It is never legal to call an exported task from within an imported function. This semantics is identical to
native SystemVerilog semantics, in which it is illegal for a function to perform a task enable.
It is legal for an imported task to call an exported task only if the imported task is declared with the
context
property. See 35.5.3 for more details.
One difference between exported tasks and exported functions is that SystemVerilog tasks do not have
return value types. The return value of an exported task is an value that indicates if a disable is active or
int
not on the current execution thread.
Similarly, imported tasks return an value that is used to indicate that the imported task has
int
acknowledged a disable. See 35.9 for more detail on disables in DPI.
35.9 Disabling DPI tasks and functions
It is possible for a statement to disable a block that is currently executing a mixed language call
disable
chain. When a DPI import subroutine is disabled, the C code is required to follow a simple disable protocol.
The protocol gives the C code the opportunity to perform any necessary resource cleanup, such as closing
open file handles, closing open VPI handles, or freeing heap memory.
An imported subroutine is said to be in the disabled state when a statement somewhere in the
disable
design targets either it or a parent for disabling. An imported subroutine can only enter the disabled state
immediately after the return of a call to an exported subroutine. An important aspect of the protocol is that
disabled import tasks and functions shall programmatically acknowledge that they have been disabled. A
subroutine can determine that it is in the disabled state by calling the API function
.
svIsDisabledState()
The protocol is composed of the following items:
a) When an exported task returns due to a disable, it shall return a value of 1. Otherwise, it shall
return0.
b) When an imported task returns due to a disable, it shall return a value of 1. Otherwise, it shall
return0.
c) Before an imported function returns due to a disable, it shall call the API function
.
svAckDisabledState()
d) Once an imported subroutine enters the disabled state, it is illegal for the current function call to
make any further calls to exported subroutines.
Item b), item c), and item d) are mandatory behavior for imported DPI tasks and functions. It is the
responsibility of the DPI programmer to correctly implement the behavior.
Item a) is guaranteed by SystemVerilog simulators. In addition, simulators shall implement checks to verify
that item b), item c), and item d) are correctly followed by imported tasks and functions. If any protocol item
is not correctly followed, a fatal simulation error is issued.
951
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The foreign language side of the DPI contains a disable protocol that is realized by user code working
together with a simulator. The disable protocol allows for foreign models to participate in SystemVerilog
disable processing. The participation is done through special return values for DPI tasks and special API
calls for DPI functions.
The special return values do not require a change in call syntax of either import or export DPI tasks in the
SystemVerilog code. While the return value for an export task is guaranteed by the simulator, for the import
task the return value has to be ensured by the DPI application.
Calls to import tasks in SystemVerilog code are indistinguishable from calls to native SystemVerilog tasks.
Likewise, calls to DPI export tasks in SystemVerilog code are indistinguishable from calls to non DPI
SystemVerilog tasks.
If an exported task itself is the target of a disable, its parent imported task is not considered to be in the
disabled state when the exported task returns. In such cases, the exported task shall return value 0, and calls
to shall return 0 as well.
svIsDisabledState()
When a DPI imported subroutine returns due to a disable, the values of its and parameters
output inout
are undefined. Similarly, function return values are undefined when an imported function returns due to a
disable. C programmers can return values from disabled functions, and C programmers can write values into
the locations of and parameters of imported subroutines. However, SystemVerilog
output inout
simulators are not obligated to propagate any such values to the calling SystemVerilog code if a disable is in
effect.
952
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
36. Programming language interface (PLI/VPI) overview
36.1 General
This clause describes the following:
— Definition and history of PLI and VPI
— User-defined system tasks and system functions
— VPI sizetf, compiletf, and calltf routines
— PLI mechanism
— Access to SystemVerilog and simulation objects
— List of VPI routines by functional category
36.2 PLI purpose and history
The Programming Language Interface (PLI) is a procedural interface that allows foreign language functions
to access the internal data structures of a SystemVerilog simulation. The SystemVerilog Verification
Procedural Interface (VPI) is part of the PLI. VPI provides a library of C language functions and a
mechanism for associating foreign language functions with SystemVerilog user-defined system task and
system function names.
The PLI provides a means for SystemVerilog users to dynamically access and modify data in an instantiated
SystemVerilog data structure. An instantiated SystemVerilog data structure is the result of compiling and
elaborating SystemVerilog source descriptions and generating the hierarchy modeled by module instances,
primitive instances, and other SystemVerilog constructs that represent scope. The PLI procedural interface
provides a library of C language functions that can directly access data within an instantiated SystemVerilog
data structure.
A few of the many possible applications for the PLI procedural interface are as follows:
— C language delay calculators for SystemVerilog model libraries that can dynamically scan the data
structure of a SystemVerilog tool and then dynamically modify the delays of each instance of
models from the library
— C language applications that dynamically read test vectors or other data from a file and pass the data
into a SystemVerilog tool
— Custom graphical waveform and debugging environments for SystemVerilog software products
— Source code decompilers that can generate SystemVerilog source code from the compiled data
structure of a SystemVerilog tool
— Simulation models written in the C language and dynamically linked into SystemVerilog
simulations
— Interfaces to actual hardware, such as a hardware modeler, that dynamically interact with
simulations
The following are the three primary generations of the SystemVerilog PLI:
a) Task/function routines, called TF routines, made up the first generation of the PLI. These routines,
most of which started with the characters tf_, were primarily used for operations involving user-
defined system task and system function arguments, along with utility functions, such as setting up
call-back mechanisms and writing data to output devices. The TF routines were sometimes referred
to as utility routines
b) Access routines, called ACC routines, formed the second generation of the PLI. These routines,
which all started with the characters acc_, provided an object-oriented access directly into a
953
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
SystemVerilog structural description. ACC routines were used to access and modify information,
such as delay values and logic values, on a wide variety of objects that exist in a SystemVerilog
description. There was some overlap in functionality between ACC routines and TF routines.
c) The SystemVerilog Verification Procedural Interface routines, called VPI routines, are the third
generation of the PLI. These routines, most of which start with the characters vpi_, provide an
object-oriented access for SystemVerilog structural, behavioral, assertion, and coverage objects. The
VPI routines are a superset of the functionality of the TF routines and ACC routines.
NOTE—IEEE Std 1364-2005 deprecated the task/function (TF) and access (ACC) routines These deprecated routines
are not included in this standard. See Clause 21 through Clause 25, Annex E, and Annex F of IEEE Std 1364-2001 for
the deprecated text.
This clause, along with Clause38, AnnexK, and AnnexM, describes the VPI procedural interface standard
and interface mechanisms.
36.3 User-defined system task and system function names
A user-defined system task or system function name is the name that will be used within a SystemVerilog
source file to invoke specific PLI applications. The name shall adhere to the following rules:
— The first character of the name shall be the dollar sign ($).
— The remaining characters shall be letters, digits, the underscore character ( _ ), or the dollar sign ($).
— Uppercase and lowercase letters shall be considered to be unique—the name is case sensitive.
— The name can be any size, and all characters are significant.
36.3.1 Defining system task and system function names
User-defined system task and system function names are defined using a system task and system function
callback registry, which is part of the PLI mechanism. Registering system tasks and system functions is
described in 36.9.1.
36.3.2 Overriding built-in system task and system function names
Clause20 and Clause21 define a number of built-in system tasks and system functions that are part of the
SystemVerilog language. In addition, SystemVerilog tools can include other built-in system tasks and
system functions specific to the tool. These built-in system task and system function names begin with the
dollar sign ($) just as user-defined system task and system function names.
If a user-provided PLI application is associated with the same name as a built-in system task or system
function (using the PLI mechanism), the user-provided C application shall override the built-in system task
or system function, replacing its functionality with that of the user-provided C application. For example, a
user could write an RNG as a PLI application and then associate the application with the name ,
$random
thereby overriding the built-in function with the user’s application.
$random
SystemVerilog timing checks, such as , are not system tasks and cannot be overridden.
$setup
The built-in system functions and can be overridden. These system functions are
$signed $unsigned
unique in that the return width is based on the width of their argument. If overridden, the PLI version shall
have the same return width for all instances of the system function. The PLI return width is defined by the
PLI sizetf routine.
954
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
36.4 User-defined system task and system function arguments
When a user-defined system task or system function is used in a SystemVerilog source file, it can have
arguments that can be used by the PLI applications associated with the system task or system function. In the
following example, the user-defined system task has two arguments:
$get_vector
$get_vector("test_vector.pat", input_bus);
The arguments to a system task or system function are referred to as task/function arguments (often
abbreviated as tfargs). These arguments are not the same as C language arguments. When the PLI
applications associated with a user-defined system task or system function are called, the task/function
arguments are not passed to the PLI application. Instead, a number of PLI routines are provided that allow
the PLI applications to read and write to the task/function arguments. See Clause38 for information on
specific routines that work with task/function arguments.
36.5 User-defined system task and system function types
The type of a user-defined system task or system function determines how a PLI application is called from
the SystemVerilog source code. The types are as follows:
— A user task can be used in the same places a SystemVerilog task can be used (see 13.3). A
user-defined system task can read and modify the arguments of the task, but does not return any
value.
— A user function can be used in the same places a SystemVerilog function can be used (see 13.4). A
user-defined system function can read and modify the arguments of the function, and it returns a
value. The bit width of a vector shall be determined by a user-supplied sizetf application (see
36.8.1).
36.6 User-supplied PLI applications
User-supplied PLI applications are C language functions that utilize the library of PLI C functions to access
and interact dynamically with SystemVerilog software implementations as the SystemVerilog source code is
executed.
These PLI applications are not independent C programs. They are C functions that are linked into a tool and
become part of the tool. This allows the PLI application to be called when the user-defined system task or
system function $ name is compiled or executed in the SystemVerilog source code (see 36.8).
36.7 PLI include files
The libraries of PLI functions are defined in C include files, which are a normative part of this standard.
These files also define constants, structures, and other data used by the library of PLI routines and the
interface mechanisms. These files are (listed in AnnexK) and _ (listed in
vpi_user.h sv vpi_user.h
AnnexM). PLI applications that use the VPI routines shall include these files.
36.8 VPI sizetf, compiletf, and calltf routines
VPI-based system tasks have sizetf, compiletf, and calltf routines, which perform specific actions for the task
or system function. The sizetf, compiletf, and calltf routines are called during specific periods during
processing. The purpose of each of these routines is explained in 36.8.1 through 36.8.4.
955
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
36.8.1 sizetf VPI application routine
A sizetf VPI application routine can be used in conjunction with user-defined system functions. A function
shall return a value, and tools that execute the system function need to determine how many bits wide that
return value shall be. When sizetf shall be called is described in 36.10.2 and 38.37.1. Each sizetf routine shall
be called at most once. It shall be called if its associated system function appears in the design. The value
returned by the sizetf routine shall be the number of bits that the calltf routine shall provide as the return
value for the system function. If no sizetf routine is specified, a user-defined system function shall return
32bits. The sizetf routine shall not be called for user-defined system tasks or for functions whose
sysfunctype is set to vpiRealFunc.
36.8.2 compiletf VPI application routine
A compiletf VPI application routine shall be called when the user-defined system task or system function
name is encountered during parsing or compiling the SystemVerilog source code. This routine is typically
used to check the correctness of any arguments passed to the user-defined system task or system function in
the SystemVerilog source code. The compiletf routine shall be called one time for each instance of a system
task or system function in the source description. Providing a compiletf routine is optional, but it is
recommended that any arguments used with the system task or system function be checked for correctness to
avoid problems when the calltf or other PLI routines read and perform operations on the arguments. When
the compiletf is called is described in 36.10.2 and 38.37.1.
36.8.3 calltf VPI application routine
A calltf VPI application routine shall be called each time the associated user-defined system task or system
function is executed within the SystemVerilog source code. For example, the following SystemVerilog loop
would call the calltf routine that is associated with the user-defined system task name
$get_vector
1024times:
for (i = 1; i <= 1024; i = i + 1)
@(posedge clk) $get_vector("test_vector.pat", input_bus);
In this example, the calltf might read a test vector from a file called (the first task/
test_vector.pat
function argument), perhaps manipulate the vector to put it in a proper format for SystemVerilog, and then
assign the vector value to the second task/function argument called .
input_bus
36.8.4 Arguments to sizetf, compiletf, and calltf application routines
The sizetf, compiletf, and calltf routines all take one argument. When the tool calls these routines, it will pass
to them the value supplied in the structure’s user_data field when the user-defined
s_vpi_systf_data
system task or system function was registered. See 38.37.
36.9 PLI mechanism
The PLI mechanism provides a means to have PLI applications called for various reasons when the
associated system task and system function $ name is encountered in the SystemVerilog source description.
For example, when a SystemVerilog simulator first compiles the SystemVerilog source description, a
specific compiletf PLI routine can be called that performs syntax checking to verify the user-defined system
task or system function is being used correctly. Then, as simulation is executing, a specific calltf PLI routine
can be called to perform the operations required by the PLI application. User-defined system tasks and
system functions, and their associated routines and data, are defined by registering system task and system
function callbacks (see 36.9.1).
956
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The PLI mechanism also enables having specific PLI applications automatically called by the simulator for
miscellaneous reasons, such as the end of a simulation time step or a logic value change on a specific signal.
This dynamic interaction with simulation is accomplished by registering simulation callbacks (see 36.9.2).
36.9.1 Registering user-defined system tasks and system functions
User-defined system tasks and system functions are created using the routine vpi_register_systf() (see
38.37). The registration of system tasks shall occur prior to elaboration or the resolution of references.
The intended use model would be to place a reference to a routine within the []
vlog_startup_routines
array. This routine would register all user-defined system tasks and system functions when it is called.
Through the VPI, an application can perform the following:
— Specify a user-defined system task or system function name that can be included in SystemVerilog
source descriptions; the user-defined system task and system function name shall begin with a dollar
sign ($), such as .
$get_vector
— Provide one or more PLI C applications to be called by a tool (such as a logic simulator).
— Define which PLI C applications are to be called—and when the applications should be called—
when the user-defined system task and system function name is encountered in the SystemVerilog
source description.
— Define whether the PLI applications should be treated as functions (which return a value) or tasks
(analogous to subroutines in other programming languages).
— Define a data argument to be passed to the PLI applications each time they are called.
36.9.2 Registering simulation callbacks
Dynamic tool interaction shall be accomplished with a registered callback mechanism. VPI callbacks allow
an application to request that a SystemVerilog tool, such as a logic simulator, call a user-defined application
when a specific activity occurs. For example, the application can request that the application routine
be called when a particular net changes value or that be called when the
my_monitor() my_cleanup()
tool execution has completed.
The VPI simulation callback facility shall provide the application with the means to interact dynamically
with a tool, detecting the occurrence of value changes, advancement of time, end of simulation, etc. This
feature allows integration with other simulation systems, specialized timing checks, complex debugging
features, etc.
The reasons for which callbacks shall be provided can be separated into the following four categories:
— Simulation event (e.g., a value change on a net or a behavioral statement execution)
— Simulation time (e.g., the end of a time queue or after certain amount of time)
— Simulator action or feature (e.g., the end of compile, end of simulation, restart, or enter interactive
mode)
— User-defined system task or system function execution
VPI simulation callbacks shall be registered by the application with the function vpi_register_cb() (see
38.36). This routine indicates the specific reason for the callback, the application routine to be called, and
what system and user_data shall be passed to the callback application when the callback occurs. A facility is
also provided to call the callback functions when a SystemVerilog tool is first invoked. A primary use of this
facility shall be for registration of user-defined system tasks and system functions.
957
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
36.10 VPI access to SystemVerilog objects and simulation objects
Accessible SystemVerilog objects and simulation objects and their relationships and properties are
described using data model diagrams. These diagrams are presented in Clause37. The data model diagrams
indicate the routines and constants that are required to access and manipulate objects within an application
environment. An associated set of routines to access these objects is defined in Clause38.
VPI also includes a set of utility routines for functions such as handle comparison, file handling, and
redirected printing, which are described in Table36-9 (in 36.11).
VPI routines provide access to objects in an instantiated SystemVerilog design. An instantiated design is
one where each instance of an object is uniquely accessible. For instance, if a module contains wire and
m w
is instantiated twice as and , then and are two distinct objects, each with its own set of
m1 m2 m1.w m2.w
related objects and properties.
VPI is designed as a simulation interface, with access to both SystemVerilog objects and specific simulation
objects. This simulation interface is different from a hierarchical language interface, which would provide
access to source code information, but would not provide information about simulation objects.
36.10.1 Error handling
To determine whether an error occurred, the routine vpi_chk_error() (see 38.2) shall be provided. The
vpi_chk_ error() routine shall return a nonzero value if an error occurred in the previously called VPI
routine. Callbacks can be set up for when an error occurs as well. The vpi_chk_error() routine can provide
detailed information about the error.
36.10.2 Function availability
Certain features of VPI shall occur early in the execution of a tool. In order to allow this process to occur in
an orderly manner, some functionality shall be restricted in these early stages. Specifically, when the
routines within the [ ] array are executed, there is very little functionality
vlog_startup_routines
available. Only the following two routines can be called at this time:
— vpi_register_systf() (see 38.37)
— vpi_register_cb() (see 38.36)
In addition, the vpi_register_cb() routine can only be called for the following reasons:
— cbEndOfCompile
— cbStartOfSimulation
— cbEndOfSimulation
— cbUnresolvedSystf
— cbError
— cbPLIError
See 38.37 for a further explanation of the use of the [ ] array.
vlog_startup_routines
The next earliest phase is when the sizetf routines are called for the user-defined system functions. At this
phase, no additional access is permitted. After the sizetf routines are called, the routines registered for reason
are called. At this point, and continuing until the tool has finished execution, all
cbEndOfCompile
functionality is available.
958
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
36.10.3 Traversing expressions
The VPI routines provide access to any expression that can be written in the source code. Dealing with these
expressions can be complex because very complex expressions can be written in the source code.
Expressions with multiple operands will result in a handle of type vpiOperation. To determine how many
operands, access the property vpiOpType. This operation will be evaluated after its subexpressions.
Therefore, it has the least precedence in the expression.
An example of a routine that traverses an entire complex expression is listed as follows:
void traverseExpr(vpiHandle expr)
{
vpiHandle subExprI, subExprH;
switch (vpi_get(vpiType,expr))
{
case vpiOperation:
subExprI = vpi_iterate(vpiOperand, expr);
if (subExprI)
while (subExprH = vpi_scan(subExprI))
traverseExpr(subExprH);
/* else it is of op type vpiNullOp */
break;
default:
/* Do whatever to the leaf object. */
break;
}
}
36.11 List of VPI routines by functional category
The VPI routines can be divided into the following groups based on primary functionality:
— Simulation-related callbacks
— System task and system function callbacks
— Traversing SystemVerilog hierarchy
— Accessing properties of objects
— Accessing objects from properties
— Delay processing
— Logic and strength value processing
— Simulation time processing
— Miscellaneous utilities
Table36-1 through Table36-9 list the VPI routines by major category. Clause38 defines each of the VPI
routines, listed in alphabetical order.
Table36-1—VPI routines for simulation-related callbacks
To Use
Register a simulation-related callback vpi_register_cb()
Remove a simulation-related callback vpi_remove_cb()
Get information about a simulation-related callback vpi_get_cb_info()
959
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table36-2—VPI routines for system task or system function callbacks
To Use
Register a system task or system function callback vpi_register_systf()
Get information about a system task or system function callback vpi_get_systf_info()
Table36-3—VPI routines for traversing SystemVerilog hierarchy
To Use
Obtain a handle for an object with a one-to-one relationship vpi_handle()
Obtain handles for objects in a one-to-many relationship vpi_iterate()
vpi_scan()
Obtain a handle for an object in a many-to-one relationship vpi_handle_multi()
Table36-4—VPI routines for accessing properties of objects
To Use
Get the value of objects with types of or vpi_get()
int bool
Get the value of a 64-bit integer property of an object vpi_get64()
Get the value of objects with types of string vpi_get_str()
Table36-5—VPI routines for accessing objects from properties
To Use
Obtain a handle for a named object vpi_handle_by_name()
Obtain a handle for an indexed object vpi_handle_by_index()
Obtain a handle to a word or bit in an array vpi_handle_by_multi_index()
Table36-6—VPI routines for delay processing
To Use
Retrieve delays or timing limits of an object vpi_get_delays()
Write delays or timing limits to an object vpi_put_delays()
Table36-7—VPI routines for logic and strength value processing
To Use
Retrieve logic value or strength value of an object vpi_get_value()
Write logic value or strength value to an object vpi_put_value()
960
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table36-8—VPI routines for simulation time processing
To Use
Find the current simulation time or the scheduled time of future events vpi_get_time()
Table36-9—VPI routines for miscellaneous utilities
To Use
Write to the output channel of the tool that invoked the PLI application vpi_printf()
and the current log file
Write to the output channel of the tool that invoked the PLI application vpi_vprintf()
and the current log file using varargs
Flush data from the current simulator output buffers vpi_flush()
Open a file for writing vpi_mcd_open()
Close one or more files vpi_mcd_close()
Write to one or more files vpi_mcd_printf()
Write to one or more open files using varargs vpi_mcd_vprintf()
Flush data from a given mcd output buffer vpi_mcd_flush()
Retrieve the name of an open file vpi_mcd_name()
Retrieve data about tool invocation options vpi_get_vlog_info()
See whether two handles refer to the same object vpi_compare_objects()
Obtain error status and error information about the previous call to a vpi_chk_error()
VPI routine
Add application-allocated storage to application saved data vpi_put_data()
Retrieve application-allocated storage from application saved data vpi_get_data()
Store user data in VPI work area vpi_put_userdata()
Retrieve user data from VPI work area vpi_get_userdata()
Release handle and its associated resources allocated by VPI routines vpi_release_handle()
Control simulation execution (e.g., stop, finish) vpi_control()
36.12 VPI backwards compatibility features and limitations
The VPI data model has evolved over many previous versions in order to keep up with corresponding
features of the Verilog language. Substantial efforts have been made to maintain backwards compatibility
with prior versions whenever possible. However, some critical incompatible changes were needed that could
not be avoided. This subclause identifies those incompatibilities and provides a way for older affected
applications to continue to run in newer VPI environments, with some important restrictions.
961
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
36.12.1 VPI Incompatibilities with other standard versions
Table36-10 summarizes the VPI incompatibilities between this version and prior versions of IEEE
standards.
Table36-10—Summary of VPI incompatibilities across versions
Incompatibility IEEE Std 1364 IEEE Std 1800
2012
See following detailed descriptions 1995 2001 2005 2005 2009
2017
1) vpiMemory exists as an object Y D N N N N
2) vpiMemoryWord exists as an object Y D N N N N
3) vpiIntegerVar and vpiTimeVar can be arrays Y Y Y N N N
4) vpiRealVar can be an array N Y Y N N N
5) vpiVariables iterations include vpiReg and vpiRegArray N N N Y Y Y
6) vpiReg iterations on vpiRegArray include other objects N N N Y Y Y
7) vpiRegArray iterations include variable arrays N N N Y Y Y
8) vpiInterfaceDecl iterations allowed on vpiClassDefn objects N N N Y Y N
9) vpiInterfaceDecl iterations produce vpiRefObj objects N N N Y Y N
Table key:
Y = Behavior, function, or object present in that version
D = Behavior, function, or object deprecated (present, but use discouraged) in that version
N = Behavior, function, or object not applicable or no longer present in that version
For Table36-10 and the following details, the types vpiReg and vpiRegArray are the same as vpiLogicVar
and vpiArrayVar, respectively, as shown in the IEEE 1800 VPI data model (see 37.16, detail 19).
Incompatibility details:
1) vpiMemory exists as an object:
Unpacked unidimensional arrays were exclusively characterized as vpiMemory objects in
reg
IEEEStd1364-1995, and later deprecated in IEEE Std 1364-2001. This object type was replaced by
vpiRegArray in IEEE Std 1364-2005, leaving vpiMemory allowed as only a one-to-many
transition for IEEE Std 1364-2005 and IEEE 1800 standards (see 37.19). IEEE Std 1364-2001
allowed either vpiMemory or vpiRegArray types to represent unpacked unidimensional arrays of
vpiReg objects.
2) vpiMemoryWord exists as an object
Elements of unpacked unidimensional arrays were exclusively characterized as
reg
vpiMemoryWord objects in IEEE Std 1364-1995, and later deprecated in IEEE Std 1364-2001.
This object type was replaced by vpiReg in IEEE Std 1364-2005, leaving vpiMemoryWord
allowed only as an iterator for IEEE Std 1364-2005 and IEEE 1800 standards (see 37.19).
IEEEStd1364-2001 allowed either vpiMemoryWord or vpiReg types to represent elements of
unpacked unidimensional arrays of vpiReg objects.
3) vpiIntegerVar and vpiTimeVar can be arrays
vpiIntegerVar and vpiTimeVar objects could represent unpacked arrays instead of simple
variables in all IEEE 1364 standards. In IEEE 1800 standards, these array types are always
962
Authorized licensed use limitedCo ptyori:g hSt ©i e20m18e InEsEE A. AGll r igGhBts Sre sBer&veSd. SOL GMS. Downloaded on December 03,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
represented as vpiRegArray objects, and vpiIntegerVar and vpiTimeVar objects are always non-
array variables (see 37.16).
4) vpiRealVar can be an array
This object type was allowed to represent an unpacked array of such variables in IEEE Std 1364-
2001 and IEEE Std 1364-2005 (vpiRealVar arrays were not yet allowed in IEEE Std 1364-1995). In
IEEE 1800 standards, these are now exclusively represented as vpiRegArray objects (see 37.16).
5) vpiVariables iterations include vpiReg and vpiRegArray
In all IEEE 1364 standards, vpiReg and vpiRegArray objects were excluded from vpiVariables
iterations, and only accessed instead by iterations on vpiReg (from a scope or vpiRegArray) or
vpiRegArray (from a scope), respectively. In IEEE 1800 standards, they are both included in
vpiVariables iterations (see 37.16).
6) vpiReg iterations on vpiRegArray include other objects
This is a consequence of vpiRegArray objects being used to represent unpacked arrays of non-
vpiReg elements in IEEE 1800 standards (see 37.16). vpiReg iterations on these array objects can
retrieve array elements that are of type vpiIntegerVar or vpiTimeVar for example, which is not
expected in IEEEStd1364-2001 and IEEE Std 1364-2005.
7) vpiRegArray iterations include variable array objects
This is another consequence of vpiRegArray objects being used to represent unpacked arrays of
non-vpiReg elements in IEEE 1800 standards (see 37.16). In IEEE Std 1364-2001 and
IEEEStd1364-2005, vpiRegArray iterations only included arrays of vpiReg objects, but in
IEEE1800 standards, this iteration includes arrays of vpiIntegerVar, vpiTimeVar, and
vpiRealVar.
8) vpiInterfaceDecl iterations allowed on vpiClassDefn objects
The vpiInterfaceDecl iteration (aliased to vpiVirtualInterfaceVar in IEEE Std 1800-2012) was
allowed on vpiClassDefn objects in IEEE Std 1800-2005 and IEEE Std 1800-2009, but this has
been disallowed in IEEE Std 1800-2012. It was deemed to be misleading since vpiClassDefn
objects are lexical-only scopes. This iteration remains allowed for vpiClassTypespec objects, which
can represent active scopes.
9) vpiInterfaceDecl iterations produce vpiRefObj objects
The vpiInterfaceDecl iteration (aliased to vpiVirtualInterfaceVar in IEEE Std 1800-2012)
returned vpiRefObj objects in IEEE Std 1800-2005 and IEEE Std 1800-2009. This behavior has
been changed to produce vpiVirtualInterfaceVar objects in IEEE Std 1800-2012 in order to match
the aliased iteration type.
36.12.2 VPI Mechanisms to deal with incompatibilities
In order to ease the transition to the latest VPI standard for older applications, capability shall be provided to
emulate the incompatible VPI behaviors where they conflict with the current standard. This allows older
VPI applications dependent on these behaviors to be run unmodified, as long as they are applied only to
designs (or portions of designs) with which they are compatible. This capability is intended only as an
interim measure to allow extra time for applications to be upgraded; it does not provide general emulation of
older behaviors for newer design constructs. For example, it does not allow IEEE 1364 applications to run
on portions of designs requiring IEEE 1800-level simulation capability.
As described in 36.12.2.1 and 36.12.2.2, two mechanisms to support this shall be provided, which can be
used in combination.
36.12.2.1 Mechanism 1: Compile-based binding to a compatibility mode
This mechanism requires recompilation of the VPI application source code and is based on defining a
compiler symbol that binds a particular application to a particular compatibility mode. To use this scheme,
963
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
one of the following compiler symbols shall be defined prior to compilation of any of the standard VPI
include files in the application source code—either using a “#define” in the source code itself (setting it to
the numeric constant “1”), or defined on the C-compiler command-line:
VPI_COMPATIBILITY_VERSION_1364v1995
VPI_COMPATIBILITY_VERSION_1364v2001
VPI_COMPATIBILITY_VERSION_1364v2005
VPI_COMPATIBILITY_VERSION_1800v2005
VPI_COMPATIBILITY_VERSION_1800v2009
VPI_COMPATIBILITY_VERSION_1800v2012
VPI_COMPATIBILITY_VERSION_1800v2017
No more than one of these symbols shall be defined for a given application, and it shall be consistently
defined for all of its source code that can access any portion of VPI, including callback functions. This
allows all design information to be handled in the same way for a given mode across the entire application.
A compilation error will occur during the processing of if more than one of the preceding
vpi_user.h
symbols is defined.
Example:
VPI source code file with a compatibility mode selected:
/* VPI application mytask */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define VPI_COMPATIBILITY_VERSION_1364v2001 1
#include “vpi_user.h”
#include “sv_vpi_user.h”
#include “my_appl_header.h”
...
...
Alternatively, the same mode selection could be performed by defining the following option on the C-
compiler command line:
-DVPI_COMPATIBILITY_VERSION_1364v2001
When a mode is selected by one of the means above, C-preprocessor constructs in cause the
vpi_user.h
following VPI functions to be redefined to mode-specific versions:
vpi_compare_objects
vpi_control
vpi_get
vpi_get_str
vpi_get_value
vpi_handle
vpi_handle_by_index
vpi_handle_by_multi_index
vpi_handle_by_name
vpi_handle_multi
vpi_iterate
vpi_put_value
vpi_register_cb
vpi_scan
964
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For example, defining the mode symbol “ ” as shown above
VPI_COMPATIBILITY_VERSION_1364v2001
will cause “ ” to be redefined as:
vpi_handle
vpi_handle_1364v2001
This retargets all calls to “ ” in the recompiled application to this mode-specific variant,
vpi_handle
achieving mode-compatible behavior. See “ ” (AnnexL) for the complete set of
vpi_compatibility.h
definitions.
36.12.2.2 Mechanism 2: Selection of default VPI compatibility mode run by host simulator
A means to set the default VPI compatibility mode shall be made available by the simulation provider. This
shall determine the compatibility mode VPI behavior for all applications not using the compile-based
scheme detailed in Mechanism 1. Although VPI applications choosing this mechanism can be run without
modification or recompilation, only one such default mode shall be selectable for a given simulation run.
Additional applications requiring different modes in the same run-time simulation environment shall use the
compile-based mechanism to do so.
36.12.3 Limitations of VPI compatibility mechanisms
When a VPI application uses the compatibility mode mechanism, the application user and application
provider should verify that the design or design partition to which the application is applied is consistent
with the mode, and does not include constructs that are only supported in other modes. If the design contains
unsupported constructs, the behavior of the VPI implementation is undefined. The extent of checking for
consistency between constructs and mode is left to the discretion of the VPI implementation.
In general, VPI users and application developers are strongly encouraged to update their applications to the
latest VPI version as soon as possible. The compatibility mode feature should be used only as a temporary
solution until such upgrades can be completed or become available. It should be expected that older modes
will be phased out as new versions of the standard become available.
965
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37. VPI object model diagrams
37.1 General
This clause describes the following:
— Using VPI data models
— VPI data model diagrams
37.2 VPI Handles
A handle is an opaque reference to an object in the VPI information model. It is represented as a value of the
data type vpiHandle (see AnnexK); however, the interpretation of the representation is implementation
defined. A handle allows a VPI program to refer to an object without assuming details of the representation
of the object. The VPI provides functions that operate on objects referred to by handles. The particular
operations that are legal for an object referred to by a handle depend on the type of the object.
37.2.1 Handle creation
A handle is created by a tool as the result of one of the following functions called by a VPI application
program:
a) vpi_handle(), which returns a handle that refers to an object in a one-to-one relationship
b) vpi_handle_by_index(), which returns a handle that refers to an object in an ordered, one-to-many
relationship using an index
c) vpi_handle_by_multi_index(), which returns a handle that refers to an indexed subobject of a
multidimensional parent object using an array of indices
d) vpi_handle_by_name(), which returns a handle that refers to an object identified by a specific name
e) vpi_handle_multi(), which returns a handle to an object in a many-to-one relationship
f) vpi_iterate(), which returns a handle to an iterator object for scanning a one-to-many relationship
g) vpi_put_value(), which returns a handle to a scheduled event object
h) vpi_register_cb(), which returns a handle to the callback object being registered.
i) vpi_register_systf(), which returns a handle to the callback object for a user-defined system task or
function
j) vpi_scan(), which returns a handle to objects in a one-to-many relationship, using their iterator
object
A tool shall support multiple VPI programs, each of which acquires handles. The way in which a tool
implements handles shall allow a VPI program to function correctly independently of other VPI programs
executing concurrently. A tool may share between VPI programs resources associated with the
implementation of handles and the objects to which they refer. However, the occurrence of such sharing
shall not alter the effect of the VPI programs. If a tool creates two handles that refer to the same object, the
tool may create two distinct handles or may provide the same handle in both cases. Two distinct handles that
refer to the same object are equivalent.
NOTE—The number of handles that an implementation can create may be constrained by the capacity of the host
system.
37.2.2 Handle release
The function vpi_release_handle() called by a VPI program causes a tool to release a handle. If a tool
shares resources associated with handles and one VPI program releases a handle, other VPI programs shall
966
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
be able to continue to refer to objects using handles that they have not released. The tool may reclaim
resources associated with the representation of a released handle.Handles may also be released as part of the
action of other VPI function calls, in particular:
a) vpi_remove_callback() releases the associated callback handle.
b) vpi_scan() releases the iterator handle after its last object has been scanned.
Simulation events or actions may also cause certain handles to be released, in particular:
1) A simulation restart shall release all handles except for cbStartOfRestart and cbEndOfRestart
callback handles.
2) Whenever the simulator frees objects belonging to a frame or thread, it shall release all handles to
those objects, and to any subelement of these objects. Handles to callbacks placed on these objects
will also be released.
3) Whenever the simulator reclaims the memory of a class object, it shall release all handles to the class
object, to any of its automatic data members, and to any subelement of its automatic data members.
Handles to callbacks placed on these objects will also be released.
NOTE 1—It is recommended that a VPI program release handles when they are no longer needed.
NOTE 2—A tool may reclaim resources associated with a handle when the handle is released by a VPI program,
provided the requirements of 37.2 are met. As a consequence, resources might not be reclaimed immediately upon
release of a handle by a VPI program, as the resources may be associated with handles in use by other VPI programs.
NOTE 3—A static local variable declared in a task/function does not belong to a frame or thread, and handles to such a
variable or callbacks associated with the variable are not released automatically when the frame or thread ends.
37.2.3 Handle comparison
Handle equivalence cannot be determined with a C “==” comparison. The function vpi_compare_objects()
compares the objects they refer to. It returns the value 1 if the objects they refer to are the same object);
otherwise it returns the value 0. See 38.3.
37.2.4 Validity of handles
The lifetime of an object is the duration of existence of the object in the VPI information model. Lifetime of
objects is discussed in 37.3.7. A tool can create a handle that refers to an object only during the lifetime of
the object. A handle is said to be valid from the time of its creation until the time at which it is released, or
until the object that it refers to ceases to exist, or until termination of the tool; at other times it is invalid. A
VPI program shall not refer to an object using an invalid handle, nor shall a VPI program attempt to release
an invalid handle.
37.3 VPI object classifications
VPI objects are classified using data model diagrams. These diagrams provide a graphical representation of
those objects within a SystemVerilog design to which the VPI routines shall provide access. The diagrams
shall show the relationships between objects and the properties of each object. Objects with sufficient
commonality are placed in groups. Group relationships and properties apply to all the objects in the group.
As an example, the simplified diagram in Figure37-1 shows that there is a one-to-many relationship from
objects of type module to objects of type net and a one-to-one relationship from objects of type net
toobjects of type module. Objects of type net have properties vpiName, vpiVector, and vpiSize with data
types string, Boolean, and integer, respectively.
967
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
module net
-> name
str: vpiName
str: vpiFullName
-> vector
bool: vpiVector
-> size
int: vpiSize
Figure37-1—Example of object relationships diagram
For object relationships (unless a special tag is shown in the diagram), the type used for access is determined
by adding “ ” to the beginning of the word within the enclosure with each word’s first letter being a
vpi
capital. Using the above example, if an application has a handle to a net and wants to go to the module
instance where the net is defined, the call would be as follows:
modH = vpi_handle(vpiModule,netH);
where is a handle to the net. As another example, to access a “named event” object, use the type
netH
vpiNamedEvent.
37.3.1 Accessing object relationships and properties
VPI defines the C data type of . All objects are manipulated via a variable. Object
vpiHandle vpiHandle
handles can be accessed from a relationship with another object or from a hierarchical name as the following
example demonstrates:
vpiHandle net;
net = vpi_handle_by_name("top.m1.w1", NULL);
This example call retrieves a handle to wire and assigns it to the variable . The
top.m1.w1 vpiHandle net
second argument directs the routine to search for the name from the top level of the design.
NULL
VPI provides generic functions for tasks, such as traversing relationships and determining property values.
One-to-one relationships are traversed with routine vpi_handle(). In the following example, the module that
contains is derived from a handle to that net:
net
vpiHandle net, mod;
net = vpi_handle_by_name("top.m1.w1", NULL);
mod = vpi_handle(vpiModule, net);
The call to vpi_handle() in the preceding example shall return a handle to module .
top.m1
Sometimes it is necessary to access a class of objects that do not have a name or whose name is ambiguous
with another class of objects that can be accessed from the reference handle. Tags are used in this situation,
as shown in Figure37-2.
968
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
expr
vpiLeftRange
part select
expr
vpiRightRange
Figure37-2—Accessing a class of objects using tags
In this example, the tags vpiLeftRange and vpiRightRange are used to access the expressions that make up
the range of the part-select. These tags are used instead of vpiExpr to get to the expressions. Without the
tags, VPI would not know which expression should be accessed. For example:
vpi_handle(vpiExpr, part_select_handle)
would be illegal when the reference handle (part_select_handle) is a handle to a part-select because the part-
select can refer to two expressions, a left-range and a right-range.
Properties of objects shall be derived with routines in the vpi_get family. The routine vpi_get() returns
integer and Boolean properties. Integer and Boolean properties shall be defined to be of type .
PLI_INT32
For Boolean properties, a value of shall represent and a value of shall represent . The
1 TRUE 0 FALSE
routine vpi_get64() returns 64-bit integer properties as type PLI_INT64. The routine vpi_get_str() accesses
string properties. String properties shall be defined to be of type . For example, to retrieve a
PLI_BYTE8 *
pointer to the full hierarchical name of the object referenced by handle , the following call would be
mod
made:
PLI_BYTE8 *name = vpi_get_str(vpiFullName, mod);
In the preceding example, the pointer shall now point to the string “ ”.
name top.m1
One-to-many relationships are traversed with an iteration mechanism. The routine vpi_iterate() creates an
object of type vpiIterator, which is then passed to the routine vpi_scan() to traverse the desired objects. In
the following example, each net in module is displayed:
top.m1
vpiHandle itr;
itr = vpi_iterate(vpiNet,mod);
while (net = vpi_scan(itr) )
vpi_printf("\t%s\n", vpi_get_str(vpiFullName, net) );
As the preceding examples illustrate, the routine naming convention is a “ ” prefix with “_” word
vpi
delimiters (with the exception of callback-related defined values, which use the “ ” prefix). Macro-defined
cb
types and properties have the “ ” prefix, and they use capitalization for word delimiters.
vpi
The routines for traversing SystemVerilog structures and accessing objects are described in Clause38.
37.3.2 Object type properties
All objects have a vpiType property, which is not shown in the data model diagrams.
-> type
int: vpiType
Using returns an integer constant that represents the type of the
vpi_get(vpiType, <object_handle>)
object.
969
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Using returns a pointer to a string containing the name of
vpi_get_str(vpiType, <object_handle>)
the type constant. The name of the type constant is derived from the name of the object as it is shown in the
data model diagram (see 37.3 for a description of how type constant names are derived from object names).
Some objects have additional type properties that are shown in the data model diagrams vpiDelayType,
vpiNetType, vpiOpType, vpiPrimType, vpiResolvedNetType, and vpiTchkType. Using
returns an integer constant that represents the
vpi_get(<type_property>, <object_handle>)
additional type of the object. See in AnnexK and in AnnexM for the types
vpi_user.h sv_vpi_user.h
that can be returned for these additional type properties. The constant names of the types returned for these
additional type properties can be accessed using vpi_get_str().
37.3.3 Object file and line properties
Most objects have the following two location properties, which are not shown in the data model diagrams:
-> location
int: vpiLineNo
str: vpiFile
The properties vpiLineNo and vpiFile can be affected by the compiler directive. See 22.12 for more
`line
details on the compiler directive. These properties are applicable to every object that corresponds to
`line
some object within the source code. The exceptions are objects of the following types:
— vpiCallback
— vpiDelayTerm
— vpiDelayDevice
— vpiInterModPath
— vpiIterator
— vpiTimeQueue
— vpiGenScopeArray
— vpiGenScope
37.3.4 Delays and values
Most properties are of type integer, Boolean, or string. Delay and logic value properties, however, are more
complex and require specialized routines and associated structures. The routines vpi_get_delays() and
vpi_put_delays() use structure pointers, where the structure contains the pertinent information about delays.
Similarly, simulation values are also handled with the routines vpi_get_value() and vpi_put_value(), along
with an associated set of structures.
The routines, C structures, and some examples for handling delays and logic values are presented in
Clause38. See 38.15 for vpi_get_value(), 38.34 for vpi_put_value(), 38.10 for vpi_get_delays(), and
38.32 for vpi_put_delays().
Nets, primitives, module paths, timing checks, and continuous assignments can have delays specified within
the SystemVerilog source code. Additional delays may exist, such as module input port delays or inter-
module path delays, that do not appear within the SystemVerilog source code. To access the delay
expressions that are specified within the SystemVerilog source code, use the method vpiDelay. These
expressions shall be either an expression that evaluates to a constant if there is only one delay specified or an
operation if there are more than one delay specified. If multiple delays are specified, then the operation’s
vpiOpType shall be vpiListOp. To access the actual delays being used by the tool, use the routine
vpi_get_delays() on any of these objects.
970
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.3.5 Expressions with side effects
VPI gives applications access to arbitrarily complex expressions from the SystemVerilog source, either as
arguments to system tasks or functions (see 36.4) or by traversing the design hierarchy. Expressions may
have side effects when evaluated; such expressions include the following:
— Assignment operators (11.4.1)
— Increment and decrement operators (11.4.2)
— Function calls, including built-in methods and system function calls, that change the state of the
simulation other than via their return values
— Expressions in which other expressions with side effects appear as operands, arguments, or index
expressions
Applying the function vpi_get_value() (38.15) to an expression with side effects shall fully evaluate the
expression together with its side effects. However, it shall be an error for an application to ask for a VPI
property or relation of an expression if the VPI implementation cannot determine the value or handle
without also evaluating an expression with side effects. Since implementations may differ in their ability to
determine whether an expression has side effects, this result may result in an error with some
implementations but not with others. It shall be an error for an application to apply vpi_put_value() (38.34)
to an object if any of its index expressions is an expression with side effects.
To provide the greatest flexibility for VPI applications, it is recommended that expressions with side effects
not be used as index expressions or as arguments to system tasks or functions or to SystemVerilog function
calls.
Example 1:
function string ename(my_enum_type e);
static first_time = 1;
begin
if (first_time == 1) first_time = 0;
ename = e.name();
end
endfunction
...
foo = ename(e);
For most implementations, asking for the vpiSize property of the function call shall be an error
ename(e)
because the implementation cannot determine the size of the function call without evaluating it, and
evaluating it may have the side effect of changing the value of .
first_time
In the unusual case in which all the names of the enumeration type have the same length, an implementation
could in principle determine the vpiSize by analyzing the function without evaluating it. However, this is not
required by the standard, and an implementation may issue an error in this case as well.
Example 2:
j = my_array[i++];
k = my_array[--i];
It shall be an error for a VPI application to apply vpi_put_value() to either or
my_array[i++] my_array
, since both expressions have side effects.
[--i]
971
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.3.6 Object protection properties
All objects have a vpiIsProtected property, which is not shown in the data model diagrams.
-> IsProtected
bool: vpiIsProtected
Using returns a Boolean constant that indicates whether
vpi_get(vpiIsProtected, object_handle)
the object represents code contained in a decryption envelope. The vpiIsProtected property shall be TRUE
if the object_handle represents code that is protected; otherwise, it shall be FALSE. Unless otherwise
specified, access to relationships and properties of a protected object shall be an error. Restrictions on access
to complex properties are specified in the function reference descriptions for the corresponding VPI
functions. Access to the vpiType property and the vpiIsProtected property of a protected object shall be
permitted for all objects.
NOTE—Handles to protected objects can be returned through object relationships or by direct lookup using VPI
functions that return handles.
37.3.7 Lifetimes of objects
The lifetime of an object is the duration of existence of the object in the VPI information model. A source
code object comes into existence during analysis and persists, independent of elaboration and runtime, until
the tool terminates. It has a lifetime that is independent of simulation. Static objects rooted in the static
design hierarchy are alive from the point at which they are created during elaboration and for the entire
simulation. Objects that may have a lifetime shorter than the duration of the simulation are called transient
objects. Class objects and automatic variables are transient objects.
A class object (see 37.30) is alive from the time it is created by a call to until the time its memory is
new()
reclaimed by the simulator’s automatic memory management (see 8.29); data members and methods that
belong to the class object have the same object lifetime as the class object. An automatic variable that
belongs to a frame (see 37.40) has the same object lifetime as that of the frame, which is alive from the point
of the call that establishes the stack frame until the stack frame is destroyed.
Other transient objects include the following:
a) Threads (see 37.42)
b) Outdated and out-of-scope references made within a thread
c) Iterators (objects of type vpiIterator), which are created by calls to vpi_iterate() (see 38.23)
d) A vpiSchedEvent created by vpi_put_value() (see 38.34)
e) Callbacks (see 38.36)
There are two properties relevant to understanding the lifetimes of objects. As a property of an object,
vpiAutomatic is a Boolean property that, when false, means the object is static. When true, it means the
object is non-static and may be an automatic variable or dynamic object. The property name vpiAutomatic
and its interpretation reflect the keywords in the language, static and automatic, used to declare the object.
Those keywords may be applied to the object declaration or to the scope of the object, the latter indicating
the default for all objects of that scope. vpiAutomatic is also a property of an instance of a module, program,
interface, or package, indicating the default lifetime for variables of any of its declared tasks/functions.
vpiAutomatic is also a property of a class defn or class typespec, indicating the default lifetime for variables
of any of its declared tasks/functions. Other exceptions to this general description of vpiAutomatic are noted
in the object diagram details.
The property vpiAllocScheme indicates how an object’s memory was allocated and thus supports
understanding its lifetime. It is useful for determining whether and how to manage a transient object. It is an
enumeration of three possible values: vpiAutomaticScheme, vpiDynamicScheme, and vpiOtherScheme.
972
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
vpiAutomaticScheme indicates the object is allocated as part of a frame or thread and has the lifetime of
that frame or thread. vpiDynamicScheme indicates the object was allocated in dynamic memory and may
be a class object or part thereof. For all other objects, vpiAllocScheme shall return vpiOtherScheme.
37.3.8 Managing transient objects
One may obtain a handle to an object during its lifetime, and it remains valid only as long as the object
exists. For a static object, one may therefore keep its handle indefinitely. For a transient object, one may
release its handle after use or expect that handle to be released and become invalid when the object ceases to
exist.
The life of a transient object may be tracked through various callbacks, depending on the specific type of
object. The callbacks are described on the object model diagrams and/or the function reference for
vpi_register_cb(), as appropriate. The relevant callbacks are as follows:
cbCreateObj, cbReclaimObj, cbStartofFrame, cbEndOfFrame, cbStartOfThread, cbEndOfThread, and
cbEndOfObject.
37.4 Key to data model diagrams
This subclause contains the keys to the symbols used in the data model diagrams. Keys are provided for
objects and classes, traversing relationships, and accessing properties.
973
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.4.1 Diagram key for objects and classes
Object definition:
obj defn
Bold letters in a solid enclosure indicate an object definition. The
properties of the object are defined in this location.
Object reference:
object
Normal letters in a solid enclosure indicate an object reference.
Class definition:
class defn
class Bold italic letters in a dotted enclosure indicate a class definition,
where the class groups other objects and classes. Properties of the
obj defn class are defined in this location. The class definition can contain an
object definition.
object
Class reference:
class
Italic letters in a dotted enclosure indicate a class reference.
Unnamed class:
obj1
A dotted enclosure with no name is an unnamed class. It is sometimes
obj2 convenient to group objects although they shall not be referenced as a
group elsewhere; therefore, a name is not indicated.
37.4.2 Diagram key for accessing properties
obj Integer and Boolean properties are accessed with the routine vpi_get().
These properties are of type .
PLI_INT32
-> vector
bool: vpiVector For example: Given handle to an object of type vpiObj, test if
obj_h
-> size the object is a vector, and get the size of the object.
int: vpiSize PLI_INT32 vect_flag = vpi_get(vpiVector, obj_h);
PLI_INT32 size = vpi_get(vpiSize, obj_h);
String properties are accessed with routine vpi_get_str(). String
obj
properties are of type .
PLI_BYTE8*
-> name
str: vpiName For example:
str: vpiFullName
PLI_BYTE8 *name = vpi_get_str(vpiName, obj_h);
object Complex properties for time and logic value are accessed with the
indicated routines. See the descriptions of the routines for usage.
-> complex
func1()
func2()
974
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.4.3 Diagram key for traversing relationships
A single arrow indicates a one-to-one relationship accessed
ref with the routine vpi_handle().
For example: Given vpiHandle variable of type ,
ref_h ref
access of type Obj:
obj obj_h
Obj
obj_h = vpi_handle( , ref_h);
ref A tagged one-to-one relationship is traversed similarly, using
Tag instead of Obj.
Tag
For example:
obj Tag
obj_h = vpi_handle( , ref_h);
A one-to-one relationship that originates from a circle is
traversed using for the .
NULL ref_h
For example:
obj
Obj
obj_h = vpi_handle( , NULL);
A double arrow indicates a one-to-many relationship accessed
ref
with the routine vpi_scan().
For example: Given vpiHandle variable of type ,
ref_h ref
scan objects of type Obj:
obj
Obj
itr = vpi_iterate( , ref_h);
while (obj_h = vpi_scan(itr) )
/* process 'obj_h' */
A tagged one-to-many relationship is traversed similarly, using
ref Tag instead of Obj.
For example:
Tag
Tag
itr = vpi_iterate( , ref_h);
obj
while (obj_h = vpi_scan(itr) )
/* process 'obj_h' */
A one-to-many relationship that originates from a circle is
traversed using for the .
NULL ref_h
For example:
obj itr = vpi_iterate( Obj , NULL);
while (obj_h = vpi_scan(itr) )
/* process 'obj_h' */
For relationships that do not have a tag, the type used for access is determined by adding “vpi” to the
beginning of the word within the enclosure, with each word’s first letter being a capital. See 37.3 for more
details on VPI access to constant names.
975
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.5 Module
expr
vpiIndex
vpiGlobalClocking
clocking block
vpiInternalScope
scope
vpiDefaultClocking
clocking block
port
interface
expr vpiDefaultDisableIff
distribution
interface array
process
instance array module
cont assign
-> top module
bool: vpiTopModule
module array module
-> decay time
int: vpiDefDecayTime
module array
primitive
primitive array
mod path
tchk
def param
io decl
alias stmt
clocking block
Details:
1) Top-level modules shall be accessed using vpi_iterate() with a reference object.
NULL
2) If a module is an element within a module array, the vpiIndex transition is used to access the index within the array.
If a module is not part of a module array, this transition shall return .
NULL
976
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.6 Interface
expr
vpiIndex
vpiGlobalClocking
clocking block
vpiDefaultClocking
clocking block
interface tf decl
expr vpiDefaultDisableIff modport
distribution
mod path
instance array interface cont assign
vpiInstance
clocking block
interface
interface array
process
Details:
1) If an interface is an element within an instance array, the vpiIndex transition is used to access the index within the
array. If an interface is not part of an instance array, this transition shall return NULL.
37.7 Modport
interface modport io decl
-> name
str: vpiName
37.8 Interface task or function declaration
task
interface tf decl
-> access type
function
int: vpiAccessType
Details:
1) vpi_iterate() can return more than one task or function declaration for modport tasks or functions with an access
type of vpiForkJoinAcc, because the task or function can be imported from multiple module instances.
2) Possible return values for the vpiAccessType property for an interface tf decl are vpiForkJoinAcc and
vpiExternAcc.
977
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.9 Program
expr
vpiIndex
vpiDefaultClocking
clocking block
expr vpiDefaultDisableIff
cont assign
distribution
clocking block
instance array program
vpiInstance
interface
interface array
process
Details:
1) If a program is an element within an instance array, the vpiIndex transition is used to access the index within the
array. If a program is not part of an instance array, this transition shall return NULL.
978
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.10 Instance
instance item
program
instance
program array
package
-> compile unit task func
bool: vpiUnit
net
interface
array net
program variables
vpiReg
logic var
module
vpiRegArray
array var
-> array member -> protected
vpiMemory
bool: vpiArray (deprecated) bool: vpiProtected array var
bool: vpiArrayMember -> timeprecision
-> cell
int: vpiTimePrecision
named event
bool: vpiCellInstance -> timeunit
-> default net type
int: vpiTimeUnit
int: vpiDefNetType -> unconnected drive named event array
-> definition location
int: vpiUnconnDrive
vpiParameter
int: vpiDefLineNo -> configuration parameters
str: vpiDefFile
str: vpiLibrary
-> definition name
str: vpiCell
spec param
str: vpiDefName str: vpiConfig
-> delay mode -> default lifetime
int: vpiDefDelayMode bool: vpiAutomatic assertion
-> name -> top
vpiTypedef
str: vpiName bool: vpiTop typespec
str: vpiFullName
class defn
Details:
1) The vpiTypedef iteration shall return the user-defined typespecs that have typedefs explicitly declared in the
instance.
2) vpiModule shall return a module if the object is inside a module instance, otherwise it shall return .
NULL
3) vpiInstance shall always return the immediate instance (package, module, interface, or program) in which the
object is instantiated.
4) vpiMemory shall return array variable objects rather than vpiMemory objects.
979
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
5) vpiFullName for objects that exist within a compilation unit shall begin with “ ”. As a result, the full
$unit::
name for objects within a compilation unit may be ambiguous. vpiFullName for a package shall be the name of the
package and should end with “ ”; this syntax disambiguates between a module and a package of the same name.
::
vpiFullName for objects that exist in a package shall begin with the name of the package followed by “ ”. The
::
separator shall appear between the package name and the immediately following name component. The
::
“ ”separator shall be used in all cases except package and class defn.
.
6) The following items shall not be accessible via :
vpi_handle_by_name()
— Imported items
— Objects that exist within a compilation unit
7) Passing a handle to vpi_get() with properties vpiTimePrecision or vpiTimeUnit shall return the smallest
NULL
time precision of all modules in the instantiated design.
8) The properties vpiDefLineNo and vpiDefFile can be affected by the compiler directive. See 22.12 for more
`line
details on the directive.
`line
9) For details on lifetime and memory allocation properties, see 37.3.7.
980
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.11 Instance arrays
vpiLeftRange
expr
expr instance array
expr
range vpiRightRange
primitive array
instance
interface array
program array param assign
module array
module
-> access by index
vpi_handle_by_index()
vpi_handle_by_multi_index()
-> name
str: vpiName
str: vpiFullName
->size
int; vpiSize
primitive array primitive
gate array
switch array expr
vpiDelay
udp array
Details:
1) Traversing from the instance array to expr shall return a simple expression object of type vpiOperation with a
vpiOpType of vpiListOp. This expression can be used to access the actual list of connections to the instance array
in the SystemVerilog source code
2) vpi_iterate(vpiRange, instance_array_handle) shall return the set of instance array ranges beginning with the
leftmost range of the array declaration and iterating through the rightmost range. Using the vpiLeftRange/
vpiRightRange properties returns the bounds of the leftmost dimension of a multidimensional array.
981
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.12 Scope
scope property decl
sequence decl
instance
task func concurrent assertion
named begin
named event
begin
named event array
named fork
variables
fork
virtual interface var
-> join type
vpiReg
int: vpiJoinType logic var
vpiRegArray
array var
class defn
stmt vpiMemory
class typespec array var
vpiParameter
class obj
parameters
clocking block vpiInternalScope
scope
gen scope
vpiImport
instance item
for
vpiTypedef
typespec
foreach stmt
let decl
-> name
str: vpiName
str: vpiFullName
Details:
1) An unnamed begin or unnamed fork shall be a scope if, and only if, it directly contains a block item declaration
such as a variable declaration or type declaration. A named begin or named fork shall always be a scope.
Example:
begin
begin : BLK
var logic v; // This declaration is not local to the unnamed begin
v = 1'b1;
end
end
In this example, the block is a scope, but the unnamed begin is not a scope because it does not directly contain
BLK
a block item declaration.
2) A for statement shall be a scope if, and only if, the vpiLocalVarDecls property returns TRUE. In this case, the
scope of each loop control variable shall be the for statement.
982
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
3) The scope of each loop control variable in a foreach stmt shall be the foreach stmt.
4) The vpiImport iterator shall return all objects imported into the current scope via import declarations. Only objects
actually referenced through the import shall be returned, rather than items potentially made visible as a result of the
import. Refer to 26.3 for more details.
5) A task func can have zero or more statements (see 13.3, 13.4). If the number of statements is greater than 1, the
vpiStmt relation shall return an unnamed that contains the statements of the task or function. If the number
begin
of statements is zero, the vpiStmt relation shall return .
NULL
6) The vpiJoinType property indicates what type of join statement terminates the fork-join block. It shall return one
of the values vpiJoin, vpiJoinNone, or vpiJoinAny.
7) The vpiVirtualInterfaceVar iteration is supported only within elaborated contexts and is not supported within
lexical contexts such as class defns (see 37.29). If the scope declares an array of virtual interfaces, the
vpiVirtualInterfaceVar iteration shall return each element of the array separately. However, the vpiVariables
iteration shall return the array declaration as a single vpiArrayVar.
37.13 IO declaration
ref obj
instance
interface tf decl
vpiExpr
udp defn io decl
nets
-> direction
task func int: vpiDirection
variables
-> name
module str: vpiName
vpiLeftRange
-> scalar expr
bool: vpiScalar
vpiRightRange
-> sign
expr
bool: vpiSigned
-> size
range
int: vpiSize
-> vector
typespec
bool: vpiVector
Details:
1) vpiDirection returns vpiRef for pass by ports or arguments.
ref
2) A ref obj type handle shall be returned for the vpiExpr of an io decl if it is passed by reference or if the io decl is an
interface or a modport. If the io decl is a virtual interface, vpiExpr shall return a vpiVirtualInterfaceVar.
3) If the vpiExpr of an io decl is a ref obj and if the vpiActual of the ref obj is an interface or modport declaration,
then the vpiDirection of the io decl shall be undefined. The vpiDirection shall also be undefined if the vpiExpr is
a virtual interface var.
4) The vpiRange, vpiLeftRange, and vpiRightRange relations for an io decl shall be the same as for the
corresponding typespec (see 37.23).
983
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLr igGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reicgehmtsb erer s0e3,r2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.14 Ports
expr
vpiHighConn
ports
instance port vpiLowConn
ref obj
vpiParent
module
typespec
vpiBit
port bit
-> access by index -> index
vpi_handle_by_index() int: vpiPortIndex
vpi_handle_by_multi_index() -> name
->connected by name
str: vpiName
bool: vpiConnByName -> port type
-> delay (mipd)
int: vpiPortType
vpi_get_delays() -> scalar
vpi_put_delays()
bool: vpiScalar
-> direction
-> size
int: vpiDirection
int: vpiSize
-> explicitly named
-> vector
bool: vpiExplicitName
bool: vpiVector
Details:
1) vpiPortType shall be one of the following three types: vpiPort, vpiInterfacePort, or vpiModportPort. Port type
depends on the formal, not on the actual.
2) vpi_get_delays() and vpi_put_delays() delays shall not be applicable for vpiInterfacePort.
3) vpiHighConn shall indicate the hierarchically higher (closer to the top module) port connection.
4) vpiLowConn shall indicate the lower (further from the top module) port connection.
5) vpiLowConn of a vpiInterfacePort shall always be vpiRefObj.
6) Properties vpiScalar and vpiVector shall indicate if the port is 1 bit or more than 1 bit. They shall not indicate
anything about what is connected to the port.
7) Properties vpiIndex and vpiName shall not apply for port bits.
8) If a port is explicitly named, then the explicit name shall be returned. If not, and a name exists, then that name shall
be returned. Otherwise, shall be returned.
NULL
9) vpiPortIndex can be used to determine the port order. The first port has a port index of zero.
10) vpiLowConn shall return if the module or interface or program port is a null port (e.g., “ ”).
NULL module M();
vpiHighConn shall return if the instance of the module, interface, or program does not have a connection to
NULL
the port.
11) vpiSize for a null port shall return 0.
984
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.15 Reference objects
vpiPortInst ports
ports
vpiLowConn vpiHighConn
ref obj ref obj
instance
vpiParent
-> name
typespec
str: vpiName
task func
str: vpiFullName
-> generic
bool: vpiGeneric vpiActual interface
-> definition name
str: vpiDefName interface array
modport
nets
variables
named event
named event array
part select
Details:
1) A ref obj represents a declared object or subelement of that object that is a reference to an actual instantiated object.
A ref obj exists for ports with ref direction, for an interface port, a modport port, or for formal task function ref
arguments. The specific cases for a ref obj are as follows:
— A variable, named event, named event array that is the lowconn of a ref port
— Any subelement expression of the above
— A local declaration of an interface or modport passed through a port or any net, variable, named event, named
event array of those
— A ref formal argument of a task or function, or subelement expression of it
2) A ref obj may be obtained when walking port connections (lowConn, highConn), when traversing an expression
that is a use of such ref obj, or when accessing the io decl of an instance or task or function.
3) The name of ref obj can be different at every instance level it is being declared. The vpiActual relationship always
returns the actual instantiated object if the ref obj is bound to an actual object at the time of the query.
4) The vpiParent relationship allows the traversal of a ref obj that is a subelement of a ref obj. In the following
example, is a ref obj whose parent is the ref obj . The vpiActual for the ref obj would return the var
r[0] r r[0]
bit , and the vpiActual of the ref obj would return the variable .
a[0] r a
module top;
logic [2:0] a;
m u1 (a);
endmodule
module m (ref [2:0] r);
initial
r[0] = 1'b0;
endmodule
985
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
5) The vpiGeneric property shall return if the ref obj is a reference to a generic interface and if the ref
TRUE FALSE
obj is a reference to an interface that is not a generic interface. The vpiGeneric property shall return vpiUndefined
for all other kinds of ref obj.
6) The vpiDefName property when applied to a ref obj that is an actual of an interface or modport shall return the
interface definition name or modport name.
7) The vpiTypespec relation returns for a ref obj that vpiActual is a not a net, variable, or part select.
NULL
Example: Passing an interface or modport through a port:
interface simple ();
logic req, gnt;
modport slave (input req, output gnt);
modport master (input gnt, output req);
endinterface
module top();
interface simple i;
child1 i1(i);
child2 i2(i.master);
endmodule
/***********************************
for the port of i1,
the vpiHighConn relationship returns a handle of type vpiRefObj. The
vpiActual relationship applied to the ref obj returns a handle of type
vpiInterface.
for the port of i2 ,
the vpiHighConn relationship returns a handle of type vpiRefObj. The
vpiActual relationship applied to the ref obj returns a handle of type
vpiModport.
****************************************/
module child1(interface simple s);
c1 c_1(s);
c1 c_2(s.master);
endmodule
/****************************
for the port of module child1,
the vpiLowConn relationship returns a handle of type vpiRefObj. The
vpiActual relationship applied to the ref obj returns a handle of type
vpiInterface.
for that refObj,
the vpiPort relationship returns the port of child1.
the vpiPortInst iteration returns handles to s, s.master.
the vpiActual relationship returns a handle to i.
for the port of instance c_1 :
vpiHighConn returns a handle of type vpiRefObj. The vpiActual relationship
applied to the ref obj handle returns a handle of type vpiInterface.
for the port of instance c_2 :
vpiHighConn returns a handle of type vpiRefObj. The vpiActual relationship
applied to the ref obj handle returns a handle of type vpiModport.
****************************************/
986
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
37.16 Nets
vpiPortInst vpiDriver
ports net drivers
vpiLoad
ports net loads
vpiLocalDriver
vpiLowConn vpiHighConn
net drivers
vpiLocalLoad
net loads
nets
prim term
net
cont assign
vpiParent
vpiIndex path term
expr vpiBit
tchk term
net bit
vpiSimNet
expr nets
vpiIndex
typespec
vpiParent
module
array net net
range vpiIndex
expr
-> access by index -> name -> size
vpi_handle_by_index() str: vpiName int: vpiSize
vpi_handle_by_multi_index() str: vpiFullName -> strength
-> array member -> net decl assign
int: vpiStrength0
bool: vpiArray (deprecated) bool: vpiNetDeclAssign int: vpiStrength1
bool: vpiArrayMember -> net type int: vpiChargeStrength
-> constant selection -> value
int: vpiNetType
bool: vpiConstantSelect int: vpiResolvedNetType vpi_get_value()
-> delay -> scalar vpi_put_value()
-> vector
vpi_get_delays() bool: vpiScalar
-> expanded -> scalared declaration bool: vpiVector
-> vectored declaration
bool: vpiExpanded bool: vpiExplicitScalared
-> implicitly declared -> sign bool: vpiExplicitVectored
->member
bool: vpiImplicitDecl bool: vpiSigned
bool: vpiStructUnionMember
vpiMember
net nets
vpiParent
struct net
enum net
enum net
vpiElement
struct net
integer net
packed array net
range time net
-> packed array member
vpiRightRange logic net
bool:
expr
vpiPackedArrayMember
packed array net
vpiLeftRange vpiIndex
expr
expr
987
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Details:
1) Any net declared as an array with one or more unpacked ranges is an array net. Any packed struct net or enum net
declared with one or more explicit packed ranges is a packed array net. The range iterator for a packed array net
returns only the explicit packed ranges for such a net. It shall not return the implicit range of packed struct net
elements themselves, nor shall it return the range (explicit or implicit) for the base type of enum net elements. For
example:
// a 34-bit-wide struct net (range iteration not allowed)
wire struct packed { logic [1:0]vec1; integer i1; } psnet;
// a packed array net (ranges [3:0] and [2:1] returned by range iteration)
wire struct packed { logic [1:0]vec1; integer i1; } [3:0][2:1] panet;
// an array net (ranges [5:4] and [6:8] returned by range iteration)
wire struct packed { logic [1:0]vec1; integer i1; } [3:0][2:1] anet
[5:4][6:8];
2) The Boolean property vpiArray is deprecated in this standard. The vpiArrayMember property shall be TRUE for
a net that is an element of an array net. It shall be otherwise. The vpiPackedArrayMember property shall
FALSE
be TRUE for a packed struct net, an enum net, or a packed array net that is an element of a packed array net.
3) For logic nets, net bits shall be available regardless of vector expansion.
4) Continuous assignments and primitive terminals shall be accessed regardless of hierarchical boundaries.
5) Continuous assignments and primitive terminals shall only be accessed from scalar nets or bit-selects.
6) For vpiPorts, if the reference handle is a net bit, then port bits shall be returned. If it is an entire net or array net,
then a handle to the entire port shall be returned.
7) For vpiPortInst, if the reference handle is a bit or scalar, then port bits or scalar ports shall be returned, unless the
highconn for the port is a complex expression where the bit index cannot be determined. If this is the case, then the
entire port shall be returned. If the reference handle is an entire net or array net, then the entire port shall be
returned.
8) For vpiPortInst, it is possible for the reference handle to be part of the highconn expression, but not connected to
any of the bits of the port. This may occur if there is a size mismatch. In this situation, the port shall not qualify as a
member for that iteration.
9) For implicit nets, vpiLineNo shall return 0, and vpiFile shall return the file name where the implicit net is first
referenced.
10) vpi_handle(vpiIndex, net_bit_handle) shall return the bit index for the net bit. vpi_iterate(vpiIndex,
net_bit_handle) shall return the set of indices for a multidimensional net array bit-select, starting with the index for
the net bit and working outward.
11) Only active forces and assign statements shall be returned for vpiLoad.
12) Only active forces shall be returned for vpiDriver.
13) vpiDriver shall also return ports that are driven by objects other than nets and net bits.
14) vpiLocalLoad and vpiLocalDriver return only the loads or drivers that are local, i.e., contained by the module
instance that contains the net, including any ports connected to the net (output and inout ports are loads, input and
inout ports are drivers).
15) For vpiLoad, vpiLocalLoad, vpiDriver, and vpiLocalDriver iterators, if the object is a vector net (an enum net,
integer net, time net, packed array net, or a logic net or struct net for which vpiVector is , then all loads or
TRUE)
drivers are returned exactly once as the loading or driving object. That is, if a part-select loads or drives only some
bits, the load or driver returned is the part-select. If a driver is repeated, it is only returned once. To trace exact
bit-by-bit connectivity, pass a vpiNetBit object to vpi_iterate.
16) An iteration on loads or drivers for a variable bit-select shall return the set of loads or drivers for whatever bit to
which the bit-select is referring to at the beginning of the iteration.
17) vpiSimNet shall return a unique net if an implementation collapses nets across hierarchy (refer to 23.3.3.7 for the
definition of simulated net and collapsed net).
18) The property vpiExpanded on an object of type vpiNetBit shall return the property’s value for the parent.
988
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
19) The loads and drivers returned from (vpiLoad, obj_handle) and vpi_iterate(vpiDriver, obj_handle) may not be
the same in different implementations, due to allowable net collapsing 23.3.3.7. The loads and drivers returned
from vpi_iterate(vpiLocalLoad, obj_handle) and vpi_iterate(vpiLocalDriver, obj_handle) shall be the same for
all implementations.
20) The Boolean property vpiConstantSelect shall return for a net or net bit if it has no parent (the vpiParent
TRUE
relation returns ) or if both of the following are true of the “select” part of the equivalent primary expression
NULL
(see A.8.4):
— Every index expression in the select is an elaboration time constant expression.
— Every element within the select denotes either a member of a struct net or a member of a packed or unpacked
array with static bounds.
Otherwise, vpiConstantSelect shall return FALSE.
NOTE—If vpiConstantSelect is TRUE, then if the handle refers to a valid underlying simulation object at the
beginning of simulation (or at any point in the simulation), it refers to the same object at all points in the simulation.
Moreover, if any index expression is in or out of bounds at the beginning of simulation, it is in or out of bounds at
all subsequent simulation times as well.
21) vpiSize for an array net shall return the number of nets in the array. For unpacked structures, the size returned
indicates the number of members in the structure. For an enum net, integer net, logic net, time net, packed struct
net, or packed array net, vpiSize shall return the size of the net in bits. For a net bit, vpiSize shall return 1.
22) vpi_iterate(vpiIndex, net_handle) shall return the set of indices for a net within an array net, starting with the
index for the net and working outward. If the net is not part of an array (the vpiArrayMember property is ),
FALSE
a shall be returned. The vpiIndex iterator shall work similarly for packed array net elements (packed struct
NULL
nets, enum nets, or packed array nets whose vpiPackedArrayMember property is TRUE). The indices returned
shall start with the index of the element and work outward until the vpiParent packed array net is reached (see
detail 28). The indices retrieved for packed array net elements shall be the same as those shown in the example for
detail 29 for each of the subelements returned by vpiElement. The indices will be retrieved in right-to-left order as
they appear in the text.
23) For an array net, vpi_iterate(vpiRange, handle) shall return the set of array range declarations beginning with the
leftmost unpacked range of the array declaration and iterating through the rightmost unpacked range. For a packed
array (logic net), the iteration shall return the set of ranges beginning with the leftmost packed range and iterating
through the rightmost packed range. For a logic net, the vpiLeftRange and vpiRightRange relations shall return
the bounds of the leftmost packed dimension.
24) vpiArrayNet is #defined the same as vpiNetArray for backward compatibility. A call to vpi_get_str(vpiType,
<array_net_handle>) may return either “vpiArrayNet” or “vpiNetArray”.
25) A logic net without a packed dimension defined is a scalar; and for that object, the property vpiScalar shall return
and the property vpiVector shall return . A logic net with one or more packed dimensions defined is
TRUE FALSE
a vector, and the property vpiVector shall return (vpiScalar shall return ). Packed struct nets and
TRUE FALSE
packed array nets are vectors, and the property vpiVector shall return (vpiScalar shall return ). A net
TRUE FALSE
bit is a scalar, and the property vpiScalar shall return (vpiVector shall return ). The properties
TRUE FALSE
vpiScalar and vpiVector when queried on a handle to an enum net shall return the value of the respective property
for an object for which the typespec is the same as the base typespec of the typespec of the enum net. For an integer
net or a time net, the property vpiVector shall return (vpiScalar shall return ). For an array net, the
TRUE FALSE
vpiScalar and vpiVector properties shall return the values of the respective properties for an array element. The
vpiScalar and vpiVector properties shall return for all other net objects.
FALSE
26) vpiLogicNet is #defined the same as vpiNet for backward compatibility. A call to vpi_get_str(vpiType, <log-
ic_net_handle>) may return either “vpiLogicNet” or “vpiNet”.
27) Neither an array net nor an unpacked struct net has a value property.
28) The vpiParent transition shall be allowed on all net objects. It shall return one of the following types of objects
listed, representing one of its prefix objects (field select prefix or indexing select prefix as described in 11.5.3), or
NULL, depending on whether certain criteria are met. For purposes of defining vpiParent, a prefix object is the
object obtained from successively removing the rightmost index or identifier from a compound or indexed/
multidimensional object name.
Consider the following vpiArrayNet objects:
wire logic [1:0][2:3] mda [4:6][6:8];
wire struct { int i1; logic[1:0][2:3]bvec[4:5]; } spa [9:11][12:13];
989
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.