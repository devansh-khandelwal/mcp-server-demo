IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The bin increments twice. The bin increments on the sample of 7 because 5=>7
allother allother
causes the matching of the pending sequence 4=>5=>6 to fail for bins and , and there were
sa sb[4=>5=>6]
no other previously pending sequences or incremented bins. The bin increments on the sample of
allother
8 since no other bin increments on the transition 11=>8 and no other sequences were previously pending.
The bin does not increment during the transitions 12=>2=>2 because the bin remains pending
allother sc
throughout.
Transitions that specify sequences of unbounded or undetermined varying length cannot be used with the
multiple bins construct (the notation). For example, the length of the transition , which uses
[] 3[=2]
nonconsecutive repetition, is unbounded and can vary during simulation. An attempt to specify multiple bins
with such sequences shall result in an error.
A transition bin is incremented every time the sequence of value transitions of its corresponding coverage
point matches a complete sequence, even when the sequences overlap. For example, given the definition
covergroup sg @(posedge clk);
coverpoint v
{
bins b2 = ( 2 [-> 3:5] ); // 3 to 5 nonconsecutive 2's
bins b3 = ( 3 [-> 3:5] ); // 3 to 5 nonconsecutive 3's
bins b5 = ( 5 [* 3] ); // 3 consecutive 5's
bins b6 = ( 1 => 3 [-> 4:6] => 1); // 1 followed by
// 4 to 6 goto nonconsecutive 3's
// followed immediately by a 1
bins b7 = ( 1 => 2 [= 3:6] => 5); // 1 followed by
// 3 to 6 non consecutive 2's
// followed sometime later by a 5
}
endgroup
and the sequence of sampled values for coverpoint variable
v
1st Sample
| 5th 10th 15th
| | | |
1 4 3 2 3 3 2 2 3 2 3 1 5 5 5 5 5 5
the preceding sequence causes transition bin to be incremented on the 8th sample (3 nonconsecutive
b2
twos), and transition bin to be incremented on the 6th sample (3 nonconsecutive threes). Likewise,
b3
transition bin is incremented on the 10th sample, and transition bin is incremented on the 9th and 11th
b2 b3
samples. Transition bin is incremented on the 15th, 16th, 17th, and 18th samples. Transition bin is
b5 b6
incremented on the 12th sample. Transition bin is incremented on the 13th sample.
b7
A transition bin is incremented at most once per sample. In the preceding example, on the 10th sample, the
transition bin is incremented only once (1 is added to the bin count).
b2
Transition bin specifications of length 0 shall be illegal. These are transition bin specifications containing a
trans_set production of a single covergroup_value_range, e.g., or , or a single
(0) ([0:1])
covergroup_value_range with a repeat_range evaluating to 1, e.g., or .
(0[*1]) ([0:1][*1])
19.5.3 Automatic bin creation for coverage points
If a coverage point does not define any bins, SystemVerilog automatically creates state bins. This provides
an easy-to-use mechanism for binning different values of a coverage point. Users can either let the tool
automatically create state bins for coverage points or explicitly define named bins for each coverage point.
566
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
When the automatic bin creation mechanism is used, SystemVerilog creates N bins to collect the sampled
values of a coverage point. The value N is determined as follows:
— For an coverage point, N is the cardinality of the enumeration.
enum
— For any other integral coverage point, N is the minimum of 2M and the value of the
auto_bin_max
option, where M is the number of bits needed to represent the coverage point.
If the number of automatic bins is smaller than the number of possible values (N < 2M), then the 2M values
are uniformly distributed in the N bins. If the number of values, 2M, is not divisible by N, then the last bin
will include the additional remaining items. For example, if M is 3 and N is 3, then the eight possible values
are distributed as follows: <0:1>, <2:3>, <4,5,6,7>.
Automatically created bins only consider 2-state values; sampled values containing or are excluded.
X Z
SystemVerilog implementations can impose a limit on the number of automatic bins. See 19.7 for the default
value of .
auto_bin_max
Each automatically created bin will have a name of the form of where is either a
auto[value] value
single coverage point value or the range of coverage point values included in the bin, in the form .
low:high
For enumerated types, is the named constant associated with a particular enumerated value.
value
19.5.4 Wildcard specification of coverage point bins
By default, a value or transition bin definition can specify 4-state values. When a bin definition includes an
or , it indicates that the bin count should only be incremented when the sampled value has an or in the
X Z X Z
same bit positions, i.e., the comparison is done using . A bin definition causes all , , or ? to
=== wildcard X Z
be treated as wildcards for or . For example:
0 1
wildcard bins g12_15 = { 4'b11?? };
The count of bin is incremented when the sampled variable is between 12 and 15:
g12_15
1100 1101 1110 1111
In the following example a separate bin is created for each of the four values shown above:
wildcard bins g12_15_array[] = { 4'b11?? };
Similarly, transition bins can define bins. For example:
wildcard
wildcard bins T0_3 = (2'b0x => 2'b1x);
The count of transition bin is incremented for the following transitions (as if by ( => ):
T0_3 0,1 2,3)
00 => 10 00 => 11 01 => 10 01 => 11
In the following example a separate bin is created for each of the four transition sequences previously
shown:
wildcard bins T0_3_array[] = (2'b0x => 2'b1x);
A wildcard bin definition only considers 2-state values; sampled values containing or are excluded.
X Z
19.5.5 Excluding coverage point values or transitions
A set of values or transitions associated with a coverage point can be explicitly excluded from coverage by
specifying them as . For example:
ignore_bins
567
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
covergroup cg23;
coverpoint a
{
ignore_bins ignore_vals = {7,8};
ignore_bins ignore_trans = (1=>3=>5);
}
endgroup
All values or transitions associated with ignored bins are excluded from coverage. For state bins, each
ignored value is removed from the set of values associated with any coverage bin. For transition bins, any
covered sequence is removed when it cannot be matched without also matching an ignored sequence. (For
example, the ignored sequence would remove the covered sequence .) The removal of
2=>3 1=>2=>3=>4
ignored values shall occur after the distribution of values to the specified bins. An ignored value has no
effect on a transition that includes the value. Ignored transition bins cannot specify a sequence of unbounded
or undetermined varying length.
The above may result in a bin that is associated with no values or sequences. Such empty bins are excluded
from coverage (see 19.11).
19.5.6 Specifying Illegal coverage point values or transitions
A set of values or transitions associated with a coverage point can be marked as illegal by specifying them as
. For example:
illegal_bins
covergroup cg3;
coverpoint b
{
illegal_bins bad_vals = {1,2,3};
illegal_bins bad_trans = (4=>5=>6);
}
endgroup
All values or transitions associated with illegal bins are excluded from coverage. For state bins, each illegal
value is removed from the set of values associated with any coverage bin. For transition bins, any covered
sequence is removed when it cannot be matched without also matching an illegal sequence. (For example,
the illegal sequence would remove the covered sequence .) The removal of illegal values
2=>3 1=>2=>3=>4
shall occur after the distribution of values to the specified bins. If an illegal value or transition occurs, a run-
time error is issued. Illegal bins take precedence over any other bins, that is, they will result in a run-time
error even if they are also included in another bin. Specifying an illegal value has no effect on a transition
that includes the value. Illegal transition bins cannot specify a sequence of unbounded or undetermined
varying length.
The above may result in a bin that is associated with no values or sequences. Such empty bins are excluded
from coverage (see 19.11).
19.5.7 Value resolution
A coverpoint expression, the expressions in a construct, and the coverpoint type, if present, are
bins
involved in comparison operations in order to determine into which bins a particular value falls. Let be the
e
coverpoint expression and be an expression in a coverpoint_range_list or
b bins
set_covergroup_expression. The following rules shall apply when evaluating and : For bins, x
e b wildcard
and z values in shall be treated as all possible 0 and 1 values prior to applying these rules.
b
a) If there is no coverpoint type, the effective type of shall be self-determined. In the presence of a
e
coverpoint type, the effective type of shall be the coverpoint type.
e
568
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
b) shall be statically cast to the effective type of . Enumeration values in expressions and shall
b e b e
first be treated as being in an expression context. This implies that the type of an enumeration value
is the base type of the enumeration and not the enumeration type itself. An implementation shall
issue a warning under the following conditions:
1) If the effective type of is unsigned and is signed with a negative value.
e b
2) If assigning to a variable of the effective type of would yield a value that is not equal to
b e b
under normal comparison rules for .
==
3) If yields a value with any x or z bits. This rule does not apply to bins because x
b wildcard
and z shall be treated as 0 and 1 as described above.
If a warning is issued for a bins element, the following rules shall apply:
— If an element of a covergroup_range_list or set_covergroup_expression is a singleton value ,
bins b
the element shall not participate in the bins values.
— If an element of a covergroup_range_list is a range and either or contains
bins [b1 : b2] b1 b2
any x or z bits or every value in the range would generate a warning, then the element shall not
participate in the bins values.
— If an element of a covergroup_range_list is a range and there exists at least one
bins [b1 : b2]
value in the range for which a warning would not be issued, then the range shall be treated as
containing the intersection of the values in the range and the values expressible by the effective type
of .
e
Examples:
bit [2:0] p1; // type expresses values in the range 0 to 7
bit signed [2:0] p2; // type expresses values in the range –4 to 3
covergroup g1 @(posedge clk);
coverpoint p1 {
bins b1 = { 1, [2:5], [6:10] };
bins b2 = { -1, [1:10], 15 };
}
coverpoint p2 {
bins b3 = {1, [2:5], [6:10] };
bins b4 = { -1, [1:10], 15 };
}
endgroup
— For , a warning is issued for the range . is treated as though it had the specification
b1 [6:10] b1
.
{1, [2:5], [6:7]}
— For , a warning is issued for the range and for the values and . is treated as
b2 [1:10] –1 15 b2
though it had the specification .
{ [1:7] }
— For , a warning is issued for the ranges and . is treated as though it had the
b3 [2:5] [6:10] b3
specification .
{ 1, [2:3] }
— For , a warning is issued for the range and for the value . is treated as though it had
b4 [1:10] 15 b2
the specification .
{ -1, [1:3] }
19.6 Defining cross coverage
A coverage group can specify cross coverage between two or more coverage points or variables. Cross
coverage is specified using the construct. When a variable is part of a cross coverage,
cross V
SystemVerilog implicitly creates a coverage point for the variable, as if it had been created by the statement
. Thus, a cross involves only coverage points. Expressions cannot be used directly in a
coverpoint V;
cross; a coverage point must be explicitly defined first.
569
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The syntax for specifying cross coverage is given in Syntax19-4.
cover_cross ::= // from A.2.11
[ cross_identifier ] list_of_cross_items [ expression ] cross_body
: cross iff( )
list_of_cross_items ::= cross_item cross_item { cross_item }
, ,
cross_item ::=
cover_point_identifier
| variable_identifier
cross_body ::=
{ cross_body_item }
{ ; }
|
;
cross_body_item ::=
function_declaraton
| bins_selection_or_option
;
bins_selection_or_option ::=
{ attribute_instance } coverage_option
| { attribute_instance } bins_selection
bins_selection ::= bins_keyword bin_identifier select_expression [ expression ]
= iff( )
select_expression24 ::=
select_condition
| select_condition
!
| select_expression select_expression
&&
| select_expression select_expression
||
| select_expression
( )
| select_expression with_covergroup_expression [ integer_covergroup_expression ]
with( ) matches
| cross_identifier
| cross_set_expression [ integer_covergroup_expression ]
matches
select_condition ::= bins_expression [ covergroup_range_list ]
binsof ( ) intersect{ }
bins_expression ::=
variable_identifier
| cover_point_identifier [ bin_identifier ]
.
covergroup_range_list ::= covergroup_value_range { covergroup_value_range }
,
covergroup_value_range ::=
covergroup_expression
| covergroup_expression covergroup_expression 25
[ : ]
with_covergroup_expression ::= covergroup_expression26
integer_covergroup_expression ::= covergroup_expression
cross_set_expression ::= covergroup_expression
24) The operator shall have higher precedence than the and operators.
matches && ||
25) It shall be legal to use the primary in an open_value_range or covergroup_value_range of the form expression
$ [ :
or expression .
$] [$: ]
26) The result of this expression shall be assignment compatible with an integral type.
Syntax19-4—Cross coverage syntax (excerpt from AnnexA)
570
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The label for a declaration provides an optional name. The label also creates a hierarchical scope for
cross
the defined within the cross.
bins
A name has limited visibility. An identifier can only refer to a in the following contexts:
cross cross
— In a hierarchical name where the prefix specifies the name of a covergroup variable. For example,
where is the name of a covergroup variable and is the name
cov1.crs.option.weight cov1 crs
of a declared within the covergroup.
cross
— Following where the left operand of the scope resolution operator refers to a covergroup. For
::
example, .
covtype :: crs :: type_option.weight
Identifiers and function calls within the cross are restricted in the same way as identifiers and function calls
within coverpoints (see 19.5). Functions declared within the cross shall not be visible outside of that scope.
The expression within the optional provides a conditional guard for the cross coverage. If at any sample
iff
point, the condition evaluates to false, the cross coverage is ignored. The expression within the optional
iff
construct at the end of a cross bin definition provides a per-bin guard condition. If the expression is false, the
cross bin is ignored.
Cross coverage of a set of N coverage points is defined as the coverage of all combinations of all bins
associated with the N coverage points, that is, the Cartesian product of the N sets of coverage point bins. For
example:
bit [3:0] a, b;
covergroup cov @(posedge clk);
aXb : cross a, b;
endgroup
The coverage group in the preceding example specifies the cross coverage of two 4-bit variables, and
cov a
. SystemVerilog implicitly creates a coverage point for each variable. Each coverage point has 16 bins,
b
namely . The cross of and (labeled ), therefore, has 256 cross products, and
auto[0]...auto[15] a b aXb
each cross product is a bin of .
aXb
Cross coverage between expressions previously defined as coverage points is also allowed. For example:
bit [3:0] a, b, c;
covergroup cov2 @(posedge clk);
BC: coverpoint b+c;
aXb : cross a, BC;
endgroup
The coverage group has the same number of cross products as the previous example, but in this case,
cov2
one of the coverage points is the expression , which is labeled .
b+c BC
bit [31:0] a_var;
bit [3:0] b_var;
covergroup cov3 @(posedge clk);
A: coverpoint a_var { bins yy[] = { [0:9] }; }
CC: cross b_var, A;
endgroup
The coverage group crosses variable with coverage point (labeled ). Variable
cov3 b_var A CC b_var
automatically creates 16 bins ( ). Coverage point explicitly creates 10 bins
auto[0]...auto[15] A
571
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
( ). The cross of two coverage points creates 16  10 = 160 cross product bins, namely the
yy[0]...yy[9]
following pairs:
<auto[0], yy[0]>
<auto[0], yy[1]>
...
<auto[0], yy[9]>
<auto[1], yy[0]>
...
<auto[15], yy[9]>
No cross coverage bins shall be created for coverpoint bins that are specified as , ignored, or illegal
default
bins.
Cross coverage is allowed only between coverage points defined within the same coverage group. Coverage
points defined in a coverage group other than the one enclosing the cross cannot participate in a cross.
Attempts to cross items from different coverage groups shall result in a compiler error.
19.6.1 Defining cross coverage bins
In addition to specifying the coverage points that are crossed, SystemVerilog includes a powerful set of
operators that allow defining cross coverage bins. Cross coverage bins can be specified in order to group
together a set of cross products. A cross coverage bin associates a name and a count with a set of cross
products. The count of the bin is incremented every time any of the cross products match, i.e., every
coverage point in the cross matches its corresponding bin in the cross product.
User-defined bins for cross coverage are defined using bin select expressions. The syntax for defining these
bin select expressions is given in Syntax19-4.
User-defined cross bins and automatically generated bins can coexist in the same cross. Automatically
generated bins are retained for those cross products that do not intersect cross products specified by any
user-defined cross bin.
Consider the following example code:
int i,j;
covergroup ct;
coverpoint i { bins i[] = { [0:1] }; }
coverpoint j { bins j[] = { [0:1] }; }
x1: cross i,j;
x2: cross i,j {
bins i_zero = binsof(i) intersect { 0 };
}
endgroup
Cross has the following bins:
x1
<i[0],j[0]>
<i[1],j[0]>
<i[0],j[1]>
<i[1],j[1]>
Cross has the following bins:
x2
i_zero // user-specified bin for <i[0],j[0]> and <i[0],j[1]>
<i[1],j[0]> // an automatically generated bin that is retained
<i[1],j[1]> // an automatically generated bin that is retained
572
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The automatically generated cross bins (which are the same as the set given above for cross ) are retained
x1
for those bins that do not overlap the explicitly declared cross bins. In this particular case, since the
explicitly declared bin covers all cases for which , the cross will have the explicitly declared bin
i == 0
( ) plus automatically generated bins for cases where .
i_zero i != 0
The construct yields the bins of its expression, which can be either a coverage point (explicitly
binsof
defined or implicitly defined for a single variable) or a coverage point bin. The resulting bins can be further
selected by including (or excluding) only the bins whose associated values intersect a desired set of values.
The desired set of values can be specified using a comma-separated list of covergroup_value_range as
shown in Syntax19-4. For example, the select expression
binsof( x ) intersect { y }
denotes the bins of coverage point whose values intersect the range given by . Its negated form
x y
! binsof( x ) intersect { y }
denotes the bins of coverage point whose values do not intersect the range given by .
x y
The covergroup_value_range syntax can specify a single value, a range of values, or an open range, which
denotes the following:
[ $ : value ] => The set of values less than or equal to value
[ value : $ ] => The set of values greater or equal to value
The bins selected can be combined with other selected bins using the logical operators and .
&& ||
19.6.1.1 Example of user-defined cross coverage and select expressions
bit [7:0] v_a, v_b;
covergroup cg @(posedge clk);
a: coverpoint v_a
{
bins a1 = { [0:63] };
bins a2 = { [64:127] };
bins a3 = { [128:191] };
bins a4 = { [192:255] };
}
b: coverpoint v_b
{
bins b1 = {0};
bins b2 = { [1:84] };
bins b3 = { [85:169] };
bins b4 = { [170:255] };
}
c : cross a, b
{
bins c1 = ! binsof(a) intersect {[100:200]};// 4 cross products
bins c2 = binsof(a.a2) || binsof(b.b2);// 7 cross products
bins c3 = binsof(a.a1) && binsof(b.b4);// 1 cross product
}
endgroup
573
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The preceding example defines a coverage group named that samples its coverage points on the positive
cg
edge of signal (not shown). The coverage group includes two coverage points, one for each of the two
clk
8-bit variables, and . Coverage point associated with variable defines four equal-sized bins
v_a v_b a v_a
for each possible value of variable . Likewise, coverage point associated with variable defines
v_a b v_b
four bins for each possible value of variable . Cross definition specifies the cross coverage of the two
v_b c
coverage points and . If the cross coverage of coverage points and were defined without any
a b a b
additional cross bins (select expressions), then cross coverage of and would include 16 cross products
a b
corresponding to all combinations of bins through with bins through , that is, cross products
a1 a4 b1 b4
.
<a1,b1>, <a1,b2>, <a1,b3>, <a1,b4>...<a4,b1>, <a4,b2>, <a4,b3>, <a4,b4>
The first user-defined cross bin, , specifies that should include only cross products of coverage point
c1 c1 a
that do not intersect the value range of 100 to 200. This select expression excludes bins , , and .
a2 a3 a4
Thus, will cover only four cross products of and .
c1 <a1,b1>, <a1,b2>, <a1,b3>, <a1,b4>
The second user-defined cross bin, , specifies that bin should include only cross products whose values
c2 c2
are covered by bin of coverage point or cross products whose values are covered by bin of coverage
a2 a b2
point . This select expression includes the following seven cross products:
b <a2,b1>, <a2,b2>,
and .
<a2,b3>, <a2,b4>, <a1,b2>, <a3,b2>, <a4,b2>
The final user-defined cross bin, , specifies that should include only cross products whose values are
c3 c3
covered by bin of coverage point and cross products whose values are covered by bin of coverage
a1 a b4
point . This select expression includes only one cross product: .
b <a1,b4>
Additionally, the cross retains those automatically generated bins that represent cross products not
intersecting any of the user-defined bins. There are 6 of these: , , , ,
<a3,b1> <a4,b1> <a3,b3> <a4,b3>
, and .
<a3,b4> <a4,b4>
When select expressions are specified on transition bins, the operator uses the last value of the
binsof
transition.
19.6.1.2 Cross bin with covergroup expressions
The clause in a select_expression specifies that only those bin tuples in the subordinate
with
select_expression for which sufficiently many value tuples satisfy the given with_covergroup_expression
(i.e., for which the expression evaluates to true, as described in 12.4) are selected.
In the with_covergroup_expression, occurrences of cross_items (i.e., those cover_point_identifiers or
variable_identifiers occurring in the list_of_cross_items for the cross) represent corresponding values in the
value tuples of the candidate bin tuples.
When a cross_identifier is used as a select_expression, it selects all possible bin tuples. When used with a
clause, the cross bin can be completely described using a with_covergroup_expression. Only the
with
cross_identifier of the enclosing cross may be used; other cross_identifiers shall be disallowed.
The optional clause specifies the selection policy. The integer_covergroup_expression shall
matches
evaluate to a positive integer or , representing the minimum number of satisfying value tuples required to
$
select the candidate bin tuple. The symbol specifies that all value tuples must satisfy the expression to
$
select the candidate bin tuple. When the clause is omitted, the selection policy defaults to one.
matches
Consider the following example:
logic [0:7] a, b;
parameter [0:7] mask;
...
covergroup cg;
coverpoint a
574
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLr igGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reicgehmtsb erer s0e3,r2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
{
bins low[] = {[0:127]};
bins high = {[128:255]};
}
coverpoint b
{
bins two[] = b with (item % 2 == 0)
bins three[] = b with (item % 3 == 0)
}
X: cross a,b
{
bins apple = X with (a+b < 257) matches 127;
bins cherry = ( binsof(b) intersect {[0:50]}
&& binsof(a.low) intersect {[0:50]}) with (a==b) );
bins plum = binsof(b.two) with (b > 12)
|| binsof(a.low) with (a & b & mask);
}
endgroup
The bin structure for coverpoint a is straightforward—bin array contains 128 single-element bins for
low
each value between 0 and 127, and bin contains all values from 128 to 255. The bins of coverpoint
high b
are specified using the clause; bin array contains a bin for each even value, and contains a
with two three
bin for each value divisible by 3.
The cross crosses coverpoints and . Three cross bins are defined, , , and .
X a b apple cherry plum apple
consists of all bin tuples for which for at least 127 value tuples. In this example, would
a+b < 257 apple
consist of three coverpoint bin tuples: < >, < >, and < >.
high, two[0] high, two[2] high, three[0]
The cross bin demonstrates using the clause on a complex select_expression. First, those bin
cherry with
tuples consisting of a bin from containing a value between 0 and 50 are selected; then, the operator
b &&
selects from those bin tuples the bin tuples with a bin from containing a value between 0 and 50. The
a.low
clause then selects from those only the bin tuples containing at least one value tuple where .
with a==b
The cross bin demonstrates a select_expression composed of covergroup expressions. The first
plum with
covergroup expression selects those bin tuples containing bins in the bin array whose values
with b.two
are greater than 12. The operator then adds the bin tuples selected by the second covergroup
|| with
expression—namely those containing a bin from and for which the bitwise-AND of the -value,
a.low a
-value and a is non-zero for some values and in the bins of the bin tuple.
b mask a b
As with array manipulation methods involving (see 7.12), if the expression has side effects, the results
with
are unpredictable.
The clause behaves as if the expression were evaluated for every value tuple of every bin tuple
with
selected by the subordinate select_expression at the time the covergroup instance is constructed. However,
implementations are not required to schedule the evaluation events when calculating the bin tuples in the
cross bin; all, some, or none of the events may be scheduled. The intent of these rules is to allow the use of
non-simulation analysis techniques to calculate the cross bin (for example, formal symbolic analysis), or for
caching of previously calculated results.
19.6.1.3 Cross bin automatically defined types
A cross defines a coverage space composed of tuples of values. To aid in describing the structure of that
space, SystemVerilog provides automatically defined types for these tuples and queues of tuples in each
cross. The types are named and . The scope of the type names is the
CrossValType CrossQueueType
cross itself and the types are not accessible outside of this scope.
575
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The definition of is a SystemVerilog struct consisting of one member for each coverpoint in
CrossValType
the cross. The name and type of each field are the name and type of the corresponding coverpoint. If range
bounds for the coverpoint type are not evident (e.g., the coverpoint expression is a concatenation and no
other type is specified), the bounds are assumed to be . The
[$bits(coverpoint_expression)-1:0]
definition of is an unbounded queue of elements.
CrossQueueType CrossValType
The cross types shall be considered as implicit typedefs in the body of the cross, even though the syntax does
not allow typedefs to appear there explicitly. Consider the following example:
covergroup cg (ref logic [0:3] x, ref logic [0:7] y, ref logic [0:2] a);
xy: coverpoint {x,y};
coverpoint y;
XYA: cross xy, a
{
// the cross types are as if defined here as follows:
// typedef struct {logic [11:0] xy;logic [0:2] a;} CrossValType;
// typedef CrossValType CrossQueueType[$];
};
endgroup
Subclause 19.6.1.4 shows how and can be used to compute explicit
CrossValType CrossQueueType
enumerations of cross bins.
19.6.1.4 Cross bin set expression
The cross_set_expression syntax allows specifying an expression yielding a queue of elements that define
the cross bin, similarly to the set_covergroup_expression for coverpoint bins. However, for cross bins the
type of the queue shall be the cross’s , whose elements are of type (see
CrossQueueType CrossValType
19.6.1.3).
The selection of bin tuples for the cross bin by the elements of the cross_set_expression is subject to the
same policy specification as the cross bin covergroup expression (see 19.6.1.2). The optional
with
expression specifies the number of value tuples in a bin tuple that must be present in the
matches
cross_set_expression for that bin tuple to be selected. The default policy is one, denoting the policy where a
single value tuple from a bin tuple must exist in the cross_set_expression to select the bin tuple.
For example:
int a;
logic [7:0] b;
covergroup cg;
coverpoint a { bins x[] = {[0:10]}; }
coverpoint b { bins y[] = {[0:20]}; }
aXb : cross a, b
{
bins one = '{ '{1,2}, '{3,4}, '{5,6} };
}
endgroup
The cross bin definition uses an array literal to define the bin tuples in cross bin as <
one a.x[1],
>, < >, and < >. Here, the cross bin provides the context
b.y[2] a.x[3], b.y[4] a.x[5], b.y[6]
required to determine the type of the literal (in this case, the cross's ). In general, literal
CrossQueueType
arrays are not required; any expression may be used as long as it evaluates to the cross’s .
CrossQueueType
A cast is required if the type is assignment-incompatible with the cross type.
576
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Following is a more involved example:
module mod_m;
logic [31:0] a, b;
covergroup cg(int cg_lim);
coverpoint a;
coverpoint b;
aXb : cross a, b
{
function CrossQueueType myFunc1(int f_lim);
for (int i = 0; i < f_lim; ++i)
myFunc1.push_back('{i,i});
endfunction
bins one = myFunc1(cg_lim);
bins two = myFunc2(cg_lim);
function CrossQueueType myFunc2(logic [31:0] f_lim);
for (logic [31:0] i = 0; i < f_lim; ++i)
myFunc2.push_back('{2*i,2*i});
endfunction
}
endgroup
cg cg_inst = new(3);
endmodule
Here functions are used to create the queues that define the cross bins. Note that the coverpoints and are
a b
32 bits wide; iterating over all value tuples using a expression would be computationally expensive.
with
By using functions, the user is able to restrict the bin computation to a reasonable subset of value tuples; the
entire cross space need not be considered.
As shown, the bins for are as follows:
cg_inst
cg_inst.aXb.one = <0,0>, <1,1>, <2,2>
cg_inst.aXb.two = <0,0>, <2,2>, <4,4>
19.6.2 Excluding cross products
A group of bins can be excluded from coverage by specifying a select expression using . For
ignore_bins
example:
covergroup yy;
cross a, b
{
ignore_bins ignore = binsof(a) intersect { 5, [1:3] };
}
endgroup
All cross products that satisfy the select expression are excluded from coverage. Ignored cross products are
excluded even if they are included in other cross coverage bins of the enclosing cross.
577
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
19.6.3 Specifying illegal cross products
A group of bins can be marked as illegal by specifying a select expression using . For
illegal_bins
example:
covergroup zz(int bad);
cross x, y
{
illegal_bins illegal = binsof(y) intersect {bad};
}
endgroup
All cross products that satisfy the select expression are excluded from coverage, and a run-time error is
issued. Illegal cross products take precedence over any other cross products, that is, they will result in a run-
time error even if they are also explicitly ignored (using an ) or included in another cross bin.
ignore_bins
19.7 Specifying coverage options
Options control the behavior of the , , and . There are two types of options:
covergroup coverpoint cross
those that are specific to an instance of a covergroup and those that specify an option for the covergroup type
as a whole.
Specifying a value for the same option more than once within the same definition shall be an
covergroup
error.
Table19-1 lists instance-specific covergroup options and their description. Each instance of a covergroup
can initialize an instance-specific option to a different value. The initialized option value affects only that
instance.
Table19-1—Instance-specific coverage options
Option name Default Description
name=string unique Specifies a name for the covergroup instance. If unspecified, a
name unique name for each instance is automatically generated by the
tool.
weight= number 1 If set at the syntactic level, it specifies the weight
covergroup
of this covergroup instance for computing the overall instance
coverage of the simulation. If set at the (or
coverpoint
) syntactic level, it specifies the weight of a
cross coverpoint
(or ) for computing the instance coverage of the enclosing
cross
. The specified weight shall be a non-negative
covergroup
integral value.
goal=number 100 Specifies the target goal for a covergroup instance or for a
coverpoint or a cross of an instance.
comment=string “ ” A comment that appears with a covergroup instance or with a
coverpoint or cross of the covergroup instance. The comment is
saved in the coverage database and included in the coverage
report.
at_least=number 1 Minimum number of hits for each bin. A bin with a hit count that
is less than number is not considered covered.
auto_bin_max=number 64 Maximum number of automatically created bins when no bins are
explicitly defined for a coverpoint.
578
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table19-1—Instance-specific coverage options (continued)
Option name Default Description
cross_num_print_missing= 0 Number of missing (not covered) cross product bins that shall be
number saved to the coverage database and printed in the coverage report.
detect_overlap=boolean 0 When true, a warning is issued if there is an overlap between the
range list (or transition list) of two bins of a coverpoint.
per_instance=boolean 0 Each instance contributes to the overall coverage information for
the type. When true, coverage information for this
covergroup
covergroup instance shall be saved in the coverage database and
included in the coverage report. When false, implementations are
not required to save instance-specific information.
get_inst_coverage=boolean 0 Only applies when the type option is set.
merge_instances
Enables the tracking of per instance coverage with the
built-in method. When false, the
get_inst_coverage
value returned by shall equal the
get_inst_coverage
value returned by .
get_coverage
The instance-specific options mentioned in Table19-1 can be set in the definition. The syntax
covergroup
for setting these options in the definition is as follows:
covergroup
option.member_name = expression ;
The identifier is a built-in member of every covergroup, coverpoint and cross (see 19.10 for a
option
description).
For example:
covergroup g1 (int w, string instComment) @(posedge clk) ;
// track coverage information for each instance of g1 in addition
// to the cumulative coverage information for covergroup type g1
option.per_instance = 1;
// comment for each instance of this covergroup
option.comment = instComment;
a : coverpoint a_var
{
// Create 128 automatic bins for coverpoint “a” of each instance of g1
option.auto_bin_max = 128;
}
b : coverpoint b_var
{
// This coverpoint contributes w times as much to the coverage of an
// instance of g1 as coverpoints "a" and "c1"
option.weight = w;
}
c1 : cross a_var, b_var ;
endgroup
Option assignment statements in the definition are evaluated at the time that the covergroup is
covergroup
instantiated. The and options can only be set in the
per_instance get_inst_coverage covergroup
definition. The and options can only be set in the or
auto_bin_max detect_overlap covergroup
definition. Other instance-specific options can be assigned procedurally after a covergroup has
coverpoint
been instantiated.
579
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For example:
covergroup gc (int maxA, int maxB) @(posedge clk) ;
a : coverpoint a_var;
b : coverpoint b_var;
endgroup
...
gc g1 = new (10,20);
g1.option.comment = "Here is a comment set for the instance g1";
g1.a.option.weight = 3; // Set weight for coverpoint "a" of instance g1
Table19-2 summarizes the syntactical level ( , , or ) at which instance
covergroup coverpoint cross
options can be specified. All instance options can be specified at the covergroup level. Except for the
, , , and options, all other options set at the covergroup syntactic
weight goal comment per_instance
level act as a default value for the corresponding option of all coverpoints and crosses in the covergroup.
Individual coverpoints or crosses can overwrite these default values. When set at the covergroup level, the
, , , and options do not act as default values to the lower syntactic
weight goal comment per_instance
levels.
Table19-2—Coverage options per syntactic level
Allowed in syntactic level
Option name
covergroup coverpoint cross
name Yes No No
weight Yes Yes Yes
goal Yes Yes Yes
comment Yes Yes Yes
at_least Yes (default for coverpoints & crosses) Yes Yes
auto_bin_max Yes (default for coverpoints) Yes No
cross_num_print_missing Yes (default for crosses) No Yes
detect_overlap Yes (default for coverpoints) Yes No
per_instance Yes No No
get_inst_coverage Yes No No
19.7.1 Covergroup type options
Table19-3 lists options that describe particular features (or properties) of the type as a whole.
covergroup
They are analogous to static data members of classes.
The type options mentioned in Table19-3 can be set in the definition. The
covergroup covergroup
syntax for setting these options in the definition is as follows:
covergroup
type_option.member_name = constant_expression ;
The identifier is a built-in static member of every covergroup, coverpoint, and cross (see
type_option
19.10 for a description).
580
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table19-3—Coverage group type (static) options
Option name Default Description
weight=constant_number 1 If set at the syntactic level, it specifies the weight of
covergroup
this covergroup for computing the overall cumulative (or type)
coverage of the saved database. If set at the (or
coverpoint
) syntactic level, it specifies the weight of a (or
cross coverpoint
) for computing the cumulative (or type) coverage of the
cross
enclosing . The specified weight shall be a
covergroup
non-negative integral value.
goal=constant_number 100 Specifies the target goal for a type or for a coverpoint
covergroup
or cross of a type.
covergroup
comment=string_literal “ ” A comment that appears with the type or with a
covergroup
coverpoint or cross of the covergroup type. The comment is saved in
the coverage database and included in the coverage report.
strobe=boolean 0 When true, all samples happen at the end of the time slot, like the
system task.
$strobe
merge_instances=boolean 0 When true, cumulative (or type) coverage is computed by merging
instances together as the union of coverage of all instances. When
false, type coverage is computed as the weighted average of
instances.
distribute_first=boolean 0 When true, instructs the tool to perform value distribution to the bins
prior to application of the with_covergroup_expression.
Different instances of a covergroup cannot assign different values to type options. This is syntactically
disallowed because these options can only be initialized via constant expressions (see 11.2.1). For example:
covergroup g1 (int w, string instComment) @(posedge clk) ;
// track coverage information for each instance of g1 in addition
// to the cumulative coverage information for covergroup type g1
option.per_instance = 1;
type_option.comment = "Coverage model for features x and y";
type_option.strobe = 1; // sample at the end of the time slot
// compute type coverage as the merge of all instances
type_option.merge_instances = 1;
// comment for each instance of this covergroup
option.comment = instComment;
a : coverpoint a_var
{
// Use weight 2 to compute the coverage of each instance
option.weight = 2;
// Use weight 3 to compute the cumulative (type) coverage for g1
type_option.weight = 3;
// NOTE: type_option.weight = w would cause syntax error.
}
b : coverpoint b_var
{
581
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
// Use weight w to compute the coverage of each instance
option.weight = w;
// Use weight 5 to compute the cumulative (type) coverage of g1
type_option.weight = 5;
}
endgroup
In the preceding example, the coverage for each instance of is computed as follows:
g1
(((instance coverage of )  2) + ((instance coverage of )  )) / ( 2 + )
a b w w
On the other hand, the coverage for type is computed as follows:
covergroup g1
( ((merge of coverage of from all instances)  3)
a
+ ((merge of coverage of from all instances)  5) ) / (3 + 5)
b
The strobe type option can only be set in the definition. Other type options can be assigned
covergroup
procedurally at any time during simulation.
For example:
covergroup gc @(posedge clk) ;
a : coverpoint a_var;
b : coverpoint b_var;
endgroup
...
// Set the comment for all covergroups of type "gc"
gc::type_option.comment = "Here is a comment for covergroup g1";
// Set the weight for coverpoint "a" of all covergroups of type gc
gc::a::type_option.weight = 3;
gc g1 = new;
Table19-4 summarizes the syntactical level ( , , or ) in which type options
covergroup coverpoint cross
can be specified. When set at the covergroup level, the type options do not act as defaults for lower syntactic
levels.
Table19-4—Coverage type options
Allowed syntactic level
Option name
covergroup coverpoint cross
weight Yes Yes Yes
goal Yes Yes Yes
comment Yes Yes Yes
strobe Yes No No
merge_instances Yes No No
distribute_first Yes No No
19.8 Predefined coverage methods
The coverage methods in Table19-5 are provided for the covergroup. These methods can be invoked
procedurally at any time.
582
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table19-5—Predefined coverage methods
Can be called on
Method
Description
(function)
covergroup coverpoint cross
void sample() Yes No No Triggers sampling of the
covergroup
real get_coverage() Yes Yes Yes Calculates type coverage number
real get_coverage(ref int, ref int) (0...100)
real get_inst_coverage() Yes Yes Yes Calculates the coverage number
real get_inst_coverage(ref int, ref int) (0...100)
void set_inst_name(string) Yes No No Sets the instance name to the
given string
void start() Yes Yes Yes Starts collecting coverage
information
void stop() Yes Yes Yes Stops collecting coverage
information
The method returns the cumulative (or type) coverage, which considers the contribution
get_coverage()
of all instances of a particular coverage item; and it is a static method that is available on both types (via the
operator) and instances (using the operator). In contrast, the method returns
:: . get_inst_coverage()
the coverage of the specific instance on which it is invoked; thus, it can only be invoked via the operator.
.
The and methods both accept an optional set of arguments, a
get_coverage() get_inst_coverage()
pair of values passed by reference. When the optional arguments are specified, the
int get_coverage()
and methods assign to the first argument the number of covered bins and to the
get_inst_coverage()
second argument the number of coverage bins defined for the given coverage item. When
is called on a or , these two values correspond to the
get_inst_coverage() coverpoint cross
numerator and the denominator used for calculating the particular coverage number (i.e., the return value
before scaling by 100); in other cases, these two values do not necessarily correspond to the numerator and
denominator. When is called on a , these values are aggregated
get_inst_coverage() covergroup
numbers of bins from all constituent coverpoints and crosses of the same instance. When
get_coverage()
is called on a or , these values are aggregated numbers of bins from the same
coverpoint cross
or in all instances. When is called on a , these values
coverpoint cross get_coverage() covergroup
are aggregated numbers of bins from all coverpoints and crosses in all instances.
For example:
covergroup cg (int xb, yb, ref int x, y) ;
coverpoint x {bins xbins[] = { [0:xb] }; }
coverpoint y {bins ybins[] = { [0:yb] }; }
endgroup
cg cv1 = new (1,2,a,b); // cv1.x has 2 bins, cv1.y has 3 bins
cg cv2 = new (3,6,c,d); // cv2.x has 4 bins, cv2.y has 7 bins
initial begin
cv1.x.get_inst_coverage(covered,total); // total = 2
cv1.get_inst_coverage(covered,total); // total = 5
cg::x::get_coverage(covered,total); // total = 6
cg::get_coverage(covered,total); // total = 16
end
583
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
19.8.1 Overriding the built-in sample method
Overriding the predefined method with a triggering function that accepts arguments facilitates
sample()
sampling coverage data from contexts other than the scope enclosing the covergroup declaration. For
example, an overridden sample method can be called with different arguments to pass directly to a
covergroup the data to be sampled from within an automatic task or function, or from within a particular
instance of a process, or from within a sequence or property of a concurrent assertion. Since concurrent
assertions have special sampling semantics (values are sampled in the Preponed region), passing their values
as arguments to an overridden sample method facilitates managing various aspects of assertion coverage,
such as sampling of multiple covergroups by one property, sampling of multiple properties by the same
covergroup, or sampling different branches of a sequence or property (including local variables) by any
arbitrary covergroup.
For example:
covergroup p_cg with function sample(bit a, int x);
coverpoint x;
cross x, a;
endgroup : p_cg
p_cg cg1 = new;
property p1;
int x;
@(posedge clk)(a, x = b) ##1 (c, cg1.sample(a, x));
endproperty : p1
c1: cover property (p1);
function automatic void F(int j);
bit d;
...
cg1.sample( d, j );
endfunction
The preceding example declares covergroup whose sample method is overridden to accept two
p_cg
arguments: and . The sample method of an instance of this covergroup ( ) is then called directly from
a x cg1
within property and from the automatic function .
p1 F()
The formal arguments of an overridden sample method shall be searched before the enclosing scope; each
such argument may only designate a coverpoint or conditional guard expression. It shall be an error to use a
sample formal argument in any context other than a coverpoint or conditional guard expression. Formal
sample arguments shall not designate an output direction. The formal arguments of an overridden sample
method belong to the same lexical scope as the formal arguments to the covergroup (consumed by the
covergroup operator). Hence, it shall be an error for the same argument name to be specified in both
new
argument lists.
For example:
covergroup C1 (int v) with function sample (int v, bit b); // error (v)
coverpoint v;
option.per_instance = b;// error: b may only designate a coverpoint
option.weight = v; // error: v is ambiguous
endgroup
584
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
19.9 Predefined coverage system tasks and system functions
SystemVerilog provides the following system tasks and system functions to help manage coverage data
collection.
— $set_coverage_db_name (filename) sets the file name of the coverage database into which
coverage information is saved at the end of a simulation run.
— $load_coverage_db (filename) loads from the given file name the cumulative coverage
information for all coverage group types.
— $get_coverage ( ) returns as a real number in the range of 0 to 100 the overall coverage of all
coverage group types. This number is computed as previously described.
19.10 Organization of option and type_option members
The and members of a covergroup, coverpoint, and cross are implicitly declared
option type_option
structures with the following composition:
struct // covergroup option declaration
{
string name ;
int weight ;
int goal ;
string comment ;
int at_least ;
int auto_bin_max ;
int cross_num_print_missing ;
bit detect_overlap ;
bit per_instance ;
bit get_inst_coverage ;
} option;
struct // coverpoint option declaration
{
int weight ;
int goal ;
string comment ;
int at_least ;
int auto_bin_max ;
bit detect_overlap ;
} option;
struct // cross option declaration
{
int weight ;
int goal ;
string comment ;
int at_least ;
int cross_num_print_missing ;
} option;
struct // covergroup type_option declaration
{
int weight ;
int goal ;
string comment ;
bit strobe ;
bit merge_instances ;
585
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
bit distribute_first ;
} type_option;
struct // coverpoint and cross type_option declaration
{
int weight ;
int goal ;
string comment ;
} type_option;
19.11 Coverage computation
This subclause describes how SystemVerilog computes functional coverage numbers. The cumulative (or
type) coverage considers the contribution of all instances of a particular coverage item, and it is the value
returned by the method. Thus, when applied to a covergroup, the
get_coverage() get_coverage()
method returns the contribution of all instances of that particular covergroup. In contrast, the
method returns the coverage of the specific coverage instance on which it is
get_inst_coverage()
invoked. Because is a static method, it is available for both types (via the operator)
get_coverage() ::
and instances (using the operator). There are two different ways in which type coverage can be computed,
.
selected with . See 19.11.3.
type_option.merge_instances
The coverage of a coverage group, C , is the weighted average of the coverage of all items defined in the
g
coverage group, and it is computed according to the following equation:
W C
i i
C = ---i-------------------------
g
W
i
i
where
i  set of coverage items (coverage points and crosses) defined in the coverage group
W is the weight associated with item i
i
C is the coverage of item i
i
The coverage of each item, C, is a measure of how much the item has been covered, and its computation
i
depends on the type of coverage item: or . Each of these is described in 19.11.1 and
coverpoint cross
19.11.2, respectively.
The rules for computation of the coverage C of an item may indicate that the item is to be excluded from the
i
coverage computation. In this case, the contribution of the item is excluded from both the numerator and the
denominator.
There are several circumstances that can result in the denominator of the covergroup calculation equation
being zero, as follows:
— All items in a covergroup are excluded from coverage due to the rules for computation of C
i
— All weights W are zero
i
— A covergroup contains no coverpoints or crosses
Any zero denominator in the coverage calculation shall result in the following:
a) The covergroup does not contribute to the overall coverage score.
b) If the covergroup’s weight is nonzero, a value of 0.0 is returned by and
get_coverage
.
get_inst_coverage
586
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
c) If the covergroup’s weight is zero, a value of 100.0 is returned by and
get_coverage
.
get_inst_coverage
d) If or is called with two arguments, zero is assigned to both
get_coverage get_inst_coverage
arguments—the numerator and denominator.
Consistent with the above behavior, shall return a value of 100.0 if called on a design that
$get_coverage
has no covergroup instances, or if called on a design in which all covergroups have a weight of 0.
19.11.1 Coverpoint coverage computation
Coverage of a coverpoint item is computed differently depending on whether the bins of the coverage point
are explicitly defined by the user (see 19.5.1, 19.5.2) or automatically created by the tool (see 19.5.3). For
user-defined bins, the coverage of a coverpoint is computed as follows:
bins
C = -------------c--o--v--e--r--e-d---
i bins
where
|bins| is the cardinality of the set of bins defined
|bins | is the cardinality of the covered bins—the subset of all (defined) bins that are covered
covered
For automatically generated bins, the coverage of a coverpoint is computed as follows:
bins
C = ------------------------------c-o---v--e-r--e--d-------------------
i MIN(auto_bin_max, 2M)
where
|bins | is the cardinality of the covered bins—the subset of all (auto-defined) bins that are
covered
covered
M is the minimum number of bits needed to represent the coverpoint
auto_bin_max is the value of the option in effect (see 19.7)
auto_bin_max
If there is no value or transition associated with a bin, the bin is ignored and shall not contribute to the
coverage computation; that is, the bin is excluded from both the numerator and the denominator of the
coverage equation.
If none of the bins have an associated value or transition, the denominator of the coverage calculation is
zero. In this case:
a) The coverpoint does not contribute to the coverage computation (of the parent covergroup).
b) If the coverpoint’s weight is nonzero, a value of 0.0 is returned by and
get_coverage
.
get_inst_coverage
c) If the coverpoint’s weight is zero, a value of 100.0 is returned by and
get_coverage
.
get_inst_coverage
d) If or is called with two arguments, zero is assigned to both
get_coverage get_inst_coverage
arguments—the numerator and denominator.
For example:
bit [2:0] a, b;
covergroup ct;
coverpoint b {
option.auto_bin_max = 4;
ignore_bins ig = { [0:1], [5:6] };
587
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
}
endgroup
In this case, coverpoint b will have 4 auto bins: , , , . The
auto[0,1] auto[2,3] auto[4,5] auto[6,7]
declaration specifies that the values 0,1,5,6 are ignored. After applying the ,
ignore_bins ignore_bins
the bins are: , , , . Since it no longer is associated with any value,
auto[] auto[2,3] auto[4] auto[7]
does not contribute to coverage.
auto[]
To determine whether a particular bin of a coverage group is covered, the cumulative coverage computation
considers the value of the option of all instances being accumulated. Consequently, a bin is not
at_least
considered covered unless its hit count equals or exceeds the maximum of all the values of all
at_least
instances. Use of the maximum represents the more conservative choice.
19.11.2 Cross coverage computation
The coverage of a item is computed according to the following equation:
cross
bins
C = -------------c--o--v--e--r--e-d---
i B +B
c u
 
B = B –B
c  j b
j
where
j  set of coverpoints being crossed
B is the cardinality (number of bins) of the j th coverpoint being crossed
j
B is the number of auto-cross bins
c
B is the number of significant user-defined cross bins—excluding and
u ignore_bins
illegal_bins
B is the number of cross products that comprise all user-defined cross bins
b
The term B represents user-defined bins that contribute towards coverage.
u
If the denominator of the cross coverage calculation equation has a value of zero:
a) The cross does not contribute to the coverage computation (of the parent covergroup).
b) If the cross’s weight is nonzero, a value of 0.0 is returned by and
get_coverage
.
get_inst_coverage
c) If the cross’s weight is zero, a value of 100.0 is returned by and
get_coverage
.
get_inst_coverage
d) If or is called with two arguments, zero is assigned to both
get_coverage get_inst_coverage
arguments—the numerator and denominator.
19.11.3 Type coverage computation
Cumulative (or type) coverage is computed in two ways. When is false,
type_option.merge_instances
type coverage is computed as the weighted average of all instances. When
is true, type coverage is computed as if instances were merged together
type_option.merge_instances
into the type, as a union of coverage of all instances.
When type coverage is computed as the weighted average of all instances, the covergroup type coverage
depends on the instances only, not its coverpoints or crosses, as follows:
588
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
W I
i i
W
i
where
W is the of a covergroup instance
i option.weight
I is the coverage of a covergroup instance
i
Likewise, the type coverage of a coverpoint or cross is computed from the coverage of that coverpoint or
cross in each instance, weighted by in the coverpoint or cross scope for each instance.
option.weight
The values returned by are consistent with the weighted sum above
get_coverage(ref int, ref int)
when is false.
type_option.merge_instances
When type coverage is computed as the merge of coverage from all instances, the union of all bins from all
instances must be computed. To determine when bins overlap among instances, the bin name is used as
described in detail as follows. When bins overlap among instances, the cumulative coverage count of an
overlapping bin is the sum of counts of that bin in all instances containing it. For example:
covergroup gt ( int l, h);
coverpoint a { bins b[] = { [l:h] }; }
endgroup
gt gv1 = new (0,1);
gt gv2 = new (1,2);
In this case, bin “b[1]” overlaps between instances referenced by and . The covergroup has bins
gv1 gv2 gt
“b[0],” “b[1],” and “b[2].” If were sampled by and sampled by both and , the
a==0 gv1 a==1 gv1 gv2
value would be 66.6667 because 2 out of 3 type bins were covered; the cumulative
gt::get_coverage()
count for the bin “b[1]” would be 2. If instance coverage were enabled with
option.get_inst_coverage
equal to 1 for both instances, would return 100.0 and
gv1.get_inst_coverage()
would return 50.0.
gv2.get_inst_coverage()
To compute the union of all bins in all instances, bins are compared by name, so that bins with the same
name are overlapping among instances. For state or transition bins declared as “binname,” all instances
share the same name, so the bin overlaps in all instances. For state bins declared as “binname[],” bin names
are “binname[value]” (as specified in 19.5.1) for a set of scalar values. Instances sharing the same value
have overlapping bins. For state bins declared as “binname[N],” bin names range “binname[0]” through
“binname[N-1].” Instances sharing the same indices have overlapping bins. For automatically created bins,
bin names are of the form “auto[value]” or “auto[low:high]” (as specified in 19.5.3), and these names are
unaffected by ignored or illegal values in the coverpoint except inasmuch as they may empty an
automatically created bin. Instances sharing the same value or low:high range have overlapping bins. For
transition bins declared as “binname[],” bin names are “binname[transition]” for some bounded transition
(as specified in 19.5.2). Instances sharing the same transition have overlapping bins. For automatically
created cross bins, bin names are of the form “<binname1,...,binnameN>” where the bin names are derived
from the crossed coverpoint bins (as specified in 19.6). Instances sharing exactly the same cross product bin
name have overlapping bins.
The following example shows automatically created bins:
bit [7:0] a;
covergroup ga ( int abm);
option.auto_bin_max = abm;
coverpoint a { ignore_bins i = {3}; }
endgroup
589
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
ga gv1 = new (64);
ga gv2 = new (32);
In this case, the bins of the instance referenced by are “auto[0:3]” through “auto[252:255],” while the
gv1
bins of the instance referenced by are “auto[0:7]” through “auto[248:255].” Note how the ignored value
gv2
3 does not have an effect on the bin names. Because none of the bin names overlap between the two
instances, the covergroup type has 96 cumulative bins.
ga
590
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
20. Utility system tasks and system functions
20.1 General
This clause describes the utility system tasks and system functions that are part of SystemVerilog. Clause21
presents additional system tasks and system functions that are specific to I/O operations. The system tasks
and system functions described in this clause are divided into several categories, as follows:
Simulation control tasks (20.2) Elaboration tasks (20.11)
$finish $stop $fatal $error
$exit $warning $info
Simulation time functions (20.3) Assertion control tasks (20.12)
$realtime $stime $asserton $assertoff
$time $assertkill $assertcontrol
$assertpasson $assertpassoff
Timescale tasks (20.4)
$assertfailon $assertfailoff
$printtimescale $timeformat $assertnonvacuouson $assertvacuousoff
Conversion functions (20.5) Sampled value system functions (20.13)
$bitstoreal $realtobits $sampled $rose
$bitstoshortreal $shortrealtobits $fell $stable
$itor $rtoi $changed $past
$signed $unsigned $past_gclk $rose_gclk
$cast $fell_gclk $stable_gclk
Data query functions (20.6) $changed_gclk $future_gclk
$rising_gclk $falling_gclk
$bits $isunbounded
$steady_gclk $changing_gclk
$typename
Coverage control functions (20.14)
Array query functions (20.7)
$coverage_control $coverage_get_max
$unpacked_dimensions $dimensions
$coverage_get $coverage_merge
$left $right
$coverage_save $get_coverage
$low $high
$set_coverage_db_name $load_coverage_db
$increment $size
Probabilistic distribution functions (20.15)
Math functions (20.8)
$random $dist_chi_square
$clog2 $asin
$dist_erlang $dist_exponential
$ln $acos
$dist_normal $dist_poisson
$log10 $atan
$dist_t $dist_uniform
$exp $atan2
$sqrt $hypot Stochastic analysis tasks and functions (20.16)
$pow $sinh
$q_initialize $q_add
$floor $cosh
$q_remove $q_full
$ceil $tanh
$q_exam
$sin $asinh
PLA modeling tasks (20.17)
$cos $acosh
$tan $atanh $async$and$array $async$and$plane
$async$nand$array $async$nand$plane
Bit vector system functions (20.9)
$async$or$array $async$or$plane
$countbits $countones $async$nor$array $async$nor$plane
$onehot $onehot0 $sync$and$array $sync$and$plane
$isunknown $sync$nand$array $sync$nand$plane
Severity tasks (20.10) $sync$or$array $sync$or$plane
$sync$nor$array $sync$nor$plane
$fatal $error
$warning $info Miscellaneous tasks and functions (20.18)
$system
591
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
20.2 Simulation control system tasks
This subclause defines the following three simulation control system tasks:
a)
$finish
b)
$stop
c)
$exit
simulation_control_task ::=
[ n ]
$stop ( ) ;
[ n ]
$finish ( ) ;
[ ]
$exit () ;
Syntax20-1—Syntax for simulation control tasks (not in AnnexA)
The system task causes simulation to be suspended.
$stop
The system task causes the simulator to exit and pass control back to the host operating system.
$finish
The control task waits for all blocks to complete, and then makes an implicit call to
$exit program
. The usage of is presented in 24.7 on program blocks.
$finish $exit
The and system tasks take an optional expression argument ( , , or ) that determines
$stop $finish 0 1 2
what type of diagnostic message is printed, as shown in Table20-1. If no argument is supplied, then a value
of 1 is taken as the default.
Table20-1—Diagnostics for $finish
Argument value Diagnostic message
0 Prints nothing
1 Prints simulation time and location
2 Prints simulation time, location, and statistics about the memory
and central processing unit (CPU) time used in simulation
20.3 Simulation time system functions
The following system functions provide access to current simulation time:
$time $stime $realtime
The syntax for time system functions is shown in Syntax20-2.
time_function ::=
$time
|
$stime
|
$realtime
Syntax20-2—Syntax for time system functions (not in AnnexA)
592
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
20.3.1 $time
The system function returns an integer that is a 64-bit time, scaled to the time unit of the module that
$time
invoked it.
For example:
`timescale 10 ns / 1 ns
module test;
logic set;
parameter p = 1.55;
initial begin
$monitor($time,,"set=", set);
#p set = 0;
#p set = 1;
end
endmodule
The output from this example is as follows:
0 set=x
2 set=0
3 set=1
In this example, the variable is assigned the value at simulation time 16 ns, and the value at
set 0 1
simulation time 32 ns. The time values returned by the system function are determined by the
$time
following steps:
a) The simulation times 16 ns and 32 ns are scaled to and because the time unit for the module
1.6 3.2
is 10 ns; therefore, time values reported by this module are multiples of 10 ns.
b) The value is rounded to , and is rounded to because the system function returns
1.6 2 3.2 3 $time
an integer. The time precision does not cause rounding of these values.
NOTE—The times at which the assignments take place in this example do not match the times reported by .
$time
20.3.2 $stime
The system function returns an unsigned integer that is a 32-bit time, scaled to the time unit of the
$stime
module that invoked it. If the actual simulation time does not fit in 32 bits, the low order 32 bits of the
current simulation time are returned.
20.3.3 $realtime
The system function returns a real number time that, like , is scaled to the time unit of the
$realtime $time
module that invoked it.
For example:
`timescale 10 ns / 1 ns
module test;
logic set;
parameter p = 1.55;
initial begin
$monitor($realtime,,"set=", set);
#p set = 0;
#p set = 1;
end
endmodule
593
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The output from this example is as follows:
0 set=x
1.6 set=0
3.2 set=1
In this example, the event times in the variable are multiples of 10 ns because 10 ns is the time unit of
set
the module. They are real numbers because returns a real number.
$realtime
20.4 Timescale system tasks
This subclause defines the system tasks that display and set timescale printing information:
a)
$printtimescale
b)
$timeformat
See 22.7 for a discussion of timescale and time units.
20.4.1 $printtimescale
The system task displays the time unit and precision for a particular module. The syntax
$printtimescale
for the system task is shown in Syntax20-3.
printtimescale_task ::=
[ hierarchical_identifier ]
$printtimescale ( ) ;
Syntax20-3—Syntax for $printtimescale (not in AnnexA)
This system task can be specified with or without an argument.
— When no argument is specified, displays the time unit and precision of the
$printtimescale
module that is the current scope.
— When an argument is specified, displays the time unit and precision of the
$printtimescale
module passed to it.
The timescale information shall appear in the following format:
Time scale of (module_name) is unit / precision
For example:
`timescale 1 ms / 1 us
module a_dat;
initial
$printtimescale(b_dat.c1);
endmodule
`timescale 10 fs / 1 fs
module b_dat;
c_dat c1 ();
endmodule
`timescale 1 ns / 1 ns
594
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
module c_dat;
.
.
.
endmodule
In this example, module invokes the system task to display timescale
a_dat $printtimescale
information about another module , which is instantiated in module .
c_dat b_dat
The information about shall be displayed in the following format:
c_dat
Time scale of (b_dat.c1) is 1ns / 1ns
20.4.2 $timeformat
The syntax for the system task is shown in Syntax20-4.
$timeformat
timeformat_task ::=
[ units_number precision_number suffix_string minimum_field_width ]
$timeformat ( , , , ) ;
Syntax20-4—Syntax for $timeformat (not in AnnexA)
The system task performs the following two functions:
$timeformat
— It specifies how the format specification reports time information for the , ,
%t $write $display
, , , , , and group of system tasks.
$strobe $monitor $fwrite $fdisplay $fstrobe $fmonitor
— It specifies the time unit for delays entered interactively.
The units number argument shall be an integer in the range from to . This argument represents the time
0 -15
unit as shown in Table20-2.
Table20-2—$timeformat units_number arguments
Unit number Time unit Unit number Time unit
1 s 10 ns
0 –8
100 ms 1 ns
–1 –9
10 ms 100 ps
–2 –10
1 ms 10 ps
–3 –11
100 us 1 ps
–4 –12
10 us 100 fs
–5 –13
1 us 10 fs
–6 –14
100 ns 1 fs
–7 –15
NOTE—While s, ms, ns, ps, and fs are the usual SI unit symbols for second, millisecond, nanosecond, picosecond, and
femtosecond, due to lack of the Greek letter  (mu) in coding character sets, “us” represents the SI unit symbol for
microsecond, properlys.
The system task performs the following two operations:
$timeformat
— It sets the time unit for all later-entered delays entered interactively.
595
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— It sets the time unit, precision number, suffix string, and minimum field width for all formats
%t
specified in all modules that follow in the source description until another system
$timeformat
task is invoked.
The default system task arguments are given in Table20-3.
$timeformat
Table20-3—$timeformat default value for arguments
Argument Default
units_number The smallest time precision argument of all the
`timescale
compiler directives in the source description
precision_number 0
suffix_string A null character string
minimum_field_width 20
The following example shows the use of with the ystem task to specify a uniform time
%t $timeformats
unit, time precision, and format for timing information.
`timescale 1 ms / 1 ns
module cntrl;
initial
$timeformat(-9, 5, " ns", 10);
endmodule
`timescale 1 fs / 1 fs
module a1_dat;
logic in1;
integer file;
buf #10000000 (o1,in1);
initial begin
file = $fopen("a1.dat");
#00000000 $fmonitor(file,"%m: %t in1=%d o1=%h", $realtime,in1,o1);
#10000000 in1 = 0;
#10000000 in1 = 1;
end
endmodule
`timescale 1 ps / 1 ps
module a2_dat;
logic in2;
integer file2;
buf #10000 (o2,in2);
initial begin
file2=$fopen("a2.dat");
#00000 $fmonitor(file2,"%m: %t in2=%d o2=%h",$realtime,in2,o2);
#10000 in2 = 0;
#10000 in2 = 1;
end
endmodule
The contents of file are as follows:
a1.dat
a1_dat: 0.00000 ns in1=x o1=x
a1_dat: 10.00000 ns in1=0 o1=x
596
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
a1_dat: 20.00000 ns in1=1 o1=0
a1_dat: 30.00000 ns in1=1 o1=1
The contents of file are as follows:
a2.dat
a2_dat: 0.00000 ns in2=x o2=x
a2_dat: 10.00000 ns in2=0 o2=x
a2_dat: 20.00000 ns in2=1 o2=0
a2_dat: 30.00000 ns in2=1 o2=1
In this example, the times of events written to the files by the system task in modules
$fmonitor a1_dat
and are reported as multiples of —even though the time units for these modules are and
a2_dat 1 ns 1 fs
, respectively—because the first argument of the system task is and the format
1 ps $timeformat -9 %t
specification is included in the arguments to This time information is reported after the
$fmonitor.
module names with five fractional digits, followed by an character string in a space wide enough for
ns
10 ASCII characters.
20.5 Conversion functions
System functions are provided to convert values to and from real number values, and to convert values to
signed or unsigned values.
The following system functions handle real number values (the and types).
real shortreal
integer $rtoi ( real_val )
real $itor ( int_val )
[63:0] $realtobits ( real_val )
real $bitstoreal ( bit_val )
[31:0] $shortrealtobits ( shortreal_val )
shortreal $bitstoshortreal ( bit_val )
These conversion system functions may be used in constant expressions, as specified in 11.2.1.
converts real values to an type by truncating the real value (for example, 123.45 becomes
$rtoi integer
123). differs from casting a real value to an or other integral type in that casting will
$rtoi integer
perform rounding instead of truncation. Directly assigning a real value to an integral type will also round
instead of truncate.
converts integer values to real values (for example, 123 becomes 123.0).
$itor
converts values from a type to a 64-bit vector representation of the real number.
$realtobits real
converts a bit pattern created by to a value of the type.
$bitstoreal $realtobits real
converts values from a type to the 32-bit vector representation of the real
$shortrealtobits shortreal
number.
converts a bit pattern created by to a value of the
$bitstoshortreal $shortrealtobits shortreal
type.
NOTE 1—The real numbers accepted or generated by these functions shall conform to the IEEE 754 representation of
the single precision and double precision floating-point numbers. The conversion shall round the result to the nearest
valid representation.
597
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The following example shows how the and functions can be used in port
$realtobits $bitstoreal
connections:
module driver (net_r);
output [64:1] net_r;
real r;
wire [64:1] net_r = $realtobits(r);
endmodule
module receiver (net_r);
input [64:1] net_r;
wire [64:1] net_r;
real r;
initial assign r = $bitstoreal(net_r);
endmodule
NOTE 2—SystemVerilog allows directly passing real values across module, interface, and program ports; it is not
necessary to use the $realtobits and $bitstoreal conversion functions as shown in this example. IEEE Std 1364-2005 did
not allow directly passing real values across module ports, and therefore utilized these system functions.
The and system functions can be used to cast the signedness (but not the type) of
$signed $unsigned
expressions. These functions shall evaluate the input expression and return a value with the same size and
value of the input expression and the type defined by the function.
—returned value is signed
$signed
—returned value is unsigned
$unsigned
See 11.7 for examples of using and . The cast operator can also be used to change the
$signed $unsigned
signedness of an expression (see 6.24.1).
The system function performs a dynamic cast of an expression type. is described in 6.24.2 and
$cast $cast
8.16.
20.6 Data query functions
SystemVerilog provides system functions to query information about expressions , , and
$typename $bits
.
$isunbounded
20.6.1 Type name function
The system function returns a string that represents the resolved type of its argument.
$typename
typename_function ::=
expression
$typename ( )
| data_type
$typename ( )
Syntax20-5—Type name function syntax (not in AnnexA)
The return string is constructed in the following steps:
a) A that creates an equivalent type is resolved back to built-in or user-defined types.
typedef
b) The default signing is removed, even if present explicitly in the source.
c) System-generated names are created for anonymous structs, unions, and enums.
d) A “$” is used as the placeholder for the name of an anonymous unpacked array.
598
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
e) Actual encoded values are appended with enumeration named constants.
f) User-defined type names are prefixed with their defining package or scope name space.
g) Array ranges are represented as unsized decimal numbers.
h) White space in the source is removed and a single space is added to separate identifiers and
keywords from each other.
This process is similar to the way that type matching (see 6.22.1) is computed, except that simple bit vector
types with predefined widths are distinguished from those with user-defined widths. Thus can
$typename
be used in string comparisons for stricter type comparison of arrays than with type references.
When called with an expression as its argument, returns a string that represents the self-
$typename
determined type result of the expression. The expression’s return type is determined during elaboration, but
never evaluated. When used as an elaboration time constant, the expression shall not contain any
hierarchical references or references to elements of dynamic objects.
// source code // $typename would return
typedef bit node; // "bit"
node [2:0] X; // "bit [2:0]"
int signed Y; // "int"
package A;
enum {A,B,C=99} X; // "enum{A=32'sd0,B=32'sd1,C=32'sd99}A::e$1"
typedef bit [9:1'b1] word; // "A::bit[9:1]"
endpackage : A
import A::*;
module top;
typedef struct {node A,B;} AB_t;
AB_t AB[10]; // "struct{bit A;bit B;}top.AB_t$[0:9]"
...
endmodule
20.6.2 Expression size system function
The system function returns the number of bits required to hold an expression as a bit stream. The
$bits
return type is . See 6.24.3 for a definition of legal types. A 4-state value counts as 1 bit.
integer
size_function ::=
expression
$bits( )
| data_type
$bits ( )
Syntax20-6—Size function syntax (not in AnnexA)
Given the declaration
logic [31:0] v;
then shall return 32, even if the implementation uses more than 32 bits of storage to represent the
$bits(v)
4-state values. Given the declaration:
typedef struct {
logic valid;
bit [8:1] data;
} MyType;
the expression shall return 9, the number of data bits needed by a variable of type .
$bits(MyType) MyType
599
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The function can be used as an elaboration time constant when used on fixed-size data types; hence,
$bits
it can be used in the declaration of other data types, variables, or nets.
typedef bit[$bits(MyType):1] MyBits; //same as typedef bit [9:1] MyBits;
MyBits b;
Variable can be used to hold the bit pattern of a variable of type without loss of information.
b MyType
The value returned by shall be determined without actual evaluation of the expression it encloses. It
$bits
shall be an error to enclose a function that returns a dynamically sized data type. The return value
$bits
shall be valid at elaboration only if the expression contains fixed-size data types.
The system function returns 0 when called with a dynamically sized expression that is currently
$bits
empty. It shall be an error to:
— Use the system function directly with a dynamically sized data type identifier.
$bits
— Use the system function on an object of an interface class type (see 8.26).
$bits
20.6.3 Range system function
The system function returns true ( ) if the argument is . Otherwise, it returns false
$isunbounded 1'b1 $
( ).
1'b0
range_function ::=
constant_expression
$isunbounded( )
Syntax20-7—Range function syntax (not in AnnexA)
Given the declaration
parameter int i = $;
then returns true.
$isunbounded(i)
20.7 Array query functions
array_query_function ::=
array_dimension_function array_expression [ dimension_expression ]
( , )
| array_dimension_function data_type [ dimension_expression ]
( , )
| array_dimensions_function array_expression
( )
| array_dimensions_function data_type
( )
array_dimensions_function ::=
$dimensions
|
$unpacked_dimensions
array_dimension_function ::=
$left
|
$right
|
$low
|
$high
|
$increment
|
$size
600
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
array_expression ::= expression
dimension_expression ::= expression
Syntax20-8—Array querying function syntax (not in AnnexA)
SystemVerilog provides system functions to return information about a particular dimension of an array (see
Clause7) or integral (see 6.11.1) data type or of data objects of such a data type.
The return type is , and the default for the optional dimension expression is 1. The dimension
integer
expression can specify any fixed-size dimension (packed or unpacked) or any dynamically sized dimension
(dynamic, associative, or queue). When used on a dynamic array or queue dimension, these functions return
information about the current state of the array. For any dimension other than an associative array
dimension:
— shall return the left bound of the dimension. For a packed dimension, this is the index of the
$left
most significant element. For a queue or dynamic array dimension, shall return 0.
$left
— shall return the right bound of the dimension. For a packed dimension, this is the index of
$right
the least significant element. For a queue or dynamic array dimension whose current size is zero,
shall return –1.
$right
— For a fixed-size dimension, shall return 1 if is greater than or equal to
$increment $left $right
and –1 if is less than . For a queue or dynamic array dimension, shall
$left $right $increment
return –1.
— shall return the same value as if returns –1, and the same value as
$low $left $increment
if returns 1.
$right $increment
— shall return the same value as if returns –1, and the same value as
$high $right $increment
if returns 1.
$left $increment
— shall return the number of elements in the dimension, which is equivalent to:
$size
– + 1.
$high $low
— shall return the following:
$dimensions
• The total number of dimensions in the array (packed and unpacked, static or dynamic)
• 1 for the data type or any other nonarray type that is equivalent to a simple bit vector
string
type (see 6.11.1)
• 0 for any other type
— shall return the following:
$unpacked_dimensions
• The total number of unpacked dimensions for an array (static or dynamic)
• 0 for any other type
The dimensions of an array shall be numbered as follows: the slowest varying dimension (packed or
unpacked) is dimension 1. Successively faster varying dimensions have sequentially higher dimension
numbers. Intermediate type definitions are expanded first before numbering the dimensions.
For example:
// Dimension numbers
// 3 4 1 2
logic [3:0][2:1] n [1:5][2:8];
typedef logic [3:0][2:1] packed_reg;
packed_reg n[1:5][2:8]; // same dimensions as in the lines above
For a fixed-size integer type ( , , , and ), dimension 1 is predefined. For an
integer shortint longint byte
integer N declared without a range specifier, its bounds are assumed to be .
[$bits(N)-1:0]
601
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If the first argument to an array query function would cause to return 0 or if the second
$dimensions
argument is out of range, then shall be returned.
'x
It is an error to use these functions directly on a dynamically sized type identifier.
Use on associative array dimensions is restricted to index types with integral values. With integral indices,
these functions shall return the following:
— shall return 0.
$left
— shall return the highest possible index value.
$right
— shall return the lowest currently allocated index value, but shall return if there are no
$low 'x
elements currently allocated.
— shall return the largest currently allocated index value, but shall return if there are no
$high 'x
elements currently allocated.
— shall return –1.
$increment
— shall return the number of elements currently allocated.
$size
It shall be legal to call any of these query functions within a constant expression if all three of the following
conditions are true: (1) the call would be legal in an expression, (2) the operator (see 6.23) applied to
type
the first argument would be legal and return some fixed-size type, and (3) any optional dimension
expression is a constant expression.
Given the declaration
typedef logic [16:1] Word;
Word Ram[0:9];
the following system functions return 16:
$size(Word)
$size(Ram,2)
20.7.1 Queries over multiple variable dimensions
If any of the functions described in 20.7 are called with arguments where denotes some array
(v, n) v
variable and is greater than 1, then it shall be an error if the dimension indicated by is a variable-sized
n n
dimension. The following examples illustrate this restriction. This restriction does not affect the
or functions, since they cannot accept a second argument.
$dimensions $unpacked_dimensions
int a[3][][5]; // array dimension 2 has variable size
$display( $unpacked_dimensions(a) ); // displays 3
a[2] = new[4];
a[2][2][0] = 220; // OK, a[2][2] is a 5-element array
$display( $size(a, 1) ); // OK, displays 3
$display( $size(a, 2) ); // ERROR, dimension 2 is dynamic
$display( $size(a[2], 1) ); // OK, displays 4 (a[2] is
// a 4-element dynamic array)
$display( $size(a[1], 1) ); // OK, displays 0 (a[1] is
// an empty dynamic array)
$display( $size(a, 3) ); // OK, displays 5 (fixed-size dimension)
602
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
20.8 Math functions
There are integer and real math functions. The math system functions may be used in constant expressions,
as specified in 11.2.1.
20.8.1 Integer math functions
The system function shall return the ceiling of the log base 2 of the argument (the log rounded up to
$clog2
an integer value). The argument can be an integer or an arbitrary sized vector value. The argument shall be
treated as an unsigned value, and an argument value of 0 shall produce a result of 0.
This system function can be used to compute the minimum address width necessary to address a memory of
a given size or the minimum vector width necessary to represent a given number of states.
For example:
integer result;
result = $clog2(n);
20.8.2 Real math functions
The system functions in Table20-4 shall accept real value arguments and return a result type. Their
real
behavior shall match the equivalent C language standard math library function indicated.
Table20-4—SystemVerilog to C real math function cross-listing
SystemVerilog
Equivalent C function Description
function
Natural logarithm
$ln(x) log(x)
Decimal logarithm
$log10(x) log10(x)
Exponential
$exp(x) exp(x)
Square root
$sqrt(x) sqrt(x)
x**y
$pow(x,y) pow(x,y)
Floor
$floor(x) floor(x)
Ceiling
$ceil(x) ceil(x)
Sine
$sin(x) sin(x)
Cosine
$cos(x) cos(x)
Tangent
$tan(x) tan(x)
Arc-sine
$asin(x) asin(x)
Arc-cosine
$acos(x) acos(x)
Arc-tangent
$atan(x) atan(x)
,x ,x Arc-tangent of
$atan2(y ) atan2(y ) y/x
sqrt(x*x+y*y)
$hypot(x,y) hypot(x,y)
Hyperbolic sine
$sinh(x) sinh(x)
Hyperbolic cosine
$cosh(x) cosh(x)
603
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table20-4—SystemVerilog to C real math function cross-listing (continued)
SystemVerilog
Equivalent C function Description
function
Hyperbolic tangent
$tanh(x) tanh(x)
Arc-hyperbolic sine
$asinh(x) asinh(x)
Arc-hyperbolic cosine
$acosh(x) acosh(x)
Arc-hyperbolic tangent
$atanh(x) atanh(x)
20.9 Bit vector system functions
bit_vector_function ::=
expression list_of_control_bits
$countbits( , )
| expression
$countones( )
| expression
$onehot( )
| expression
$onehot0( )
| expression
$isunknown( )
list_of_control_bits ::= control_bit { control_bit }
,
Syntax20-9—Bit vector system function syntax (not in AnnexA)
The function counts the number of bits that have a specific set of values (e.g., 0, 1, X, Z) in a
$countbits
bit vector.
— expression control_bit { control_bit }
$countbits( , , )
This function returns an equal to the number of bits in expression whose values match one of the
int
control_bit entries. For example:
— returns the number of bits in expression having value 1.
$countbits (expression, '1)
— returns the number of bits in expression having values
$countbits (expression, '1, '0)
1or 0.
— returns the number of bits in expression having values X
$countbits (expression, 'x, 'z)
or Z.
The argument type for the control_bit argument is 1-bit logic and represents one of the values being counted
in the vector. If a value with a width greater than 1 is passed in, only the LSB is used. If any individual value
appears more than once in the control bits, it is treated exactly as if it had appeared once.
The expression argument to shall be of a bit-stream type. For the purpose of calculating the
$countbits
return value, the argument is treated as a vector of equal size assigned from (see
{>>{expression}}
11.4.14).
For convenience, the following related functions are also provided:
— expression is equivalent to .
$countones( ) $countbits(expression,'1)
— expression returns true ( ) if , otherwise it
$onehot ( ) 1'b1 $countbits(expression,'1)==1
returns false ( ).
1'b0
— expression returns true ( ) if , otherwise it
$onehot0( ) 1'b1 $countbits(expression,'1)<=1
returns false ( ).
1'b0
604
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— expression returns true ( ) if ,
$isunknown ( ) 1'b1 $countbits(expression,'x,'z)!=0
otherwise it returns false ( ).
1'b0
The expression argument to each of the preceding functions follows the same rules as the expression
argument to . The return type of is . The return type of , ,
$countbits $countones int $onehot $onehot0
and is . The functions , , , , and
$isunknown bit $countbits $countones $onehot $onehot0
may be used in any context where a value of their return type is legal. These functions may be
$isunknown
used as constant expressions as specified in 11.2.1 as long as all their arguments are also constant
expressions.
The following example shows how can be used to replicate common one-hot and related
$countbits
checks, with special handling possible for 4-valued logic:
// Custom one-hot that, unlike $onehot, fails on any X or Z
let my_one_hot_known(myvec) = (
($countones(myvec) == 1) &&
($countbits(myvec,'x,'z) == 0) );
The control bit arguments to may be variables, as shown in the following example:
$countbits
logic [1:0] bad_bits;
logic [31:0] myvec;
logic design_initialization_done;
...
always_comb begin
if (!design_initialization_done) begin
bad_bits[0] = 'x;
bad_bits[1] = 'x; // Repeated control_bit same as single occurrence
end else begin
bad_bits[0] = 'x;
bad_bits[1] = 'z;
end
// Z allowed during initialization, but no Z or X allowed afterwards
a1: assert ($countbits(myvec,bad_bits[0],bad_bits[1]) == 0);
end
20.10 Severity tasks
severity_message_task ::=
fatal_message_task
| nonfatal_message_task
fatal_message_task ::= [ finish_number [ list_of_arguments ] ]
$fatal ( , ) ;
nonfatal_message_task ::= severity_task [ [ list_of_arguments ] ]
( ) ;
severity_task ::= | |
$error $warning $info
finish_number ::= | |
0 1 2
Syntax20-10—Severity system task syntax (not in AnnexA)
SystemVerilog provides special text messaging system tasks that can be used to flag various exception
conditions. The tasks are defined as follows:
605
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— shall generate a run-time fatal error, which terminates the simulation with an error code.
$fatal
The first argument passed to shall be consistent with the corresponding argument to the
$fatal
system task (see 20.2), which sets the level of diagnostic information reported by the tool.
$finish
Calling results in an implicit call to .
$fatal $finish
— shall be a run-time error.
$error
— shall be a run-time warning.
$warning
— shall indicate that the message carries no specific severity.
$info
Each of the severity system tasks can include optional user-defined information to be reported. The user-
defined message shall use the same syntax as the system task (see 21.2.1) and thus can include
$display
any number of arguments.
All of the severity system tasks shall print a tool-specific message, indicating the severity of the exception
condition and specific information about the condition, which shall include the following information:
— The file name and line number of the severity system task call. The file name and line number shall
be the same as and compiler directives, respectively.
`__FILE__ `__LINE__
— The hierarchical name of the scope in which the severity system task call is made.
— For simulation tools, the simulation run time at which the severity system task is called.
The tool-specific message shall include the user-defined message if specified.
20.11 Elaboration system tasks
It is often necessary to validate the actual parameter values used in a SystemVerilog model and report any
error without generating the executable simulation model. This is achieved by using elaboration system
tasks. These tasks have the same names as the severity system tasks (see 20.10) that can be used during
simulation. However, the elaboration system tasks shall be called outside procedural code and their
activation can be controlled by conditional generate constructs. If such a task is called from within a
procedure, then it becomes a simulation-time severity system task.
elaboration_system_task ::= // from A.1.4
[ finish_number [ list_of_arguments ] ]
$fatal ( , ) ;
| [ [ list_of_arguments ] ]
$error ( ) ;
| [ [ list_of_arguments ] ]
$warning ( ) ;
| [ [ list_of_arguments ] ]
$info ( ) ;
finish_number ::= | |
0 1 2
Syntax20-11—Elaboration system task syntax (excerpt from AnnexA)
list_of_arguments may only contain a formatting string and constant expressions, including constant
function calls. If a call to such a task remains in the elaborated model after any generate construct expansion,
the task is executed. Depending on the severity of the task, the elaboration may be aborted or continue to
successful completion. If more than one elaboration system task call is present, they may be executed in any
order.
If is executed then after outputting the message the elaboration may be aborted, and in no case shall
$fatal
simulation be executed. Some of the elaboration system task calls may not be executed either. The
finish_number may be used in an implementation-specific manner.
606
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If is executed then the message is issued and the elaboration continues. However, no simulation
$error
shall be executed.
The other two tasks, and , only output their text message but do not affect the rest of the
$warning $info
elaboration and the simulation.
All of the elaboration system tasks shall print a tool-specific message, indicating the severity of the
exception condition and specific information about the condition, which shall include the following
information:
— The file name and line number of the elaboration system task call. The file name and line number
shall be the same as and compiler directives, respectively.
`__FILE__ `__LINE__
— The hierarchical name of the scope in which the elaboration system task call is made.
The tool-specific message shall include the user-defined message if specified.
Example 1: Sometimes it is desirable to validate elaboration-time constants, such as bounds on a parameter,
in a way that can be enforced during model elaboration. In this example, if the module parameter value is
outside the range 1 to 8, an error is issued and the model elaboration is aborted.
module test #(N = 1) (input [N-1:0] in, output [N-1:0] out);
if ((N < 1) || (N > 8)) // conditional generate construct
$error("Parameter N has an invalid value of %0d", N);
assign out = in;
endmodule
Example 2: In this simple example, the generate construct builds a concatenation ( ) of subsequences,
##1
each of length 1, over a bit from a vector passed as argument to the top sequence definition. Elaboration
system tasks are used to indicate if the vector is only a 1-bit vector, otherwise informational messages are
issued that indicate which conditional branches were generated.
generate
if ($bits(vect) == 1) begin : err $error("Only a 1-bit vector"); end
for (genvar i = 0; i < $bits(vect); i++) begin : Loop
if (i==0) begin : Cond
sequence t; vect[0]; endsequence
$info("i=0 branch generated");
end : Cond
else begin : Cond
sequence t; vect[i] ##1 Loop[i-1].Cond.t; endsequence
$info("i = %0d branch generated", i);
end : Cond
end : Loop
endgenerate
// instantiate the last generated sequence in a property
property p;
@(posedge clk) trig |-> Loop[$bits(vect)-1].Cond.t;
endproperty
607
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
20.12 Assertion control system tasks
assert_control_task ::=
assert_task [ levels [ list_of_scopes_or_assertions ] ]
( , ) ;
| assert_action_task [ levels [ list_of_scopes_or_assertions ] ]
( , ) ;
| control_type [ [ assertion_type ] [ [ directive_type ] [ [ levels ]
$assertcontrol( , , ,
[ list_of_scopes_or_assertions ] ] ] ]
, );
assert_task ::=
$asserton
|
$assertoff
|
$assertkill
assert_action_task ::=
$assertpasson
|
$assertpassoff
|
$assertfailon
|
$assertfailoff
|
$assertnonvacuouson
|
$assertvacuousoff
list_of_scopes_or_assertions ::=
scope_or_assertion { scope_or_assertion }
,
scope_or_assertion ::=
hierarchical_identifier
Syntax20-12—Assertion control syntax (not in AnnexA)
SystemVerilog provides the system task to control the evaluation of assertions (see
$assertcontrol
16.2). The system task can also be used to control the execution of assertion action
$assertcontrol
blocks associated with assertions and statements. This system task provides the capability to enable/
expect
disable/kill the assertions based on assertion type or directive type. Similarly, this task also provides the
capability to enable/disable action block execution of assertions and statements based on assertion
expect
type or directive type. The violation reporting for , and and case constructs
unique unique0 priorityif
(see 12.4.2 and 12.5.3) can also be controlled using these tasks. The arguments for the
$assertcontrol
system task are described as follows:
— : This argument controls the effect of the system task. This
control_type $assertcontrol
argument shall be an integer expression. The valid values for this argument are described in
Table20-5.
— : This argument selects the assertion types and violation report types that are
assertion_type
affected by the system task. This argument shall be an integer expression. The
$assertcontrol
valid values for this argument are described in Table20-6. Multiple values can
assertion_type
be specified at a time by OR-ing different values. For example, a task with value
assertion_type
of 3 (which is the same as Concurrent|SimpleImmediate) shall apply to concurrent and simple
immediate assertions. Similarly, a task with assertion_type value of 96 (which is same as
Unique|Unique0) shall apply to and and case constructs. If
unique unique0if assertion_type
is not specified, then it defaults to 255 and the system task applies to all types of assertions,
expect
statements, and violation reports.
— : This argument selects the directive types that are affected by the
directive_type
system task. This argument shall be an integer expression. The valid values for
$assertcontrol
this argument are described in Table20-7. This argument is checked only for assertions. Multiple
values can be specified at a time by OR-ing different values. For example, a task
directive_type
with value of 3 (which is same as Assert|Cover) shall apply to assert and cover
directive_type
608
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
directives. If is not specified, then it defaults to 7 (Assert|Cover|Assume) and the
directive_type
system task applies to all types of directives.
— : This argument specifies the levels of hierarchy, consistent with the corresponding
levels
argument to the system task (see 21.7.1.2). If this argument is not specified, it defaults
$dumpvars
to 0. This argument shall be an integer expression.
— : This argument specifies which scopes of the model to
list_of_scopes_or_assertions
control. These arguments can specify any scopes or individual assertions.
Table20-5—Values for control_type for assertion control tasks
control_type values Effect
1 Lock
2 Unlock
3 On
4 Off
5 Kill
6 PassOn
7 PassOff
8 FailOn
9 FailOff
10 NonvacuousOn
11 VacuousOff
Table20-6—Values for assertion_type for assertion control tasks
assertion_type values Types of assertions affected
1 Concurrent
2 Simple Immediate
4 Observed Deferred Immediate
8 Final Deferred Immediate
16 Expect
32 Unique
64 Unique0
128 Priority
609
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table20-7—Values for directive_type for assertion control tasks
directive_type values Types of directives affected
1 Assert directives
2 Cover directives
4 Assume directives
The effect of the system task is determined by the value of its first argument
$assertcontrol
, which shall be an integer expression. The effect of the system task based on the value of
control_type
is described as follows:
control_type
— Lock: A value of 1 for this argument prevents status change of all specified assertions,
expect
statements, and violation reports until they are unlocked. Once an with
$assertcontrol
of value 1 (Lock) is applied to an assertion, statement, or violation report,
control_type expect
it becomes locked and no shall affect it until the locked state is removed by a
$assertcontrol
subsequent with a value of 2 (Unlock).
$assertcontrol control_type
— Unlock: A value of 2 for this argument shall remove the locked status of all specified assertions,
statements, and violation reports.
expect
— On: A value of 3 for this argument shall re-enable the execution of all specified assertions. A value
of 3 for this argument shall also re-enable violation reporting from all the specified violation report
types. This value does not affect statements.
control_type expect
— Off: A value of 4 for this argument shall stop the checking of all specified assertions until a
subsequent with a of 3 (On). No new attempts will be started.
$assertcontrol control_type
Attempts that are already executing for the assertions, and their pass or fail statements, are not
affected. In the case of a deferred assertion (see 16.4), currently queued reports are not flushed and
may still mature, though further checking is prevented until a subsequent with a
$assertcontrol
of 3 (On). In the case of a pending procedural assertion instance (see 16.14.6),
control_type
currently queued instances are not flushed and may still mature, though no new instances may be
queued until a subsequent with a of 3 (On). A value of 4 for this
$assertcontrol control_type
argument shall also disable the violation reporting from all the specified violation report types.
Currently queued violation reports are not flushed and may still mature, though no new violation
reports shall be added to the pending violation report queue until a subsequent
$assertcontrol
with a value of 3 (On). The violation reporting can be re-enabled subsequently by
control_type
with a value of 3 (On). This value does not
$assertcontrol control_type control_type
affect statements.
expect
— Kill: A value of 5 for this argument shall abort execution of any currently executing attempts for the
specified assertions and then stop the checking of all specified assertions until a subsequent
with a of 3 (On). This also flushes any queued pending reports
$assertcontrol control_type
of deferred assertions (see 16.4) or pending procedural assertion instances (see 16.14.6) that have
not yet matured. A value of 5 for this argument shall also abort violation reporting from all the
specified violation report types. Currently queued violation reports that have not yet matured are
also flushed, and no new violation reports shall be added to the pending violation report queue until
a subsequent with a value of 3 (On). This value
$assertcontrol control_type control_type
does not affect statements.
expect
— PassOn: A value of 6 for this argument shall enable execution of the pass action for vacuous and
nonvacuous success of all the specified assertions and statements. An assertion that is
expect
already executing, including execution of the pass or fail action, is not affected. This
value does not affect violation report types.
control_type
610
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— PassOff: A value of 7 for this argument shall stop execution of the pass action for vacuous and
nonvacuous success of all the specified assertions and statements. Execution of the pass
expect
action for both vacuous and nonvacuous successes can be re-enabled subsequently by
with a value of 6 (PassOn), while the execution of the pass
$assertcontrol control_type
action for only nonvacuous successes can be enabled subsequently by with a
$assertcontrol
value of 10 (NonvacuousOn). An assertion that is already executing, including
control_type
execution of the pass or fail action, is not affected. By default, the pass action is executed. This
value does not affect violation report types.
control_type
— FailOn: A value of 8 for this argument shall enable execution of the fail action of all the specified
assertions and statements. An assertion that is already executing, including execution of the
expect
pass or fail action, is not affected. This task also affects the execution of the default fail action block.
This value does not affect violation report types.
control_type
— FailOff: A value of 9 for this argument shall stop execution of the fail action of all the specified
assertions and statements until a subsequent with a
expect $assertcontrol control_type
value of 8 (FailOn). An assertion that is already executing, including execution of the pass or fail
action, is not affected. By default, the fail action is executed. This task also affects the execution of
default fail action block, i.e., , which is called in case no clause is specified for the
$error else
assertion. This value does not affect violation report types.
control_type
— NonvacuousOn: A value of 10 for this argument shall enable execution of the pass action of all the
specified assertions and statements on nonvacuous success. An assertion that is already
expect
executing, including execution of the pass or fail action, is not affected. Refer to 16.14.8 for the
definition of vacuous success. This value does not affect violation report types.
control_type
— VacuousOff: A value of 11 for this argument shall stop execution of the pass action of all the
specified assertions and statements on vacuous success until a subsequent
expect
with a value of 6 (PassOn). An assertion that is already
$assertcontrol control_type
executing, including execution of the pass or fail action, is not affected. By default, the pass action is
executed on vacuous success. Refer to 16.14.8 for the definition of vacuous success. This
value does not affect violation report types.
control_type
The assertion action control tasks or with values of 6 (PassOn) to 11
$assertcontrol control_type
(VacuousOff) do not affect statistics counters for the assertions.
The details related to the behavior of for assertions referring to global clocking future
$assertcontrol
sampled value functions are explained in 16.9.4.
The system task provides finer grain assertion selection controls than the ,
$assertcontrol $asserton
, and system tasks. The , , and system
$assertoff $assertkill $asserton $assertoff $assertkill
tasks are provided for convenience and backward compatibility. They can be defined as follows:
— [(levels[, list])] is equivalent to (3, 15, 7, levels [,list])
$asserton $assertcontrol
— (levels[, list])] is equivalent to (4, 15, 7, levels [,list])
$assertoff[ $assertcontrol
— [(levels[, list])] is equivalent to (5, 15, 7, levels [,list])
$assertkill $assertcontrol
Similarly, assertion action control tasks , , ,
$assertpasson $assertpassoff $assertfailon
, , and are provided for convenience and
$assertfailoff $assertvacuousoff $assertnonvacuouson
backward compatibility. These tasks can be defined as follows:
— [(levels[, list])] is equivalent to (6, 31, 7, levels [,list])
$assertpasson $assertcontrol
— [(levels[, list])] is equivalent to (7, 31, 7, levels [,list])
$assertpassoff $assertcontrol
— [(levels[, list])] is equivalent to (8, 31, 7, levels [,list])
$assertfailon $assertcontrol
— [(levels[, list])] is equivalent to (9, 31, 7, levels [,list])
$assertfailoff $assertcontrol
— [(levels[, list])] is equivalent to (10, 31, 7, levels [,list])
$assertnonvacuouson $assertcontrol
— [(levels[, list])] is equivalent to (11, 31, 7, levels [,list])
$assertvacuousoff $assertcontrol
611
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In the following example, assertion control tasks are used to control the directive behavior.
module test;
logic clk;
logic a, b;
logic c, d;
// Define lets to make the code more readable.
let LOCK = 1;
let UNLOCK = 2;
let ON = 3;
let OFF = 4;
let KILL = 5;
let CONCURRENT = 1;
let S_IMMEDIATE = 2; // simple immediate
let D_IMMEDIATE = 12; // Final and Observed deferred immediate
let EXPECT = 16;
let UNIQUE = 32; // unique if and case violation
let UNIQUE0 = 64; // unique0 if and case violation
let PRIORITY = 128; // priority if and case violation
let ASSERT = 1;
let COVER = 2;
let ASSUME = 4;
let ALL_DIRECTIVES = (ASSERT|COVER|ASSUME);
let ALL_ASSERTS = (CONCURRENT|S_IMMEDIATE|D_IMMEDIATE|EXPECT);
let VACUOUSOFF = 11;
a1: assert property (@(posedge clk) a |=> b) $info("assert passed");
else $error("assert failed");
c1: cover property (@(posedge clk) a ##1 b);
always @(posedge clk) begin
ia1: assert (a);
end
always_comb begin
if (c)
df1: assert #0 (d);
unique if ((a==0) || (a==1)) $display("0 or 1");
else if (a == 2) $display("2");
else if (a == 4) $display("4"); // values 3,5,6,7 cause a violation
// report
end
initial begin
// The following systasks affect the whole design so no modules
// are specified
// Disable vacuous pass action for all the concurrent asserts,
// covers and assumes in the design. Also disable vacuous pass
// action for expect statements.
$assertcontrol(VACUOUSOFF, CONCURRENT | EXPECT);
// Disable concurrent and immediate asserts and covers.
// This will also disable violation reporting.
612
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
// The following systask does not affect expect
// statements as control type is Off.
$assertcontrol(OFF); // using default values of all the
// arguments after first argument
// After 20 time units, enable assertions,
// This will not enable violation reporting.
// explicitly specifying second, third and fourth arguments
// in the following task call
#20 $assertcontrol(ON, CONCURRENT|S_IMMEDIATE|D_IMMEDIATE,
ASSERT|COVER|ASSUME, 0);
// Enable violation reporting after 20 time units.
#20 $assertcontrol(ON, UNIQUE|UNIQUE0|PRIORITY);
// Kill currently executing concurrent assertions after
// 100 time units but do not kill concurrent covers/assumes
// and immediate/deferred asserts/covers/assumes
// using appropriate values of second and third arguments.
#100 $assertcontrol(KILL, CONCURRENT, ASSERT, 0);
// The following assertion control task does not have any effect as
// directive_type is assert but it has selected cover directive c1.
#10 $assertcontrol(ON, CONCURRENT|S_IMMEDIATE|D_IMMEDIATE, ASSERT, 0,
c1);
// Now, after 10 time units, enable all the assertions except a1.
// To accomplish this, first we’ll lock a1 and then we’ll enable all
// the assertions and then unlock a1 as we want future assertion
// control tasks to affect a1.
#10 $assertcontrol(LOCK, ALL_ASSERTS, ALL_DIRECTIVES, 0, a1);
$assertcontrol(ON); // enable all the assertions except a1
$assertcontrol(UNLOCK, ALL_ASSERTS, ALL_DIRECTIVES, 0, a1);
end
endmodule
Table20-8 lists the VPI callbacks (see 36.9.2 and 39.4) corresponding to the assertion control system task’s
invocation.
Table20-8—VPI callbacks for assertion control tasks
No arguments—assertion system With arguments—assertion callback
Task
callback (see 39.4.1) (see 39.4.2)
cbAssertionSysOn cbAssertionEnable
$asserton
cbAssertionSysOff cbAssertionDisable
$assertoff
cbAssertionSysKill cbAssertionReset +
$assertkill
cbAssertionDisable
cbAssertionSysEnablePassAction cbAssertionEnablePassAction
$assertpasson
cbAssertionSysEnableFailAction cbAssertionEnableFailAction
$assertfailon
cbAssertionSysDisablePassAction cbAssertionDisablePassAction
$assertpassoff
cbAssertionSysDisableFailAction cbAssertionDisableFailAction
$assertfailoff
cbAssertionSysEnableNonvacuousAction cbAssertionEnableNonvacuousAction
$assertnonvacuouson
613
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table20-8—VPI callbacks for assertion control tasks (continued)
No arguments—assertion system With arguments—assertion callback
Task
callback (see 39.4.1) (see 39.4.2)
cbAssertionSysDisableVacuousAction cbAssertionDisableVacuousAction
$assertvacuousoff
with cbAssertionSysLock cbAssertionLock
$assertcontrol
1 (lock)
control_type
with cbAssertionSysUnlock cbAssertionUnlock
$assertcontrol
2
control_type
(unlock)
with cbAssertionSysOn cbAssertionEnable
$assertcontrol
3 (On)
control_type
with cbAssertionSysOff cbAssertionDisable
$assertcontrol
4 (Off)
control_type
with cbAssertionSysKill cbAssertionReset + cbAssertionDisable
$assertcontrol
5 (Kill)
control_type
with cbAssertionSysEnablePassAction cbAssertionEnablePassAction
$assertcontrol
6
control_type
(PassOn)
with cbAssertionSysEnableFailAction cbAssertionEnableFailAction
$assertcontrol
8
control_type
(FailOn)
with cbAssertionSysDisablePassAction cbAssertionDisablePassAction
$assertcontrol
7
control_type
(PassOff)
with cbAssertionSysDisableFailAction cbAssertionDisableFailAction
$assertcontrol
9
control_type
(FailOff)
with cbAssertionSysEnableNonvacuousAction cbAssertionEnableNonvacuousAction
$assertcontrol
10
control_type
(NonvacuousOn)
with cbAssertionSysDisableVacuousAction cbAssertionDisableVacuousAction
$assertcontrol
11
control_type
(VacuousOff)
20.13 Sampled value system functions
sampled_value_function ::=
expression
$sampled( )
| expression [ [ clocking_event ] ]
$rose( , )
| expression [ [ clocking_event ] ]
$fell( , )
| expression [ [ clocking_event ] ]
$stable( , )
| expression [ [ clocking_event ] ]
$changed( , )
| expression1 [ [ number_of_ticks ] [ [ expression2 ] [ [ clocking_event ] ] ] ]
$past( , , , )
global_clocking_past_function ::=
expression
$past_gclk( )
| expression
$rose_gclk( )
| expression
$fell_gclk( )
614
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| expression
$stable_gclk( )
| expression
$changed_gclk( )
global_clocking_future_function ::=
expression
$future_gclk( )
| expression
$rising_gclk( )
| expression
$falling_gclk( )
| expression
$steady_gclk( )
| expression
$changing_gclk( )
Syntax20-13—Sampled value system function syntax (not in AnnexA)
System functions based on sampled values (16.5) and global clocking (14.14) are provided to perform
various temporal calculations. These functions are fully described in other clauses as follows:
Sampled value functions , , , , , and are described in
$sampled $rose $fell $stable $changed $past
16.9.3.
Global clocking functions , , , , ,
$past_gclk $rose_gclk $fell_gclk $stable_gclk $changed_gclk
, , , , and are described
$future_gclk $rising_gclk $falling_gclk $steady_gclk $changing_gclk
in 16.9.4.
20.14 Coverage system functions
SystemVerilog has several built-in system functions for obtaining test coverage information:
$coverage_
, , , , and . The
control $coverage_get_max $coverage_get $coverage_merge $coverage_save
coverage system functions are described in 40.3.2.
System tasks and system functions are also provided to help manage coverage data collection and reporting:
, , and . The coverage data system tasks
$set_coverage_db_name $load_coverage_db $get_coverage
and system functions are described in 19.9.
20.15 Probabilistic distribution functions
Constrained pseudo-random value generation (see Clause18) uses the method and two special
.randomize
system functions, and (see 18.13).
$urandom $urandom_range
In addition to the constrained random value generation discussed in Clause18, SystemVerilog provides a set
of RNGs that return integer values distributed according to standard probabilistic functions. These are:
, , , , ,
$random $dist_uniform $dist_normal $dist_exponential $dist_poisson
, , and .
$dist_chi_square $dist_t $dist_erlang
The value generation algorithm for these system functions is part of this standard, ensuring repeatable
random value sets across different implementations. The C source code for this algorithm is included in
AnnexN.
20.15.1 $random function
The syntax for the system function is shown in Syntax20-14.
$random
615
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
random_function ::=
[ seed ]
$random ( )
Syntax20-14—Syntax for $random (not in AnnexA)
The system function provides a mechanism for generating random numbers. The function returns
$random
a new 32-bit random number each time it is called. The random number is a signed integer; it can be positive
or negative. For further information on probabilistic RNGs, see 20.15.2.
The argument controls the numbers that returns so that different seeds generate different
seed $random
random streams. The argument shall be an integral variable. The seed value should be assigned to this
seed
variable prior to calling .
$random
Example 1: Where is greater than , the expression gives a number in the following
b 0 ($random % b)
range: .
[(-b+1):(b-1)]
The following code fragment shows an example of random number generation between –59 and 59:
int randvar;
randvar = $random % 60;
Example 2: The following example shows how adding the concatenation operator to the preceding example
gives a positive value from to :
randvar 0 59
int randvar;
randvar = {$random} % 60;
20.15.2 Distribution functions
The syntax for the probabilistic distribution functions is shown in Syntax20-15.
dist_functions ::=
seed start end
$dist_uniform ( , , )
| seed mean standard_deviation
$dist_normal ( , , )
| seed mean
$dist_exponential ( , )
| seed mean
$dist_poisson ( , )
| seed degree_of_freedom
$dist_chi_square ( , )
| seed degree_of_freedom
$dist_t ( , )
| seed k_stage mean
$dist_erlang ( , , )
Syntax20-15—Syntax for probabilistic distribution functions (not in AnnexA)
All arguments to the system functions are integer values. For the exponential, poisson, chi-square, t, and
erlang functions, the arguments , , and shall be greater than .
mean degree_of_freedom k_stage 0
Each of these functions returns a pseudo-random number whose characteristics are described by the function
name. In other words, returns random numbers uniformly distributed in the interval
$dist_uniform
specified by its arguments.
For each system function, the argument is an argument; that is, a value is passed to the
seed inout
function, and a different value is returned. The system functions shall always return the same value given the
616
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
same . This facilitates debugging by making the operation of the system repeatable. The
seed seed
argument should be an integral variable that is initialized by the user and only updated by the system
function so that the desired distribution is achieved.
In the function, the and arguments are integer inputs that bound the values
$dist_uniform start end
returned. The value should be smaller than the value.
start end
The argument, used by , , , and
mean $dist_normal $dist_exponential $dist_poisson
, is an integer input that causes the average value returned by the function to approach the
$dist_erlang
value specified.
The argument used with the function is an integer input that helps
standard_deviation $dist_normal
determine the shape of the density function. Larger numbers for spread the returned
standard_deviation
values over a wider range.
The argument used with the and functions is an
degree_of_freedom $dist_chi_square $dist_t
integer input that helps determine the shape of the density function. Larger numbers spread the returned
values over a wider range.
20.16 Stochastic analysis tasks and functions
This subclause describes a set of system tasks and system functions that manage queues. These tasks
facilitate implementation of stochastic queueing models.
The set of system tasks and system functions that create and manage queues follows:
q_id q_type max_length status
$q_initialize( , , , ) ;
q_id job_id inform_id status
$q_add( , , , ) ;
q_id job_id inform_id status
$q_remove( , , , ) ;
q_id status
$q_full( , )
q_id q_stat_code q_stat_value status
$q_exam( , , , ) ;
20.16.1 $q_initialize
The system task creates new queues. The argument is an integer input that shall
$q_initialize q_id
uniquely identify the new queue. The argument is an integer input. The value of the
q_type q_type
argument specifies the type of the queue as shown in Table20-9.
Table20-9—Types of queues of $q_type values
q_type value Type of queue
1 First-in, first-out
2 Last-in, first-out
The argument is an integer input that specifies the maximum number of entries allowed on the
max_length
queue. The success or failure of the creation of the queue is returned as an integer value in status. The error
conditions and corresponding values of status are described in Table20-11 in 20.16.6.
617
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
20.16.2 $q_add
The system task places an entry on a queue. The argument is an integer input that indicates to
$q_add q_id
which queue to add the entry. The argument is an integer input that identifies the job.
job_id
The argument is an integer input that is associated with the queue entry. Its meaning is user-
inform_id
defined. For example, the argument can represent execution time for an entry in a CPU model.
inform_id
The code reports on the success of the operation or error conditions as described in Table20-11.
status
20.16.3 $q_remove
The system task receives an entry from a queue. The argument is an integer input that
$q_remove q_id
indicates from which queue to remove. The argument is an integer output that identifies the entry
job_id
being removed. The argument is an integer output that the queue manager stored during
inform_id
. Its meaning is user-defined. The code reports on the success of the operation or error
$q_add status
conditions as described in Table20-11.
20.16.4 $q_full
The system function checks whether there is room for another entry on a queue. It returns when
$q_full 0
the queue is not full and when the queue is full. The code reports on the success of the operation
1 status
or error conditions as described in Table20-11.
20.16.5 $q_exam
The system task provides statistical information about activity at the queue . It returns a
$q_exam q_id
value in depending on the information requested in . The values of
q_stat_value q_stat_code
and the corresponding information returned in are described in Table20-10.
q_stat_code q_stat_value
The code reports on the success of the operation or error conditions as described in Table20-11.
status
Table20-10—Argument values for $q_exam system task
Value requested in Information received back
q_stat_code from q_stat_value
1 Current queue length
2 Mean interarrival time
3 Maximum queue length
4 Shortest wait time ever
5 Longest wait time for jobs still in the queue
6 Average wait time in the queue
618
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
20.16.6 Status codes
All of the queue management tasks and functions return an output status code. The status code values and
corresponding information are described in Table20-11.
Table20-11—Status code values
Status code values What it means
0 OK
1 Queue full, cannot add
2 Undefined q_id
3 Queue empty, cannot remove
4 Unsupported queue type, cannot create queue
5 Specified length <= 0, cannot create queue
6 Duplicate q_id, cannot create queue
7 Not enough memory, cannot create queue
20.17 Programmable logic array modeling system tasks
The modeling of programmable logic array (PLA) devices is provided by a group of system tasks. This
subclause describes the syntax and use of these system tasks and the formats of the logic array personality
file. The syntax for PLA modeling system task is shown in Syntax20-16.
pla_system_task ::=
array_type logic format memory_identifier input_terms output_terms
$ $ $ ( , , ) ;
array_type ::=
|
sync async
logic ::=
| | |
and or nand nor
format ::=
|
array plane
memory_identifier ::=
identifier
input_terms ::=
expression
output_terms ::=
variable_lvalue
Syntax20-16—Syntax for PLA modeling system task (not in AnnexA)
The input terms can be nets or variables whereas the output terms shall only be variables.
619
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The PLA syntax allows for the system tasks as shown in Table20-12.
Table20-12—PLA modeling system tasks
$async$and$array $sync$and$array $async$and$plane $sync$and$plane
$async$nand$array $sync$nand$array $async$nand$plane $sync$nand$plane
$async$or$array $sync$or$array $async$or$plane $sync$or$plane
$async$nor$array $sync$nor$array $async$nor$plane $sync$nor$plane
20.17.1 Array types
The modeling of both synchronous and asynchronous arrays is provided by the PLA system tasks. The
synchronous forms control the time at which the logic array shall be evaluated and the outputs shall be
updated. For the asynchronous forms, the evaluations are automatically performed whenever an input term
changes value or any word in the personality memory is changed.
For both the synchronous and asynchronous forms, the output terms are updated without any delay.
An example of an asynchronous system call is as follows:
wire a1, a2, a3, a4, a5, a6, a7;
logic b1, b2, b3;
wire [1:7] awire;
logic [1:3] breg;
$async$and$array(mem,{a1,a2,a3,a4,a5,a6,a7},{b1,b2,b3});
or
$async$and$array(mem,awire, breg);
An example of a synchronous system call is as follows:
$sync$or$plane(mem,{a1,a2,a3,a4,a5,a6,a7}, {b1,b2,b3});
20.17.2 Array logic types
The logic arrays are modeled with and, or, nand, and nor logic planes. This applies to all array types and
formats.
An example of a nor plane system call is as follows:
$async$nor$plane(mem,{a1,a2,a3,a4,a5,a6,a7},{b1,b2,b3});
An example of a nand plane system call is as follows:
$sync$nand$plane(mem,{a1,a2,a3,a4,a5,a6,a7}, {b1,b2,b3});
20.17.3 Logic array personality declaration and loading
The logic array personality is declared as an array of variables that is as wide as the number of input terms
and as deep as the number of output terms.
620
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The personality of the logic array is normally loaded into the memory from a text data file using the system
tasks or (see 21.4). Alternatively, the personality data can be written directly into
$readmemb $readmemh
the memory using the procedural assignment statements. PLA personalities can be changed dynamically at
any time during simulation simply by changing the contents of the memory. The new personality shall be
reflected on the outputs of the logic array at the next evaluation.
The following example shows a logic array with input terms and output terms:
n m
logic [1:n] mem[1:m];
As shown in the examples in 20.17, PLA input terms, output terms, and memory shall be specified in
ascending order.
20.17.4 Logic array personality formats
Two separate personality formats are supported and are differentiated by using either an array system call or
a plane system call. The array system call allows for a or in the memory that has been declared. A
1 0
means take the input value, and a means do not take the input value.
1 0
The plane system call complies with the University of California at Berkeley format for Espresso.13 Each bit
of the data stored in the array has the following meaning:
— 0 Take the complemented input value.
— 1 Take the true input value.
— x Take the “worst case” of the input value.
— z Do-not-care; the input value is of no significance.
— ? Same as z.
Example 1: The following example illustrates an array with logic equations:
b1 = a1 & a2
b2 = a3 & a4 & a5
b3 = a5 & a6 & a7
The PLA personality is as follows:
1100000 in mem[1]
0011100 in mem[2]
0000111 in mem[3]
The module for the PLA is as follows:
module async_array(a1,a2,a3,a4,a5,a6,a7,b1,b2,b3);
input a1, a2, a3, a4, a5, a6, a7 ;
output b1, b2, b3;
logic [1:7] mem[1:3]; // memory declaration for array personality
logic b1, b2, b3;
initial begin
// set up the personality from the file array.dat
$readmemb("array.dat", mem);
// set up an asynchronous logic array with the input
// and output terms expressed as concatenations
$async$and$array(mem,{a1,a2,a3,a4,a5,a6,a7},{b1,b2,b3});
end
endmodule
13Information on Espresso can be found at http://embedded.eecs.berkeley.edu/pubs/downloads/espresso/index.htm.
621
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Where the file contains the binary data for the PLA personality:
array.dat
1100000
0011100
0000111
A synchronous version of this example has the following description:
module sync_array(a1,a2,a3,a4,a5,a6,a7,b1,b2,b3,clk);
input a1, a2, a3, a4, a5, a6, a7, clk;
output b1, b2, b3;
logic [1:7] mem[1:3]; // memory declaration
logic b1, b2, b3;
initial begin
// set up the personality
$readmemb("array.dat", mem);
// set up a synchronous logic array to be evaluated
// when a positive edge on the clock occurs
forever @(posedge clk)
$async$and$array(mem,{a1,a2,a3,a4,a5,a6,a7},{b1,b2,b3});
end
endmodule
Example 2: An example of the usage of the plane format tasks follows. The logical function of this PLA is
shown first, followed by the PLA personality in the new format, the SystemVerilog description using the
system task, and finally the result of running the simulation.
$async$and$plane
The logical function of the PLA is as follows:
b[1] = a[1] & ~a[2];
b[2] = a[3];
b[3] = ~a[1] & ~a[3];
b[4] = 1;
The PLA personality is as follows:
3'b10?
3'b??1
3'b0?0
3'b???
An example of using the system task is as follows:
$async$and$plane
module pla;
`define rows 4
`define cols 3
logic [1:`cols] a, mem[1:`rows];
logic [1:`rows] b;
initial begin
// PLA system call
$async$and$plane(mem,a[1:3],b[1:4]);
mem[1] = 3'b10?;
mem[2] = 3'b??1;
mem[3] = 3'b0?0;
mem[4] = 3'b???;
// stimulus and display
#10 a = 3'b111;
622
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#10 $displayb(a, " -> ", b);
#10 a = 3'b000;
#10 $displayb(a, " -> ", b);
#10 a = 3'bxxx;
#10 $displayb(a, " -> ", b);
#10 a = 3'b101;
#10 $displayb(a, " -> ", b);
end
endmodule
The output is as follows:
111 -> 0101
000 -> 0011
xxx -> xxx1
101 -> 1101
20.18 Miscellaneous tasks and functions
20.18.1 $system
The syntax for is shown in Syntax20-17.
$system
system_call ::=
[ terminal_command_line ]
$system ( " " )
Syntax20-17—$system function syntax (not in AnnexA)
makes a call to the C function system(). The C function executes the argument passed to it as if the
$system
argument was executed from the terminal. can be called as either a task or a function. When called
$system
as a function, it returns the return value of the call to system() with data type . If is called with
int $system
no string argument, the C function system() will be called with the NULL string.
The following example calls as a task to rename a file.
$system
module top;
initial $system("mv design.v adder.v");
endmodule
623
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
21. Input/output system tasks and system functions
21.1 General
This clause describes input/output (I/O) system tasks and system functions. These system tasks and system
functions are divided into several categories as follows:
Display tasks (21.2) Memory load tasks (21.4)
$display $write $readmemb $readmemh
$displayb $writeb
$displayh $writeh
Memory dump tasks (21.5)
$displayo $writeo
$strobe $monitor $writememb $writememh
$strobeb $monitorb
$strobeh $monitorh Command line input (21.6)
$strobeo $monitoro
$test$plusargs $value$plusargs
$monitoroff
$monitoron
VCD tasks (21.7)
File I/O tasks and functions (21.3) $dumpfile $dumpvars
$dumpoff $dumpon
$fclose $fopen
$dumpall $dumplimit
$fdisplay $fwrite
$dumpflush $dumpports
$fdisplayb $fwriteb
$dumpportsoff $dumpportson
$fdisplayh $fwriteh
$dumpportsall $dumpportslimit
$fdisplayo $fwriteo
$dumpportsflush
$fstrobe $fmonitor
$fstrobeb $fmonitorb
$fstrobeh $fmonitorh
$fstrobeo $fmonitoro
$swrite $sformat
$swriteb $sformatf
$swriteh $fgetc
$swriteo $ungetc
$fscanf $fgets
$fread $sscanf
$fseek $rewind
$fflush $ftell
$feof $ferror
21.2 Display system tasks
The display group of system tasks is divided into three categories: the display and write tasks, strobed
monitoring tasks, and continuous monitoring tasks.
21.2.1 The display and write tasks
The syntax for and system tasks is shown in Syntax21-1.
$display $write
624
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
display_tasks ::=
display_task_name [ list_of_arguments ]
( ) ;
display_task_name ::=
| | |
$display $displayb $displayo $displayh
| | | |
$write $writeb $writeo $writeh
Syntax21-1—Syntax for $display and $write system tasks (not in AnnexA)
These are the main system task routines for displaying information. The two sets of tasks are identical
except that automatically adds a newline character to the end of its output, whereas the
$display $write
task does not.
The and tasks display their arguments in the same order as they appear in the argument
$display $write
list. Each argument can be a quoted string literal, an expression that returns a value, or an empty argument.
(An empty argument is characterized by two adjacent commas in the argument list.) Any argument
expression of either a data type or an unpacked array of data type that has no corresponding
string byte
format specification shall be formatted as a character string. Any expression argument of any other
unpacked data type that has no corresponding format specification shall be illegal.
The contents of string literal arguments are output literally except when certain escape sequences are
inserted to display special characters or to specify the display format for a subsequent expression.
Escape sequences are inserted into a string in the following three ways:
— The special character indicates that the character to follow is a literal or nonprintable character
\
(see Table21-1).
— The special character indicates that the next character should be interpreted as a format
%
specification that establishes the display format for a subsequent expression argument (see
Table21-2). For each character (except , , and ) that appears in a string, a corresponding
% %m %l %%
expression argument shall be supplied after the string.
— The special character string indicates the display of the percent sign character (see Table21-1).
%% %
An empty argument produces a single space character in the display.
The task, when invoked without arguments, simply prints a newline character. A task
$display $write
supplied without arguments prints nothing at all.
21.2.1.1 Escape sequences for special characters
The escape sequences given in Table21-1, when included in a string argument, cause special characters to
be displayed.
Table21-1—Escape sequences for printing special characters
Escape string Character produced by escape string
\n Newline character
\t Tab character
\\ \ character
\" " character
625
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table21-1—Escape sequences for printing special characters (continued)
Escape string Character produced by escape string
\v Vertical tab
\f Form feed
\a Bell
%% % character
\ddd A character specified in 1 to 3 octal digits, where 0  d  7.
If fewer than three characters are used, the following character shall not be an octal digit.
Implementations may issue an error if the character represented is greater than \377.
\xdd A character specified in 2 hexadecimal digits, where 0  d  F
For example:
module disp;
initial begin
$display("\\\t\\\n\"\123");
end
endmodule
Simulating this example shall display the following:
\ \
"S
An escaped character not appearing in Table21-1 shall cause the character to be printed by itself. For
example, a string argument “ ” shall print simply “ ”.
\b b
21.2.1.2 Format specifications
Table21-2 shows the escape sequences used for format specifications. Each escape sequence, when
included in a string literal argument, specifies the display format for a subsequent expression. For each
%
character (except , , and ) that appears in a string literal, a corresponding expression shall follow the
%m %l %%
string in the argument list. The value of the expression replaces the format specification when the string is
displayed. It shall be an error if an undefined format specifier appears in a string literal argument.
Any expression argument that has no corresponding format specification is displayed using the default
decimal format in and , binary format in and , octal format in
$display $write $displayb $writeb
and , and hexadecimal format in and .
$displayo $writeo $displayh $writeh
Table21-2—Escape sequences for format specifications
Argument Description
%h or %H Display in hexadecimal format
%x or %X
%d or %D Display in decimal format
%o or %O Display in octal format
%b or %B Display in binary format
626
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table21-2—Escape sequences for format specifications (continued)
Argument Description
%c or %C Display in ASCII character format
%l or %L Display library binding information
%v or %V Display net signal strength
%m or %M Display hierarchical name
%p or %P Display as an assignment pattern
%s or %S Display as a string
%t or %T Display in current time format
%u or %U Unformatted 2 value data
%z or %Z Unformatted 4 value data
The integer format specifiers, , , , , , , , and (uppercase or lowercase), may be used with
%h %x %d %o %b %c %u %z
any of the SystemVerilog integral data types, including enumerated types and packed aggregate data types.
These format specifiers can also be used with user-defined types that have been defined (using ) to
typedef
be represented using one of these basic types. They shall not be used with any unpacked aggregate type.
The formatting specification (or ) is defined for displaying the library information of the specific
%l %L
module. This information shall be displayed as corresponding to the library name from
"library.cell"
which the current module instance was extracted and the cell name of the current module instance. See
Clause33 for information on libraries and configuring designs.
The formatting specification (or ) is defined for writing data without formatting (binary values). The
%u %U
application shall transfer the 2 value binary representation of the specified data to the output stream. This
escape sequence can be used with any of the existing display system tasks, although (see 21.3.2)
$fwrite
should be the preferred one to use. Any unknown or high-impedance bits in the source shall be treated as
zero. This formatting specifier is intended to be used to support transferring data to and from external
programs that have no concept of and . Applications that require preservation of and are encouraged
x z x z
to use the I/O format specification.
%z
— For packed data, and are defined to operate as though the operation were applied to the equiv-
%u %z
alent vector.
— For unpacked struct data, and are defined to apply as though the operation were performed on
%u %z
each member in declaration order.
— For unpacked union data, and are defined to apply as though the operation were performed on
%u %z
the first member in declaration order.
— and are not defined on unpacked arrays.
%u %z
— The count of data items read by a or for an aggregate type is always either 1 or 0; the individ-
%u %z
ual members are not counted separately.
The data shall be written to the file in the native endian format of the underlying system [i.e., in the same
endian order as if the PLI was used and the C language system call was used]. The data shall be
write(2)
written in units of 32 bits with the word containing the LSB written first.
NOTE 1—For POSIX applications, it might be necessary to open files for unformatted I/O with the , , or
wb wb+ w+b
specifiers to avoid the systems implementation of I/O altering patterns in the unformatted stream that match special
characters.
627
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The formatting specification (or ) is defined for writing data without formatting (binary values). The
%z %Z
application shall transfer the 4 value binary representation of the specified data to the output stream. This
escape sequence can be used with any of the existing display system tasks, although (see 21.3.2)
$fwrite
should be the preferred one to use.
This formatting specifier is intended to be used to support transferring data to and from external programs
that recognize and support the concept of and . Applications that do not require the preservation of and
x z x
are encouraged to use the I/O format specification.
z %u
The data shall be written to the file in the native endian format of the underlying system [i.e., in the same
endian order as if the PLI was used, the data were in a structure (see Figure38-8 in 38.15),
s_vpi_vecval
and the C language system call was used to write the structure to disk]. The data shall be written
write(2)
in units of 32 bits with the structure containing the LSB written first.
NOTE 2—For POSIX applications, it might be necessary to open files for unformatted I/O with the , , or
wb wb+ w+b
specifiers to avoid the systems implementation of I/O altering patterns in the unformatted stream that match special
characters.
The format specifications in Table21-3 are used with real numbers (i.e., and types) and
real shortreal
have the full formatting capabilities available in the C language. For example, the format specification
specifies a minimum field width of 10 with 3 fractional digits.
%10.3g
Table21-3—Format specifications for real numbers
Argument Description
%e or %E Display real numbers in an exponential format
%f or %F Display real numbers in a decimal format
%g or %G Display real numbers in exponential or decimal format,
whichever format results in the shorter printed output
The net signal strength, hierarchical name, assignment pattern, and string format specifications are described
in 21.2.1.5 through 21.2.1.8.
The format specification works with the system task to specify a uniform time unit, time
%t $timeformat
precision, and format for reporting timing information from various modules that use different time units
and precisions. The task is described in 20.4.2.
$timeformat
For example:
module disp;
logic [31:0] rval;
pulldown (pd);
initial begin
rval = 101;
$display("rval = %h hex %d decimal",rval,rval);
$display("rval = %o octal\nrval = %b bin",rval,rval);
$display("rval has %c ascii character value",rval);
$display("pd strength value is %v",pd);
$display("current scope is %m");
$display("%s is ascii value for 101",101);
$display("simulation time is %t", $time);
end
endmodule
628
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Simulating this example shall display the following:
rval = 00000065 hex 101 decimal
rval = 00000000145 octal
rval = 00000000000000000000000001100101 bin
rval has e ascii character value
pd strength value is StX
current scope is disp
e is ascii value for 101
simulation time is 0
21.2.1.3 Size of displayed data
For expression arguments, the values written to the output file (or terminal) are sized automatically.
For example, the result of a 12-bit expression would be allocated three characters when displayed in
hexadecimal format and four characters when displayed in decimal format because the largest possible value
for the expression is FFF (hexadecimal) and 4095 (decimal).
When displaying decimal values, leading zeros are suppressed and replaced by spaces. In other radices,
leading zeros are always displayed.
The automatic sizing of displayed data can be overridden by inserting a field width between the character
%
and the letter that indicates the radix. The field width shall be a non-negative decimal integer constant. If the
field width is 0, the result is displayed in the minimum width, with no leading spaces or zeros, as shown in
the following example:
$display("d=%0h a=%0h", data, addr);
For example:
module printval;
logic [11:0] r1;
initial begin
r1 = 10;
$display( "Printing with maximum size - :%d: :%h:", r1,r1 );
$display( "Printing with minimum size - :%0d: :%0h:", r1,r1 );
end
endmodule
This example will print:
Printing with maximum size - : 10: :00a:
Printing with minimum size - :10: :a:
In this example, the result of a 12-bit expression is displayed. The first call to uses the standard
$display
format specifier syntax and produces results requiring four and three columns for the decimal and
hexadecimal radices, respectively. The second call uses the form of the format specifier
$display %0
syntax and produces results requiring two columns and one column, respectively.
If the value to be displayed has fewer characters than the field width, the field is padded on the left to the
length specified by the field width. If the value is wider than the field width, the field is expanded to contain
the converted result. Decimal and string values are expanded with leading spaces while hexadecimal, octal,
and binary values use leading zeros. No truncation occurs.
629
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Examples:
Format Value Displays
%d 32'd10 : 10:
%0d 32'd10 :10:
%h 32'd10 :0000000a:
%0h 32'd10 :a:
%3d 32'd5 : 5:
%3d 32'd100 :100:
%3d 32'd1234 :1234:
%3h 32'h5 :005:
%3h 32'h100 :100:
%3h 32'h1234 :1234:
%s "abc" :abc:
%3s "a" : a:
%3s "abc" :abc:
%3s "abcdef" :abcdef:
21.2.1.4 Unknown and high-impedance values
When the result of an expression contains an unknown or high-impedance value, certain rules apply to
displaying that value.
In decimal ( ) format, the rules are as follows:
%d
— If all bits are at the unknown value, a single lowercase character is displayed.
x
— If all bits are at the high-impedance value, a single lowercase character is displayed.
z
— If some, but not all, bits are at the unknown value, the uppercase character is displayed.
X
— If some, but not all, bits are at the high-impedance value, the uppercase character is displayed,
Z
unless there are also some bits at the unknown value, in which case the uppercase character is
X
displayed.
— Decimal numerals always appear right-justified in a fixed-width field.
In hexadecimal ( , ) and octal ( ) formats, the rules are as follows:
%h %x %o
— Each group of 4 bits is represented as a single hexadecimal digit; each group of 3 bits is represented
as a single octal digit.
— If all bits in a group are at the unknown value, a lowercase is displayed for that digit.
x
— If all bits in a group are at a high-impedance state, a lowercase is printed for that digit.
z
— If some, but not all, bits in a group are unknown, an uppercase is displayed for that digit.
X
— If some, but not all, bits in a group are at a high-impedance state, then an uppercase is displayed
Z
for that digit, unless there are also some bits at the unknown value, in which case an uppercase is
X
displayed for that digit.
In binary ( ) format, each bit is printed separately using the characters , , , and .
%b 0 1 x z
For example:
STATEMENT RESULT
$display("%d", 1'bx); x
$display("%h", 14'bx01010); xxXa
$display("%h %o", 12'b001xxx101x01,
12'b001xxx101x01); XXX 1x5X
630
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
21.2.1.5 Strength format
The format specification is used to display the strength of scalar nets. For each specification that
%v %v
appears in a string, a corresponding scalar reference shall follow the string in the argument list.
The strength of a scalar net is reported in a three-character format. The first two characters indicate the
strength. The third character indicates the current logic value of the scalar and can be any one of the values
given in Table21-4.
Table21-4—Logic value component of strength format
Argument Description
0 For a logic 0 value
1 For a logic 1 value
X For an unknown value
Z For a high-impedance value
L For a logic 0 or high-impedance value
H For a logic 1 or high-impedance value
The first two characters—the strength characters—are either a two-letter mnemonic or a pair of decimal
digits. Usually, a mnemonic is used to indicate strength information; however, in less typical cases, a pair of
decimal digits can be used to indicate a range of strength levels. Table21-5 shows the mnemonics used to
represent the various strength levels.
Table21-5—Mnemonics for strength levels
Mnemonic Strength name Strength level
Su Supply drive 7
St Strong drive 6
Pu Pull drive 5
La Large capacitor 4
We Weak drive 3
Me Medium capacitor 2
Sm Small capacitor 1
Hi High impedance 0
There are four driving strengths and three charge storage strengths. The driving strengths are associated with
gate outputs and continuous assignment outputs. The charge storage strengths are associated with the
type net. (See Clause28 for strength modeling.)
trireg
For the logic values and , a mnemonic is used when there is no range of strengths in the signal.
0 1
Otherwise, the logic value is preceded by two decimal digits, which indicate the maximum and minimum
strength levels.
631
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For the unknown value, a mnemonic is used when both the and strength components are at the same
0 1
strength level. Otherwise, the unknown value is preceded by two decimal digits, which indicate the and
X 0
strength levels, respectively.
1
The high-impedance strength cannot have a known logic value; the only logic value allowed for this level is
.
Z
For the values and , a mnemonic is always used to indicate the strength level.
L H
For example:
always
#15 $display($time,,"group=%b signals=%v %v %v",{s1,s2,s3},s1,s2,s3);
The following example shows the output that might result from such a call, while Table21-6 explains the
various strength formats that appear in the output.
0 group=111 signals=St1 Pu1 St1
15 group=011 signals=Pu0 Pu1 St1
30 group=0xz signals=520 PuH HiZ
45 group=0xx signals=Pu0 65X StX
60 group=000 signals=Me0 St0 St0
Table21-6—Explanation of strength formats
Argument Description
St1 A strong driving 1 value
Pu0 A pull driving 0 value
HiZ The high-impedance state
Me0 A 0 charge storage of medium capacitor strength
StX A strong driving unknown value
PuH A pull driving strength of 1 or high-impedance value
65X An unknown value with a strong driving 0 component and a pull driving 1 component
520 An 0 value with a range of possible strength from pull driving to medium capacitor
21.2.1.6 Hierarchical name format
The format specifier does not accept an argument. Instead, it causes the display task to print the
%m
hierarchical name of the design element, subroutine, named block, or labeled statement that invokes the
system task containing the format specifier. This is useful when there are many instances of the module that
calls the system task. One obvious application is timing check messages in a flip-flop or latch module; the
format specifier pinpoints the module instance responsible for generating the timing check message.
%m
21.2.1.7 Assignment pattern format
The format specifier may be used to print aggregate expressions such as unpacked structures, arrays, and
%p
unions. For unpacked structure data types, it shall print the value as an assignment pattern with named
elements. For unions, only the first declared elements shall be printed. In the case of a tagged union, it shall
print “tag:value” along with the currently valid element. For unpacked array data types, it shall print the
632
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
value as an assignment pattern, which may include the use of index labels. The use of white space is
implementation dependent; however the output shall be a legal interpretation of the assignment pattern
syntax (see 10.8).
An unpacked data type is traversed until reaching a singular data type. Each element that is a singular type
shall print its value as follows:
— A packed structure data type shall print its value as an assignment pattern with named elements.
Each element shall be printed under one of these rules.
— An enumerated data type shall print its value as an enumeration name if the value is valid for that
type. Otherwise the value shall print according to the base type of the enumeration.
— A string data type or string literal shall print its value as a string enclosed in quotes.
— A chandle, class handle, interface class handle, event, or virtual interface shall print its value in an
implementation-dependent format, except that a null handle value shall print the word .
null
— All other singular data types shall print their values as they would unformatted.
An implementation may use a “default” element to reduce its output and may set a limit on the maximum
length of characters output, but that limit shall be at least 1024 characters. If that limit is reached, the output
shall be truncated and a warning issued.
The format specifier may be used to print aggregate expressions such as unpacked structures, arrays,
%0p
and unions in a shorter, implementation-specific form. An implementation may set a limit on the maximum
length of characters output as with .
%p
The and format specifiers can also be used to print singular expressions, in which case the
%p %0p
expression is formatted as an element of an aggregate expression previously described.
For example:
module top;
typedef enum {ON, OFF} switch_e;
typedef struct {switch_e sw; string s;} pair_t;
pair_t va[int] = '{10:'{OFF, "switch10"}, 20:'{ON, "switch20"}};
initial begin
$display("va[int] = %p;",va);
$display("va[int] = %0p;",va);
$display("va[10].s = %p;", va[10].s);
end
endmodule : top
This example may print:
va[int] = '{10:'{sw:OFF, s:"switch10"}, 20:'{sw:ON, s:"switch20"}} ;
va[int] = '{10:'{OFF, "switch10"}, 20:'{ON, "switch20"}} ;
va[10].s = "switch10";
21.2.1.8 String format
The format specifier is used to print ASCII codes as characters. For each specification that appears in
%s %s
a string, a corresponding argument shall follow the string in the argument list. The associated argument is
interpreted as a sequence of 8-bit hexadecimal ASCII codes, with each 8 bits representing a single character.
If the argument is a variable, its value should be right-justified so that the rightmost bit of the value is the
LSB of the last character in the string. No termination character or value is required at the end of a string,
and leading zeros are never printed.
633
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The argument corresponding to a % format specifier may also have a type or unpacked array of
s string
data types. Character ordering of the unpacked array is from left bound to right bound.
byte
21.2.2 Strobed monitoring
The syntax for system task is shown in Syntax21-2.
$strobe
strobe_tasks ::=
strobe_task_name [ list_of_arguments ]
( ) ;
strobe_task_name ::=
| | |
$strobe $strobeb $strobeo $strobeh
Syntax21-2—Syntax for $strobe system tasks (not in AnnexA)
The system task provides the ability to display simulation data at a selected time. That time is the
$strobe
end of the current simulation time, when all the simulation events have occurred for that simulation time,
just before simulation time is advanced. The arguments for this task are specified in exactly the same
manner as for the system task—including the use of escape sequences for special characters and
$display
format specifications (see 21.2.1).
For example:
forever @(negedge clock)
$strobe ("At time %d, data is %h",$time,data);
In this example, writes the time and data information to the standard output and the log file at each
$strobe
negative edge of the clock. The action shall occur just before simulation time is advanced and after all other
events at that time have occurred so that the data written are sure to be the correct data for that simulation
time.
21.2.3 Continuous monitoring
The syntax for system task is shown in Syntax21-3.
$monitor
monitor_tasks ::=
monitor_task_name [ list_of_arguments ]
( ) ;
|
$monitoron ;
|
$monitoroff ;
monitor_task_name ::=
| | |
$monitor $monitorb $monitoro $monitorh
Syntax21-3—Syntax for $monitor system tasks (not in AnnexA)
The task provides the ability to monitor and display the values of any variables or expressions
$monitor
specified as arguments to the task. The arguments for this task are specified in exactly the same manner as
for the system task—including the use of escape sequences for special characters and format
$display
specifications (see 21.2.1).
When a task is invoked with one or more arguments, the simulator sets up a mechanism whereby
$monitor
each time a variable or an expression in the argument list changes value—with the exception of the ,
$time
, or system functions—the entire argument list is displayed at the end of the time step as
$stime $realtime
634
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
if reported by the task. If two or more arguments change value at the same time, only one display
$display
is produced that shows the new values.
Only one display list can be active at any one time; however, a new task with a new
$monitor $monitor
display list can be issued any number of times during simulation.
The and tasks control a monitor flag that enables and disables the monitoring.
$monitoron $monitoroff
Use to turn off the flag and disable monitoring. The system task can be used to
$monitoroff $monitoron
turn on the flag so that monitoring is enabled and the most recent call to can resume its display.
$monitor
A call to shall produce a display immediately after it is invoked, regardless of whether a value
$monitoron
change has taken place; this is used to establish the initial values at the beginning of a monitoring session.
By default, the monitor flag is turned on at the beginning of simulation.
21.3 File input/output system tasks and system functions
The system tasks and system functions for file-based operations are divided into the following categories:
— System tasks and system functions that open and close files
— System tasks that output values into files
— System tasks that output values into variables
— System tasks and system functions that read values from files and load into variables or memories
21.3.1 Opening and closing files
The syntax for $fopen and $fclose system tasks is shown in Syntax21-4.
file_open_function ::=
multi_channel_descriptor = filename
$fopen( ) ;
| fd = filename type
$fopen( , ) ;
file_close_task ::=
multi_channel_descriptor
$fclose( ) ;
| fd
$fclose( ) ;
Syntax21-4—Syntax for $fopen and $fclose system tasks (not in AnnexA)
The function $fopen opens the file specified as the filename argument and returns either a 32-bit
multichannel descriptor or a 32-bit file descriptor, determined by the absence or presence of the type
argument.
filename is an expression that is a string literal, data type, or an integral data type containing a
string
character string that names the file to be opened.
type is an expression that is a string literal, data type, or an integral data type containing a character
string
string of one of the forms in Table21-7 that indicates how the file should be opened. If type is omitted, the
file is opened for writing, and a multichannel descriptor mcd is returned. If type is supplied, the file is
opened as specified by the value of type, and a file descriptor fd is returned.
635
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table21-7—Types for file descriptors
Argument Description
"r" or "rb" Open for reading
"w" or "wb" Truncate to zero length or create for writing
"a" or "ab" Append; open for writing at end of file (EOF), or create for writing
"r+", "r+b", or "rb+" Open for update (reading and writing)
"w+", "w+b", or "wb+" Truncate or create for update
"a+", "a+b", or "ab+" Append; open or create for update at EOF
The multichannel descriptor mcd is a 32-bit packed array value in which a single bit is set indicating which
file is opened. The LSB (bit 0) of an always refers to the standard output. Output is directed to two or
mcd
more files opened with multichannel descriptors by bitwise OR-ing together their s and writing to the
mcd
resultant value.
The MSB (bit 31) of a multichannel descriptor is reserved and shall always be cleared, limiting an
implementation to at most 31 files opened for output via multichannel descriptors.
The file descriptor fd is a 32-bit packed array value. The MSB (bit 31) of a is reserved and shall always
fd
be set; this allows implementations of the file input and output functions to determine how the file was
opened. The remaining bits hold a small number indicating what file is opened. Three file descriptors are
pre-opened; they are STDIN, STDOUT, and STDERR, which have the values ,
32'h8000_0000
, and , respectively. STDIN is pre-opened for reading, and STDOUT and
32'h8000_0001 32'h8000_0002
STDERR are pre-opened for append.
Unlike multichannel descriptors, file descriptors cannot be combined via bitwise OR in order to direct
output to multiple files. Instead, files are opened via file descriptor for input, output, and both input and
output, as well as for append operations, based on the value of type, according to Table21-7.
If a file cannot be opened (either the file does not exist and the type specified is , , , , or
"r" "rb" "r+" "r+b"
, or the permissions do not allow the file to be opened at that path), a zero is returned for the or
"rb+" mcd
. Applications can call to determine the cause of the most recent error (see 21.3.7).
fd $ferror
The in the preceding types exists to distinguish binary files from text files. Many systems make no
"b"
distinction between binary and text files, and on these systems the is ignored. However, some systems
"b"
perform data mappings on certain binary values written to and read from files that are opened for text access.
The system task closes the file specified by fd or closes the file(s) specified by the multichannel
$fclose
descriptor mcd. No further output to or input from any file descriptor(s) closed by is allowed.
$fclose
Active and/or operations on a file descriptor or multichannel descriptor are
$fmonitor $fstrobe
implicitly cancelled by an operation. The function shall reuse channels that have been
$fclose $fopen
closed.
NOTE—The number of simultaneous input and output channels that can be open at any one time is dependent on the
operating system. Some operating systems do not support opening files for update.
21.3.2 File output system tasks
The syntax for , , , and system tasks is shown in Syntax21-5.
$fdisplay $fwrite $fmonitor $fstrobe
636
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
file_output_tasks ::=
file_output_task_name multi_channel_descriptor [ list_of_arguments ]
( , );
| file_output_task_name fd [ list_of_arguments ]
( , );
file_output_task_name ::=
| | |
$fdisplay $fdisplayb $fdisplayh $fdisplayo
| | | |
$fwrite $fwriteb $fwriteh $fwriteo
| | | |
$fstrobe $fstrobeb $fstrobeh $fstrobeo
| | | |
$fmonitor $fmonitorb $fmonitorh $fmonitoro
Syntax21-5—Syntax for file output system tasks (not in AnnexA)
Each of the four formatted display tasks— , , , and —has a
$display $write $monitor $strobe
counterpart that writes to specific files as opposed to the standard output. These counterpart tasks—
, , and —accept the same type of arguments as the tasks upon
$fdisplay $fwrite,$fmonitor $fstrobe
which they are based, with one exception: The first argument shall be either a multichannel descriptor or a
file descriptor, which indicates where to direct the file output. Multichannel descriptors are described in
detail in 21.3.1. A multichannel descriptor is either a variable or the result of an expression that takes the
form of a 32-bit unsigned integer value.
The and system tasks work just like their counterparts, and ,
$fstrobe $fmonitor $strobe $monitor
except that they write to files using the multichannel descriptor for control. Unlike , any number
$monitor
of tasks can be set up to be simultaneously active. However, there is no counterpart to
$fmonitor
and tasks. The task is used to cancel an active or
$monitoron $monitoroff $fclose $fstrobe
task.
$fmonitor
The following example shows how to set up multichannel descriptors. In this example, three different
channels are opened using the function. The three multichannel descriptors that are returned by the
$fopen
function are then combined in a bitwise OR operation and assigned to the integer variable . The
messages
variable can then be used as the first argument in a file output task to direct output to all three
messages
channels at once. To create a descriptor that directs output to the standard output as well, the
messages
variable is a bitwise OR with the constant , which effectively enables channel 0.
1
integer
messages, broadcast,
cpu_chann, alu_chann, mem_chann;
initial begin
cpu_chann = $fopen("cpu.dat");
if (cpu_chann == 0) $finish;
alu_chann = $fopen("alu.dat");
if (alu_chann == 0) $finish;
mem_chann = $fopen("mem.dat");
if (mem_chann == 0) $finish;
messages = cpu_chann | alu_chann | mem_chann;
// broadcast includes standard output
broadcast = 1 | messages;
end
endmodule
The following file output tasks show how the channels opened in the preceding example might be used:
$fdisplay( broadcast, "system reset at time %d", $time );
$fdisplay( messages, "Error occurred on address bus",
637
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
" at time %d, address = %h", $time, address );
forever @(posedge clock)
$fdisplay( alu_chann, "acc= %h f=%h a=%h b=%h", acc, f, a, b );
21.3.3 Formatting data to a string
The syntax for the family of tasks and for system task is shown in Syntax21-6.
$swrite $sformat
string_output_tasks ::=
string_output_task_name output_var [ list_of_arguments ]
( , ) ;
string_output_task_name ::=
| | |
$swrite $swriteb $swriteh $swriteo
variable_format_string_output_task ::=
output_var format_string [ list_of_arguments ]
$sformat ( , , ) ;
variable_format_string_output_function ::=
format_string [ list_of_arguments ]
$sformatf ( , )
Syntax21-6—Syntax for formatting data tasks (not in AnnexA)
The family of tasks is based on the family of tasks and accepts the same type of
$swrite $fwrite
arguments as the tasks upon which it is based, with one exception: The first argument to shall be a
$swrite
variable of integral, unpacked array of , or data types to which the resulting string shall be
byte string
written, instead of a variable specifying the file to which to write the resulting string. Character ordering of
the unpacked array is from left bound to right bound.
The system task is similar to the system task , with one major difference. Unlike the
$sformat $swrite
display and write family of output system tasks, always interprets its second argument, and only
$sformat
its second argument, as a format string. This format argument can be a string literal, such as
, or may be an expression of integral, unpacked array of byte, or data types whose
"data is %d" string
content is interpreted as the formatting string. No other arguments are interpreted as format strings.
supports all the format specifiers supported by , as documented in 21.2.1.2.
$sformat $display
The remaining arguments to , if any, are processed using any format specifiers in the
$sformat
format_string, until all such format specifiers are used up. If not enough arguments are supplied for the
format specifiers or too many are supplied, then the application shall issue a warning and continue
execution. The application, if possible, can statically determine a mismatch in format specifiers and number
of arguments and issue a compile time error message.
NOTE—If the format_string is a not a constant expression, it might not be possible to determine its value at compile
time.
The variable output_var is assigned using the string literal assignment to variable rules, as specified in
11.10.
The system function behaves like except that the string result is passed back as the
$sformatf $sformat
function result value for , not placed in the first argument as for . Thus
$sformatf $sformat $sformatf
can be used where a string value would be valid.
638
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
21.3.4 Reading data from a file
file_read_functions ::=
fd
$fgetc( )
| c fd
$ungetc( , )
| str fd
$fgets( , )
| fd format args
$fscanf( , , )
| str format args
$sscanf( , , )
| integral_var fd
$fread( , )
| mem fd [ [ start ] [ count ] ]
$fread( , , , )
Syntax21-7—Syntax for file read system functions (not in AnnexA)
Files opened using file descriptors (fd) can be read from only if they were opened with either the or type
r r+
values. See 21.3.1 for more information about opening files.
21.3.4.1 Reading a character at a time
A single character can be read from a file using . For example:
$fgetc
Example 1:
integer c;
c = $fgetc ( fd );
reads a byte from the file specified by . If an error occurs reading from the file, then is set to ( ).
fd c EOF -1
The code defines the width of variable to be wider than 8 bits so that a return value from of
c $fgetc EOF
( ) can be differentiated from the character code . Applications can call to determine the
-1 0xFF $ferror
cause of the most recent error (see 21.3.7).
Example 2:
integer code;
code = $ungetc ( c, fd );
inserts the character specified by into the buffer specified by file descriptor . The character shall be
c fd c
returned by the next call on that file descriptor. The file itself is unchanged. If an error occurs
$fgetc
pushing a character onto a file descriptor, then code is set to . Otherwise, code is set to zero.
EOF
Applications can call to determine the cause of the most recent error (see 21.3.7).
$ferror
NOTE—The features of the underlying implementation of file I/O on the host system limit the number of characters that
can be pushed back onto a stream. Operations like $fseek might erase any pushed back characters.
21.3.4.2 Reading a line at a time
One line can be read from a file using . For example:
$fgets
integer code;
code = $fgets ( str, fd );
reads characters from the file specified by into the variable until is filled, or a newline character
fd str str
is read and transferred to , or an condition is encountered. If is not an integral number of bytes
str EOF str
in length, the most significant partial byte is not used in order to determine the size.
639
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If an error occurs reading from the file, then is set to zero. Otherwise, the number of characters read is
code
returned in . Applications can call to determine the cause of the most recent error (see
code $ferror
21.3.7).
21.3.4.3 Reading formatted data
The system function can be used to format data as it is read from a file. For example:
$fscanf
integer code ;
code = $fscanf ( fd, format, args );
code = $sscanf ( str, format, args );
reads from the files specified by the file descriptor .
$fscanf fd
reads from the argument , which may be an expression of integral, unpacked array of byte, or
$sscanf str
data type.
string
Both functions read characters, interpret them according to a format, and store the results. Both expect as
arguments a control string, , and a set of arguments specifying where to place the results. If there are
format
insufficient arguments for the format, the behavior is undefined. If the format is exhausted while arguments
remain, the excess arguments are ignored.
If an argument is too small to hold the converted input, then, in general, the LSBs are transferred. Arguments
of any length that are supported by SystemVerilog can be used. However, if the destination is ,
real
, or , then the value (or ) is transferred. The format can be an expression
shortreal realtime +Inf -Inf
containing a string, data type, or an integral data type. The string contains conversion specifications,
string
which direct the conversion of input into the arguments. The control string can contain the following:
a) White space characters (blanks, tabs, newlines, or formfeeds) that, except in one case described
below, cause input to be read up to the next nonwhite space character. For , null characters
$sscanf
shall also be considered white space.
b) An ordinary character (not ) that shall match the next character of the input stream.
%
c) Conversion specifications consisting of the character , an optional assignment suppression
%
character , a decimal digit string that specifies an optional numerical maximum field width, and a
*
conversion code.
A conversion specification directs the conversion of the next input field; the result is placed in the variable
specified in the corresponding argument unless assignment suppression was indicated by the character . In
*
this case, no argument shall be supplied.
The suppression of assignment provides a way of describing an input field that is to be skipped. An input
field is defined as a string of nonspace characters; it extends to the next inappropriate character or until the
maximum field width, if one is specified, is exhausted. For all descriptors except the character , white
c
space leading an input field is ignored. Table21-8 describes the input field characters for .
$fscanf
The integer format specifiers, (or ), (or ), (or ), (or ), (or ), (or ), and
%h %H %d %D %o %O %b %B %c %C %u %U %z
(or ), may be used to read into any of the integral data types, including enumerated data types and packed
%Z
aggregate data types. These format specifiers can also be used with user-defined data types that have been
defined (using ) to be represented using one of these basic types. They shall not be used with any
typedef
unpacked aggregate data type.
640
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table21-8—$fscanf input field characters
Input
Description
field
A single is expected in the input at this point; no assignment is done.
% %
Matches a binary number, consisting of a sequence from the set 0,1,X,x,Z,z,?, and _.
b
Matches a octal number, consisting of a sequence of characters from the set 0,1,2,3,4,5,6,7,X,x,Z,z,?,
o
and _.
Matches an optionally signed decimal number, consisting of the optional sign from the set + or –,
d
followed by a sequence of characters from the set 0,1,2,3,4,5,6,7,8,9, and _, or a single value from the
set x,X,z,Z,?.
or Matches a hexadecimal number, consisting of a sequence of characters from the set
h x
0,1,2,3,4,5,6,7,8,9,a,A,b,B,c,C,d,D,e,E,f,F,x,X,z,Z,?, and _.
, , or Matches a floating-point number. The format of a floating-point number is an optional sign (either + or
f e
–), followed by a string of digits from the set 0,1,2,3,4,5,6,7,8,9 optionally containing a decimal point
g
character (.), followed by an optional exponent part including e or E, followed by an optional sign,
followed by a string of digits from the set 0,1,2,3,4,5,6,7,8,9.
Matches a net signal strength, consisting of a three-character sequence as specified in 21.2.1.5. This
v
conversion is not extremely useful, as strength values are really only usefully assigned to nets and
can only assign values to integral variables (if assigned to integral variables, the values are
$fscanf
converted to the 4 value equivalent).
Matches a floating-point number. The format of a floating-point number is an optional sign (either + or
t
–), followed by a string of digits from the set 0,1,2,3,4,5,6,7,8,9 optionally containing a decimal point
character (.), followed by an optional exponent part including or , followed by an optional sign,
e E
followed by a string of digits from the set 0,1,2,3,4,5,6,7,8,9. The value matched is then scaled and
rounded according to the current timescale as set by . For example, if the timescale is
$timeformat
and the time format is , then a
`timescale 1ns/100ps $timeformat(–3,2," ms",10);
value read with would return 10350000.0.
$sscanf("10.345", "%t", t)
Matches a single character, whose 8-bit ASCII value is returned.
c
Matches a string, which is a sequence of nonwhite space characters.
s
Matches unformatted (binary) data. The application shall transfer sufficient data from the input to fill
u
the target variable. Typically, the data are obtained from a matching or
$fwrite ("%u",data)
from an external application written in another programming language such as C, Perl, or FORTRAN.
The application shall transfer the 2 value binary data from the input stream to the destination variable,
expanding the data to the 4 value format. This escape sequence can be used with any of the existing
input system tasks, although $fscanf should be the preferred one to use. As the input data cannot
represent x or z, it is not possible to obtain an x or z in the result variable. This formatting specifier is
intended to be used to support transferring data to and from external programs that have no concept of
x and z.
Applications that require preservation of x and z are encouraged to use the format
%z I/O
specification.
The data shall be read from the file in the native endian format of the underlying system [i.e., in the
same endian order as if the PLI was used and the C language system call was used].
read(2)
For POSIX applications, it might be necessary to open files for unformatted I/O with the ,
"rb"
, or specifiers to avoid the systems implementation of I/O altering patterns in the
"rb+" "r+b"
unformatted stream that match special characters.
641
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table21-8—$fscanf input field characters (continued)
Input
Description
field
The formatting specification (or ) is defined for reading data without formatting (binary values).
z %z %Z
The application shall transfer the 4 value binary representation of the specified data from the input
stream to the destination variable. This escape sequence can be used with any of the existing input
system tasks, although $fscanf should be the preferred one to use.
This formatting specifier is intended to be used to support transferring data to and from external
programs that recognize and support the concept of x and z. Applications that do not require the
preservation of x and z are encouraged to use the %u I/O format specification.
The data shall be read from the file in the native endian format of the underlying system [i.e., in the
same endian order as if the PLI was used, the data were in a structure (see
s_vpi_vecval
Figure38-8 in 38.15), and the C language system call was used to read the data from disk].
read(2)
For POSIX applications, it might be necessary to open files for unformatted I/O with the ,
"rb"
, or specifiers to avoid the systems implementation of I/O altering patterns in the unfor-
"rb+" "r+b"
matted stream that match special characters.
Returns the current hierarchical path as a string. Does not read data from the input file or str
m
argument.
The string format specifier (or ) may be used to read into a variable of integral, unpacked array of
%s %S
, or data types.
byte string
If an invalid conversion character follows the , the results of the operation are implementation dependent.
%
If the format string or the argument to contains unknown bits ( or ), then the system
str $sscanf x z
function shall return ( ).
EOF -1
If is encountered during input, conversion is terminated. If occurs before any characters matching
EOF EOF
the current directive have been read (other than leading white space, where permitted), execution of the
current directive terminates with an input failure. Otherwise, unless execution of the current directive is
terminated with a matching failure, execution of the following directive (if any) is terminated with an input
failure.
If conversion terminates on a conflicting input character, the offending input character is left unread in the
input stream. Trailing white space (including newline characters) is left unread unless matched by a
directive. The success of literal matches and suppressed assignments is not directly determinable.
The number of successfully matched and assigned input items is returned in ; this number can be 0 in
code
the event of an early matching failure between an input character and the control string. If the input ends
before the first matching failure or conversion, ( ) is returned. Applications can call to
EOF -1 $ferror
determine the cause of the most recent error (see 21.3.7).
21.3.4.4 Reading binary data
can be used to read binary data from a file. For example:
$fread
integer code ;
code = $fread( integral_var, fd);
code = $fread( mem, fd);
code = $fread( mem, fd, start);
code = $fread( mem, fd, start, count);
code = $fread( mem, fd, , count);
642
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
read binary data from the file specified by into the variable or the memory .
fd integral_var mem
The integral variable variant,
$fread(integral_var, fd);
is defined to be the one applied for all packed data.
is an optional argument. If present, shall be used as the address of the first element in the
start start
memory to be loaded. If not present, the lowest numbered location in the memory shall be used.
is an optional argument. If present, shall be the maximum number of locations in that
count count mem
shall be loaded. If not supplied, the memory shall be filled with what data are available.
and are ignored if is loading an integral variable.
start count $fread
If no addressing information is specified within the system task and no address specifications appear within
the data file, then the default start address is the lowest address given in the declaration of the memory.
Consecutive words are loaded toward the highest address until either the memory is full or the data file is
completely read. If the start address is specified in the task without the finish address, then loading starts at
the specified start address and continues toward the highest address given in the declaration of the memory.
is the address in the memory. For and the memory , the first data would be
start start = 12 up[10:20]
loaded at . For the memory , the first location loaded would be , then
up[12] down[20:10] down[12]
.
down[13]
The data in the file shall be read byte by byte to fulfill the request. An 8-bit wide memory is loaded using
1byte per memory word, while a 9-bit wide memory is loaded using 2 bytes per memory word. The data are
read from the file in a big endian manner; the first byte read is used to fill the most significant location in the
memory element. If the memory width is not evenly divisible by 8 (8, 16, 24, 32), not all data in the file are
loaded into memory because of truncation.
For unpacked data, is defined to apply as though the operation were performed on each
struct $fread
member in declaration order.
For unpacked data, is defined to apply as though the operation were performed on the first
union $fread
member in declaration order.
The data loaded from the file are taken as 2 value data. A bit set in the data is interpreted as a 1, and bit not
set is interpreted as a 0. It is not possible to read a value of or using $fread.
x z
If an error occurs reading from the file, then code is set to zero. Otherwise, the number of characters read is
returned in code. Applications can call to determine the cause of the most recent error (see 21.3.7).
$ferror
NOTE—There is not a “binary” mode and an “ASCII” mode; one can freely intermingle binary and formatted read
commands from the same file.
21.3.5 File positioning
file_positioning_functions ::=
fd
$ftell( )
| fd offset operation
$fseek( , , )
| fd
$rewind( )
Syntax21-8—Syntax for file positioning system functions (not in AnnexA)
643
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
is used to determine the current read or write position within a file. For example:
$ftell
integer pos ;
pos = $ftell ( fd );
returns in the offset from the beginning of the file of the current byte of the file , which shall be read
pos fd
or written by a subsequent operation on that file descriptor.
This value can be used by subsequent calls to reposition the file to this point. Any repositioning
$fseek
shall cancel any operations. If an error occurs, ( ) is returned. Applications can call
$ungetc EOF -1
to determine the cause of the most recent error (see 21.3.7).
$ferror
and can be used to change the current read or write position within a file. For example:
$fseek $rewind
integer code ;
code = $fseek ( fd, offset, operation );
code = $rewind ( fd );
sets the position of the next input or output operation on the file specified by . The new position is at the
fd
signed distance offset bytes from the beginning, from the current position, or from the end of the file,
according to an operation value of , , and as follows:
0 1 2,
— sets position equal to offset bytes
0
— sets position to current location plus offset
1
— sets position to plus offset
2 EOF
is equivalent to
$rewind $fseek (fd,0,0);
Repositioning the current file position with or shall cancel any operations.
$fseek $rewind $ungetc
allows the file position indicator to be set beyond the end of the existing data in the file. If data
$fseek()
are later written at this point, subsequent reads of data in the gap shall return zero until data are actually
written into the gap. , by itself, does not extend the size of the file.
$fseek
When a file is opened for append (that is, when type is or ), it is impossible to overwrite
"a" "a+"
information already in the file. can be used to reposition the file pointer to any position in the file,
$fseek
but when output is written to the file, the current file pointer is disregarded. All output is written at the end of
the file and causes the file pointer to be repositioned at the end of the output.
If an error occurs repositioning the file, then code is set to . Otherwise, code is set to . Applications can
–1 0
call to determine the cause of the most recent error (see 21.3.7).
$ferror
21.3.6 Flushing output
file_flush_task ::=
[ mcd | fd ]
$fflush( ) ;
Syntax21-9—Syntax for file flush system task (not in AnnexA)
The file I/O buffer can be flushed used . For example:
$fflush
$fflush ( mcd );
$fflush ( fd );
$fflush ( );
644
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
writes any buffered output to the file(s) specified by , to the file specified by , or if is
mcd fd $fflush
invoked with no arguments, to all open files.
21.3.7 I/O error status
file_error_detect_function ::=
fd str
$ferror( , )
Syntax21-10—Syntax for file I/O error detection system function (not in AnnexA)
Should any error be detected by one of the file I/O routines, an error code is returned. Often this is sufficient
for normal operation (i.e., if the opening of an optional configuration file fails, the application typically
would simply continue using default values). However, sometimes it is useful to obtain more information
about the error for correct application operation. In this case, the function can be used, as follows:
$ferror
integer errno ;
errno = $ferror ( fd, str );
A string description of the type of error encountered by the most recent file I/O operation is written into the
variable , which should be a packed array of at least 640 bits wide or a type. The integral value
str string
of the error code is returned in . If the most recent operation did not result in an error, then the value
errno
returned shall be zero, and the variable shall be cleared.
str
21.3.8 Detecting EOF
file_eof_detect_function ::=
fd
$feof( )
Syntax21-11—Syntax for end-of-file file detection system function (not in AnnexA)
EOF can be tested for using . For example:
$feof
integer code;
code = $feof ( fd );
returns a nonzero value when has previously been detected reading the input file . It returns zero
EOF fd
otherwise.
21.4 Loading memory array data from a file
Two system tasks— and —read and load data from a specified text file into a
$readmemb $readmemh
specified memory array (see 7.4.4). The syntax for and system tasks is shown in
$readmemb $readmemh
Syntax21-12.
load_memory_tasks ::=
filename memory_name [ start_addr [ finish_addr ] ]
$readmemb ( , , , ) ;
| filename memory_name [ start_addr [ finish_addr ] ]
$readmemh( , , , ) ;
Syntax21-12—Syntax for memory load system tasks (not in AnnexA)
645
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The filename is an expression that is a string literal, data type, or an integral data type containing a
string
character string that names the file to be opened.
The memory_name can be an unpacked array or a partially indexed multidimensional unpacked array that
resolves to a lesser dimensioned unpacked array (see 21.4.3). Higher order dimensions shall be specified
with an index, rather than a complete or partial dimension range. The lowest dimension (i.e., the rightmost
specified dimension in the identifier) can be specified with slice syntax. See 7.4.6 for details on legal array
indexing in SystemVerilog.
The start_addr and finish_addr arguments apply to the addresses of the unpacked array selected by
memory_name. This address range represents the highest dimension of data in the filename.
When slice syntax is used in the memory_name argument, any start_addr and finish_addr arguments shall
fall within the bounds of the slice’s range.
The direction of the highest dimension’s file entries is given by the relative magnitudes of start_addr and
finish_addr.
These tasks can be executed at any time during simulation.
The text file to be read shall contain only the following:
— White space (spaces, newlines, tabs, and formfeeds)
— Comments (both types of comment are allowed)
— Binary or hexadecimal numbers
The numbers shall have neither the length nor the base format specified. For , each number shall
$readmemb
be binary. For , the numbers shall be hexadecimal. The unknown value ( or ), the high-
$readmemh x X
impedance value ( or ), and the underscore ( ) can be used in specifying a number as in a SystemVerilog
z Z _
source description. White space and/or comments shall be used to separate the numbers.
In the following discussion, the term address refers to an index into the array that models the memory.
As the file is read, each number encountered is assigned to a successive word element of the memory.
Addressing is controlled both by specifying start and/or finish addresses in the system task invocation and
by specifying addresses in the data file.
When addresses appear in the data file, the format is an at character ( ) followed by a hexadecimal number,
@
as follows:
@hh...h
Both uppercase and lowercase digits are allowed in the number. No white space is allowed between the
@
and the number. As many address specifications as needed within the data file can be used. When the system
task encounters an address specification, it loads subsequent data starting at that memory address.
If no addressing information is specified within the system task and no address specifications appear within
the data file, then the default start address shall be the lowest address in the memory. Consecutive words
shall be loaded until either the highest address in the memory is reached or the data file is completely read. If
the start address is specified in the task without the finish address, then loading shall start at the specified
start address and shall continue upward toward the highest address in the memory. In both cases, loading
shall continue upward even after an address specification in the data file.
646
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If both start and finish addresses are specified as arguments to the task, then loading shall begin at the start
address and shall continue toward the finish address. If the start address is greater than the finish address,
then the address will be decremented between consecutive loads rather than being incremented. Loading
shall continue to follow this direction even after an address specification in the data file.
When addressing information is specified both in the system task and in the data file, the addresses in the
data file shall be within the address range specified by the system task arguments; otherwise, an error
message is issued, and the load operation is terminated.
A warning shall be issued if the number of data words in the file differs from the number of words in the
range implied by the start through finish addresses and no address specifications appear within the data file.
In this case, the data words that are contained in the file shall be loaded into the memory beginning at the
start address, and memory addresses for which the file does not contain data words are not modified by the
operation.
For example:
logic [7:0] mem[1:256];
Given this declaration, each of the following statements load data into in a different manner:
mem
initial $readmemh("mem.data", mem);
initial $readmemh("mem.data", mem, 16);
initial $readmemh("mem.data", mem, 128, 1);
The first statement loads up the memory at simulation time starting at the memory address . The second
0 1
statement begins loading at address 16 and continues on toward address 256. For the third and final
statement, loading begins at address 128 and continues down toward address .
1
In the third case, when loading is complete, a final check is performed to verify that exactly 128 numbers are
contained in the file. If the check fails, a warning is issued.
21.4.1 Reading packed data
and support unpacked arrays of packed data. In such cases, the system tasks treat
$readmemb $readmemh
each packed element as the vector equivalent and perform the normal operation.
When loading dynamic arrays and queues, the current size of the array is fixed; the array shall not be resized.
When loading associative arrays, indices shall be of integral types. Loading an address creates an element of
that index, if it does not already exist. When an associative array’s index is of an enumerated type, address
entries in the pattern file are in numeric format and correspond to the numeric values associated with the
elements of the enumerated type.
21.4.2 Reading 2-state types
and support packed data of 2-state types, such as or enumerated types. For
$readmemb $readmemh int
2-state integer types, reading proceeds the same as for 4-state variable types (e.g., integer), with the
exception that or data are converted to 0. For enumerated types, the file data represents the numeric
X Z
values associated with each element of the enumerated type (see 6.19). If a numeric value is out of range for
a given type, then an error shall be issued and no further reading shall take place.
647
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
21.4.3 File format considerations for multidimensional unpacked arrays
The and system tasks (and the and tasks) can work
$readmemb $readmemh $writememb $writememh
with multidimensional unpacked arrays.
The file contents are organized in row-major order, with each dimension’s entries ranging from low to high
address. This is backward compatible with one-dimensional memory arrays.
In this organization, the lowest dimension (i.e., the rightmost dimension in the array declaration) varies the
most rapidly. There is a hierarchical sense to the file data. The higher dimensions contain words of lower
dimension data, sorted in row-major order. Each successive lower dimension is entirely enclosed as part of
higher dimension words.
As an example of file format organization, here is the layout of a file representing words for a memory
declared:
logic [31:0] mem [0:2][0:4][5:8];
In the example word contents, ,
wzyx
— corresponds to words of the dimension.
z [0:2]
— corresponds to words of the dimension.
y [0:4]
— corresponds to words of the dimension.
x [5:8]
w005 w006 w007 w008
w015 w016 w017 w018
w025 w026 w027 w028
w035 w036 w037 w038
w045 w046 w047 w048
w105 w106 w107 w108
w115 w116 w117 w118
w125 w126 w127 w128
w135 w136 w137 w138
w145 w146 w147 w148
w205 w206 w207 w208
w215 w216 w217 w218
w225 w226 w227 w228
w235 w236 w237 w238
w245 w246 w247 w248
The preceding diagram would be identical if one or more of the unpacked dimension declarations were
reversed, as in the following:
logic [31:0] mem [2:0][0:4][8:5]
Address entries in the file exclusively address the highest dimension’s words. In the preceding case, address
entries in the file could look something as follows:
@0 w005 w006 w007 w008
w015 w016 w017 w018
w025 w026 w027 w028
w035 w036 w037 w038
w045 w046 w047 w048
@1 w105 w106 w107 w108
w115 w116 w117 w118
w125 w126 w127 w128
648
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
w135 w136 w137 w138
w145 w146 w147 w148
@2 w205 w206 w207 w208
w215 w216 w217 w218
w225 w226 w227 w228
w235 w236 w237 w238
w245 w246 w247 w248
When or is given a file without address entries, all data are read assuming that each
$readmemh $readmemb
dimension has complete data. i.e., each word in each dimension will be initialized with the appropriate value
from the file. If the file contains incomplete data, the read operation will stop at the last initialized word, and
any remaining array words or subwords will be left unchanged.
When or is given a file with address entries, initialization of the specified highest
$readmemh $readmemb
dimension words is done. If the file contains insufficient words to completely fill a highest dimension word,
then the remaining subwords are left unchanged.
When a memory contains multiple packed dimensions, the memory words in the pattern file are composed
of the sum total of all bits in the packed dimensions. The layout of packed bits in packed dimensions is
defined in 7.4.5.
21.5 Writing memory array data to a file
The and system tasks can be used to dump memory array (see 7.4.4) contents to
$writememb $writememh
files that are readable by and , respectively.
$readmemb $readmemh
writemem_tasks ::=
filename memory_name [ start_addr [ finish_addr ] ]
$writememb ( , , , ) ;
| filename memory_name [ start_addr [ finish_addr ] ]
$writememh ( , , , ) ;
Syntax21-13—$writemem system task syntax (not in AnnexA)
If filename exists at the time or is called, the file will be overwritten (i.e., there
$writememb $writememh
is no append mode).
21.5.1 Writing packed data
and treat packed data identically to and . See 21.4.1.
$writememb $writememh $readmemb $readmemh
21.5.2 Writing 2-state types
and can write out data corresponding to unpacked arrays of 2-state types, such
$writememb $writememh
as or enumerated types. For enumerated types, values in the file correspond to the ordinal values of the
int
enumerated type (see 6.19).
21.5.3 Writing addresses to output file
When and write out data corresponding to unpacked or dynamic arrays, address
$writememb $writememh
specifiers ( -words) shall not be written to the output file.
@
649
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
When and write out data corresponding to associative arrays, address specifiers
$writememb $writememh
shall be written to the output file. As specified in 21.4.1, associative arrays shall have indices of integral
types in order to be legal arguments to the and calls.
$writememb $writememh
21.6 Command line input
An alternative to reading a file to obtain information for use in the simulation is specifying information with
the command to invoke the simulator. This information is in the form of an optional argument provided to
the simulation. These arguments are visually distinguished from other simulator arguments by their starting
with the plus ( ) character.
+
These arguments, referred to below as plusargs, are accessible through the following system functions:
string
$test$plusargs ( )
user_string, variable
$value$plusargs ( )
The system function searches the list of plusargs for a user-specified plusarg_string. The
$test$plusargs
string is specified in the argument to the system function as either a string or an integral variable that is
interpreted as a string. If a variable is used to specify the string, leading nulls in the variable shall be ignored
and shall not be considered as part of the matching string. This string shall not include the leading plus sign
of the command line argument. The plusargs present on the command line are searched in the order
provided. If the prefix of one of the supplied plusargs matches all characters in the provided string, the
function returns a nonzero integer. If no plusarg from the command line matches the string provided, the
function returns the integer value zero.
For example:
Run simulator with command:
+HELLO
initial begin
if ($test$plusargs("HELLO")) $display("Hello argument found.");
if ($test$plusargs("HE")) $display("The HE subset string is detected.");
if ($test$plusargs("H")) $display("Argument starting with H found.");
if ($test$plusargs("HELLO_HERE")) $display("Long argument.");
if ($test$plusargs("HI")) $display("Simple greeting.");
if ($test$plusargs("LO")) $display("Does not match.");
end
This code would produce the following output:
Hello argument found.
The HE subset string is detected.
Argument starting with H found.
The system function searches the list of plusargs (like the system
$value$plusargs $test$plusargs
function) for a user-specified plusarg_string. The string is specified in the first argument to the system
function as either a string or an integral variable that is interpreted as a string. If a variable is used to specify
the string, leading nulls in the variable shall be ignored and shall not be considered as part of the matching
string. This string shall not include the leading plus sign of the command line argument. The plusargs
present on the command line are searched in the order provided. If the prefix of one of the supplied plusargs
matches all characters in the provided string, the function returns a nonzero integer, the remainder of the
string is converted to the type specified in the user_string, and the resulting value is stored in the variable
provided. If no string is found matching, the function returns the integer value zero, and the variable
provided is not modified. No warnings shall be generated when the function returns zero ( ).
0
650
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The user_string shall be of the following form: plusarg_string format_string . The format strings are the
" "
same as the system tasks. The following are the only valid format strings (uppercase and
$display
lowercase as well as leading forms are valid):
0
decimal conversion
%d
octal conversion
%o
, hexadecimal conversion
%h %x
binary conversion
%b
real exponential conversion
%e
real decimal conversion
%f
real decimal or exponential conversion
%g
string (no conversion)
%s
The first string from the list of plusargs provided to the simulator, which matches the plusarg_string portion
of the user_string specified, shall be the plusarg string available for conversion. The remainder string of the
matching plusarg (the remainder is the part of the plusarg string after the portion that matches the user’s
plusarg_string) shall be converted from a string into the format indicated by the format string and stored in
the variable provided. If there is no remaining string, the value stored into the variable shall be either a zero
or an empty string value.
If the size of the variable is larger than the value after conversion, the value stored is zero-padded to the
width of the variable. If the variable cannot contain the value after conversion, the value shall be truncated.
If the value is negative, the value shall be considered larger than the variable provided. If characters exist in
the string available for conversion that are illegal for the specified conversion, the variable shall be written
with the value .
'bx
Given the SystemVerilog code:
`define STRING logic [1024 * 8:1]
module goodtasks;
`STRING str;
integer i1;
logic [31:0] vect;
real realvar;
initial
begin
if ($value$plusargs("TEST=%d", i1))
$display("value was %d", i1);
else
$display("+TEST= not found");
#100 $finish;
end
endmodule
module ieee1364_example;
real frequency;
logic [8*32:1] testname;
logic [64*8:1] pstring;
logic clk;
initial
begin
if ($value$plusargs("TESTNAME=%s",testname))
begin
651
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
$display(" TESTNAME= %s.",testname);
$finish;
end
if (!($value$plusargs("FREQ+%0F",frequency)))
frequency = 8.33333; // 166 MHz
$display("frequency = %f",frequency);
pstring = "TEST%d";
if ($value$plusargs(pstring, testname))
$display("Running test number %0d.",testname);
end
endmodule
and adding to the tool’s command line the plusarg
+TEST=5
will result in the following output:
value was 5
frequency = 8.333330
Running text number x.
Adding to the tool’s command line the plusarg
+TESTNAME=t1
will result in the following output:
+TEST= not found
TESTNAME= t1.
Adding to the tool’s command line the plusarg
+FREQ+9.234
will result in the following output:
+TEST= not found
frequency = 9.234000
Adding to the tool’s command line the plusarg
+TEST23
will result in the following output:
+TEST= not found
frequency = 8.333330
Running test number 23.
652
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
21.7 Value change dump (VCD) files
A VCD file contains information about value changes on selected variables in the design stored by VCD
system tasks. The following two types of VCD files exist:
a) 4-state: to represent variable changes in , , , and with no strength information.
0 1 x z
b) Extended: to represent variable changes in all states and strength information.
This subclause describes how to generate both types of VCD files and their format.
21.7.1 Creating 4-state VCD file
The steps involved in creating the 4-state VCD file are listed as follows and illustrated in Figure21-1.
a) Insert the VCD system tasks in the SystemVerilog source file to define the dump file name and to
specify the variables to be dumped.
b) Run the simulation.
SystemVerilog Source File 4-State VCD File
dump1.dump
initial
(Header
$dumpfile("dump1.dump"); Information)
. User
simulation
. (Node Postprocessing
.
Information)
$dumpvars(...);
.
(Value
.
Changes)
.
Figure21-1—Creating the 4-state VCD file
A VCD file is an ASCII file that contains header information, variable definitions, and the value changes for
all variables specified in the task calls.
Several system tasks can be inserted in the source description to create and control the VCD file.
21.7.1.1 Specifying name of dump file ($dumpfile)
The task shall be used to specify the name of the VCD file. The syntax for the task is given in
$dumpfile
Syntax21-14.
dumpfile_task ::=
filename
$dumpfile ( ) ;
Syntax21-14—Syntax for $dumpfile task (not in AnnexA)
The filename is an expression that is a string literal, data type, or an integral data type containing a
string
character string that names the file to be opened. The filename is optional and defaults to the string literal
if not specified.
"dump.vcd"
653
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For example:
initial $dumpfile ("module1.dump") ;
21.7.1.2 Specifying variables to be dumped ($dumpvars)
The task shall be used to list which variables to dump into the file specified by .
$dumpvars $dumpfile
The task can be invoked as often as desired throughout the model (for example, within various
$dumpvars
blocks), but the execution of all the tasks shall be at the same simulation time.
$dumpvars
The task can be used with or without arguments. The syntax for the task is given
$dumpvars $dumpvars
in Syntax21-15.
dumpvars_task ::=
$dumpvars ;
| levels [ list_of_modules_or_variables ]
$dumpvars ( , ) ;
list_of_modules_or_variables ::=
module_or_variable { module_or_variable }
,
module_or_variable ::=
module_identifier
| variable_identifier
Syntax21-15—Syntax for $dumpvars task (not in AnnexA)
When invoked with no arguments, dumps all the variables in the model to the VCD file.
$dumpvars
When the task is specified with arguments, the first argument indicates how many levels of the
$dumpvars
hierarchy below each specified module instance to dump to the VCD file. Subsequent arguments specify
which scopes of the model to dump to the VCD file. These arguments can specify entire modules or
individual variables within a module.
Setting the first argument to causes a dump of all variables in the specified module and in all module
0
instances below the specified module. The argument applies only to subsequent arguments that specify
0
module instances, and not to individual variables.
Example 1:
$dumpvars (1, top);
Because the first argument is a , this invocation dumps all variables within the module ; it does not
1 top
dump variables in any of the modules instantiated by module .
top
Example 2:
$dumpvars (0, top);
In this example, the task shall dump all variables in the module and in all module instances
$dumpvars top
below module in the hierarchy.
top
Example 3: This example shows how the task can specify both modules and individual
$dumpvars
variables.
$dumpvars (0, top.mod1, top.mod2.net1);
654
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
This call shall dump all variables in module and in all module instances below , along with
mod1 mod1
variable in module . The argument applies only to the module instance and not to
net1 mod2 0 top.mod1
the individual variable .
top.mod2.net1
21.7.1.3 Stopping and resuming the dump ($dumpoff/$dumpon)
Executing the task causes the value change dumping to start at the end of the current simulation
$dumpvars
time unit. To suspend the dump, the task can be invoked. To resume the dump, the task
$dumpoff $dumpon
can be invoked. The syntax of these two tasks is given in Syntax21-16.
dumpoff_task ::=
$dumpoff ;
dumpon_task ::=
$dumpon ;
Syntax21-16—Syntax for $dumpoff and $dumpon tasks (not in AnnexA)
When the task is executed, a checkpoint is made in which every selected variable is dumped as
$dumpoff
an value. When the task is later executed, each variable is dumped with its value at that time. In
x $dumpon
the interval between and , no value changes are dumped.
$dumpoff $dumpon
The and tasks provide the mechanism to control the simulation period during which the
$dumpoff $dumpon
dump shall take place.
For example:
initial begin
#10 $dumpvars( . . . );
#200 $dumpoff;
#800 $dumpon;
#900 $dumpoff;
end
This example starts the VCD after 10 time units, stops it 200 time units later (at time 210), restarts it again
800 time units later (at time 1010), and stops it 900 time units later (at time 1910).
21.7.1.4 Generating a checkpoint ($dumpall)
The task creates a checkpoint in the VCD file that shows the current value of all selected
$dumpall
variables. The syntax is given in Syntax21-17.
dumpall_task ::=
$dumpall ;
Syntax21-17—Syntax for $dumpall task (not in AnnexA)
When dumping is enabled, the value change dumper records the values of the variables that change during
each time increment. Values of variables that do not change during a time increment are not dumped.
655
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
21.7.1.5 Limiting size of dump file ($dumplimit)
The task can be used to set the size of the VCD file. The syntax for this task is given in
$dumplimit
Syntax21-18.
dumplimit_task ::=
filesize
$dumplimit ( ) ;
Syntax21-18—Syntax for $dumplimit task (not in AnnexA)
The filesize argument specifies the maximum size of the VCD file in bytes. When the size of the VCD file
reaches this number of bytes, the dumping stops, and a comment is inserted in the VCD file indicating the
dump limit was reached.
21.7.1.6 Reading dump file during simulation ($dumpflush)
The task can be used to empty the VCD file buffer of the operating system to verify all the
$dumpflush
data in that buffer are stored in the VCD file. After executing a task, dumping is resumed as
$dumpflush
before so no value changes are lost. The syntax for the task is given in Syntax21-19.
dumpflush_task ::=
$dumpflush ;
Syntax21-19—Syntax for $dumpflush task (not in AnnexA)
A common application is to call to update the dump file so an application program can read
$dumpflush
the VCD file during a simulation.
Example 1: This example shows how the task can be used in a SystemVerilog source file.
$dumpflush
initial begin
$dumpvars ;
.
.
.
$dumpflush ;
$(applications program) ;
end
Example 2: The following is a simple source description example to produce a VCD file:
In this example, the name of the dump file is . It dumps value changes for all variables in the
verilog.dump
model. Dumping begins when an event occurs. The dumping continues for 500 clock cycles and
do_dump
then stops and waits for the event to be triggered again. At every 10 000 time steps, the current
do_dump
values of all VCD variables are dumped.
module dump;
event do_dump;
656
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
initial $dumpfile("verilog.dump");
initial @do_dump
$dumpvars; //dump variables in the design
always @do_dump //to begin the dump at event do_dump
begin
$dumpon; //no effect the first time through
repeat (500) @(posedge clock); //dump for 500 cycles
$dumpoff; //stop the dump
end
initial @(do_dump)
forever #10000 $dumpall; // checkpoint all variables
endmodule
21.7.2 Format of 4-state VCD file
The dump file is structured in a free format. White space is used to separate commands and to make the file
easily readable by a text editor.
21.7.2.1 Syntax of 4-state VCD file
The syntax of the 4-state VCD file is given in Syntax21-20.
value_change_dump_definitions ::=
{ declaration_command }{ simulation_command }
declaration_command ::=
[ comment_text ]
$comment $end
| [ date_text ]
$date $end
|
$enddefinitions$end
| [ scope_type scope_identifier ]
$scope $end
| [ time_number time_unit ]
$timescale $end
|
$upscope$end
| [ var_type size identifier_code reference ]
$var $end
| [ version_text system_task ]
$version $end
simulation_command ::=
{ value_change }
$dumpall $end
| { value_change }
$dumpoff $end
| { value_change }
$dumpon $end
| { value_change }
$dumpvars $end
| [ comment_text ]
$comment $end
| simulation_time
| value_change
scope_type ::=
begin
|
fork
|
function
|
module
|
task
time_number ::= | |
1 10 100
time_unit ::= | | | | |
s ms us ns ps fs
var_type ::=
| | | | | | | |
event integer parameter real realtime reg supply0 supply1 time
657
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
| | | | | | | | |
tri triand trior trireg tri0 tri1 wand wire wor
simulation_time ::= decimal_number
#
value_change ::=
scalar_value_change
| vector_value_change
scalar_value_change ::= value identifier_code
value ::= | | | | |
0 1 x X z Z
vector_value_change ::=
binary_number identifier_code
b
| binary_number identifier_code
B
| real_number identifier_code
r
| real_number identifier_code
R
identifier_code ::= { ASCII character }
size ::= decimal_number
reference ::=
identifier
| identifier bit_select_index
[ ]
| identifier msb_index lsb_index
[ : ]
index ::= decimal_number
scope_identifier ::= { ASCII character }
comment_text ::= { ASCII character }
date_text ::= { ASCII character }
version_text ::= { ASCII character }
system_task ::= {ASCII character}
$
Syntax21-20—Syntax for output 4-state VCD file (not in AnnexA)
The VCD file starts with header information giving the date, the version number of the simulator used for
the simulation, and the timescale used. Next, the file contains definitions of the scope and type of variables
being dumped, followed by the actual value changes at each simulation time increment. Only the variables
that change value during a time increment are listed.
The simulation time recorded in the VCD file is the absolute value of the simulation time for the changes in
variable values that follow.
Value changes for real variables are specified by real numbers. Value changes for all other variables are
specified in binary format by , , , or values. Strength information and memories are not dumped.
0 1 x z
A real number is dumped using a format. This preserves the precision of that number by
%.16g printf()
outputting all 53 bits in the mantissa of a 64-bit IEEE 754 double-precision number. Application programs
can read a real number using a format to .
%g scanf()
The value change dumper generates character identifier codes to represent variables. The identifier code is a
code composed of the printable characters, which are in the ASCII character set from ! to ~ (decimal 33 to
126).
The VCD format does not support a mechanism to dump part of a vector. For example, bits 8 to 15
( ) of a 16-bit vector cannot be dumped in VCD file; instead, the entire vector ( ) has to be
[8:15] [0:15]
dumped. In addition, expressions, such as a + b, cannot be dumped in the VCD file.
658
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Data in the VCD file are case sensitive.
21.7.2.2 Formats of variable values
Variables can be either scalars or vectors. Each type is dumped in its own format. Dumps of value changes
to scalar variables shall not have any white space between the value and the identifier code.
Dumps of value changes to vectors shall not have any white space between the base letter and the value
digits, but they shall have one white space between the value digits and the identifier code.
The output format for each value is right-justified. Vector values appear in the shortest form possible:
redundant bit values that result from left-extending values to fill a particular vector size are eliminated.
The rules for left-extending vector values are given in Table21-9.
Table21-9—Rules for left-extending vector values
When the value is VCD left-extends with
1 0
0 0
Z Z
X X
Table21-10 shows how the VCD can shorten values.
Table21-10—How the VCD can shorten values
Extends to fill a Appears in the
Binary value
4-bit reg as VCD file as
10 0010 b10
X10 XX10 bX10
ZX0 ZZX0 bZX0
0X10 0X10 b0X10
Events are dumped in the same format as scalars; for example, . For events, however, the value (1 in this
1*%
example) is irrelevant. Only the identifier code ( in this example) is significant. It appears in the VCD file
*%
as a marker to indicate the event was triggered during the time step.
For example:
1*@ No space between the value 1 and the identifier code *@
b1100x01z (k No space between the b and 1100x01z,
but a space between b1100x01z and (k
659
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
21.7.2.3 Description of keyword commands
The general information in the VCD file is presented as a series of sections surrounded by keywords.
Keyword commands provide a means of inserting information in the VCD file. Keyword commands can be
inserted either by the dumper or manually.
This subclause deals with the keyword commands given in Table21-11.
Table21-11—Keyword commands
Declaration keywords Simulation keywords
$comment $timescale $dumpall
$date $upscope $dumpoff
$enddefinitions $var $dumpon
$scope $version $dumpvars
The section provides a means of inserting a comment in the VCD file. For example:
$comment
$comment This is a single-line comment $end
$comment This is a
multiple-line comment
$end
The section indicates the date on which the VCD file was generated. For example:
$date
$date
June 25, 1989 09:24:35
$end
The section marks the end of the header information and definitions.
$enddefinitions
The section defines the scope of the variables being dumped. The scope type indicates one of the
$scope
following scopes:
module Top-level module and module instances
task Tasks
function Functions
begin Named sequential blocks
fork Named parallel blocks
For example:
$scope
module top
$end
The keyword specifies what timescale was used for the simulation. For example:
$timescale
$timescale 10 ns $end
The section indicates a change of scope to the next higher level in the design hierarchy.
$upscope
660
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The section prints the names and identifier codes of the variables being dumped. The size specifies
$var
how many bits are in the variable. The identifiercode specifies the name of the variable using printable
ASCII characters, as previously described.
a) The msbindex indicates the most significant index; the lsbindex indicates the least significant
index.
b) More than one reference name can be mapped to the same identifier code. For example, and
net10
can be interconnected in the circuit and, therefore, have the same identifier code.
net15
c) The individual bits of vector nets can be dumped individually.
d) The identifier is the name of the variable being dumped in the model.
In the section, a net of net type shall have a var_type of .
$var uwire wire
For example:
$var
integer 32 (2 index
$end
The section indicates which version of the VCD writer was used to produce the VCD file and the
$version
system task used to create the file. If a variable or an expression was used to specify the
$dumpfile
filename within , the unevaluated variable or expression literal shall appear in the
$dumpfile $version
string. For example:
$version
VERILOG-SIMULATOR 1.0a
$dumpfile("dump1.dump")
$end
keyword specifies current values of all variables dumped. For example:
The$dumpall
$dumpall 1*@ x*# 0*$ bx (k $end
The keyword indicates all variables dumped with X values. For example:
$dumpoff
$dumpoff x*@ x*# x*$ bx (k $end
The keyword indicates resumption of dumping and lists current values of all variables dumped.
$dumpon
For example:
$dumpon x*@ 0*# x*$ b1 (k $end
The section beginning with keyword lists initial values of all variables dumped. For example:
$dumpvars
$dumpvars x*@ z*$ b0 (k $end
21.7.2.4 4-state VCD file format example
The following example illustrates the format of the 4-state VCD file:
$date June 26, 1989 10:05:41
$end
$version VERILOG-SIMULATOR 1.0a
$end
$timescale 1 ns
$end
661
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
$scope module top $end
$scope module m1 $end
$var trireg 1 *@ net1 $end
$var trireg 1 *# net2 $end
$var trireg 1 *$ net3 $end
$upscope $end
$scope task t1 $end
$var reg 32 (k accumulator[31:0] $end
$var integer 32 {2 index $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment
$dumpvars was executed at time '#500'.
All initial values are dumped at this time.
$end
#500
$dumpvars
x*@
x*#
x*$
bx (k
bx {2
$end
#505
0*@
1*#
1*$
b10zx1110x11100 (k
b1111000101z01x {2
#510
0*$
#520
1*$
#530
0*$
bz (k
#535
$dumpall 0*@ 1*# 0*$
bz (k
b1111000101z01x {2
$end
#540
1*$
#1000
$dumpoff
x*@
x*#
x*$
bx (k
bx {2
$end
#2000
$dumpon
z*@
1*#
0*$
b0 (k
bx {2
662
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
$end
#2010
1*$
21.7.3 Creating extended VCD file
The steps involved in creating the extended VCD file are listed as follows and illustrated in Figure21-2.
a) Insert the extended VCD system tasks in the SystemVerilog source file to define the dump file name
and to specify the variables to be dumped.
b) Run the simulation.
SystemVerilog Source File Extended VCD File
dump2.dump
initial
(Header
$dumpports(,"dump2.dump"); Information)
. User
simulation
. (Node Postprocessing
.
Information)
.
(Value
.
Changes)
.
Figure21-2—Creating the extended VCD file
The 4-state VCD file rules and syntax apply to the extended VCD file unless otherwise stated in this
subclause.
21.7.3.1 Specifying dump file name and ports to be dumped ($dumpports)
The task shall be used to specify the name of the VCD file and the ports to be dumped. The
$dumpports
syntax for the task is given in Syntax21-21.
dumpports_task ::=
scope_list filename
$dumpports ( , ) ;
scope_list ::=
module_identifier { module_identfier }
,
Syntax21-21—Syntax for $dumpports task (not in AnnexA)
The arguments are optional and are defined as follows:
The scope_list is one or more module_identifiers. Only modules are allowed (not variables). If more than
one module_identifier is specified, they shall be separated by a comma. Path names to modules are allowed,
using the period hierarchy separator. String literals are not allowed for the module_identifier. If no
scope_list value is provided, the scope shall be the module from which is called.
$dumpports
The filename is an expression that is a string literal, data type, or an integral data type containing a
string
character string that denotes the file that shall contain the port VCD information. If no filename is provided,
663
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
the file shall be written to the current working directory with the name dumpports.vcd. If that file already
exists, it shall be silently overwritten. All file-writing checks shall be made by the simulator (e.g., write
rights, correct path name) and appropriate errors or warnings issued.
The following rules apply to the use of the $dumpports system task:
— All the ports in the model from the point of the call are considered primary I/O pins
$dumpports
and shall be included in the VCD file. However, any ports that exist in instantiations below
scope_list are not dumped.
— If no arguments are specified for the task, and are allowed. In both
$dumpports; $dumpports();
of these cases, the default values for the arguments shall be used.
— If the first argument is null, a comma shall be used before specifying the second argument in the
argument list.
— Each scope specified in the scope_list shall be unique. If multiple calls to are
$dumpports
specified, the scope_list values in these calls shall also be unique.
— The task can be used in source code that also contains the task.
$dumpports $dumpvars
— When executes, the associated value change dumping shall start at the end of the
$dumpports
current simulation time unit.
— The task can be invoked multiple times throughout the model, but the execution of all
$dumpports
tasks shall be at the same simulation time. Specifying the same filename multiple
$dumpports
times is not allowed.
21.7.3.2 Stopping and resuming the dump ($dumpportsoff/$dumpportson)
The and system tasks provide a means to control the simulation period
$dumpportsoff $dumpportson
for dumping port values. The syntax for these system tasks is given in Syntax21-22.
dumpportsoff_task ::=
filename
$dumpportsoff ( ) ;
dumpportson_task ::=
filename
$dumpportson ( ) ;
Syntax21-22—Syntax for $dumpportsoff and $dumpportson system tasks (not in AnnexA)
The filename is an expression that is a string literal, data type, or an integral data type containing a
string
character string that denotes the filename specified in the system task.
$dumpports
When the task is executed, a checkpoint is made in the filename where each specified port
$dumpportsoff
is dumped with an X value. Port values are no longer dumped from that simulation time forward. If filename
is not specified, all dumping to files opened by calls shall be suspended.
$dumpports
When the task is executed, all ports specified by the associated call shall have
$dumpportson $dumpports
their values dumped. This system task is typically used to resume dumping after the execution of
. If filename is not specified, dumping shall resume for all files specified by
$dumpportsoff $dumpports
calls, if dumping to those files was stopped.
If is executed while ports are already being dumped to filename, the system task is ignored.
$dumpportson
If is executed while port dumping is already suspended for filename, the system task is
$dumpportsoff
ignored.
664
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd. o An llD reigcehmtsb reer s0e3r,v2e02d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
21.7.3.3 Generating a checkpoint ($dumpportsall)
The system task creates a checkpoint in the VCD file that shows the value of all selected
$dumpportsall
ports at that time in the simulation, regardless of whether the port values have changed since the last time
step. The syntax for this system task is given in Syntax21-23.
dumpportsall_task ::=
filename
$dumpportsall ( ) ;
Syntax21-23—Syntax for $dumpportsall system task (not in AnnexA)
The filename is an expression that is a string literal, data type, or an integral data type containing a
string
character string that denotes the filename specified in the system task.
$dumpports
If the filename is not specified, checkpointing occurs for all files opened by calls to .
$dumpports
21.7.3.4 Limiting size of dump file ($dumpportslimit)
The system task allows control of the VCD file size. The syntax for this system task is
$dumpportslimit
given in Syntax21-24.
dumpportslimit_task ::=
filesize , filename
$dumpportslimit ( ) ;
Syntax21-24—Syntax for $dumpportslimit system task (not in AnnexA)
The filesize integer argument is required, and it specifies the maximum size in bytes for the associated
filename. When this filesize is reached, the dumping stops, and a comment is inserted into filename
indicating the size limit was attained.
The filename is an expression that is a string literal, data type, or an integral data type containing a
string
character string that denotes the filename specified in the system task.
$dumpports
If the filename is not specified, the filesize limit applies to all files opened for dumping due to calls to
.
$dumpports
21.7.3.5 Reading dump file during simulation ($dumpportsflush)
To facilitate performance, simulators often buffer VCD output and write to the file at intervals, instead of
line by line. The system task writes all port values to the associated file, clearing a
$dumpportsflush
simulator’s VCD buffer.
The syntax for this system task is given in Syntax21-25.
dumpportsflush_task ::=
filename
$dumpportsflush ( ) ;
Syntax21-25—Syntax for $dumpportsflush system task (not in AnnexA)
665
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The filename is an expression that is a string literal, data type, or an integral data type containing a
string
character string that denotes the filename specified in the system task.
$dumpports
If the filename is not specified, the VCD buffers shall be flushed for all files opened by calls to
.
$dumpports
21.7.3.6 Description of keyword commands
The general information in the extended VCD file is presented as a series of sections surrounded by
keywords. Keyword commands provide a means of inserting information in the extended VCD file.
Keyword commands can be inserted either by the dumper or manually. Extended VCD provides one
additional keyword command to that of the 4-state VCD.
21.7.3.6.1 $vcdclose
The keyword indicates the final simulation time at the time the extended VCD file is closed.
$vcdclose
This allows accurate recording of the end simulation time, regardless of the state of signal changes, in order
to assist parsers that require this information. The syntax for the keyword is given in Syntax21-26.
vcdclose_task ::=
final_simulation_time
$vcdclose $end
Syntax21-26—Syntax for $vcdclose keyword (not in AnnexA)
For example:
$vcdclose #13000 $end
21.7.3.7 General rules for extended VCD system tasks
For each extended VCD system task, the following rules apply:
— If a filename is specified that does not match a filename specified in a call, the control
$dumpports
task shall be ignored.
— If no arguments are specified for the tasks that have only optional arguments, the system task name
can be used with no arguments or the name followed by ( ) can be specified, for example,
or . In both of these cases, the default actions for the
$dumpportsflush $dumpportsflush()
arguments shall be executed.
21.7.4 Format of extended VCD file
The format of the extended VCD file is similar to that of the 4-state VCD file, as it is also structured in a free
format. White space is used to separate commands and to make the file easily readable by a text editor.
21.7.4.1 Syntax of extended VCD file
The syntax of the extended VCD file is given in Syntax21-27. A 4-state VCD construct name that matches
an extended VCD construct shall be considered equivalent, except if preceded by an .
*
value_change_dump_definitions ::= {declaration_command} {simulation_command}
declaration_command ::= declaration_keyword [command_text]
$end
simulation_command ::=
666
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
simulation_keyword { value_change }
$end
| [comment_text]
$comment $end
| simulation_time
| value_change
declaration_keyword ::=
| | | | | | |
$comment $date $enddefinitions $scope $timescale $upscope $var $vcdclose
|
$version
command_text ::=
comment_text | close_text | date_section | scope_section | timescale_section | var_section
| version_section
simulation_keyword ::= | | |
$dumpports $dumpportsoff $dumpportson $dumpportsall
simulation_time ::= decimal_number
#
final_simulation_time ::= simulation_time
value_change ::= value identifier_code
value ::= port_value 0_strength_component 1_strength_component
p
port_value ::= input_value | output_value | unknown_direction_value
input_value ::= | | | | |
D U N Z d u
output_value ::= | | | | |
L H X T l h
unknown_direction_value ::= | | | | | | | | | |
0 1 ? F A a B b C c f
strength_component ::= | | | | | | |
0 1 2 3 4 5 6 7
identifier_code ::= {integer}
<
comment_text ::= {ASCII_character}
close_text ::= final_simulation_time
date_section ::= date_text
date_text :: = day month date time year
scope_section ::= scope_type scope_identifier
scope_type ::=
module
timescale_section ::= number time_unit
number ::= | |
1 10 100
time_unit ::= | | | | |
fs ps ns us ms s
var_section ::= var_type size identifier_code reference
var_type ::=
port
size ::= | vector_index
1
vector_index ::= msb_index lsb_index
[ : ]
index ::= decimal_number
msb_index ::= index
lsb_index ::= index
reference ::= port_identifier
identifier ::= {printable_ASCII_character}
version_section ::= version_text
version_text ::= version_identifier {dumpports_command}
dumpports_command ::=
scope_identifier string_literal | variable | expression
$dumpports ( , )
Syntax21-27—Syntax for output extended VCD file (not in AnnexA)
667
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The extended VCD file starts with header information giving the date, the version number of the simulator
used for the simulation, and the timescale used. Next, the file contains definitions of the scope of the ports
being dumped, followed by the actual value changes at each simulation time increment. Only the ports that
change value during a time increment are listed.
The simulation time recorded in the extended VCD file is the absolute value of the simulation time for the
changes in port values that follow.
Value changes for all ports are specified in binary format by , , , or values and include strength
0 1 x z
information.
A real number is dumped using a format. This preserves the precision of that number by
%.16g printf()
outputting all 53 bits in the mantissa of a 64-bit IEEE 754 double-precision number. Application programs
can read a real number using a format to .
%g scanf()
The extended VCD format does not support a mechanism to dump part of a vector. For example, bits 8 to 15
( ) of a 16-bit vector cannot be dumped in VCD file; instead, the entire vector ( ) has to be
[8:15] [0:15]
dumped. In addition, expressions, such as , cannot be dumped in the VCD file.
a + b
Data in the extended VCD file are case sensitive.
21.7.4.2 Extended VCD node information
The node information section (also referred to as the variable definitions section) is affected by the
task as Syntax21-28 shows.
$dumpports
var_type size identifier_code reference
$var < $end
var_type ::=
port
size ::= | vector_index
1
vector_index ::= msb_index lsb_index
[ : ]
index ::= decimal_number
identifier_code ::= integer
reference ::= port_identifier
Syntax21-28—Syntax for extended VCD node information (not in AnnexA)
The constructs are defined as follows:
var_type The keyword . No other keyword is allowed.
port
size A decimal number indicating the number of bits in the port. If the port is a single
bit, the value shall be . If the port is a bus, the actual index is printed. The msb
1
indicates the most significant index; lsb, the least significant index.
identifier_code An integer preceded by <, which starts at zero and ascends in one-unit increments
for each port, in the order found in the module declaration.
reference Identifier indicating the port name.
For example:
module test_device(count_out, carry, data, reset)
output count_out, carry ;
input [0:3] data;
input reset;
668
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.