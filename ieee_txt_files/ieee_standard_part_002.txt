IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
An unsized single-bit value can be specified by preceding the single-bit value with an apostrophe ( ), but
'
without the base specifier. All bits of the unsized value shall be set to the value of the specified bit. In a
self-determined context, an unsized single-bit value shall have a width of 1 bit, and the value shall be treated
as unsigned.
'0, '1, 'X, 'x, 'Z, 'z // sets all bits to specified value
The use of and in defining the value of a number is case insensitive.
x z
When used in a number, the question mark character is a SystemVerilog alternative for the character.
(?) z
It sets 4 bits to the high-impedance value in hexadecimal numbers, 3 bits in octal, and 1 bit in binary. The
question mark can be used to enhance readability in cases where the high-impedance value is a do-not-care
condition. See the discussion of and in 12.5.1. The question mark character is also used in
casez casex
UDP state tables. See Table29-1 in 29.3.6.
In a decimal literal constant, the unsigned number token shall not contain any , , or digits, unless there is
x z ?
exactly one digit in the token, indicating that every bit in the decimal literal constant is or .
x z
The underscore character (_) shall be legal anywhere in a number except as the first character. The
underscore character is ignored. This feature can be used to break up long numbers for readability purposes.
Several examples of specifying literal integer numbers are as follows:
Example 1: Unsized literal constant numbers
659 // is a decimal number
'h 837FF // is a hexadecimal number
'o7460 // is an octal number
4af // is illegal (hexadecimal format requires 'h)
Example 2: Sized literal constant numbers
4'b1001 // is a 4-bit binary number
5 'D 3 // is a 5-bit decimal number
3'b01x // is a 3-bit number with the least
// significant bit unknown
12'hx // is a 12-bit unknown number
16'hz // is a 16-bit high-impedance number
Example 3: Using sign with literal constant numbers
8 'd -6 // this is illegal syntax
-8 'd 6 // this defines the two's-complement of 6,
// held in 8 bits—equivalent to -(8'd 6)
4 'shf // this denotes the 4-bit number '1111', to
// be interpreted as a two's-complement number,
// or '-1'. This is equivalent to -4'h 1
-4 'sd15 // this is equivalent to -(-4'd 1), or '0001'
16'sd? // the same as 16'sbz
Example 4: Automatic left padding of literal constant numbers
logic [11:0] a, b, c, d;
logic [84:0] e, f, g;
initial begin
a = 'h x; // yields xxx
74
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
b = 'h 3x; // yields 03x
c = 'h z3; // yields zz3
d = 'h 0z3; // yields 0z3
e = 'h5; // yields {82{1'b0},3'b101}
f = 'hx; // yields {85{1'hx}}
g = 'hz; // yields {85{1'hz}}
end
Example 5: Automatic left padding of constant literal numbers using a single-bit value
logic [15:0] a, b, c, d;
a = '0; // sets all 16 bits to 0
b = '1; // sets all 16 bits to 1
c = 'x; // sets all 16 bits to x
d = 'z; // sets all 16 bits to z
Example 6: Underscores in literal constant numbers
27_195_000 // unsized decimal 27195000
16'b0011_0101_0001_1111 // 16-bit binary number
32 'h 12ab_f001 // 32-bit hexadecimal number
Sized negative literal constant numbers and sized signed literal constant numbers are sign-extended when
assigned to a data object of type , regardless of whether the type itself is signed.
logic
The default length of and is the same as the default length of an integer.
x z
5.7.2 Real literal constants
The real literal constant numbers shall be represented as described by IEEE Std 754, an IEEE standard for
double-precision floating-point numbers.
Real numbers can be specified in either decimal notation (for example, 14.72) or in scientific notation (for
example, 39e8, which indicates 39 multiplied by 10 to the eighth power). Real numbers expressed with a
decimal point shall have at least one digit on each side of the decimal point.
For example:
1.2
0.1
2394.26331
(the exponent symbol can be e or E)
1.2E12
1.30e-2
0.1e-0
23E10
29E-2
(underscores are ignored)
236.123_763_e-12
The following are invalid forms of real numbers because they do not have at least one digit on each side of
the decimal point:
.12
9.
4.E3
.2e-7
75
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The default type for fixed-point format (e.g., 1.2), and exponent format (e.g., 2.0e10) shall be .
real
A cast can be used to convert literal real values to the type (e.g., ). Casting
shortreal shortreal'(1.2)
is described in 6.24.
Real numbers shall be converted to integers by rounding the real number to the nearest integer, rather than
by truncating it. Implicit conversion shall take place when a real number is assigned to an integer. The ties
shall be rounded away from zero. For example:
— The real numbers 35.7 and 35.5 both become 36 when converted to an integer and 35.2 becomes 35.
— Converting –1.5 to integer yields –2, converting 1.5 to integer yields 2.
5.8 Time literals
Time is written in integer or fixed-point format, followed without a space by a time unit ( ).
fspsnsusmss
For example:
2.1ns
40ps
The time literal is interpreted as a value scaled to the current time unit and rounded to the current
realtime
time precision.
5.9 String literals
A string literal is a sequence of characters enclosed by double quotes ( ).
""
Nonprinting and other special characters are preceded with a backslash.
A string literal shall be contained in a single line unless the newline character is immediately preceded by a
(backslash). In this case, the backslash and the newline character are ignored. There is no predefined limit
\
to the length of a string literal.
Example 1:
$display("Humpty Dumpty sat on a wall. \
Humpty Dumpty had a great fall.");
prints
Humpty Dumpty sat on a wall. Humpty Dumpty had a great fall.
Example 2:
$display("Humpty Dumpty sat on a wall.\n\
Humpty Dumpty had a great fall.");
prints
Humpty Dumpty sat on a wall.
Humpty Dumpty had a great fall.
String literals used as operands in expressions and assignments shall be treated as unsigned integer constants
represented by a sequence of 8-bit ASCII values, with one 8-bit ASCII value representing one character.
76
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A string literal can be assigned to an integral type, such as a packed array. If the size differs, it is right
justified. To fully store a string literal, the integral type should be declared with a width equal to the number
of characters in the string multiplied by 8. For example:
byte c1 = "A" ;
bit [7:0] d = "\n" ;
The rules of SystemVerilog assignments shall be followed if the packed array width does not match the
number of characters multiplied by 8. When an integral type is larger than required to hold the string literal
value being assigned, the value is right-justified, and the leftmost bits are padded with zeros, as is done with
nonstring values. If a string literal is larger than the destination integral type, the string is right-justified, and
the leftmost characters are truncated.
For example, to store the 12-character string requires a variable 8  12, or 96 bits wide.
"Hello world\n"
bit [8*12:1] stringvar = "Hello world\n";
Alternatively, a multidimensional packed array can be used, with 8-bit subfields, as in:
bit [0:11] [7:0] stringvar = "Hello world\n" ;
A string literal can be assigned to an unpacked array of bytes. If the size differs, it is left justified.
byte c3 [0:12] = "hello world\n" ;
Packed and unpacked arrays are discussed in 7.4.
String literals can also be cast to a packed or unpacked array type, which shall follow the same rules as
assigning a string literal to a packed or unpacked array. Casting is discussed in 6.24.
SystemVerilog also includes a data type to which a string literal can be assigned. Variables of type
string
have arbitrary length; they are dynamically resized to hold any string. String literals are packed
string
arrays (of a width that is a multiple of 8 bits), and they are implicitly converted to the type when
string
assigned to a type or used in an expression involving type operands (see 6.16).
string string
String literals stored in vectors can be manipulated using the SystemVerilog operators. The value being
manipulated by the operator is the sequence of 8-bit ASCII values. See 11.10 for operations on string
literals.
5.9.1 Special characters in strings
Certain characters can only be used in string literals when preceded by an introductory character called an
escape character. Table5-1 lists these characters in the right-hand column, with the escape sequence that
represents the character in the left-hand column.
Table5-1—Specifying special characters in string literals
Escape string Character produced by escape string
\n Newline character
\t Tab character
\\ \ character
\" " character
77
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table5-1—Specifying special characters in string literals (continued)
Escape string Character produced by escape string
\v vertical tab
\f form feed
\a bell
\ddd A character specified in 1 to 3 octal_digits (see Syntax5-2). If fewer than three
characters are used, the following character shall not be an octal_digit. Implementations
may issue an error if the character represented is greater than \377. It shall be illegal for
an octal_digit in an escape sequence to be an x_digit or a z_digit (see Syntax5-2).
\xdd A character specified in 1 to 2 hex_digits (see Syntax5-2). If only one digit is used, the
following character shall not be a hex_digit. It shall be illegal for a hex_digit in an
escape sequence to be an x_digit or a z_digit (see Syntax5-2).
5.10 Structure literals
Structure literals are structure assignment patterns or pattern expressions with constant member expressions
(see 10.9.2). A structure literal must have a type, which may be either explicitly indicated with a prefix or
implicitly indicated by an assignment-like context (see 10.8).
typedef struct {int a; shortreal b;} ab;
ab c;
c = '{0, 0.0}; // structure literal type determined from
// the left-hand context (c)
Nested braces shall reflect the structure. For example:
ab abarr[1:0] = '{'{1, 1.0}, '{2, 2.0}};
The C-like alternative for the preceding example is not allowed.
'{1, 1.0, 2, 2.0}
Structure literals can also use member name and value or use data type and default value (see 10.9.2):
c = '{a:0, b:0.0}; // member name and value for that member
c = '{default:0}; // all elements of structure c are set to 0
d = ab'{int:1, shortreal:1.0}; // data type and default value for all
// members of that type
When an array of structures is initialized, the nested braces shall reflect the array and the structure. For
example:
ab abarr[1:0] = '{'{1, 1.0}, '{2, 2.0}};
Replication operators can be used to set the values for the exact number of members. The inner pair of
braces in a replication is removed.
struct {int X,Y,Z;} XYZ = '{3{1}};
typedef struct {int a,b[4];} ab_t;
int a,b,c;
ab_t v1[1:0] [2:0];
v1 = '{2{'{3{'{a,'{2{b,c}}}}}}};
/* expands to '{ '{3{ '{ a, '{2{ b, c }} } }},
78
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
'{3{ '{ a, '{2{ b, c }} } }}
} */
/* expands to '{ '{ '{ a, '{2{ b, c }} },
'{ a, '{2{ b, c }} },
'{ a, '{2{ b, c }} }
},
'{ '{ a, '{2{ b, c }} },
'{ a, '{2{ b, c }} },
'{ a, '{2{ b, c }} }
}
} */
/* expands to '{ '{ '{ a, '{ b, c, b, c } },
'{ a, '{ b, c, b, c } },
'{ a, '{ b, c, b, c } }
},
'{ '{ a, '{ b, c, b, c } },
'{ a, '{ b, c, b, c } },
'{ a, '{ b, c, b, c } }
}
} */
5.11 Array literals
Array literals are syntactically similar to C initializers, but with the replication operator ( ) allowed.
{{}}
int n[1:2][1:3] = '{'{0,1,2},'{3{4}}};
The nesting of braces shall follow the number of dimensions, unlike in C. However, replication operators
can be nested. The inner pair of braces in a replication is removed. A replication expression only operates
within one dimension.
int n[1:2][1:6] = '{2{'{3{4, 5}}}}; // same as
'{'{4,5,4,5,4,5},'{4,5,4,5,4,5}}
Array literals are array assignment patterns or pattern expressions with constant member expressions (see
10.9.1). An array literal must have a type, which may be either explicitly indicated with a prefix or implicitly
indicated by an assignment-like context (see 10.8).
typedef int triple [1:3];
$mydisplay(triple'{0,1,2});
Array literals can also use their index or type as a key and use a default key value (see 10.9.1).
triple b = '{1:1, default:0}; // indices 2 and 3 assigned 0
5.12 Attributes
A mechanism is included for specifying properties about objects, statements, and groups of statements in the
SystemVerilog source that can be used by various tools, including simulators, to control the operation or
behavior of the tool. These properties are referred to as attributes. This subclause specifies the syntactic
mechanism used for specifying attributes, without standardizing on any particular attributes.
The syntax for specifying an attribute is shown in Syntax5-3.
79
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
attribute_instance ::= attr_spec { attr_spec } // from A.9.1
(* , *)
attr_spec ::= attr_name [ constant_expression ]
=
attr_name ::= identifier
Syntax5-3—Syntax for attributes (excerpt from AnnexA)
An attribute_instance can appear in the SystemVerilog description as a prefix attached to a declaration, a
module item, a statement, or a port connection. It can appear as a suffix to an operator or a function name in
an expression.
The default type of an attribute with no value is , with a value of 1. Otherwise, the attribute takes the
bit
type of the expression.
If the same attribute name is defined more than once for the same language element, the last attribute value
shall be used, and a tool can issue a warning that a duplicate attribute specification has occurred.
Nesting of attribute instances is disallowed. It shall be illegal to specify the value of an attribute with a
constant expression that contains an attribute instance.
Refer to AnnexA for the syntax of specifying an attribute instance on specific language elements. Several
examples are illustrated below.
Example 1: The following example shows how to attach attributes to a case statement:
(* full_case, parallel_case *)
case (a)
<rest_of_case_statement>
or
(* full_case=1 *)
(* parallel_case=1 *) // Multiple attribute instances also OK
case (a)
<rest_of_case_statement>
or
(* full_case, // no value assigned
parallel_case=1 *)
case (a)
<rest_of_case_statement>
Example 2: To attach the attribute, but not the attribute:
full_case parallel_case
(* full_case *) // parallel_case not specified
case (a)
<rest_of_case_statement>
or
(* full_case=1, parallel_case = 0 *)
case (a)
<rest_of_case_statement>
80
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Example 3: To attach an attribute to a module definition:
(* optimize_power *)
module mod1 (<port_list>);
or
(* optimize_power=1 *)
module mod1 (<port_list>);
Example 4: To attach an attribute to a module instantiation:
(* optimize_power=0 *)
mod1 synth1 (<port_list>);
Example 5: To attach an attribute to a variable declaration:
(* fsm_state *) logic [7:0] state1;
(* fsm_state=1 *) logic [3:0] state2, state3;
logic [3:0] reg1; // reg1 does NOT have fsm_state set
(* fsm_state=0 *) logic [3:0] reg2; // nor does reg2
Example 6: To attach an attribute to an operator:
a = b + (* mode = "cla" *) c; // sets the value for the attribute mode
// to be the string cla.
Example 7: To attach an attribute to a function call:
a = add (* mode = "cla" *) (b, c);
Example 8: To attach an attribute to a conditional operator:
a = b ? (* no_glitch *) c : d;
5.13 Built-in methods
SystemVerilog uses a C++-like class method calling syntax, in which a subroutine is called using the dot
notation ( ):
.
object.task_or_function()
The object uniquely identifies the data on which the subroutine operates. Hence, the method concept is
naturally extended to built-in types in order to add functionality, which traditionally was done via system
tasks or system functions. Unlike system tasks, built-in methods are not prefixed with a because they
$
require no special prefix to avoid collisions with user-defined identifiers. Thus, the method syntax allows
extending the language without the addition of new keywords or the cluttering of the global name space with
system tasks.
Built-in methods, unlike system tasks, cannot be redefined by users via PLI tasks. Thus, only functions that
users should not be allowed to redefine are good candidates for built-in method calls.
In general, a built-in method is preferred over a system task when a particular functionality applies to all
data types or when it applies to a specific data type. For example:
81
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
dynamic_array.size, associative_array.num, and string.len
These are all similar concepts, but they represent different things. A dynamic array has a size, an associative
array contains a given number of items, and a string has a given length. Using the same system task, such as
, for all of them would be less clear and intuitive.
$size
A built-in method can only be associated with a particular data type. Therefore, if some functionality is a
simple side effect (i.e., or ) or it operates on no specific data (i.e., ), then a system
$stop $reset $random
task must be used.
When a subroutine built-in method call specifies no arguments, the empty parenthesis, , following the
()
subroutine name is optional. This is also true for subroutines that require arguments, when all arguments
have defaults specified. For a method, this rule allows simple calls to appear as properties of the object or
built-in type. Similar rules are defined for subroutines in 13.5.5.
82
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
6. Data types
6.1 General
This clause describes the following:
— SystemVerilog logic value and strength set
— Net declarations
— Singular variable declarations
— Constants
— Scope and lifetime of data
— Type compatibility
— Type operator and type casting
6.2 Data types and data objects
SystemVerilog makes a distinction between an object and its data type. A data type is a set of values and a
set of operations that can be performed on those values. Data types can be used to declare data objects or to
define user-defined data types that are constructed from other data types. A data object is a named entity that
has a data value and a data type associated with it, such as a parameter, a variable, or a net.
6.3 Value set
6.3.1 Logic values
The SystemVerilog value set consists of the following four basic values:
—represents a logic zero or a false condition
0
1—represents a logic one or a true condition
—represents an unknown logic value
x
—represents a high-impedance state
z
The values 0 and 1 are logical complements of one another.
When the z value is present at the input of a gate or when it is encountered in an expression, the effect is
usually the same as an x value. Notable exceptions are the metal-oxide semiconductor (MOS) primitives,
which can pass the z value.
The name of this primitive data type is . This name can be used to declare objects and to construct
logic
other data types from the 4-state data type.
Several SystemVerilog data types are 4-state types, which can store all four logic values. All bits of 4-state
vectors can be independently set to one of the four basic values. Some SystemVerilog data types are 2-state,
and only store 0 or 1 values in each bit of a vector. Other exceptions are the event type (see 6.17), which has
no storage, and the real types (see 6.12).
6.3.2 Strengths
The language includes strength information in addition to the basic value information for nets. This is
described in detail in Clause28. The additional strength information associated with bits of a net is not
considered part of the data type.
83
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Two types of strengths can be specified in a net declaration, as follows:
— Charge strength shall only be used when declaring a net of type .
trireg
— Drive strength shall only be used when placing a continuous assignment on a net in the same
statement that declares the net.
Gate declarations can also specify a drive strength. See Clause28 for more information on gates and for
information on strengths.
6.3.2.1 Charge strength
The charge strength specification shall be used only with trireg nets. A trireg net shall be used to model
charge storage; charge strength shall specify the relative size of the capacitance indicated by one of the
following keywords:
—
small
—
medium
—
large
The default charge strength of a trireg net shall be .
medium
A trireg net can model a charge storage node whose charge decays over time. The simulation time of a
charge decay shall be specified in the delay specification for the trireg net (see 28.16.2).
For example:
trireg a; // trireg net of charge strength medium
trireg (large) #(0,0,50) cap1; // trireg net of charge strength large
// with charge decay time 50 time units
trireg (small) signed [3:0] cap2; // signed 4-bit trireg vector of
// charge strength small
6.3.2.2 Drive strength
The drive strength specification allows a continuous assignment to be placed on a net in the same statement
that declares that net. See Clause10 for more details. Net drive strength properties are described in detail in
Clause28.
6.4 Singular and aggregate types
Data types are categorized as either singular or aggregate. A singular type shall be any data type except an
unpacked structure, unpacked union, or unpacked array (see 7.4 on arrays). An aggregate type shall be any
unpacked structure, unpacked union, or unpacked array data type. A singular variable or expression
represents a single value, symbol, or handle. Aggregate expressions and variables represent a set or
collection of singular values. Integral types (see 6.11.1) are always singular even though they can be sliced
into multiple singular values. The data type is singular even though a string can be indexed in a
string
similar way to an unpacked array of bytes.
These categories are defined so that operators and functions can simply refer to these data types as a
collective group. For example, some functions recursively descend into an aggregate variable until reaching
a singular value and then perform an operation on each singular value.
Although a class is a type, there are no variables or expressions of class type directly, only class object
handles that are singular. Therefore, classes need not be categorized in this manner (see Clause8 on classes).
84
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
6.5 Nets and variables
There are two main groups of data objects: variables and nets. These two groups differ in the way in which
they are assigned and hold values.
A net can be written by one or more continuous assignments, by primitive outputs, or through module ports.
The resultant value of multiple drivers is determined by the resolution function of the net type. A net cannot
be procedurally assigned. If a net on one side of a port is driven by a variable on the other side, a continuous
assignment is implied. A statement can override the value of a net. When released, the net returns to
force
the resolved value.
Variables can be written by one or more procedural statements, including procedural continuous
assignments. The last write determines the value. Alternatively, variables can be written by one continuous
assignment or one port.
Variables can be packed or unpacked aggregates of other types (see 7.4 for packed and unpacked types).
Multiple assignments made to independent elements of a variable are examined individually. Independent
elements include different members of a structure or different elements of an array. Each bit in a packed type
is also an independent element. Thus, in an aggregate of packed types, each bit in the aggregate is an
independent element.
An assignment where the left-hand side contains a slice is treated as a single assignment to the entire slice.
Thus, a structure or array can have one element assigned procedurally and another element assigned
continuously. And elements of a structure or array can be assigned with multiple continuous assignments,
provided that each element is covered by no more than a single continuous assignment.
The precise rule is that it shall be an error to have multiple continuous assignments or a mixture of
procedural and continuous assignments writing to any term in the expansion of a written longest static prefix
of a variable (see 11.5.3 for the definition of a longest static prefix).
For example, assume the following structure declaration:
struct {
bit [7:0] A;
bit [7:0] B;
byte C;
} abc;
The following statements are legal assignments to :
structabc
assign abc.C = sel ? 8'hBE : 8'hEF;
not (abc.A[0],abc.B[0]),
(abc.A[1],abc.B[1]),
(abc.A[2],abc.B[2]),
(abc.A[3],abc.B[3]);
always @(posedge clk) abc.B <= abc.B + 1;
The following additional statements are illegal assignments to :
structabc
// Multiple continuous assignments to abc.C
assign abc.C = sel ? 8'hDE : 8'hED;
// Mixing continuous and procedural assignments to abc.A[3]
always @(posedge clk) abc.A[7:3] <= !abc.B[7:3];
85
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For the purposes of the preceding rule, a declared variable initialization or a procedural continuous
assignment is considered a procedural assignment. The statement overrides the procedural assign
force
statement, which in turn overrides the normal assignments. A statement is neither a continuous nor a
force
procedural assignment.
A continuous assignment shall be implied when a variable is connected to an input port declaration. This
makes assignments to a variable declared as an input port illegal. A continuous assignment shall be implied
when a variable is connected to the output port of an instance. This makes additional procedural or
continuous assignments to a variable connected to the output port of an instance illegal.
Variables cannot be connected to either side of an port. Variables can be shared across ports with the
inout
port type. See 23.3.3 for more information about ports and port connection rules.
ref
The compiler can issue a warning if a continuous assignment could drive strengths other than , ,
St0 St1
, or to a variable. In any case, automatic type conversion shall be applied to the assignment, and the
StX HiZ
strength is lost.
Unlike nets, a variable cannot have an implicit continuous assignment as part of its declaration. An
assignment as part of the declaration of a variable is a variable initialization, not a continuous assignment.
For example:
wire w = vara & varb; // net with a continuous assignment
logic v = consta & constb; // variable with initialization
logic vw; // no initial assignment
assign vw = vara & varb; // continuous assignment to a variable
real circ;
assign circ = 2.0 * PI * R; // continuous assignment to a variable
Data shall be declared before they are used, apart from implicit nets (see 6.10).
Within a name space (see 3.13), it shall be illegal to redeclare a name already declared by a net, variable, or
other declaration.
6.6 Net types
There are two different kinds of net types: built-in and user-defined. The net types can represent physical
connections between structural entities, such as gates. A net shall not store a value (except for the
trireg
net). Instead, its value shall be determined by the values of its drivers, such as a continuous assignment or a
gate. See Clause10 and Clause28 for definitions of these constructs. If no driver is connected to a net, its
value shall be high-impedance ( ) unless the net is a , in which case it shall hold the previously
z trireg
driven value.
There are several distinct types of built-in net types, as shown in Table6-1.
86
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table6-1—Built-in net types
wire tri tri0 supply0
wand triand tri1 supply1
wor trior trireg uwire
6.6.1 Wire and tri nets
The wire and tri nets connect elements. The net types and shall be identical in their syntax and
wire tri
functions; two names are provided so that the name of a net can indicate the purpose of the net in that model.
A net can be used for nets that are driven by a single gate or continuous assignment. The net type
wire tri
can be used where multiple drivers drive a net.
Logical conflicts from multiple sources of the same strength on a or a net result in (unknown)
wire tri x
values.
Table6-2 is a truth table for resolving multiple drivers on and nets. It assumes equal strengths for
wire tri
both drivers. See 28.11 for a discussion of logic strength modeling.
Table6-2—Truth table for wire and tri nets
0 1 x z
wire/tri
0 0 x x 0
1 x 1 x 1
x x x x x
z 0 1 x z
6.6.2 Unresolved nets
The net is an unresolved or unidriver wire and is used to model nets that allow only a single driver.
uwire
The type can be used to enforce this restriction. It shall be an error to connect any bit of a net
uwire uwire
to more than one driver. It shall be an error to connect a net to a bidirectional terminal of a
uwire
bidirectional pass switch.
The port connection rule in 23.3.3.6 enforces this restriction across the net hierarchy or shall issue a warning
if not.
6.6.3 Wired nets
Wired nets are of type , , , and and are used to model wired logic configurations.
wor wand trior triand
Wired nets use different truth tables to resolve the conflicts that result when multiple drivers drive the same
net. The and nets shall create wired or configurations so that when any of the drivers is 1, the
wor trior
resulting value of the net is 1. The and nets shall create wired and configurations so that if any
wand triand
driver is 0, the value of the net is 0.
87
Authorized licensed use limited to: SiCeompyernigsh t A©G 2 0G18B ISE EBE&. ASl l SrigOhLts GreMseSrv.e dD.ownloaded on December 03,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The net types and shall be identical in their syntax and functionality. The net types and
wor trior wand
shall be identical in their syntax and functionality. Table6-3 and Table6-4 give the truth tables for
triand
wired nets, assuming equal strengths for both drivers. See 28.11 for a discussion of logic strength modeling.
Table6-3—Truth table for wand and triand nets
0 1 x z
wand/triand
0 0 0 0 0
1 0 1 x 1
x 0 x x x
z 0 1 x z
Table6-4—Truth table for wor and trior nets
0 1 x z
wor/trior
0 0 1 x 0
1 1 1 1 1
x x 1 x x
z 0 1 x z
6.6.4 Trireg net
The trireg net stores a value and is used to model charge storage nodes. A trireg net can be in one of two
states, as follows:
Driven state When at least one driver of a net has a value of , , or , the resolved
trireg 1 0 x
value propagates into the net and is the driven value of the net.
trireg trireg
Capacitive state When all the drivers of a net are at the high-impedance value ( ), the
trireg z
net retains its last driven value; the high-impedance value does not
trireg
propagate from the driver to the .
trireg
The strength of the value on the net in the capacitive state can be , , or ,
trireg small medium large
depending on the size specified in the declaration of the net. The strength of a net in the
trireg trireg
driven state can be , , , or , depending on the strength of the driver.
supply strong pull weak
For example, Figure6-1 shows a schematic that includes a net whose size is , its driver, and
trireg medium
the simulation results.
88
Authorized licensed use limited to: SiCeompyernigsh t A©G 2 0G18B ISE EBE&. ASl l SrigOhLts GreMseSrv.e dD.ownloaded on December 03,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
wire a wire b
wire c
nmos1 nmos2
trireg d
simulation time
wire a wire b wire c trireg d
0
1 1 strong 1 strong 1
10
0 1 HiZ medium 1
Figure6-1—Simulation values of a trireg and its driver
a) At simulation time 0, wire and wire have a value of . A value of with a strength
a b 1 1 strong
propagates from the gate through the switches connected to each other by wire into
and nmos c
trireg net .
d
b) At simulation time 10, wire changes value to , disconnecting wire from the gate. When
a 0 c and
wire is no longer connected to the gate, the value of wire changes to . The value of wire
c and c HiZ
remains 1 so wire remains connected to trireg net through the switch. The value
b c d nmos2 HiZ
does not propagate from wire into trireg net . Instead, net enters the capacitive state,
c d trireg d
storing its last driven value of . It stores the with a strength.
1 1 medium
6.6.4.1 Capacitive networks
A capacitive network is a connection between two or more trireg nets. In a capacitive network whose trireg
nets are in the capacitive state, logic and strength values can propagate between trireg nets.
For example, Figure6-2 shows a capacitive network in which the logic value of some trireg nets change the
logic value of other trireg nets of equal or smaller size.
In Figure6-2, the capacitive strength of net is , and are
trireg_la large trireg_me1 trireg_me2
, and is . Simulation reports the following sequence of events:
medium trireg_sm small
a) At simulation time 0, wire and wire have a value of . The wire drives a value of into
a b 1 c 1
and ; wire drives a value of into and .
trireg_la trireg_sm d 1 trireg_me1 trireg_me2
b) At simulation time 10, the value of wire changes to , disconnecting and
b 0 trireg_sm
from their drivers. These trireg nets enter the capacitive state and store the value ,
trireg_me2 1
their last driven value.
c) At simulation time 20, wire drives a value of into .
c 0 trireg_la
d) At simulation time 30, wire drives a value of into .
d 0 trireg_me1
e) At simulation time 40, the value of wire changes to , disconnecting and
a 0 trireg_la
from their drivers. These trireg nets enter the capacitive state and store the value .
trireg_me1 0
f) At simulation time 50, the value of wire changes to .
b 1
g) This change of value in wire connects to ; these trireg nets have different
b trireg_sm trireg_la
sizes and stored different values. This connection causes the smaller trireg net to store the value of
the larger trireg net, and now stores a value of .
trireg_sm 0
This change of value in wire also connects to ; these trireg nets have
b trireg_me1 trireg_me2
the same size and stored different values. The connection causes both and
trireg_me1
to change value to .
trireg_me2 x
89
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
wire a
wire b
wire c
nmos_1 tranif1_1
trireg_la trireg_sm
wire d
nmos_2 tranif1_2
trireg_me1 trireg_me2
simulation
wire a wire b wire c wire d trireg_la trireg_sm trireg_me1 trireg_me2
time
0
1 1 1 1 1 1 1 1
10
1 0 1 1 1 1 1 1
20
1 0 0 1 0 1 1 1
30
1 0 0 0 0 1 0 1
40
0 0 0 0 0 1 0 1
50
0 1 0 0 0 0 x x
Figure6-2—Simulation results of a capacitive network
In a capacitive network, charge strengths propagate from a larger trireg net to a smaller trireg net. Figure6-3
shows a capacitive network and its simulation results.
In Figure6-3, the capacitive strength of is , and the capacitive strength of is
trireg_la large trireg_sm
. Simulation reports the following results:
small
a) At simulation time 0, the values of wire , wire , and wire are , and wire drives a
a b c 1 a strong 1
into and .
trireg_la trireg_sm
b) At simulation time 10, the value of wire changes to , disconnecting and
b 0 trireg_la trireg_sm
from wire . The and nets enter the capacitive state. Both trireg nets share
a trireg_la trireg_sm
the charge of because they remain connected through .
large trireg_la tranif1_2
c) At simulation time 20, the value of wire changes to , disconnecting from
c 0 trireg_sm
. The no longer shares charge of and now stores a
trireg_la trireg_sm large trireg_la
charge.
small
d) At simulation time 30, the value of wire changes to , connecting the two trireg nets. These trireg
c 1
nets now share the same charge.
e) At simulation time 40, the value of wire changes again to , disconnecting from
c 0 trireg_sm
. Once again, no longer shares the charge of and now
trireg_la trireg_sm large trireg_la
stores a charge.
small
90
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
wire b wire c
wire a
tranif1_1 tranif1_2
trireg_la trireg_sm
simulation
wire a wire b wire c trireg_la trireg_sm
time
0
strong 1 1 1 strong 1 strong 1
10
strong 1 0 1 large 1 large 1
20
strong 1 0 0 large 1 small 1
30
strong 1 0 1 large 1 large 1
40
strong 1 0 0 large 1 small 1
Figure6-3—Simulation results of charge sharing
6.6.4.2 Ideal capacitive state and charge decay
A net can retain its value indefinitely, or its charge can decay over time. The simulation time of
trireg
charge decay is specified in the delay specification of the net. See 28.16.2 for charge decay
trireg
explanation.
6.6.5 Tri0 and tri1 nets
The and nets model nets with resistive pulldown and resistive pullup devices on them. A
tri0 tri1 tri0
net is equivalent to a wire net with a continuous value of strength driving it. A net is equivalent
0 pull tri1
to a wire net with a continuous value of strength driving it.
1 pull
When no driver drives a net, its value is with strength . When no driver drives a net, its
tri0 0 pull tri1
value is with strength . When there are drivers on a or net, the drivers combine with the
1 pull tri0 tri1
strength value implicitly driven on the net to determine the net’s value. See 28.11 for a discussion of
pull
logic strength modeling.
Table6-5 and Table6-6 are truth tables for modeling multiple drivers of strength on and
strong tri0
nets. The resulting value on the net has strength , unless both drivers are , in which case the
tri1 strong z
net has strength .
pull
91
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table6-5—Truth table for tri0 net
0 1 x z
tri0
0 0 x x 0
1 x 1 x 1
x x x x x
z 0 1 x 0
Table6-6—Truth table for tri1 net
0 1 x z
tri1
0 0 x x 0
1 x 1 x 1
x x x x x
z 0 1 x 1
6.6.6 Supply nets
The and nets can be used to model the power supplies in a circuit. These nets shall have
supply0 supply1
strengths.
supply
6.6.7 User-defined nettypes
A user-defined allows users to describe more general abstract values for a wire, including its
nettype
resolution function. This is similar to a in some ways, but shall only be used in declaring
nettype typedef
a net. It provides a name for a particular data type and optionally an associated resolution function.
The syntax for net type declarations is given in Syntax6-1.
net_type_declaration ::= // from A.2.1.3
data_type net_type_identifier
nettype
[ [ package_scope | class_scope ] tf_identifier ]
with ;
| [ package_scope | class_scope ] net_type_identifier net_type_identifier
nettype ;
Syntax6-1—Syntax for net type declarations (excerpt from AnnexA)
A net declared with a therefore uses that data type and, if specified, the associated resolution
nettype
function. An explicit data type is required for a user-defined .
nettype
92
Authorized licensed use limited to: SiCeompyernigsh t A©G 2 0G18B ISE EBE&. ASl l SrigOhLts GreMseSrv.e dD.ownloaded on December 03,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Certain restrictions apply to the data type of a net with a user-defined . A valid data type shall be
nettype
one of the following:
a) A 4-state integral type, including a packed array, packed structure or union.
b) A 2-state integral type, including a packed array, packed structure or union with 2-state data type
members.
c) A or type.
real shortreal
d) A fixed-size unpacked array, unpacked structure or union, where each element has a valid data type
for a net of a user-defined .
nettype
A second form of a declaration is to create another name for an existing .
nettype nettype
An atomic net is a net whose value is updated and resolved as a whole. A net declared with a user-defined
is an atomic net. Similarly, a net is an atomic net, but a vector net is not an atomic
nettype logic logic
net as each element is resolved and updated independently. While an atomic net may have a singular
logic
or aggregate value, each atomic net is intended to describe a single connection point in the design.
The resolution for a user-defined is specified using a SystemVerilog function declaration. If a
nettype
resolution function is specified, then when a driver of the net changes value, an update event is scheduled on
the net in the Active (or Reactive) region. When the update event matures, the simulator calls the resolution
function to compute the value of the net from the values of the drivers. The return type of the function shall
match the data type of the . The function shall accept an arbitrary number of drivers, since different
nettype
instances of the net could be connected to different numbers of drivers. Any change in the value of one or
more of the drivers shall trigger the evaluation of the resolution function associated with that .
nettype
A user-defined resolution function for a net of a user-defined with a data type shall be a function
nettype T
with a return type of and a single input argument whose type is a dynamic array of elements of type . A
T T
resolution function shall be automatic (or preserve no state information) and have no side effects. A
resolution function shall not resize the dynamic array input argument nor shall it write to any part of the
dynamic array input argument. While a class function method may be used for a resolution function, such
functions shall be class static methods as the method call occurs in a context where no class object is
involved in the call. Parameterized variants of such methods can be created through the use of parameterized
class methods as described in 13.8.
Two different nettypes can use the same data type, but have different resolution functions A may
nettype
be declared without a resolution function, in which case it shall be an error for a net of that to have
nettype
multiple drivers.
Due to nondeterminism within scheduling regions, if there are multiple driver updates within a scheduling
region, there may be multiple evaluations of the resolution function.
A statement can override the value of a net of a user-defined . When released, the net
force nettype
returns to the resolved value.
// user-defined data type T
typedef struct {
real field1;
bit field2;
} T;
// user-defined resolution function Tsum
function automatic T Tsum (input T driver[]);
Tsum.field1 = 0.0;
foreach (driver[i])
Tsum.field1 += driver[i].field1;
93
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
endfunction
nettype T wT; // an unresolved nettype wT whose data type is T
// a nettype wTsum whose data type is T and
// resolution function is Tsum
nettype T wTsum with Tsum;
// user-defined data type TR
typedef real TR[5];
// an unresolved nettype wTR whose data type
// is an array of real
nettype TR wTR;
// declare another name nettypeid2 for nettype wTsum
nettype wTsum nettypeid2;
The following example shows how to use a combination of a parameterized class definition with class static
methods to parameterize the data type of a user-defined .
nettype
class Base #(parameter p = 1);
typedef struct {
real r;
bit[p-1:0] data;
} T;
static function T Tsum (input T driver[]);
Tsum.r = 0.0;
Tsum.data = 0;
foreach (driver[i])
Tsum.data += driver[i].data;
Tsum.r = $itor(Tsum.data);
endfunction
endclass
typedef Base#(32) MyBaseT;
nettype MyBaseT::T narrowTsum with MyBaseT::Tsum;
typedef Base#(64) MyBaseType;
nettype MyBaseType::T wideTsum with MyBaseType::Tsum;
narrowTsum net1; // data is 32 bits wide
wideTsum net2; // data is 64 bits wide
6.6.8 Generic interconnect
In SystemVerilog it is possible to use net types and configurations to create design models with varying
levels of abstraction. In order to support netlist designs, which primarily specify design element instances
and the net connections between the design elements, SystemVerilog defines a generic form of nets. Such
generic nets allow the separation of the specification of the net connections from the types of the
connections.
A net or port declared as (an net or port) indicates a typeless or generic net.
interconnect interconnect
Such nets or ports are only able to express net port and terminal connections and shall not be used in any
procedural context nor in any continuous or procedural continuous assignments. An net or
interconnect
port shall not be used in any expression other than a net_lvalue expression in which all nets or ports in the
expression are also nets. An array shall be considered valid even if
interconnect interconnect
different bits in the array are resolved to different net types as demonstrated in the following example. It
94
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
shall be legal to specify a net_alias statement with an net_lvalue. See 23.3.3.7.1 and
interconnect
23.3.3.7.2 for port and terminal connection rules for nets.
interconnect
package NetsPkg;
nettype real realNet;
endpackage : NetsPkg
module top();
interconnect [0:1] iBus;
lDriver l1(iBus[0]);
rDriver r1(iBus[1]);
rlMod m1(iBus);
endmodule : top
module lDriver(output wire logic out);
endmodule : lDriver
module rDriver
import NetsPkg::*;
(output realNet out);
endmodule : rDriver
module rlMod(input interconnect [0:1] iBus);
lMod l1(iBus[0]);
rMod r1(iBus[1]);
endmodule : rlMod
The following simple example serves to illustrate the usefulness of an net. The example
interconnect
contains a top level module ( ) that instantiates a stimulus module ( ) and a comparator module
top driver
( ). This configuration is intended to compare two elements and determine if they are equal. There are
cmp
two different versions of the configuration, as described by the two different blocks: one that works
config
on values and one that works on values. By using the typeless net, we can use
real logic interconnect
the same testbench with both configurations, without having to change anything in the testbench itself. The
net takes its data type from the type of its connections.
interconnect aBus
<file lib.map>
library realLib *.svr;
library logicLib *.sv;
config cfgReal;
design logicLib.top;
default liblist realLib logicLib;
endconfig
config cfgLogic;
design logicLib.top;
default liblist logicLib realLib;
endconfig
<file top.sv>
module top();
interconnect [0:3] [0:1] aBus;
logic [0:3] dBus;
driver driverArray[0:3](aBus);
cmp cmpArray[0:3](aBus,rst,dBus);
endmodule : top
<file nets.pkg>
package NetsPkg;
95
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
nettype real realNet;
endpackage : NetsPkg
<file driver.svr>
module driver
import NetsPkg::*;
#(parameter int delay = 30,
int iterations = 256)
(output realNet [0:1] out);
timeunit 1ns / 1ps;
real outR[1:0];
assign out = outR;
initial begin
outR[0] = 0.0;
outR[1] = 3.3;
for (int i = 0; i < iterations; i++) begin
#delay outR[0] += 0.2;
outR[1] -= 0.2;
end
end
endmodule : driver
<file driver.sv>
module driver #(parameter int delay = 30,
int iterations = 256)
(output wire logic [0:1] out);
timeunit 1ns / 1ps;
logic [0:1] outvar;
assign out = outvar;
initial begin
outvar = '0;
for (int i = 0; i < iterations; i++)
#delay outvar++;
end
endmodule : driver
<file cmp.svr>
module cmp
import NetsPkg::*;
#(parameter real hyst = 0.65)
(input realNet [0:1] inA,
input logic rst,
output logic out);
timeunit 1ns / 1ps;
real updatePeriod = 100.0;
initial out = 1'b0;
always #updatePeriod begin
if (rst) out <= 1'b0;
else if (inA[0] > inA[1]) out <= 1'b1;
else if (inA[0] < inA[1] - hyst) out <= 1'b0;
end
endmodule : cmp
<file cmp.sv>
module cmp #(parameter real hyst = 0.65)
96
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
(input wire logic [0:1] inA,
input logic rst,
output logic out);
initial out = 1'b0;
always @(inA, rst) begin
if (rst) out <= 1'b0;
else if (inA[0] & ~inA[1]) out <= 1'b1;
else out <= 1'b0;
end
endmodule : cmp
6.7 Net declarations
The syntax for net declarations is given in Syntax6-2.
net_declaration12 ::= // from A.2.1.3
net_type [ drive_strength | charge_strength ] [ | ]
vectored scalared
data_type_or_implicit [ delay3 ] list_of_net_decl_assignments
;
| net_type_identifier [ delay_control ]
list_of_net_decl_assignments
;
| implicit_data_type [ delay_value ]
interconnect #
net_identifier { unpacked_dimension }
[ net_identifier { unpacked_dimension }]
, ;
net_type ::= // from A.2.2.1
| | | | | | | | | | |
supply0 supply1 tri triand trior trireg tri0 tri1 uwire wire wand wor
drive_strength ::= // from A.2.2.2
strength0 , strength1
( )
| strength1 , strength0
( )
| strength0 ,
( highz1)
| strength1 ,
( highz0)
| , strength1
(highz0 )
| , strength0
(highz1 )
strength0 ::= | | |
supply0 strong0 pull0 weak0
strength1 ::= | | |
supply1 strong1 pull1 weak1
charge_strength ::= | |
( small ) ( medium ) ( large )
delay3 ::= // from A.2.2.3
delay_value | mintypmax_expression [ mintypmax_expression [ mintypmax_expression ] ]
# # ( , , )
delay2 ::= delay_value | mintypmax_expression [ mintypmax_expression ]
# # ( , )
delay_value ::=
unsigned_number
| real_number
| ps_identifier
| time_literal
|
1step
list_of_net_decl_assignments ::= net_decl_assignment { net_decl_assignment } // from A.2.3
,
net_decl_assignment ::= net_identifier { unpacked_dimension } [ expression ] // from A.2.4
=
12) A charge strength shall only be used with the keyword. When the or keyword is
trireg vectored scalared
used, there shall be at least one packed dimension.
Syntax6-2—Syntax for net declarations (excerpt from AnnexA)
97
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
6.7.1 Net declarations with built-in net types
Net declarations without assignments and whose is not a user-defined are described in
nettype nettype
this subclause. Net declarations with assignments are described in Clause10.
A net declaration begins with a net type that determines how the values of the nets in the declaration are
resolved. The declaration can include optional information such as delay values, drive or charge strength,
and a data type.
If a set of nets share the same characteristics, they can be declared in the same declaration statement.
Any 4-state data type can be used to declare a net. For example:
trireg (large) logic #(0,0,0) cap1;
typedef logic [31:0] addressT;
wire addressT w1;
wire struct packed { logic ecc; logic [7:0] data; } memsig;
If a data type is not specified in the net declaration or if only a range and/or signing is specified, then the data
type of the net is implicitly declared as . For example:
logic
wire w; // equivalent to "wire logic w;"
wire [15:0] ww; // equivalent to "wire logic [15:0] ww;"
A net declared as an net shall:
interconnect
— have no data type but may have optional packed or unpacked dimensions;
— not specify drive_strength or charge_strength;
— not have assignment expressions;
— specify at most one delay value.
Certain restrictions apply to the data type of a net. A valid data type for a net shall be one of the following:
a) A 4-state integral type, including a packed array or packed structure.
b) A fixed-size unpacked array or unpacked structure, where each element has a valid data type for a
net.
The effect of this recursive definition is that a net is composed entirely of 4-state bits and is treated
accordingly. In addition to a signal value, each bit of a net shall have additional strength information. When
bits of signals combine, the strength and value of the resulting signal shall be determined as described in
28.12.
A lexical restriction applies to the use of the keyword in a net or port declaration. A net type keyword
reg
shall not be followed directly by the keyword. Thus, the following declarations are in error:
reg
tri reg r;
inout wire reg p;
The keyword can be used in a net or port declaration if there are lexical elements between the net type
reg
keyword and the keyword.
reg
The default initialization value for a net shall be the value z. Nets with drivers shall assume the output value
of their drivers. The net is an exception. The net shall default to the value x, with the
trireg trireg
strength specified in the net declaration ( , , or ).
small medium large
98
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
As described in 6.6.8, an net is restricted in terms of its declaration and use. The following
interconnect
are some examples of legal and illegal net declarations:
interconnect
interconnect w1; // legal
interconnect [3:0] w2; // legal
interconnect [3:0] w3 [1:0]; // legal
interconnect logic [3:0] w4; // illegal – data type specified
interconnect #(1,2,3) w5; // illegal – only one delay permitted
assign w1 = 1; // illegal – not allowed in a
// continuous assign
initial $display(w1); // illegal – not allowed in a
// procedural context
6.7.2 Net declarations with user-defined nettypes
A net with a user-defined allows users to describe more general abstract values for a wire. A net
nettype
declared with a uses the data type and any associated resolution function for that .
nettype nettype
// an unresolved nettype wT whose data type is T
// Refer to example in 6.6.7 for declaration of the data type T
nettype T wT;
// a nettype wTsum whose data type is T and
// resolution function is Tsum
// Refer to example in 6.6.7 for the declaration of Tsum
nettype T wTsum with Tsum;
// a net of unresolved nettype wT
wT w1;
// an array of nets, each net element is of unresolved nettype wT
wT w2[8];
// a net of resolved nettype wTsum and resolution function Tsum
wTsum w3;
// an array of nets, each net is of resolved nettype wTsum
wTsum w4[8];
// user-defined data type TR which is an array of reals
typedef real TR[5];
// an unresolved nettype wTR with data type TR
nettype TR wTR;
// a net with unresolved nettype wTR and data type TR
wTR w5;
// an array of nets, each net has an unresolved nettype wTR
// and data type TR
wTR w6[8];
6.7.3 Initialization of nets with user-defined nettypes
The resolution function for any net of a user-defined shall be activated at time zero at least once.
nettype
This activation occurs even for such nets with no drivers or no value changes on drivers at time zero. Since
the actual evaluation of the resolution function is subject to scheduling nondeterminism, no assumptions can
99
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
be made regarding the state of driven values during the guaranteed call, which may precede or follow any
driver changes at time zero.
The initial value of a net with a user-defined shall be set before any initial or always procedures
nettype
are started and before the activation of the guaranteed time zero resolution call. The default initialization
value for a net with a user-defined shall be the default value defined by the data type. Table6-7
nettype
defines the default value for data types of variables if no initializer is provided; those default values shall
also apply to nets of user-defined nettypes for valid data types of a net. For a net with a user-defined
whose data type is a type, any initialization expressions for the members within the
nettype struct
shall be applied.
struct
NOTE— The default value for a net of a user-defined is X. This default means that a bit of a
logic nettype logic
data type in an unresolved user-defined will be X if it has no drivers, not Z. For a net with a resolved
nettype
, the value would be determined by the resolution function executed with an empty array of driver values.
nettype
6.8 Variable declarations
A variable is an abstraction of a data storage element. A variable shall store a value from one assignment to
the next. An assignment statement in a procedure acts as a trigger that changes the value in the data storage
element.
The syntax for variable declarations is given in Syntax6-3.
data_declaration ::= // from A.2.1.3
[ ] [ ] [ lifetime ] data_type_or_implicit list_of_variable_decl_assignments 10
const var ;
| type_declaration
...
data_type ::= // from A.2.2.1
integer_vector_type [ signing ] { packed_dimension }
| integer_atom_type [ signing ]
| non_integer_type
| struct_union [ [ signing ] ] struct_union_member { struct_union_member }
packed { }
{ packed_dimension }13
| [ enum_base_type ] enum_name_declaration { enum_name_declaration }
enum { , }
{ packed_dimension }
|
string
|
chandle
| [ ] interface_identifier [ parameter_value_assignment ] [ modport_identifier ]
virtual interface .
| [ class_scope | package_scope ] type_identifier { packed_dimension }
| class_type
|
event
| ps_covergroup_identifier
| type_reference14
integer_type ::= integer_vector_type | integer_atom_type
integer_atom_type ::= | | | | |
byte shortint int longint integer time
integer_vector_type ::= | |
bit logic reg
non_integer_type ::= | |
shortreal real realtime
signing ::= |
signed unsigned
simple_type ::= integer_type | non_integer_type | ps_type_identifier | ps_parameter_identifier
data_type_or_void ::= data_type |
void
100
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
variable_decl_assignment ::= // from A.2.4
variable_identifier { variable_dimension } [ expression ]
=
| dynamic_array_variable_identifier unsized_dimension { variable_dimension }
[ dynamic_array_new ]
=
| class_variable_identifier [ class_new ]
=
10) In a data_declaration that is not within a procedural context, it shall be illegal to use the keyword. In
automatic
a data_declaration, it shall be illegal to omit the explicit data_type before a list_of_variable_decl_assignments
unless the keyword is used.
var
13) When a packed dimension is used with the or keyword, the keyword shall also be used.
struct union packed
14) When a type_reference is used in a net declaration, it shall be preceded by a net type keyword; and when it is used
in a variable declaration, it shall be preceded by the keyword.
var
Syntax6-3—Syntax for variable declarations (excerpt from AnnexA)
One form of variable declaration consists of a data type followed by one or more instances.
shortint s1, s2[0:9];
Another form of variable declaration begins with the keyword . The data type is optional in this case. If
var
a data type is not specified or if only a range and/or signing is specified, then the data type is implicitly
declared as .
logic
var byte my_byte; // equivalent to "byte my_byte;"
var v; // equivalent to "var logic v;"
var [15:0] vw; // equivalent to "var logic [15:0] vw;"
var enum bit { clear, error } status;
input var logic data_in;
var reg r;
If a set of variables share the same characteristics, they can be declared in the same declaration statement.
A variable can be declared with an initializer, for example:
int i = 0;
Setting the initial value of a static variable as part of the variable declaration (including static class
members) shall occur before any initial or always procedures are started (also see 6.21 and 10.5 on variable
initialization with static and automatic lifetimes).
NOTE—In IEEE Std 1364-2005, an initialization value specified as part of the declaration was executed as if the
assignment were made from an initial procedure, after simulation has started.
Initial values are not constrained to simple constants; they can include run-time expressions, including
dynamic memory allocation. For example, a static class handle or a mailbox can be created and initialized by
calling its method (see 15.4.1), or static variables can be initialized to random values by calling the
new
system task. This may require a special pre-initial pass at run time.
$urandom
Table6-7 contains the default values for variables if no initializer is specified.
101
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table6-7—Default variable initial values
Type Default initial value
4-state integral
'X
2-state integral
'0
,
real shortreal 0.0
Enumeration Base type default initial value
(empty string)
string ""
New event
event
class null
interface class null
(Opaque handle)
chandle null
virtual interface null
Nets and variables can be assigned negative values, but only signed types shall retain the significance of the
sign. The , , , , and types are signed types by default. Other net and
byte shortint int integer longint
variable types can be explicitly declared as signed. See 11.4.3.1 for a description of how signed and
unsigned nets and variables are treated by certain operators.
6.9 Vector declarations
A data object declared as , , or (or as a matching user-defined type or implicitly as )
reg logic bit logic
without a range specification shall be considered 1-bit wide and is known as a scalar. A multibit data object
of one of these types shall be declared by specifying a range and is known as a vector. Vectors are packed
arrays of scalars (see 7.4).
6.9.1 Specifying vectors
The range specification ([msb_constant_expression : lsb_constant_expression]) gives addresses to the
individual bits in a multibit , , or vector. The most significant bit, specified by the msb
reg logic bit
constant expression, is the left-hand value in the range, and the least significant bit, specified by the lsb
constant expression, is the right-hand value in the range.
Both the msb constant expression and the lsb constant expression shall be constant integer expressions. The
msb and lsb constant expressions (see 11.2.1) may be any integer value—positive, negative, or zero. It shall
be illegal for them to contain any unknown (x) or high-impedance bits. The lsb value may be greater than,
equal to, or less than the msb value.
Vectors shall obey laws of arithmetic modulo-2 to the power n (2n), where n is the number of bits in the
vector. Vectors of , , and types shall be treated as unsigned quantities, unless declared to be
reg logic bit
signed or connected to a port that is declared to be signed (see 23.2.2.1 and 23.3.3.8).
Examples:
wand w; // a scalar "wand" net
102
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
tri [15:0] busa; // a 16-bit bus
trireg (small) storeit; // a charge storage node of strength small
logic a; // a scalar variable
logic[3:0] v; // a 4-bit vector made up of (from most to
// least significant)v[3], v[2], v[1], and v[0]
logic signed [3:0] signed_reg; // a 4-bit vector in range -8 to 7
logic [-1:4] b; // a 6-bit vector
wire w1, w2; // declares two nets
logic [4:0] x, y, z; // declares three 5-bit variables
Implementations may set a limit on the maximum length of a vector, but the limit shall be at least
65536(216) bits.
Implementations are not required to detect overflow of integer operations.
6.9.2 Vector net accessibility
Vectored and scalared shall be optional advisory keywords to be used in vector net declarations. If these
keywords are implemented, certain operations on vector nets may be restricted. If the keyword is
vectored
used, bit-selects and part-selects and strength specifications may not be permitted, and the PLI may consider
the net unexpanded. If the keyword is used, bit-selects and part-selects of the net shall be
scalared
permitted, and the PLI shall consider the net expanded.
For example:
tri1 scalared [63:0] bus64; //a bus that will be expanded
tri vectored [31:0] data; //a bus that may or may not be expanded
6.10 Implicit declarations
The syntax shown in 6.7 and 6.8 shall be used to declare nets and variables explicitly. In the absence of an
explicit declaration, an implicit net of default net type shall be assumed in the following circumstances:
— If an identifier is used in a port expression declaration, then an implicit net of default net type shall
be assumed, with the vector width of the port expression declaration. See 23.2.2.1 for a discussion of
port expression declarations.
— If an identifier is used in the terminal list of a primitive instance or in the port connection list of a
module, interface, program, or static checker instance (but not a procedural checker instance, see
17.3), and that identifier has not been declared previously in the scope where the instantiation
appears or in any scope whose declarations can be directly referenced from the scope where the
instantiation appears (see 23.9), then an implicit scalar net of default net type shall be assumed.
— If an identifier appears on the left-hand side of a continuous assignment statement, and that identifier
has not been declared previously in the scope where the continuous assignment statement appears or
in any scope whose declarations can be directly referenced from the scope where the continuous
assignment statement appears (see 23.9), then an implicit scalar net of default net type shall be
assumed. See 10.3 for a discussion of continuous assignment statements.
The implicit net declaration shall belong to the scope in which the net reference appears. For example, if the
implicit net is declared by a reference in a generate block, then the net is implicitly declared only in that
generate block. Subsequent references to the net from outside the generate block or in another generate
block within the same module either would be illegal or would create another implicit declaration of a
different net (depending on whether the reference meets the preceding criteria). See Clause27 for
information about generate blocks.
103
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
See 22.8 for a discussion of control of the type for implicitly declared nets with the
`default_nettype
compiler directive.
6.11 Integer data types
SystemVerilog provides several integer data types, as shown in Table6-8.
Table6-8—Integer data types
2-state data type, 16-bit signed integer
shortint
2-state data type, 32-bit signed integer
int
2-state data type, 64-bit signed integer
longint
2-state data type, 8-bit signed integer or ASCII character
byte
2-state data type, user-defined vector size, unsigned
bit
4-state data type, user-defined vector size, unsigned
logic
4-state data type, user-defined vector size, unsigned
reg
4-state data type, 32-bit signed integer
integer
4-state data type, 64-bit unsigned integer
time
6.11.1 Integral types
The term integral is used throughout this standard to refer to the data types that can represent a single basic
integer data type, packed array, packed structure, packed union, enum variable, or time variable.
The term simple bit vector type is used throughout this standard to refer to the data types that can directly
represent a one-dimensional packed array of bits. The integer types listed in Table6-8 are simple bit vector
types with predefined widths. The packed structure types (see 7.2) and multidimensional packed array types
(see 7.4) are not simple bit vector types, but each is equivalent (see 6.22.2) to some simple bit vector type, to
and from which it can be easily converted.
6.11.2 2-state (two-value) and 4-state (four-value) data types
Types that can have unknown and high-impedance values are called 4-state types. These are , ,
logic reg
, and . The other types do not have unknown values and are called 2-state types, for example,
integer time
and .
bit int
The difference between and is that is a 2-state type and is a 4-state type. The
int integer int integer
4-state values have additional bits, which encode the and states. The 2-state data types can simulate
X Z
faster, take less memory, and are preferred in some design styles.
The keyword does not always accurately describe user intent, as it could be perceived to imply a
reg
hardware register. The keyword is a more descriptive term. and denote the same type.
logic logic reg
Automatic type conversions from a smaller number of bits to a larger number of bits involve zero extensions
if unsigned or sign extensions if signed. Automatic type conversions from a larger number of bits to a
smaller number of bits involve truncations of the most significant bits (MSBs). When a 4-state value is
automatically converted to a 2-state value, any unknown or high-impedance bits shall be converted to zeros.
104
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
6.11.3 Signed and unsigned integer types
Integer types use integer arithmetic and can be signed or unsigned. This affects the meaning of certain
operators (see Clause11 on operators and expressions).
The data types , , , , and default to signed. The data types , ,
byte shortint int integer longint time bit
, and default to unsigned, as do arrays of these types. The signedness can be explicitly defined
reg logic
using the keywords and .
signed unsigned
int unsigned ui;
int signed si;
6.12 Real, shortreal, and realtime data types
The 12 data type is the same as a C . The data type is the same as a C . The
real double shortreal float
declarations shall be treated synonymously with declarations and can be used
realtime real
interchangeably. Variables of these three types are collectively referred to as real variables.
6.12.1 Operators and real numbers
The result of using logical or relational operators on real numbers and real variables is a single-bit scalar
value. Not all operators can be used with expressions involving real numbers and real variables (see 11.3.1).
Real number constants and real variables are also prohibited in the following cases:
— Edge event controls ( , , ) applied to real variables
posedge negedge edge
— Bit-select or part-select references of variables declared as
real
— Real number index expressions of bit-select or part-select references of vectors
6.12.2 Conversion
Real numbers shall be converted to integers by rounding the real number to the nearest integer, rather than
by truncating it. Implicit conversion shall take place when a real number is assigned to an integer. If the
fractional part of the real number is exactly 0.5, it shall be rounded away from zero.
Implicit conversion shall also take place when an expression is assigned to a real. Individual bits that are
x
or in the net or the variable shall be treated as zero upon conversion.
z
Explicit conversion can be specified using casting (see 6.24) or using system tasks (see 20.5).
6.13 Void data type
The data type represents nonexistent data. This type can be specified as the return type of functions to
void
indicate no return value. This type can also be used for members of tagged unions (see 7.3.2).
6.14 Chandle data type
The data type represents storage for pointers passed using the DPI (see Clause35). The size of a
chandle
value of this data type is platform dependent, but shall be at least large enough to hold a pointer on the
machine on which the tool is running.
The syntax to declare a handle is as follows:
12The real and shortreal types are represented as described by IEEE Std 754.
105
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
chandle variable_name ;
where is a valid identifier. Chandles shall always be initialized to the value , which
variable_name null
has a value of 0 on the C side. Chandles are restricted in their usage, with the only legal uses being as
follows:
— Only the following operators are valid on variables:
chandle
• Equality ( ), inequality ( ) with another or with
== != chandle null
• Case equality ( ), case inequality ( ) with another or with (same semantics
=== !== chandle null
as and )
== !=
— Chandles can be tested for a Boolean value, which shall be 0 if the is and
chandle null
1otherwise.
— Only the following assignments can be made to a :
chandle
• Assignment from another
chandle
• Assignment to
null
— Chandles can be inserted into associative arrays (refer to 7.8), but the relative ordering of any two
entries in such an associative array can vary, even between successive runs of the same tool.
— Chandles can be used within a class.
— Chandles can be passed as arguments to subroutines.
— Chandles can be returned from functions.
The use of chandles is restricted as follows:
— Ports shall not have the data type.
chandle
— Chandles shall not be assigned to variables of any other type.
— Chandles shall not be used as follows:
• In any expression other than as permitted in this subclause
• As ports
• In sensitivity lists or event expressions
• In continuous assignments
• In untagged unions
• In packed types
6.15 Class
A class variable can hold a handle to a class object. Defining classes and creating objects is discussed in
Clause8.
6.16 String data type
The data type is an ordered collection of characters. The length of a variable is the number
string string
of characters in the collection. Variables of type are dynamic as their length may vary during
string
simulation. A single character of a variable may be selected for reading or writing by indexing the
string
variable. A single character of a variable is of type .
string byte
SystemVerilog also includes a number of special methods to work with strings, which are defined in this
subclause.
106
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A string variable does not represent a string in the same way as a string literal (see 5.9). String literals
behave like packed arrays of a width that is a multiple of 8 bits. A string literal assigned to a packed array of
an integral variable of a different size is either truncated to the size of the variable or padded with zeros to
the left as necessary. When using the data type instead of an integral variable, strings can be of
string
arbitrary length and no truncation occurs. String literals are implicitly converted to the type when
string
assigned to a type or used in an expression involving type operands.
string string
The indices of string variables shall be numbered from 0 to N–1 (where N is the length of the string) so that
index 0 corresponds to the first (leftmost) character of the string and index N–1 corresponds to the last
(rightmost) character of the string. The string variables can take on the special value , which is the empty
""
string. Indexing an empty string variable shall be an out-of-bounds access.
A string variable shall not contain the special character . Assigning the value 0 to a string character
"\0"
shall be ignored.
The syntax to declare a string variable is as follows:
string variable_name [= initial_value];
where is a valid identifier and the optional can be a string literal, the
variable_name initial_value
value for an empty string, or a string data type expression. For example:
""
parameter string default_name = "John Smith";
string myName = default_name;
If an initial value is not specified in the declaration, the variable is initialized to , the empty string. An
""
empty string has zero length.
SystemVerilog provides a set of operators that can be used to manipulate combinations of string variables
and string literals. The basic operators defined on the data type are listed in Table6-9.
string
A string literal can be assigned to a variable of a or an integral data type. When assigning to a
string
variable of integral data type, if the number of bits of the data object is not equal to the number of characters
in the string literal multiplied by 8, the literal is right justified and either truncated on the left or zero-filled
on the left, as necessary. For example:
byte c = "A"; // assigns to c "A"
bit [10:0] b = "\x41"; // assigns to b 'b000_0100_0001
bit [1:4][7:0] h = "hello" ; // assigns to h "ello"
A string literal or an expression of type can be assigned directly to a variable of type (a
string string
string variable). Values of integral type can be assigned to a string variable, but require a cast. When casting
an integral value to a string variable, that variable shall grow or shrink to accommodate the integral value. If
the size of the integral value is not a multiple of 8 bits, then the value shall be zero-filled on the left so that its
size is a multiple of 8 bits.
A string literal assigned to a string variable is converted according to the following steps:
— All characters in the string literal are ignored (i.e., removed from the string).
"\0"
— If the result of the first step is an empty string literal, the string is assigned the empty string.
— Otherwise, the string is assigned the remaining characters in the string literal.
Casting an integral value to a string variable proceeds in the following steps:
107
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— If the size (in bits) of the integral value is not a multiple of 8, the integral value is left extended and
filled with zeros until its bit size is a multiple of 8. The extended value is then treated the same as a
string literal, where each successive 8 bits represent a character.
— The steps described previously for string literal conversion are then applied to the extended value.
For example:
string s0 = "String literal assign";// sets s0 to "String literal assign"
string s1 = "hello\0world"; // sets s1 to "helloworld"
bit [11:0] b = 12'ha41;
string s2 = string'(b); // sets s2 to 16'h0a41
As a second example:
typedef logic [15:0] r_t;
r_t r;
integer i = 1;
string b = "";
string a = {"Hi", b};
r = r_t'(a); // OK
b = string'(r); // OK
b = "Hi"; // OK
b = {5{"Hi"}}; // OK
a = {i{"Hi"}}; // OK (non-constant replication)
r = {i{"Hi"}}; // invalid (non-constant replication)
a = {i{b}}; // OK
a = {a,b}; // OK
a = {"Hi",b}; // OK
r = {"H",""}; // yields "H\0". "" is converted to 8'b0
b = {"H",""}; // yields "H". "" is the empty string
a[0] = "h"; // OK, same as a[0] = "cough"
a[0] = b; // invalid, requires a cast
a[1] = "\0"; // ignored, a is unchanged
Table6-9—String operators
Operator Semantics
Equality. Checks whether the two string operands are equal. Result is 1 if they
Str1 == Str2
are equal and 0 if they are not. Both operands can be expressions of
string
type, or one can be an expression of type and the other can be a string
string
literal, which shall be implicitly converted to type for the comparison.
string
If both operands are string literals, the operator is the same equality operator as
for integral types.
Inequality. Logical negation of ==
Str1 != Str2
Comparison: Relational operators return 1 if the corresponding condition is true
Str1 < Str2
using the lexicographic ordering of the two strings and . The
Str1 <= Str2 Str1 Str2
comparison uses the compare string method. Both operands can be expressions
Str1 > Str2
of type, or one can be an expression of type and the other can
Str1 >= Str2 string string
be a string literal, which shall be implicitly converted to type for the
string
comparison. If both operands are string literals, the operator is the same
comparison operator as for integral types.
108
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table6-9—String operators (continued)
Operator Semantics
Concatenation: Each operand can be a string literal or an expression of
{Str1,Str2,...,Strn} string
type. If all the operands are string literals the expression shall behave as a con-
catenation of integral values; if the result of such a concatenation is used in an
expression involving types then it shall be implicitly converted to
string
type. If at least one operand is an expression of type, then
string string
any operands that are string literals shall be converted to type before
string
the concatenation is performed, and the result of the concatenation shall be of
type.
string
Replication: can be a string literal or an expression of type.
{multiplier{Str}} Str string
shall be an expression of integral type and is not required to be a
multiplier
constant expression. If is non-constant or is an expression
multiplier Str
of type, the result is a string containing N concatenated copies of ,
string Str
where N is specified by the . If is a literal and the
multiplier Str
is constant, the expression behaves like numeric replication (if
multiplier
the result is used in another expression involving types, it is implicitly
string
converted to the type).
string
Indexing. Returns a byte, the ASCII code at the given index. Indices range from
Str[index]
0 to N–1, where N is the number of characters in the string. If given an index out
of range, returns 0. Semantically equivalent to in 6.16.3.
Str.getc(index)
The dot ( ) operator is used to invoke a specified method on strings.
Str.method(...) .
SystemVerilog also includes a number of special methods to work with strings, which use the built-in
method notation. These methods are described in 6.16.1 through 6.16.15.
6.16.1 Len()
function int len();
— returns the length of the string, i.e., the number of characters in the string.
str.len()
— If is " ", then returns 0.
str str.len()
6.16.2 Putc()
function void putc(int i, byte c);
— replaces the ith character in str with the given integral value.
str.putc(i, c)
— does not change the size of : If < 0 or >= , then str is unchanged.
putc str i i str.len()
— If the second argument to is zero, the string is unaffected.
putc
The putc method assignment is semantically equivalent to .
str.putc(j, x) str[j] = x
6.16.3 Getc()
function byte getc(int i);
— returns the ASCII code of the th character in .
str.getc(i) i str
— If < 0 or >= , then returns 0.
i i str.len() str.getc(i)
The getc method assignment is semantically equivalent to .
x = str.getc(j) x = str[j]
109
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
6.16.4 Toupper()
function string toupper();
— returns a string with characters in converted to uppercase.
str.toupper() str
— is unchanged.
str
6.16.5 Tolower()
function string tolower();
— returns a string with characters in converted to lowercase.
str.tolower() str
— is unchanged.
str
6.16.6 Compare()
function int compare(string s);
— compares and , as in the ANSI C function with regard to lexical
str.compare(s) str s strcmp
ordering and return value.
See the relational string operators in Table6-9.
6.16.7 Icompare()
function int icompare(string s);
— compares and , like the ANSI C function with regard to lexical
str.icompare(s) str s strcmp
ordering and return value, but the comparison is case insensitive.
6.16.8 Substr()
function string substr(int i, int j);
— returns a new string that is a substring formed by characters in position
str.substr(i, j) i
through of .
j str
— If < 0, < , or >= , returns (the empty string).
i j i j str.len() substr() ""
6.16.9 Atoi(), atohex(), atooct(), atobin()
function integer atoi();
function integer atohex();
function integer atooct();
function integer atobin();
— returns the integer corresponding to the ASCII decimal representation in . For
str.atoi() str
example:
str = "123";
int i = str.atoi(); // assigns 123 to i.
110
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The conversion scans all leading digits and underscore characters ( _ ) and stops as soon as it encounters any
other character or the end of the string. It returns zero if no digits were encountered. It does not parse the full
syntax for integer literals (sign, size, apostrophe, base).
— interprets the string as hexadecimal.
atohex
— interprets the string as octal.
atooct
— interprets the string as binary.
atobin
NOTE—These ASCII conversion functions return a 32-bit integer value. Truncation is possible without warning. For
converting integer values greater than 32 bits, see in 21.3.4.
$sscanf
6.16.10 Atoreal()
function real atoreal();
— returns the real number corresponding to the ASCII decimal representation in
str.atoreal()
.
str
The conversion parses for real constants. The scan stops as soon as it encounters any character that does not
conform to this syntax or the end of the string. It returns zero if no digits were encountered.
6.16.11 Itoa()
function void itoa(integer i);
— stores the ASCII decimal representation of into (inverse of ).
str.itoa(i) i str atoi
6.16.12 Hextoa()
function void hextoa(integer i);
— stores the ASCII hexadecimal representation of into (inverse of ).
str.hextoa(i) i str atohex
6.16.13 Octtoa()
function void octtoa(integer i);
— stores the ASCII octal representation of into (inverse of ).
str.octtoa(i) i str atooct
6.16.14 Bintoa()
function void bintoa(integer i);
— stores the ASCII binary representation of into (inverse of ).
str.bintoa(i) i str atobin
6.16.15 Realtoa()
function void realtoa(real r);
— stores the ASCII real representation of into (inverse of ).
str.realtoa(r) r str atoreal
111
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
6.17 Event data type
An event object gives a powerful and efficient means of describing the communication between, and
synchronization of, two or more concurrently active processes. A basic example of this is a small waveform
clock generator that synchronizes control of a synchronous circuit by signaling the occurrence of an explicit
event periodically while the circuit waits for the event to occur.
The data type provides a handle to a synchronization object. The object referenced by an event
event
variable can be explicitly triggered and waited for. Furthermore, event variables have a persistent triggered
state that lasts for the duration of the entire time step. Its occurrence can be recognized by using the event
control syntax described in 9.4.2.
An event variable can be assigned or compared to another event variable or assigned the special value .
null
When assigned another event variable, both event variables refer to the same synchronization object. When
assigned , the association between the synchronization object and the event variable is broken.
null
If an initial value is not specified in the declaration of an event variable, then the variable is initialized to a
new synchronization object.
Examples:
event done; // declare a new event called done
event done_too = done; // declare done_too as alias to done
event empty = null; // event variable with no synchronization object
Event operations and semantics are discussed in detail in 15.5.
6.18 User-defined types
SystemVerilog’s data types can be extended with user-defined types using . The syntax for
typedef
declaring user-defined types is shown in Syntax6-4.
type_declaration ::= // from A.2.1.3
data_type type_identifier { variable_dimension }
typedef ;
| interface_instance_identifier constant_bit_select type_identifier type_identifier
typedef . ;
| [ | | | | ] type_identifier
typedef enum struct union class interfaceclass ;
Syntax6-4—User-defined types (excerpt from AnnexA)
A may be used to give a user-defined name to an existing data type. For example:
typedef
typedef int intP;
The named data type can then be used as follows:
intP a, b;
User-defined data type names must be used for complex data types in casting (see 6.24), which only allows
simple data type names, and as type parameter values (see 6.20.3) when unpacked array types are used.
A type parameter may also be used to declare a type_identifier. The declaration of a user-defined data type
shall precede any reference to its type_identifier. User-defined data type identifiers have the same scoping
112
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
rules as data identifiers, except that hierarchical references to type_identifier shall not be allowed.
References to type identifiers defined within an interface through ports are not considered hierarchical
references and are allowed provided they are locally redefined before being used. Such a is called
typedef
an interface based typedef.
interface intf_i;
typedef int data_t;
endinterface
module sub(intf_i p);
typedef p.data_t my_data_t;
my_data_t data;
// type of 'data' will be int when connected to interface above
endmodule
Sometimes a user-defined type needs to be declared before the contents of the type have been defined. This
is of use with user-defined types derived from the basic data types: , , ,
enum struct union
, and . Support for this is provided by the following forms for a forward typedef:
interface class class
typedef enum type_identifier;
typedef struct type_identifier;
typedef union type_identifier;
typedef class type_identifier;
typedef interface class type_identifier;
typedef type_identifier;
NOTE—While an empty user-defined type declaration is useful for coupled definitions of classes as shown in 8.27, it
cannot be used for coupled definitions of structures because structures are statically declared and there is no support for
handles to structures.
The last form shows that the basic data type of the user-defined type does not have to be defined in the
forward declaration.
The actual data type definition of a forward declaration shall be resolved within the same local
typedef
scope or block. It shall be an error if the type_identifier does not resolve to a data type. It shall be
generate
an error if a basic data type was specified by the forward type declaration and the actual type definition does
not conform to the specified basic data type. It shall be legal to have a forward type declaration in the same
scope, either before or after the final type definition. It shall be legal to have multiple forward type
declarations for the same type identifier in the same scope. The use of the term forward type declaration
does not require the forward type declaration to precede the final type definition.
A forward typedef shall be considered incomplete prior to the final type definition. While incomplete
forward types, type parameters, and types defined by an interface based typedef may resolve to class types,
use of the class scope resolution operator (see 8.23) to select a type with such a prefix shall be restricted to a
typedef declaration. It shall be an error if the prefix does not resolve to a class.
Example:
typedef C;
C::T x; // illegal; C is an incomplete forward type
typedef C::T c_t; // legal; reference to C::T is made by a typedef
c_t y;
class C;
typedef int T;
endclass
113
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
6.19 Enumerations
Enumerated types shall be defined using the syntax shown in Syntax6-5.
data_type ::= // from A.2.2.1
...
| [ enum_base_type ] enum_name_declaration { enum_name_declaration }
enum { , }
{ packed_dimension }
...
enum_base_type ::=
integer_atom_type [ signing ]
| integer_vector_type [ signing ] [ packed_dimension ]
| type_identifier [ packed_dimension ] 15
enum_name_declaration ::=
enum_identifier [ integral_number [ integral_number ] ] [ constant_expression ]
[ : ] =
15) A type_identifier shall be legal as an enum_base_type if it denotes an integer_atom_type, with which an additional
packed dimension is not permitted, or an integer_vector_type.
Syntax6-5—Enumerated types (excerpt from AnnexA)
An enumerated type declares a set of integral named constants. Enumerated data types provide the capability
to abstractly declare strongly typed variables without either a data type or data value(s) and later add the
required data type and value(s) for designs that require more definition. Enumerated data types also can be
easily referenced or displayed using the enumerated names as opposed to the enumerated values.
In the absence of a data type declaration, the default data type shall be . Any other data type used with
int
enumerated types shall require an explicit data type declaration.
An enumerated type defines a set of named values. In the following example, and are
light1 light2
defined to be variables of the anonymous (unnamed) enumerated type that includes the three members:
int
, , and .
red yellow green
enum {red, yellow, green} light1, light2; // anonymous int type
An enumerated name with or assignments assigned to an with no explicit data type or an explicit
x z enum
2-state declaration shall be a syntax error.
// Syntax error: IDLE=2'b00, XX=2'bx <ERROR>, S1=2'b01, S2=2'b10
enum bit [1:0] {IDLE, XX='x, S1=2'b01, S2=2'b10} state, next;
An declaration of a 4-state type, such as , that includes one or more names with or
enum integer x z
assignments shall be permitted.
// Correct: IDLE=0, XX='x, S1=1, S2=2
enum integer {IDLE, XX='x, S1='b01, S2='b10} state, next;
An unassigned enumerated name that follows an name with or assignments shall be a syntax error.
enum x z
// Syntax error: IDLE=0, XX='x, S1=??, S2=??
enum integer {IDLE, XX='x, S1, S2} state, next;
114
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The values can be cast to integer types and increment from an initial value of 0. This can be overridden.
enum {bronze=3, silver, gold} medal; // silver=4, gold=5
The values can be set for some of the names and not set for other names. The optional value of an
enum
named constant is an elaboration time constant expression (see 6.20) and can include references to
parameters, local parameters, genvars, other named constants, and constant functions of these.
enum
Hierarchical names and variables are not allowed. A name without a value is automatically assigned
const
an increment of the value of the previous name. It shall be an error to automatically increment the maximum
representable value of the enum.
// c is automatically assigned the increment-value of 8
enum {a=3, b=7, c} alphabet;
Both the enumeration names and their integer values shall be unique. It shall be an error to set two values to
the same name or to set the same value to two names, regardless of whether the values are set explicitly or
by automatic incrementing.
// Error: c and d are both assigned 8
enum {a=0, b=7, c, d=8} alphabet;
If the first name is not assigned a value, it is given the initial value of 0.
// a=0, b=7, c=8
enum {a, b=7, c} alphabet;
The integer value expressions are evaluated in the context of a cast to the base type. Any enumeration
enum
encoding value that is outside the representable range of the base type shall be an error. For an
enum
unsigned base type, this occurs if the cast truncates the value and any of the discarded bits are nonzero. For a
signed base type, this occurs if the cast truncates the value and any of the discarded bits are not equal to the
sign bit of the result. If the integer value expression is a sized literal constant, it shall be an error if the size is
different from the base type, even if the value is within the representable range. The value after the
enum
cast is the value used for the name, including in the uniqueness check and automatic incrementing to get a
value for the next name.
// Correct declaration - bronze and gold are unsized
enum bit [3:0] {bronze='h3, silver, gold='h5} medal2;
// Correct declaration - bronze and gold sizes are redundant
enum bit [3:0] {bronze=4'h3, silver, gold=4'h5} medal3;
// Error in the bronze and gold member declarations
enum bit [3:0] {bronze=5'h13, silver, gold=3'h5} medal4;
// Error in c declaration, requires at least 2 bits
enum bit [0:0] {a,b,c} alphabet;
Type checking of enumerated types used in assignments, as arguments, and with operators is covered in
6.19.3. As in C, there is no overloading of literals; therefore, and cannot be defined in the
medal2 medal3
same scope because they contain the same names.
6.19.1 Defining new data types as enumerated types
A type name can be given so that the same type can be used in many places.
typedef enum {NO, YES} boolean;
boolean myvar; // named type
115
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
6.19.2 Enumerated type ranges
A range of enumeration elements can be specified automatically, via the syntax shown in Table6-10.
Table6-10—Enumeration element ranges
Associates the next consecutive number with name.
name
Associates the constant to .
name = C C name
Generates N named constants in the sequence: name0, name1,..., nameN–1. N shall be a
name[N]
positive integral number.
Optionally, a constant can be assigned to the generated named constants to associate that
name[N] = C
constant to the first generated named constant; subsequent generated named constants are
associated consecutive values.
N shall be a positive integral number.
Creates a sequence of named constants starting with nameN and incrementing or
name[N:M]
decrementing until reaching named constant nameM.
N and M shall be nonnegative integral numbers.
Optionally, a constant can be assigned to the generated named constants to associate that
name[N:M] = C
constant to the first generated named constants; subsequent generated named constants are
associated consecutive values.
N and M shall be nonnegative integral numbers.
For example:
typedef enum { add=10, sub[5], jmp[6:8] } E1;
This example defines the enumerated type , which assigns the number 10 to the enumerated named
E1
constant . It also creates the enumerated named constants , , , , and and
add sub0 sub1 sub2 sub3 sub4
assigns them the values 11...15, respectively. Finally, the example creates the enumerated named constants
, , and and assigns them the values 16 through 18, respectively.
jmp6 jmp7 jmp8
enum { register[2] = 1, register[2:4] = 10 } vr;
The preceding example declares enumerated variable , which creates the enumerated named constants
vr
and , which are assigned the values 1 and 2, respectively. Next, it creates the
register0 register1
enumerated named constants , , and and assigns them the values 10, 11,
register2 register3 register4
and 12.
6.19.3 Type checking
Enumerated types are strongly typed; thus, a variable of type cannot be directly assigned a value that
enum
lies outside the enumeration set unless an explicit cast is used or unless the variable is a member of a
enum
union. This is a powerful type-checking aid, which prevents users from accidentally assigning nonexistent
values to variables of an enumerated type. The enumeration values can still be used as constants in
expressions, and the results can be assigned to any variable of a compatible integral type.
Enumerated variables are type-checked in assignments, arguments, and relational operators. Enumerated
variables are auto-cast into integral values, but assignment of arbitrary expressions to an enumerated
variable requires an explicit cast.
For example:
typedef enum { red, green, blue, yellow, white, black } Colors;
116
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
This operation assigns a unique number to each of the color identifiers and creates the new data type
. This type can then be used to create variables of that type.
Colors
Colors c;
c = green;
c = 1; // Invalid assignment
if ( 1 == c ) // OK. c is auto-cast to integer
In the preceding example, the value is assigned to the variable of type . The second
green c Colors
assignment is invalid because of the strict typing rules enforced by enumerated types.
Casting can be used to perform an assignment of a different data type, or an out-of-range value, to an
enumerated type. Casting is discussed in 6.19.4, 6.24.1, and 6.24.2.
6.19.4 Enumerated types in numerical expressions
Elements of enumerated type variables can be used in numerical expressions. The value used in the
expression is the numerical value associated with the enumerated value. For example:
typedef enum { red, green, blue, yellow, white, black } Colors;
Colors col;
integer a, b;
a = blue * 3;
col = yellow;
b = col + green;
From the previous declaration, has the numerical value 2. This example assigns the value of 6 (2*3),
blue a
and it assigns a value of 4 (3+1).
b
An variable or identifier used as part of an expression is automatically cast to the base type of the
enum
declaration (either explicitly or using as the default). A cast shall be required for an expression
enum int
that is assigned to an variable where the type of the expression is not equivalent to the enumeration
enum
type of the variable.
Casting to an type shall cause a conversion of the expression to its base type without checking the
enum
validity of the value (unless a dynamic cast is used as described in 6.24.2).
typedef enum {Red, Green, Blue} Colors;
typedef enum {Mo,Tu,We,Th,Fr,Sa,Su} Week;
Colors C;
Week W;
int I;
C = Colors'(C+1); // C is converted to an integer, then added to
// one, then converted back to a Colors type
C = C + 1; C++; C+=2; C = I; // Illegal because they would all be
// assignments of expressions without a cast
C = Colors'(Su); // Legal; puts an out of range value into C
I = C + W; // Legal; C and W are automatically cast to int
117
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reicgehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
6.19.5 Enumerated type methods
SystemVerilog includes a set of specialized methods to enable iterating over the values of enumerated types,
which are defined in 6.19.5.1 through 6.19.5.6.
6.19.5.1 First()
The prototype for the method is as follows:
first()
function enum first();
The method returns the value of the first member of the enumeration.
first()
6.19.5.2 Last()
The prototype for the method is as follows:
last()
function enum last();
The method returns the value of the last member of the enumeration.
last()
6.19.5.3 Next()
The prototype for the method is as follows:
next()
function enum next( int unsigned N = 1 );
The method returns the Nth next enumeration value (default is the next one) starting from the
next()
current value of the given variable. A wrap to the start of the enumeration occurs when the end of the
enumeration is reached. If the given value is not a member of the enumeration, the method returns
next()
the default initial value for the enumeration (see Table6-7).
6.19.5.4 Prev()
The prototype for the method is as follows:
prev()
function enum prev( int unsigned N = 1 );
The method returns the Nth previous enumeration value (default is the previous one) starting from
prev()
the current value of the given variable. A wrap to the end of the enumeration occurs when the start of the
enumeration is reached. If the given value is not a member of the enumeration, the method returns
prev()
the default initial value for the enumeration (see Table6-7).
6.19.5.5 Num()
The prototype for the method is as follows:
num()
function int num();
The method returns the number of elements in the given enumeration.
num()
6.19.5.6 Name()
The prototype for the name() method is as follows:
function string name();
118
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The method returns the string representation of the given enumeration value. If the given value is
name()
not a member of the enumeration, the method returns the empty string.
name()
6.19.5.7 Using enumerated type methods
The following code fragment shows how to display the name and value of all the members of an
enumeration:
typedef enum { red, green, blue, yellow } Colors;
Colors c = c.first;
forever begin
$display( "%s : %d\n", c.name, c );
if( c == c.last ) break;
c = c.next;
end
6.20 Constants
Constants are named data objects that never change. SystemVerilog provides three elaboration-time
constants: , , and . SystemVerilog also provides a run-time constant,
parameter localparam specparam
(see 6.20.6).
const
The , , and constants are collectively referred to as parameter
parameter localparam specparam
constants.
Parameter constants can be initialized with a literal.
localparam byte colon1 = ":" ;
specparam delay = 10 ; // specparams are used for specify blocks
parameter logic flag = 1 ;
SystemVerilog provides several methods for setting the value of parameter constants. Each parameter may
be assigned a default value when declared. The value of a parameter of an instantiated module, interface, or
program can be overridden in each instance using one of the following:
— Assignment by ordered list (e.g., ) (see 23.10.2.1)
m #(value, value) u1 (...);
— Assignment by name
(e.g., ) (see 23.10.2.2)
m #(.param1(value), .param2(value)) u1 (...);
— statements, using hierarchical path names to redefine each parameter (see 23.10.1)
defparam
NOTE—The statement might be removed from future versions of the language. See C.4.1.
defparam
6.20.1 Parameter declaration syntax
local_parameter_declaration ::= // from A.2.1.1
data_type_or_implicit list_of_param_assignments
localparam
| list_of_type_assignments
localparamtype
parameter_declaration ::=
data_type_or_implicit list_of_param_assignments
parameter
| list_of_type_assignments
parametertype
specparam_declaration ::=
[ packed_dimension ] list_of_specparam_assignments
specparam ;
data_type_or_implicit ::= // from A.2.2.1
119
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
data_type
| implicit_data_type
implicit_data_type ::= [ signing ] { packed_dimension }
list_of_param_assignments ::= param_assignment { param_assignment } // from A.2.3
,
list_of_specparam_assignments ::= specparam_assignment { specparam_assignment }
,
list_of_type_assignments ::= type_assignment { type_assignment }
,
param_assignment ::= // from A.2.4
parameter_identifier { unpacked_dimension } [ constant_param_expression ]18
=
specparam_assignment ::=
specparam_identifier constant_mintypmax_expression
=
| pulse_control_specparam
type_assignment ::=
type_identifier [ data_type ]18
=
parameter_port_list ::= // from A.1.3
list_of_param_assignments { parameter_port_declaration }
#( , )
| parameter_port_declaration { parameter_port_declaration }
#( , )
|
#()
parameter_port_declaration ::=
parameter_declaration
| local_parameter_declaration
| data_type list_of_param_assignments
| list_of_type_assignments
type
18) It shall be legal to omit the constant_param_expression from a param_assignment or the data_type from a type_as-
signment only within a parameter_port_list. However, it shall not be legal to omit them from localparam declara-
tions in a parameter_port_list.
Syntax6-6—Parameter declaration syntax (excerpt from AnnexA)
The list_of_param_assignments can appear in a module, interface, program, class, or package or in the
parameter_port_list of a module (see 23.2), interface, program, or class. If the declaration of a design
element uses a parameter_port_list (even an empty one), then in any parameter_declaration directly
contained within the declaration, the keyword shall be a synonym for the
parameter localparam
keyword (see 6.20.4). All param_assignments appearing within a class body shall become
localparam
declarations regardless of the presence or absence of a parameter_port_list. All param_assignments
appearing within a block, package, or compilation-unit scope shall become
generate localparam
declarations.
The keyword can be omitted in a parameter port list. For example:
parameter
class vector #(size = 1); // size is a parameter in a parameter port list
logic [size-1:0] v;
endclass
interface simple_bus #(AWIDTH = 64, type T = word) // parameter port list
(input logic clk) ; // port list
...
endinterface
120
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In a list of parameter constants, a parameter can depend on earlier parameters. In the following declaration,
the default value of the second parameter depends on the value of the first parameter. The third parameter is
a type, and the fourth parameter is a value of that type.
module mc #(int N = 5, M = N*16, type T = int, T x = 0)
( ... );
...
endmodule
In the declaration of a parameter in a parameter port list, the specification for its default value may be
omitted, in which case the parameter shall have no default value. If no default value is specified for a
parameter of a design element, then an overriding parameter value shall be specified in every instantiation of
that design element (see 23.10). Also, if no default value is specified for a parameter of a design element,
then a tool shall not implicitly instantiate that design element (see 23.3, 23.4, and 24.3). If no default value is
specified for a parameter of a class, then an overriding parameter value shall be specified in every
specialization of that class (see 8.25).
class Mem #(type T, int size);
T words[size];
...
endclass
typedef Mem#(byte, 1024) Kbyte;
6.20.2 Value parameters
A parameter constant can have a type specification and a range specification. The type and range of
parameters shall be in accordance with the following rules:
— A parameter declaration with no type or range specification shall default to the type and range of the
final value assigned to the parameter, after any value overrides have been applied. If the expression
is real, the parameter is real. If the expression is integral, the parameter is a vector of the
logic
same size with range .
[size-1:0]
— A parameter with a range specification, but with no type specification, shall have the range of the
parameter declaration and shall be unsigned. The sign and range shall not be affected by value
overrides.
— A parameter with a type specification, but with no range specification, shall be of the type specified.
A signed parameter shall default to the range of the final value assigned to the parameter, after any
value overrides have been applied.
— A parameter with a signed type specification and with a range specification shall be signed and shall
have the range of its declaration. The sign and range shall not be affected by value overrides.
— A parameter with no range specification and with either a signed type specification or no type
specification shall have an implied range with an lsb equal to and an msb equal to one less than the
0
size of the final value assigned to the parameter.
— A parameter with no range specification, with either a signed type specification or no type
specification, and for which the final value assigned to it is unsized shall have an implied range with
an lsb equal to and an msb equal to an implementation-dependent value of at least 31.
0
In an assignment to, or override of, a parameter with an explicit type declaration, the type of the right-hand
expression shall be assignment compatible with the declared type (see 6.22.3).
The conversion rules between real and integer values described in 6.12.2 apply to parameters as well.
Bit-selects and part-selects of parameters that are of integral types shall be allowed (see 6.11.1).
121
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A value parameter ( , , or ) can only be set to an expression of literals,
parameter localparam specparam
value parameters or local parameters, genvars, enumerated names, or a constant function of these. Package
references are allowed. Hierarchical names are not allowed. A can also be set to an expression
specparam
containing one or more specparams.
Examples:
parameter msb = 7; // defines msb as a constant value 7
parameter e = 25, f = 9; // defines two constant numbers
parameter r = 5.7; // declares r as a real parameter
parameter byte_size = 8,
byte_mask = byte_size - 1;
parameter average_delay = (r + f) / 2;
parameter signed [3:0] mux_selector = 0;
parameter real r1 = 3.5e17;
parameter p1 = 13'h7e;
parameter [31:0] dec_const = 1'b1; // value converted to 32 bits
parameter newconst = 3'h4; // implied range of [2:0]
parameter newconst = 4; // implied range of at least [31:0]
A parameter can also be declared as an aggregate type, such as an unpacked array or an unpacked structure.
An aggregate parameter must be assigned to or overridden as a whole; individual members of an aggregate
parameter may not be assigned or overridden separately. However, an individual member of an aggregate
parameter may be used in an expression. For example:
parameter logic [31:0] P1 [3:0] = '{ 1, 2, 3, 4 } ; // unpacked array
// parameter declaration
initial begin
if ( P1[2][7:0] ) ... // use part-select of individual element of the array
6.20.2.1 $ as a parameter value
The value $ can be assigned to parameters of integer types. A parameter to which $ is assigned shall only be
used wherever $ can be specified as a literal constant.
For example, $ represents unbounded range specification, where the upper index can be any integer.
parameter r2 = $;
property inq1(r1,r2);
@(posedge clk) a ##[r1:r2] b ##1 c |=> d;
endproperty
assert property (inq1(3, r2));
A system function is provided to test whether a constant is a $. The syntax of the system function is
$isunbounded(constant_expression)
returns true ( ) if constant_expression is unbounded. Typically, would
$isunbounded 1'b1 $isunbounded
be used as a condition in the generate statement.
The following example illustrates the benefit of using $ in writing properties concisely where the range is
parameterized. The checker in the example verifies that a bus driven by signal remains 0, i.e, quiet for the
en
specified minimum ( ) and maximum ( ) quiet time.
min_quiet max_quiet
NOTE—The function is used for checking the validity of the actual arguments.
$isunbounded
122
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
interface quiet_time_checker #(parameter min_quiet = 0,
parameter max_quiet = 0)
(input logic clk, reset_n, logic [1:0]en);
generate
if ( max_quiet == 0) begin
property quiet_time;
@(posedge clk) reset_n |-> ($countones(en) == 1);
endproperty
a1: assert property (quiet_time);
end
else begin
property quiet_time;
@(posedge clk)
(reset_n && ($past(en) != 0) && en == 0)
|->(en == 0)[*min_quiet:max_quiet]
##1 ($countones(en) == 1);
endproperty
a1: assert property (quiet_time);
end
if ((min_quiet == 0) && ($isunbounded(max_quiet))
$warning(warning_msg);
endgenerate
endinterface
quiet_time_checker #(0, 0) quiet_never (clk,1,enables);
quiet_time_checker #(2, 4) quiet_in_window (clk,1,enables);
quiet_time_checker #(0, $) quiet_any (clk,1,enables);
Another example below illustrates that by testing for , a property can be configured according to the
$
requirements. When parameter is unbounded, it is not required to test for to become false.
max_cks expr
interface width_checker #(parameter min_cks = 1, parameter max_cks = 1)
(input logic clk, reset_n, expr);
generate
if ($isunbounded(max_cks)) begin
property width;
@(posedge clk)
(reset_n && $rose(expr)) |-> (expr [* min_cks]);
endproperty
a2: assert property (width);
end
else begin
property assert_width_p;
@(posedge clk)
(reset_n && $rose(expr)) |-> (expr[* min_cks:max_cks])
##1 (!expr);
endproperty
a2: assert property (width);
end
endgenerate
endinterface
width_checker #(3, $) max_width_unspecified (clk,1,enables);
width_checker #(2, 4) width_specified (clk,1,enables);
123
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
6.20.3 Type parameters
A parameter constant can also specify a data type, allowing modules, interfaces, or programs to have ports
and data objects whose type is set for each instance.
module ma #( parameter p1 = 1, parameter type p2 = shortint )
(input logic [p1:0] i, output logic [p1:0] o);
p2 j = 0; // type of j is set by a parameter, (shortint unless redefined)
always @(i) begin
o = i;
j++;
end
endmodule
module mb;
logic [3:0] i,o;
ma #(.p1(3), .p2(int)) u1(i,o); //redefines p2 to a type of int
endmodule
In an assignment to, or override of, a type parameter, the right-hand expression shall represent a data type.
A data-type parameter ( ) can only be set to a data type. Package references are allowed.
parameter type
Hierarchical names are not allowed.
It shall be illegal to override a type parameter with a statement.
defparam
6.20.4 Local parameters (localparam)
Local parameters are identical to parameters except that they cannot directly be modified by
defparam
statements (see 23.10.1) or instance parameter value assignments (see 23.10.2). Local parameters can be
assigned constant expressions (see 11.2.1) containing parameters, which in turn can be modified with
statements or instance parameter value assignments.
defparam
Unlike nonlocal parameters, local parameters can be declared in a block, package, class body, or
generate
compilation-unit scope. In these contexts, the keyword shall be a synonym for the
parameter localparam
keyword.
Local parameters may be declared in a module’s parameter_port_list. Any parameter declaration appearing
in such a list between a keyword and the next keyword (or the end of the list, if
localparam parameter
there is no next keyword) shall be a local parameter. Any other parameter declaration in such a
parameter
list shall be a nonlocal parameter that may be overridden as described in 23.10.
6.20.5 Specify parameters
The keyword declares a special type of parameter that is intended only for providing timing and
specparam
delay values, but can appear in any expression that is not assigned to a parameter and is not part of the range
specification of a declaration. Specify parameters (also called specparams) are permitted both within the
specify block (see Clause30) and in the main module body.
A specify parameter declared outside a specify block shall be declared before it is referenced. The value
assigned to a specify parameter can be any constant expression. A specify parameter can be used as part of a
constant expression for a subsequent specify parameter declaration. Unlike the constant, a
parameter
specify parameter cannot be modified from within the language, but it can be modified through SDF
annotation (see Clause32).
124
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Specify parameters and constants are not interchangeable. In addition, and
parameter parameter
shall not be assigned a constant expression that includes any specify parameters. Table6-11
localparam
summarizes the differences between the two types of parameter declarations.
Table6-11—Differences between specparams and parameters
Specparams (specify parameter) Parameters
Use keyword Use keyword
specparam parameter
Shall be declared inside a module or specify block Shall be declared outside specify blocks
May only be used inside a module or specify block May not be used inside specify blocks
May be assigned specparams and parameters May not be assigned specparams
Use SDF annotation to override values Use or instance declaration
defparam
parameter value passing to override values
A specify parameter can have a range specification. The range of specify parameters shall be in accordance
with the following rules:
— A declaration with no range specification shall default to the range of the final value
specparam
assigned to the parameter, after any value overrides have been applied.
— A with a range specification shall have the range of the parameter declaration. The
specparam
range shall not be affected by value overrides.
Examples:
specify
specparam tRise_clk_q = 150, tFall_clk_q = 200;
specparam tRise_control = 40, tFall_control = 50;
endspecify
The lines between the keywords and declare four specify parameters. The first line
specify endspecify
declares specify parameters called and with values 150 and 200, respectively;
tRise_clk_q tFall_clk_q
the second line declares and specify parameters with values 40 and 50,
tRise_control tFall_control
respectively.
module RAM16GEN ( output [7:0] DOUT,
input [7:0] DIN,
input [5:0] ADR,
input WE, CE);
specparam dhold = 1.0;
specparam ddly = 1.0;
parameter width = 1;
parameter regsize = dhold + 1.0; // Illegal - cannot assign
// specparams to parameters
endmodule
6.20.6 Const constants
A form of constant differs from a constant in that the shall be set during
const localparam localparam
elaboration, whereas a can be set during simulation, such as in an automatic task.
const
125
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A static constant declared with the keyword can be set to an expression of literals, parameters, local
const
parameters, genvars, enumerated names, a constant function of these, or other constants. Hierarchical names
are allowed because constants declared with the keyword are calculated after elaboration.
const
const logic option = a.b.c ;
An automatic constant declared with the keyword can be set to any expression that would be legal
const
without the keyword.
const
An instance of a class (an object handle) can also be declared with the keyword.
const
const class_name object = new(5,3);
In other words, the object acts like a variable that cannot be written. The arguments to the method shall
new
be constant expressions (see 11.2.1). The members of the object can be written (except for those members
that are declared ).
const
6.21 Scope and lifetime
Variables declared outside a module, program, interface, checker, task, or function are local to the
compilation unit and have a static lifetime (exist for the whole simulation). This is roughly equivalent to C
static variables declared outside a function, which are local to a file. Variables declared inside a module,
interface, program, or checker, but outside a task, process, or function, are local in scope and have a static
lifetime.
Variables declared inside a static task, function, or block are local in scope and default to a static lifetime.
Specific variables within a static task, function, or block can be explicitly declared as automatic. Such
variables have the lifetime of the call or block and are initialized on each entry to the call or block (also see
6.8 on variable initialization). This is roughly equivalent to a C automatic variable.
Tasks and functions may be declared as . Variables declared in an automatic task, function, or
automatic
block are local in scope, default to the lifetime of the call or block, and are initialized on each entry to the
call or block (also see 6.8 on variable initialization). An automatic block is one in which declarations are
automatic by default. Specific variables within an automatic task, function, or block can be explicitly
declared as static. Such variables have a static lifetime. This is roughly equivalent to C static variables
declared within a function.
The lifetime of a fork-join block (see 9.3.2) shall encompass the execution of all processes spawned by the
block. The lifetime of a scope enclosing any fork-join block includes the lifetime of the fork-join block.
A variable declaration shall precede any simple reference (non-hierarchical) to that variable. Variable
declarations shall precede any statements within a procedural block. Variables may also be declared in
unnamed blocks. These variables are visible to the unnamed block and any nested blocks below it.
Hierarchical references shall not be used to access these variables by name.
module msl;
int st0; // static
initial begin
int st1; // static
static int st2; // static
automatic int auto1; // automatic
end
task automatic t1();
int auto2; // automatic
126
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
static int st3; // static
automatic int auto3; // automatic
endtask
endmodule
Variables declared in a static task, function, or procedural block default to a static lifetime and a local scope.
However, an explicit keyword shall be required when an initialization value is specified as part of a
static
static variable’s declaration to indicate the user’s intent of executing that initialization only once at the
beginning of simulation. The keyword shall be optional where it would not be legal to declare the
static
variables as automatic. For example:
module top_legal;
int svar1 = 1; // static keyword optional
initial begin
for (int i=0; i<3; i++) begin
automatic int loop3 = 0; // executes every loop
for (int j=0; j<3; j++) begin
loop3++;
$display(loop3);
end
end // prints 1 2 3 1 2 3 1 2 3
for (int i=0; i<3; i++) begin
static int loop2 = 0; // executes once at time zero
for (int j=0; j<3; j++) begin
loop2++;
$display(loop2);
end
end // prints 1 2 3 4 5 6 7 8 9
end
endmodule : top_legal
module top_illegal; // should not compile
initial begin
int svar2 = 2; // static/automatic needed to show intent
for (int i=0; i<3; i++) begin
int loop3 = 0; // illegal statement
for (int i=0; i<3; i++) begin
loop3++;
$display(loop3);
end
end
end
endmodule : top_illegal
An optional qualifier can be used to specify the default lifetime of all variables declared in a task, function,
or block defined within a module, interface, package, or program. The lifetime qualifier is or
automatic
. The default lifetime is .
static static
program automatic test ;
int i; // not within a procedural block - static
task t ( int a ); // arguments and variables in t are automatic
... // unless explicitly declared static
endtask
endprogram
It is permissible to hierarchically reference any static variable unless the variable is declared inside an
unnamed block. This includes static variables declared inside automatic tasks and functions.
127
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Class methods (see Clause8) and declared loop variables (see 12.7.1) are by default automatic,
for
regardless of the lifetime attribute of the scope in which they are declared.
Automatic variables and elements of dynamically sized array variables shall not be written with
nonblocking, continuous, or procedural continuous assignments. Non-static class properties shall not be
written with continuous or procedural continuous assignments. References to automatic variables and
elements or members of dynamic variables shall be limited to procedural blocks.
See also Clause13 on tasks and functions.
6.22 Type compatibility
Some constructs and operations require a certain level of type compatibility for their operands to be legal.
There are five levels of type compatibility, formally defined here: matching, equivalent, assignment
compatible, cast compatible, and nonequivalent.
SystemVerilog does not require a category for identical types to be defined here because there is no
construct in the SystemVerilog language that requires it. For example, as defined below, can be
int
interchanged with wherever it is syntactically legal to do so. Users can define their
bit signed [31:0]
own level of type identity by using the system function (see 20.6.1) or through use of the PLI.
$typename
The scope of a data type identifier shall include the hierarchical instance scope. In other words, each
instance with a user-defined type declared inside the instance creates a unique type. To have type matching
or equivalence among multiple instances of the same module, interface, program, or checker, a class, ,
enum
unpacked structure, or unpacked union type must be declared at a higher level in the compilation-unit scope
than the declaration of the module, interface, program, or checker, or imported from a package. For type
matching, this is true even for packed structure and packed union types.
6.22.1 Matching types
Two data types shall be defined as matching data types using the following inductive definition. If two data
types do not match using the following definition, then they shall be defined to be nonmatching.
a) Any built-in type matches every other occurrence of itself, in every scope.
b) A simple or type parameter override that renames a built-in or user-defined type matches
typedef
that built-in or user-defined type within the scope of the type identifier.
typedef bit node; // 'bit' and 'node' are matching types
typedef type1 type2; // 'type1' and 'type2' are matching types
c) An anonymous , , or type matches itself among data objects declared within the
enum struct union
same declaration statement and no other data types.
struct packed {int A; int B;} AB1, AB2; // AB1, AB2 have matching types
struct packed {int A; int B;} AB3; // the type of AB3 does not match
// the type of AB1
d) A for an , , , or matches itself and the type of data objects
typedef enum struct union class
declared using that data type within the scope of the data type identifier.
typedef struct packed {int A; int B;} AB_t;
AB_t AB1; AB_t AB2; // AB1 and AB2 have matching types
typedef struct packed {int A; int B;} otherAB_t;
128
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
otherAB_t AB3; // the type of AB3 does not match the type of AB1 or AB2
e) A simple bit vector type that does not have a predefined width and one that does have a predefined
width match if both are 2-state or both are 4-state, both are signed or both are unsigned, both have
the same width, and the range of the simple bit vector type without a predefined width is [width–
1:0].
typedef bit signed [7:0] BYTE; // matches the byte type
typedef bit signed [0:7] ETYB; // does not match the byte type
f) Two array types match if they are both packed or both unpacked, are the same kind of array (fixed-
size, dynamic, associative, or queue), have matching index types (for associative arrays), and have
matching element types. Fixed-size arrays shall also have the same left and right range bounds. Note
that the element type of a multidimensional array is itself an array type.
typedef byte MEM_BYTES [256];
typedef bit signed [7:0] MY_MEM_BYTES [256]; // MY_MEM_BYTES matches
// MEM_BYTES
typedef logic [1:0] [3:0] NIBBLES;
typedef logic [7:0] MY_BYTE; // MY_BYTE and NIBBLES are not matching types
typedef logic MD_ARY [][2:0];
typedef logic MD_ARY_TOO [][0:2]; // Does not match MD_ARY
g) Explicitly adding or modifiers to a type that does not change its default signing
signed unsigned
creates a type that matches the type without the explicit signing specification.
typedef byte signed MY_CHAR; // MY_CHAR matches the byte type
h) A for an , , , or type declared in a package always matches
typedef enum struct union class
itself, regardless of the scope into which the type is imported.
6.22.2 Equivalent types
Two data types shall be defined as equivalent data types using the following inductive definition. If the two
data types are not defined as equivalent using the following definition, then they shall be defined to be
nonequivalent.
a) If two types match, they are equivalent.
b) An anonymous , unpacked , or unpacked type is equivalent to itself among data
enum struct union
objects declared within the same declaration statement and no other data types.
struct {int A; int B;} AB1, AB2; // AB1, AB2 have equivalent types
struct {int A; int B;} AB3; // AB3 is not type equivalent to AB1
c) Packed arrays, packed structures, packed unions, and built-in integral types are equivalent if they
contain the same number of total bits, are either all 2-state or all 4-state, and are either all signed or
all unsigned.
NOTE—If any bit of a packed structure or union is 4-state, the entire structure or union is considered 4-state.
typedef bit signed [7:0] BYTE; // equivalent to the byte type
typedef struct packed signed {bit[3:0] a, b;} uint8;
// equivalent to the byte type
129
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
d) Unpacked fixed-size array types are equivalent if they have equivalent element types and equal size;
the actual range bounds may differ. Note that the element type of a multidimensional array is itself
an array type.
bit [9:0] A [0:5];
bit [1:10] B [6];
typedef bit [10:1] uint10;
uint10 C [6:1]; // A, B and C have equivalent types
typedef int anint [0:0]; // anint is not type equivalent to int
e) Dynamic array, associative array, and queue types are equivalent if they are the same kind of array
(dynamic, associative, or queue), have equivalent index types (for associative arrays), and have
equivalent element types.
The following example is assumed to be within one compilation unit, although the package declaration need
not be in the same unit:
package p1;
typedef struct {int A;} t_1;
endpackage
typedef struct {int A;} t_2;
module sub();
import p1::t_1;
parameter type t_3 = int;
parameter type t_4 = int;
typedef struct {int A;} t_5;
t_1 v1; t_2 v2; t_3 v3; t_4 v4; t_5 v5;
endmodule
module top();
typedef struct {int A;} t_6;
sub #(.t_3(t_6)) s1 ();
sub #(.t_3(t_6)) s2 ();
initial begin
s1.v1 = s2.v1; // legal - both types from package p1 (rule 8)
s1.v2 = s2.v2; // legal - both types from $unit (rule 4)
s1.v3 = s2.v3; // legal - both types from top (rule 2)
s1.v4 = s2.v4; // legal - both types are int (rule 1)
s1.v5 = s2.v5; // illegal - types from s1 and s2 (rule 4)
end
endmodule
6.22.3 Assignment compatible
All equivalent types, and all nonequivalent types that have implicit casting rules defined between them, are
assignment-compatible types. For example, all integral types are assignment compatible. Conversion
between assignment-compatible types can involve loss of data by truncation or rounding.
Unpacked arrays are assignment compatible with certain other arrays that are not of equivalent type.
Assignment compatibility of unpacked arrays is discussed in detail in 7.6.
Compatibility can be in one direction only. For example, an can be converted to an integral type
enum
without a cast, but not the other way around. Implicit casting rules are defined in 6.24.
130
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
6.22.4 Cast compatible
All assignment-compatible types, plus all nonequivalent types that have defined explicit casting rules, are
cast-compatible types. For example, an integral type requires a cast to be assigned to an .
enum
Explicit casting rules are defined in 6.24.
6.22.5 Type incompatible
Type incompatible includes all the remaining nonequivalent types that have no defined implicit or explicit
casting rules. Class handles, interface class handles, and chandles are type incompatible with all other types.
6.22.6 Matching nettypes
a) A matches itself and the of nets declared using that within the scope of
nettype nettype nettype
the type identifier.
nettype
b) A simple that renames a user-defined matches that user-defined
nettype nettype nettype
within the scope of the identifier.
nettype
// declare another name nettypeid2 for nettype nettypeid1
nettype nettypeid1 nettypeid2;
6.23 Type operator
The operator provides a way to refer to the data type of an expression. A type reference can be used
type
like a type name or local type parameter, for example, in casts, data object declarations, and type parameter
assignments and overrides. It can also be used in equality/inequality and case equality/inequality
comparisons with other type references, and such comparisons are considered to be constant expressions
(see 11.2.1). When a type reference is used in a net declaration, it shall be preceded by a net type keyword;
and when it is used in a variable declaration, it shall be preceded by the keyword.
var
var type(a+b) c, d;
c = type(i+3)'(v[15:0]);
The operator applied to an expression shall represent the self-determined result type of that expression.
type
The expression shall not be evaluated and shall not contain any hierarchical references or references to
elements of dynamic objects.
The type operator can also be applied to a data type.
localparam type T = type(bit[12:0]);
When a type reference is used in an equality/inequality or case equality/inequality comparison, it shall only
be compared with another type reference. Two type references shall be considered equal in such
comparisons if, and only if, the types to which they refer match (see 6.22.1).
bit [12:0] A_bus, B_bus;
parameter type bus_t = type(A_bus);
generate
case (type(bus_t))
type(bit[12:0]): addfixed_int #(bus_t) (A_bus,B_bus);
type(real): add_float #(type(A_bus)) (A_bus,B_bus);
endcase
endgenerate
131
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
6.24 Casting
6.24.1 Cast operator
A data type can be changed by using a cast ( ) operation. The syntax for cast operations is shown in
'
Syntax6-7.
constant_cast ::= // from A.8.4
casting_type constant_expression
' ( )
cast ::=
casting_type expression
' ( )
casting_type ::= simple_type | constant_primary | signing | | // from A.2.2.1
string const
simple_type ::= integer_type | non_integer_type | ps_type_identifier | ps_parameter_identifier
Syntax6-7—Casting (excerpt from AnnexA)
In a static cast, the expression to be cast shall be enclosed in parentheses that are prefixed with the casting
type and an apostrophe. If the expression is assignment compatible with the casting type, then the cast shall
return the value that a variable of the casting type would hold after being assigned the expression. If the
expression is not assignment compatible with the casting type, then if the casting type is an enumerated type,
the behavior shall be as described as in 6.19.4, and if the casting type is a bit-stream type, the behavior shall
be as described in 6.24.3.
int'(2.0 * 3.0)
shortint'({8'hFA,8'hCE})
Thus, in the following example, if expressions and are assignment compatible with data
expr_1 expr_2
types and , respectively, then
cast_t1 cast_t2
A = cast_t1'(expr_1) + cast_t2'(expr_2);
is the same as
cast_t1 temp1;
cast_t2 temp2;
temp1 = expr_1;
temp2 = expr_2;
A = temp1 + temp2;
Thus, an implicit cast (e.g., ), if defined, gives the same results as the corresponding
temp1 = expr1
explicit cast ( ).
cast_t1'(expr1)
If the casting type is a constant expression with a positive integral value, the expression in parentheses shall
be padded or truncated to the size specified. It shall be an error if the size specified is zero or negative.
Examples:
17'(x - 2)
parameter P = 16;
(P+1)'(x – 2)
132
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The signedness can also be changed.
signed'(x)
The expression inside the cast shall be an integral value when changing the size or signing.
When changing the size, the cast shall return the value that a packed array type with a single
[n-1:0]
dimension would hold after being assigned the expression, where is the cast size. The signedness shall
n
pass through unchanged, i.e., the signedness of the result shall be the self-determined signedness of the
expression inside the cast. The array elements shall be of type if the expression inside the cast is 2-state,
bit
otherwise they shall be of type .
logic
When changing the signing, the cast shall return the value that a packed array type with a single
[n-1:0]
dimension would hold after being assigned the expression, where is the number of bits in the expression to
n
be cast ( ). The signedness of the result shall be the signedness specified by the cast
$bits(expression)
type. The array elements shall be of type if the expression inside the cast is 2-state; otherwise, they shall
bit
be of type .
logic
NOTE—The and system functions (see 11.7) return the same results as and
$signed() $unsigned() signed'()
, respectively.
unsigned'()
Examples:
logic [7:0] regA;
logic signed [7:0] regS;
regA = unsigned'(-4); // regA = 8'b11111100
regS = signed'(4'b1100); // regS = -4
An expression may be changed to a constant with a cast.
const
const'(x)
When casting an expression as a constant, the type of the expression to be cast shall pass through unchanged.
The only effect is to treat the value as though it had been used to define a variable of the type of the
const
expression.
When casting to a predefined type, the prefix of the cast shall be the predefined type keyword. When casting
to a user-defined type, the prefix of the cast shall be the user-defined type identifier.
When a is converted to an or to 32 bits using either casting or assignment, its value is
shortreal int
rounded (see 6.12). Therefore, the conversion can lose information. To convert a to its
shortreal
underlying bit representation without a loss of information, use as defined in 20.5. To
$shortrealtobits
convert from the bit representation of a shortreal value into a , use as
shortreal $bitstoshortreal
defined in 20.5.
Structures can be converted to bits preserving the bit pattern. In other words, they can be converted back to
the same value without any loss of information. When unpacked data are converted to the packed
representation, the order of the data in the packed representation is such that the first field in the structure
occupies the MSBs. The effect is the same as a concatenation of the data items ( fields or array
struct
elements) in order. The type of the elements in an unpacked structure or array shall be valid for a packed
representation in order to be cast to any other type, whether packed or unpacked.
An explicit cast between packed types is not required because they are implicitly cast as integral values, but
a cast can be used by tools to perform stronger type checking.
133
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The following example demonstrates how can be used to obtain the size of a structure in bits (the
$bits
system function is discussed in 20.6.2), which facilitates conversion of the structure into a packed
$bits
array:
typedef struct {
bit isfloat;
union { int i; shortreal f; } n; // anonymous type
} tagged_st; // named structure
typedef bit [$bits(tagged_st) - 1 : 0] tagbits; // tagged_st defined above
tagged_st a [7:0]; // unpacked array of structures
tagbits t = tagbits'(a[3]); // convert structure to array of bits
a[4] = tagged_st'(t); // convert array of bits back to structure
Note that the data type loses values. If these are to be preserved, the type should be used
bit X logic
instead.
The size of a union in bits is the size of its largest member. The size of a in bits is 1.
logic
The functions , , , , , and can also be used
$itor $rtoi $bitstoreal $realtobits $signed $unsigned
to perform type conversions (see Clause20).
6.24.2 $cast dynamic casting
The system task can be used to assign values to variables that might not ordinarily be valid because
$cast
of differing data type. can be called as either a task or a function.
$cast
The syntax for is as follows:
$cast
function int $cast( singular dest_var, singular source_exp );
or
task $cast( singular dest_var, singular source_exp );
The dest_var is the variable to which the assignment is made.
The source_exp is the expression that is to be assigned to the destination variable.
Use of as either a task or a function determines how invalid assignments are handled.
$cast
When called as a task, attempts to assign the source expression to the destination variable. If the
$cast
assignment is invalid, a run-time error occurs, and the destination variable is left unchanged.
When called as a function, attempts to assign the source expression to the destination variable and
$cast
returns 1 if the cast is legal. If the cast fails, the function does not make the assignment and returns 0. When
called as a function, no run-time error occurs, and the destination variable is left unchanged.
It is important to note that performs a run-time check. No type checking is done by the compiler,
$cast
except to check that the destination variable and source expression are singulars. The behavior when
$cast
applied to class handles is described in 8.16.
For example:
typedef enum { red, green, blue, yellow, white, black } Colors;
134
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Colors col;
$cast( col, 2 + 3 );
This example assigns the expression to the enumerated type. Without or a static
(5 => black) $cast
compile-time cast operation, this type of assignment is illegal.
The following example shows how to use the to check whether an assignment will succeed:
$cast
if ( ! $cast( col, 2 + 8 ) ) // 10: invalid cast
$display( "Error in cast" );
Alternatively, the preceding examples can be cast using a static cast operation. For example:
col = Colors'(2 + 3);
However, this is a compile-time cast, i.e, a coercion that always succeeds at run time and does not provide
for error checking or warn if the expression lies outside the enumeration values.
Allowing both types of casts gives full control to the user. If users know that certain expressions assigned to
an enumerated variable lie within the enumeration values, the faster static compile-time cast can be used. If
users need to check if an expression lies within the enumeration values, it is not necessary to write a lengthy
case statement manually. The compiler automatically provides that functionality via the function. By
$cast
providing both types of casts, SystemVerilog enables users to balance the trade-offs of performance and
checking associated with each cast type.
NOTE— is similar to the dynamic_cast function available in C++. However, allows users to check
$cast $cast
whether the operation will succeed, whereas dynamic_cast always raises a C++ exception.
6.24.3 Bit-stream casting
Type casting can also be applied to unpacked arrays and structs. It is thus possible to convert freely between
bit-stream types using explicit casts. Types that can be packed into a stream of bits are called bit-stream
types. A bit-stream type is a type consisting of the following:
— Any integral, packed, or string type
— Unpacked arrays, structures, or classes of the preceding types
— Dynamically sized arrays (dynamic, associative, or queues) of any of the preceding types
This definition is recursive so that, for example, a structure containing a queue of is a bit-stream type.
int
Assuming is of bit-stream type and is of bit-stream type , it is legal to convert into
A source_t B dest_t A
by an explicit cast:
B
B = dest_t'(A);
The conversion from of type to of type proceeds in two steps:
A source_t B dest_t
a) Conversion from to a generic packed value containing the same number of bits as
source_t
. If contains any 4-state data, the entire packed value is 4-state; otherwise, it is
source_t source_t
2-state.
b) Conversion from the generic packed value to . If the generic packed value is a 4-state type
dest_t
and parts of designate 2-state types, then those parts in are assigned as if cast to a
dest_t dest_t
2-state.
When a dynamic array, queue, or string type is converted to the packed representation, the item at index
0occupies the MSBs. When an associative array is converted to the packed representation, items are packed
135
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
in index-sorted order with the first indexed element occupying the MSBs. An associative array type or class
shall be illegal as a destination type. A class handle with local or protected members shall be illegal as a
source type except when the handle is the current instance (see 8.11 and 8.18).
this
Both and can include one or more dynamically sized data in any position (for example, a
source_t dest_t
structure containing a dynamic array followed by a queue of bytes). If the source type, , includes
source_t
dynamically sized variables, they are all included in the bit stream. If the destination type, , includes
dest_t
unbounded dynamically sized types, the conversion process is greedy: compute the size of the ,
source_t
subtract the size of the fixed-size data items in the destination, and then adjust the size of the first
dynamically sized item in the destination to the remaining size; any remaining dynamically sized items are
left empty.
For the purposes of a bit-stream cast, a string type is considered a dynamic array of bytes.
Regardless of whether the destination type contains only fixed-size items or dynamically sized items, data
are extracted into the destination in left-to-right order. It is thus legal to fill a dynamically sized item with
data extracted from the middle of the packed representation.
If both and are fixed-size types of different sizes and either type is unpacked, then a cast
source_t dest_t
generates a compile-time error. If or contain dynamically sized types, then a difference
source_t dest_t
in their sizes will issue an error either at compile time or at run time, as soon as it is possible to determine the
size mismatch. For example:
// Illegal conversion from 24-bit struct to 32 bit int - compile time error
struct {bit[7:0] a; shortint b;} a;
int b = int'(a);
// Illegal conversion from 20-bit struct to int (32 bits) - run time error
struct {bit a[$]; shortint b;} a = {{1,2,3,4}, 67};
int b = int'(a);
// Illegal conversion from int (32 bits) to struct dest_t (25 or 33 bits),
// compile time error
typedef struct {byte a[$]; bit b;} dest_t;
int a;
dest_t b = dest_t'(a);
Bit-stream casting can be used to convert between different aggregate types, such as two structure types, or
a structure and an array or queue type. This conversion can be useful to model packet data transmission over
serial communication streams. For example, the following code uses bit-stream casting to model a control
packet transfer over a data stream:
typedef struct {
shortint address;
logic [3:0] code;
byte command [2];
} Control;
typedef bit Bits [36:1];
Control p;
Bits stream[$];
p = ... // initialize control packet
stream.push_back(Bits'(p)); // append packet to unpacked queue of Bits
136
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Bits b;
Control q;
b = stream.pop_front(); // get packet (as Bits) from stream
q = Control'(b); // convert packet bits back to a Control packet
The following example uses bit-stream casting to model a data packet transfer over a byte stream:
typedef struct {
byte length;
shortint address;
byte payload[];
byte chksum;
} Packet;
The preceding type defines a generic data packet in which the size of the payload field is stored in the length
field. Following is a function that randomly initializes the packet and computes the checksum.
function Packet genPkt();
Packet p;
void'( randomize( p.address, p.length, p.payload )
with { p.length > 1 && p.payload.size == p.length; } );
p.chksum = p.payload.xor();
return p;
endfunction
The byte stream is modeled using a queue, and a bit-stream cast is used to send the packet over the stream.
typedef byte channel_type[$];
channel_type channel;
channel = {channel, channel_type'(genPkt())};
And the code to receive the packet:
Packet p;
int size;
size = channel[0] + 4;
p = Packet'( channel[0 : size - 1] ); // convert stream to Packet
channel = channel[ size : $ ]; // update the stream so it now
// lacks that packet
6.25 Parameterized data types
SystemVerilog provides a way to create parameterized data types. A parameterized data type allows the user
to generically define a data type and then conveniently create many varieties of that data type. When using
such a data type one may provide the parameters that fully define its sets of values and operations. This
allows for only one definition to be written and maintained instead of multiple definitions.
Parameterized data types are implemented through the use of type definitions in parameterized classes (see
8.25). The following example shows how to use type definitions and class parameterization to implement
parameterized data types. The example has one class with three data types. The class may be declared
in order to prevent object construction and enforce its usage only for data type definition.
virtual
virtual class C#(parameter type T = logic, parameter SIZE = 1);
typedef logic [SIZE-1:0] t_vector;
137
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
typedef T t_array [SIZE-1:0];
typedef struct {
t_vector m0 [2*SIZE-1:0];
t_array m1;
} t_struct;
endclass
Class contains three data types: , , and . Each data type is parameterized by
C t_vector t_array t_struct
reusing the class parameters and .
T SIZE
module top ();
typedef logic [7:0] t_t0;
C#(t_t0,3)::t_vector v0;
C#(t_t0,3)::t_array a0;
C#(bit,4)::t_struct s0;
endmodule
The top level module first defines a data type . Data type and the constant 3 are then used to
t_t0 t_t0
declare variable . The number of bits in variable is determined by the specialized class
v0 t_vector
parameter value of 3. Data type is referenced inside class using the static class scope resolution
t_vector C
operator (see 8.23). Similarly for variable , the specialized class parameter values of and 3,
:: a0 t_t0
declare as an unpacked array of 3 elements of type . Finally, variable is declared as an unpacked
a0 t_t0 s0
struct whose member data types are defined through the values of specialized class parameter values
bit
and 4.
138
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
7. Aggregate data types
7.1 General
This clause describes the following:
— Structure definitions and usage
— Union definitions and usage
— Packed arrays, unpacked arrays, dynamic arrays, associative arrays, and queues
— Array query and manipulation methods
7.2 Structures
A structure represents a collection of data types that can be referenced as a whole, or the individual data
types that make up the structure can be referenced by name. By default, structures are unpacked, meaning
that there is an implementation-dependent packing of the data types. Unpacked structures can contain any
data type.
Structure declarations follow the C syntax, but without the optional structure tags before the “ ”. The syntax
{
for structure declarations is shown in Syntax7-1.
data_type ::= // from A.2.2.1
...
| struct_union [ [ signing ] ] struct_union_member { struct_union_member }
packed { }
{ packed_dimension }13
struct_union_member16 ::=
{ attribute_instance } [random_qualifier] data_type_or_void list_of_variable_decl_assignments
;
data_type_or_void ::= data_type |
void
struct_union ::= | [ ]
struct union tagged
13) When a packed dimension is used with the or keyword, the keyword shall also be used.
struct union packed
16) It shall be legal to declare a struct_union_member only within tagged unions. It shall be legal to declare a
void
random_qualifier only within unpacked structures.
Syntax7-1—Structure declaration syntax (excerpt from AnnexA)
Examples of declaring structures are as follows:
struct { bit [7:0] opcode; bit [23:0] addr; }IR; // anonymous structure
// defines variable IR
IR.opcode = 1; // set field in IR.
typedef struct {
bit [7:0] opcode;
bit [23:0] addr;
} instruction; // named structure type
instruction IR; // define variable
139
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
7.2.1 Packed structures
A packed structure is a mechanism for subdividing a vector into subfields, which can be conveniently
accessed as members. Consequently, a packed structure consists of bit fields, which are packed together in
memory without gaps. An unpacked structure has an implementation-dependent packing, normally
matching the C compiler. A packed structure differs from an unpacked structure in that, when a packed
structure appears as a primary, it shall be treated as a single vector.
A packed structure can also be used as a whole with arithmetic and logical operators, and its behavior is
determined by its signedness, with unsigned being the default. The first member specified is the most
significant and subsequent members follow in decreasing significance.
struct packed signed {
int a;
shortint b;
byte c;
bit [7:0] d;
} pack1; // signed, 2-state
struct packed unsigned {
time a;
integer b;
logic [31:0] c;
} pack2; // unsigned, 4-state
The signing of unpacked structures is not allowed. The following declaration would be considered illegal:
typedef struct signed {
int f1 ;
logic f2 ;
} sIllegalSignedUnpackedStructType; // illegal declaration
If all data types within a packed structure are 2-state, the structure as a whole is treated as a 2-state vector.
If any data type within a packed structure is 4-state, the structure as a whole is treated as a 4-state vector. If
there are also 2-state members in the structure, there is an implicit conversion from 4-state to 2-state when
reading those members and from 2-state to 4-state when writing them.
One or more bits of a packed structure can be selected as if it were a packed array with the range :
[n-1:0]
pack1 [15:8] // c
Only packed data types and the integer data types summarized in Table6-8 (see 6.11) shall be legal in
packed structures.
A packed structure can be used with a .
typedef
typedef struct packed { // default unsigned
bit [3:0] GFC;
bit [7:0] VPI;
bit [11:0] VCI;
bit CLP;
bit [3:0] PT ;
bit [7:0] HEC;
bit [47:0] [7:0] Payload;
bit [2:0] filler;
} s_atmcell;
140
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
7.2.2 Assigning to structures
A structure can be assigned as a whole and passed to or from a subroutine as a whole.
Members of a structure data type can be assigned individual default member values by using an initial
assignment with the declaration of each member. The assigned expression shall be a constant expression.
An example of initializing members of a structure type is as follows:
typedef struct {
int addr = 1 + constant;
int crc;
byte data [4] = '{4{1}};
} packet1;
The structure can then be instantiated.
packet1 p1; // initialization defined by the typedef.
// p1.crc will use the default value for an int
If an explicit initial value expression is used with the declaration of a variable, the initial assignment
expression within the structure data type shall be ignored. Subclause 5.10 discusses assigning initial values
to a structure. For example:
packet1 pi = '{1,2,'{2,3,4,5}}; //suppresses the typedef initialization
Members of unpacked structures containing a union as well as members of packed structures shall not be
assigned individual default member values.
The initial assignment expression within a data type shall be ignored when using a data type to declare a net
that does not have a user-defined (see 6.7.1).
nettype
7.3 Unions
A union is a data type that represents a single piece of storage that can be accessed using one of the named
member data types. Only one of the data types in the union can be used at a time. By default, a union is
unpacked, meaning there is no required representation for how members of the union are stored. Dynamic
types and chandle types can only be used in tagged unions.
The syntax for union declarations is shown in Syntax7-2.
data_type ::= // from A.2.2.1
...
| struct_union [ [ signing ] ] struct_union_member { struct_union_member }
packed { }
{ packed_dimension }13
struct_union_member16 ::=
{ attribute_instance } [random_qualifier] data_type_or_void list_of_variable_decl_assignments
;
data_type_or_void ::= data_type |
void
141
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
struct_union ::= | [ ]
struct union tagged
13) When a packed dimension is used with the or keyword, the keyword shall also be used.
struct union packed
16) It shall be legal to declare a struct_union_member only within tagged unions. It shall be legal to declare a
void
random_qualifier only within unpacked structures.
Syntax7-2—Union declaration syntax (excerpt from AnnexA)
Examples:
typedef union { int i; shortreal f; } num; // named union type
num n;
n.f = 0.0; // set n in floating point format
typedef struct {
bit isfloat;
union { int i; shortreal f; } n; // anonymous union type
} tagged_st; // named structure
If no initial value is specified in the declaration of a variable of an unpacked union type, then the variable
shall be initialized to the default initial value for variables of the type of the first member in declaration order
of the union type.
One special provision exists in order to simplify the use of unpacked unions: if an unpacked union contains
several unpacked structures that share a common initial sequence and if the unpacked union object currently
contains one of these structures, it is permitted to inspect the common initial part of any of them anywhere
that a declaration of the complete type of the union is visible. Two structures share a common initial
sequence if corresponding members have equivalent types for a sequence of one or more initial members.
7.3.1 Packed unions
Packed unions shall only contain members that are of integral data types. The members of a packed,
untagged union shall all be the same size (in contrast to an unpacked union or a packed, tagged union, where
the members can be different sizes). Thus, a union member that was written as another member can be read
back. A packed union differs from an unpacked union in that when a packed union appears as a primary, it
shall be treated as a single vector.
A packed union can also be used as a whole with arithmetic and logical operators, and its behavior is
determined by its signedness, with unsigned being the default. One or more bits of a packed union can be
selected as if it were a packed array with the range .
[n-1:0]
Only packed data types and the integer data types summarized in Table6-8 (see 6.11) shall be legal in
packed unions.
If a packed union contains a 2-state member and a 4-state member, the entire union is 4-state. There is an
implicit conversion from 4-state to 2-state when reading and from 2-state to 4-state when writing the 2-state
member.
For example, a union can be accessible with different access widths:
typedef union packed { // default unsigned
s_atmcell acell;
bit [423:0] bit_slice;
bit [52:0][7:0] byte_slice;
142
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
} u_atmcell;
u_atmcell u1;
byte b; bit [3:0] nib;
b = u1.bit_slice[415:408]; // same as b = u1.byte_slice[51];
nib = u1.bit_slice [423:420]; // same as nib = u1.acell.GFC;
With packed unions, writing one member and reading another is independent of the byte ordering of the
machine, unlike an unpacked union of unpacked structures, which are C-compatible and have members in
ascending address order.
7.3.2 Tagged unions
The qualifier in a union declares it as a tagged union, which is a type-checked union. An ordinary
tagged
(untagged) union can be updated using a value of one member type and read as a value of another member
type, which is a potential type loophole. A tagged union stores both the member value and a tag, i.e.,
additional bits representing the current member name. The tag and value can only be updated together
consistently using a statically type-checked tagged union expression (see 11.9). The member value can only
be read with a type that is consistent with the current tag value (i.e., member name). Thus, it is impossible to
store a value of one type and (mis)interpret the bits as another type.
Dynamic types and chandle types shall not be used in untagged unions, but may be used in tagged unions.
Members of tagged unions can be referenced as tagged expressions. See 11.9.
In addition to type safety, the use of member names as tags also makes code simpler and smaller than code
that has to track unions with explicit tags. Tagged unions can also be used with pattern matching (see 12.6),
which improves readability even further.
In tagged unions, members can be declared with type , when all the information is in the tag itself, as in
void
the following example of an integer together with a valid bit:
typedef union tagged {
void Invalid;
int Valid;
} VInt;
A value of type is either (and contains nothing) or (and contains an ). Subclause
VInt Invalid Valid int
11.9 describes how to construct values of this type and also describes how it is impossible to read an integer
out of a value that currently has the tag.
VInt Invalid
For example:
typedef union tagged {
struct {
bit [4:0] reg1, reg2, regd;
} Add;
union tagged {
bit [9:0] JmpU;
struct {
bit [1:0] cc;
bit [9:0] addr;
} JmpC;
} Jmp;
} Instr;
143
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A value of type is either an instruction, in which case it contains three 5-bit register fields, or it is
Instr Add
a instruction. In the latter case, it is either an unconditional jump, in which case it contains a 10-bit
Jmp
destination address, or it is a conditional jump, in which case it contains a 2-bit condition-code register field
and a 10-bit destination address. Subclause 11.9 describes how to construct values of type and
Instr
describes how, in order to read the field, for example, the instruction must have opcode and
cc Jmp
sub-opcode .
JmpC
When the qualifier is used on a tagged union, all the members shall have packed types, but they do
packed
not have to be of the same size. The (standard) representation for a packed tagged union is the following:
— The size is always equal to the number of bits needed to represent the tag plus the maximum of the
sizes of the members.
— The size of the tag is the minimum number of bits needed to code for all the member names (e.g.,
five to eight members would need 3 tag bits).
— The tag bits are always left-justified (i.e., towards the MSBs).
— For each member, the member bits are always right-justified [i.e., towards the least significant bits
(LSBs)].
— The bits between the tag bits and the member bits are undefined. In the extreme case of a void
member, only the tag is significant and all the remaining bits are undefined.
The representation scheme is applied recursively to any nested tagged unions.
For example, if the type definition had the qualifier, and values will have the
VInt packed Invalid Valid
layouts shown in Figure7-1, respectively.
1 32
0 x x x x x x x ... ... ... x x x x x x x x x
1 32
1 ... an int value ...
tag is 0 for Invalid, 1 for Valid
Figure7-1—VInt type with packed qualifier
For example, if the type had the qualifier, its values will have the layouts shown in
Instr packed
Figure7-2
144
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
.
1 5 5 5
0 reg1 reg2 regd Add Instructions
1 2 1 2 10
1 xx 0 xx Jmp/JmpU Instructions
1 2 1 2 10
1 xx 1 cc addr Jmp/JmpC Instructions
Outer tag is 0 for Add, 1 for Jmp
Inner tag is 0 for JmpU, 1 for JmpC
Figure7-2—Instr type with packed qualifier
7.4 Packed and unpacked arrays
SystemVerilog supports both packed arrays and unpacked arrays of data. The term packed array is used to
refer to the dimensions declared before the data identifier name. The term unpacked array is used to refer to
the dimensions declared after the data identifier name.
bit [7:0] c1; // packed array of scalar bit types
real u [7:0]; // unpacked array of real types
A one-dimensional packed array is often referred to as a vector (see 6.9). Multidimensional packed arrays
are also allowed.
Unpacked arrays may be fixed-size arrays (see 7.4.2), dynamic arrays (see 7.5), associative arrays (see 7.8),
or queues (see 7.10). Unpacked arrays are formed from any data type, including other packed or unpacked
arrays (see 7.4.5).
7.4.1 Packed arrays
A packed array is a mechanism for subdividing a vector into subfields, which can be conveniently accessed
as array elements. Consequently, a packed array is guaranteed to be represented as a contiguous set of bits.
An unpacked array may or may not be so represented. A packed array differs from an unpacked array in that,
when a packed array appears as a primary, it is treated as a single vector.
If a packed array is declared as signed, then the array viewed as a single vector shall be signed. The
individual elements of the array are unsigned unless they are of a named type declared as signed. A
part-select of a packed array shall be unsigned.
Packed arrays allow arbitrary length integer types; therefore, a 48-bit integer can be made up of 48 bits.
These integers can then be used for 48-bit arithmetic. The maximum size of a packed array can be limited,
but shall be at least 65536 (216) bits.
Packed arrays can be made of only the single bit data types ( , , ), enumerated types, and
bit logic reg
recursively other packed arrays and packed structures.
145
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Integer types with predefined widths shall not have packed array dimensions declared. These types are
, , , , , and . Although an integer type with a predefined width
byte shortint int longint integer time n
is not a packed array, it matches (see 6.22), and can be selected from as if it were, a packed array type with a
single dimension.
[n-1:0]
byte c2; // same as bit signed [7:0] c2;
integer i1; // same as logic signed [31:0] i1;
7.4.2 Unpacked arrays
Unpacked arrays can be made of any data type. Arrays whose elements are themselves arrays are declared as
multidimensional arrays (see 7.4.5). Unpacked arrays shall be declared by specifying the element address
range(s) after the declared identifier.
Elements of net arrays can be used in the same fashion as a scalar or vector net. Net arrays are useful for
connecting to ports of module instances inside loop generate constructs (see 27.4).
Each fixed-size dimension shall be represented by an address range, such as , or a single positive
[1:1024]
number to specify the size of a fixed-size unpacked array, as in C. In other words, becomes the
[size]
same as .
[0:size-1]
The following examples declare equivalent size two-dimensional fixed-size arrays of variables:
int
int Array[0:7][0:31]; // array declaration using ranges
int Array[8][32]; // array declaration using sizes
The expressions that specify an address range shall be constant integer expressions. The value of the
constant expression can be a positive integer, a negative integer, or zero. It shall be illegal for them to
contain any unknown (x) or high-impedance bits.
Implementations may limit the maximum size of an array, but they shall allow at least
16777216(224)elements.
7.4.3 Operations on arrays
The following operations can be performed on all arrays, packed or unpacked. The examples provided with
these rules assume that and are arrays of the same shape and type.
A B
— Reading and writing the array, e.g.,
A = B
— Reading and writing a slice of the array, e.g.,
A[i:j] = B[i:j]
— Reading and writing a variable slice of the array, e.g.,
A[x+:c] = B[y+:c]
— Reading and writing an element of the array, e.g.,
A[i] = B[i]
— Equality operations on the array or slice of the array, e.g.,
A==B, A[i:j] != B[i:j]
The following operations can be performed on packed arrays, but not on unpacked arrays. The examples
provided with these rules assume that is an array.
A
— Assignment from an integer, e.g.,
A = 8'b11111111;
— Treatment as an integer in an expression, e.g.,
(A + 3)
If an unpacked array is declared as signed, then this applies to the individual elements of the array because
the whole array cannot be viewed as a single vector.
See 7.6 for rules for assigning to packed and unpacked arrays.
146
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
7.4.4 Memories
A one-dimensional array with elements of types , , or is also called a memory. Memory
reg logic bit
arrays can be used to model read-only memories (ROMs), random access memories (RAMs), and register
files. An element of the packed dimension in the array is known as a memory element or word.
logic [7:0] mema [0:255]; // declares a memory array of 256 8-bit
// elements. The array indices are 0 to 255
mema[5] = 0; // Write to word at address 5
data = mema[addr]; // Read word at address indexed by addr
7.4.5 Multidimensional arrays
A multidimensional array is an array of arrays. Multidimensional arrays can be declared by including
multiple dimensions in a single declaration. The dimensions preceding the identifier set the packed
dimensions. The dimensions following the identifier set the unpacked dimensions.
bit [3:0] [7:0] joe [1:10]; // 10 elements of 4 8-bit bytes
// (each element packed into 32 bits)
can be used as follows:
joe[9] = joe[8] + 1; // 4 byte add
joe[7][3:2] = joe[6][1:0]; // 2 byte copy
In a multidimensional declaration, the dimensions declared following the type and before the name
( in the preceding declaration) vary more rapidly than the dimensions following the name
[3:0][7:0]
( in the preceding declaration). When referenced, the packed dimensions ( ) follow
[1:10] [3:0], [7:0]
the unpacked dimensions ( ).
[1:10]
In a list of dimensions, the rightmost one varies most rapidly, as in C. However, a packed dimension varies
more rapidly than an unpacked one.
bit [1:10] v1 [1:5]; // 1 to 10 varies most rapidly; compatible with
memory arrays
bit v2 [1:5] [1:10]; // 1 to 10 varies most rapidly, compatible with C
bit [1:5] [1:10] v3 ; // 1 to 10 varies most rapidly
bit [1:5] [1:6] v4 [1:7] [1:8]; // 1 to 6 varies most rapidly, followed by
// 1 to 5, then 1 to 8 and then 1 to 7
Multiple packed dimensions can also be defined in stages with .
typedef
typedef bit [1:5] bsix;
bsix [1:10] v5; // 1 to 5 varies most rapidly
Multiple unpacked dimensions can also be defined in stages with .
typedef
typedef bsix mem_type [0:3]; // array of four 'bsix' elements
mem_type ba [0:7]; // array of eight 'mem_type' elements
147
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
A subarray is an array that is an element of another array. As in the C language, subarrays are referenced by
omitting indices for one or more array dimensions, always omitting the ones that vary most rapidly.
Omitting indices for all the dimensions references the entire array.
int A[2][3][4], B[2][3][4], C[5][4];
...
A[0][2] = B[1][1]; // assign a subarray composed of four ints
A[1] = B[0]; // assign a subarray composed of three arrays of
// four ints each
A = B; // assign an entire array
A[0][1] = C[4]; // assign compatible subarray of four ints
A comma-separated list of array declarations can be specified. All arrays in the list shall have the same data
type and the same packed array dimensions.
bit [7:0] [31:0] v7 [1:5] [1:10], v8 [0:255]; // two arrays declared
7.4.6 Indexing and slicing of arrays
An expression can select part of a packed array, or any integer type, which is assumed to be numbered down
to 0.
The term part-select refers to a selection of one or more contiguous bits of a single-dimension packed array.
logic [63:0] data;
logic [7:0] byte2;
byte2 = data[23:16]; // an 8-bit part-select from data
The term slice refers to a selection of one or more contiguous elements of an array.
NOTE—IEEE Std 1364-2005 only permitted a single element of an array to be selected.
A single element of a packed or unpacked array can be selected using an indexed name.
bit [3:0] [7:0] j; // j is a packed array
byte k;
k = j[2]; // select a single 8-bit element from j
One or more contiguous elements can be selected using a slice name. A slice name of a packed array is a
packed array. A slice name of an unpacked array is an unpacked array.
bit signed [31:0] busA [7:0] ; // unpacked array of 8 32-bit vectors
int busB [1:0]; // unpacked array of 2 integers
busB = busA[7:6]; // select a 2-vector slice from busA
The size of the part-select or slice shall be constant, but the position can be variable.
int i = bitvec[j +: k]; // k must be constant.
int a[x:y], b[y:z], e;
a = {b[c -: d], e}; // d must be constant
Slices of an array can only apply to one dimension, but other dimensions can have single index values in an
expression.
If an index expression is out of bounds or if any bit in the index expression is or , then the index shall be
x z
invalid. Reading from an unpacked array of any kind with an invalid index shall return the value specified in
Table7-1. Writing to an array with an invalid index shall perform no operation, with the exceptions of
148
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
writing to element of a queue (described in 7.10.1) and creating a new element of an associative array
[$+1]
(described in 7.8.6). Implementations may issue a warning if an invalid index occurs for a read or write
operation on an array.
Access to a packed array with an invalid index is described in 11.5.1.
See 11.5.1 and 11.5.2 for more information on vector and array element selecting and slicing.
Table7-1—Value read from a nonexistent array entry
Type of array Value read
4-state integral type
'X
2-state integral type
'0
Enumeration Value specified in this table for the enumeration’s
base type
,
real shortreal 0.0
string ""
class null
interface class null
event null
chandle null
virtualinterface null
Variable-size unpacked array Array of size zero (no elements)
(dynamic, queue or associative)
Fixed-size unpacked array Array, all of whose elements have the value
specified in this table for that array’s element type
Unpacked , each of whose members has the value
struct struct
specified in this table for that member’s type, unless
the member has an initial assignment as part of its
declaration (see 7.2.2), in which case the member’s
value shall be as given by its initial assignment
Unpacked Value specified in this table for the type of the first
union
member of the
union
7.5 Dynamic arrays
A dynamic array is an unpacked array whose size can be set or changed at run time. The default size of an
uninitialized dynamic array is zero. The size of a dynamic array is set by the constructor or array
new
assignment, described in 7.5.1 and 7.6, respectively. Dynamic arrays support all variable data types as
element types, including arrays.
Dynamic array dimensions are denoted in the array declaration by . Any unpacked dimension in an array
[ ]
declaration may be a dynamic array dimension.
For example:
bit [3:0] nibble[]; // Dynamic array of 4-bit vectors
149
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
integer mem[2][]; // Fixed-size unpacked array composed
// of 2 dynamic subarrays of integers
Note that in order for an identifier to represent a dynamic array, it must be declared with a dynamic array
dimension as the leftmost unpacked dimension.
The constructor is used to set or change the size of the array and initialize its elements (see 7.5.1).
new[]
The built-in method returns the current size of the array (see 7.5.2).
size()
The built-in method clears all the elements yielding an empty array (zero size) (see 7.5.3).
delete()
7.5.1 New[ ]
The constructor sets the size of a dynamic array and initializes its elements. It may appear in place of
new
the right-hand side expression of variable declaration assignments and blocking procedural assignments
when the left-hand side indicates a dynamic array.
blocking_assignment ::= // from A.6.2
...
| nonrange_variable_lvalue dynamic_array_new
=
...
dynamic_array_new ::= expression [ expression ] // from A.2.4
new [ ] ( )
Syntax7-3—Dynamic array new constructor syntax (excerpt from AnnexA)
[ expression ]:
The desired size of the dynamic array. The type of this operand is . It shall be an error if the
longint
value of this operand is negative. If this operand is zero, the array shall become empty.
( expression ):
Optional. An array with which to initialize the dynamic array.
The constructor follows the SystemVerilog precedence rules. Because both the square brackets and
new []
the parenthesis have the same precedence, the arguments to the constructor are evaluated left to
() new
right: [expression ] first, and ( expression ) second.
Dynamic array declarations may include a declaration assignment with the constructor as the right-hand
new
side:
int arr1 [][2][3] = new [4]; // arr1 sized to length 4; elements are
// fixed-size arrays and so do not require
// initializing
int arr2 [][] = new [4]; // arr2 sized to length 4; dynamic subarrays
// remain unsized and uninitialized
int arr3 [1][2][] = new [4]; // Error – arr3 is not a dynamic array, though
// it contains dynamic subarrays
Dynamic arrays may be initialized in procedural contexts using the constructor in blocking
new
assignments:
150
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
int arr[2][][];
arr[0] = new [4]; // dynamic subarray arr[0] sized to length 4
arr[0][0] = new [2]; // legal, arr[0][n] created above for n = 0..3
arr[1][0] = new [2]; // illegal, arr[1] not initialized so arr[1][0] does
// not exist
arr[0][] = new [2]; // illegal, syntax error - dimension without
// subscript on left hand side
arr[0][1][1] = new[2]; // illegal, arr[0][1][1] is an int, not a dynamic
// array
In either case, if the constructor call does not specify an initialization expression, the elements are
new
initialized to the default value for their type.
The optional initialization expression is used to initialize the dynamic array. When present, it shall be an
array that is assignment compatible with the left-hand-side dynamic array.
int idest[], isrc[3] = '{5, 6, 7};
idest = new [3] (isrc); // set size and array element data values (5, 6, 7)
The size argument need not match the size of the initialization array. When the initialization array’s size is
greater, it is truncated to match the size argument; when it is smaller, the initialized array is padded with
default values to attain the specified size.
int src[3], dest1[], dest2[];
src = '{2, 3, 4};
dest1 = new[2] (src); // dest1's elements are {2, 3}.
dest2 = new[4] (src); // dest2's elements are {2, 3, 4, 0}.
This behavior provides a mechanism for resizing a dynamic array while preserving its contents. An existing
dynamic array can be resized by using it both as the left-hand side term and the initialization expression.
integer addr[]; // Declare the dynamic array.
addr = new[100]; // Create a 100-element array.
...
// Double the array size, preserving previous values.
// Preexisting references to elements of addr are outdated.
addr = new[200](addr);
Resizing or reinitializing a previously initialized dynamic array using is destructive; no preexisting
new
array data is preserved (unless reinitialized with its old contents—see preceding), and all preexisting
references to array elements become outdated.
7.5.2 Size()
The prototype for the method is as follows:
size()
function int size();
The method returns the current size of a dynamic array or returns zero if the array has not been
size()
created.
int j = addr.size;
addr = new[ addr.size() * 4 ] (addr); // quadruple addr array
151
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The dynamic array method is equivalent to array query system function (see
size $size( addr, 1 )
20.7).
7.5.3 Delete()
The prototype for the method is as follows:
delete()
function void delete();
The method empties the array, resulting in a zero-sized array.
delete()
int ab [] = new[ N ]; // create a temporary array of size N
// use ab
ab.delete; // delete the array contents
$display( "%d", ab.size ); // prints 0
7.6 Array assignments
For the purposes of assignment, a packed array is treated as a vector. Any vector expression can be assigned
to any packed array. The packed array bounds of the target packed array do not affect the assignment. A
packed array cannot be directly assigned to an unpacked array without an explicit cast.
Associative arrays are assignment compatible only with associative arrays, as described in 7.9.9. A fixed-
size unpacked array, dynamic array, or queue, or a slice of such an array, shall be assignment compatible
with any other such array or slice if all the following conditions are satisfied:
— The element types of source and target shall be equivalent.
— If the target is a fixed-size array or a slice, the source array shall have the same number of elements
as the target.
Here element refers to elements of the slowest-varying array dimension. These elements may themselves be
of some unpacked array type. Consequently, for two arrays to be assignment compatible it is necessary (but
not sufficient) that they have the same number of unpacked dimensions. Assignment compatibility of
unpacked arrays is a weaker condition than type equivalence because it does not require their slowest-
varying dimensions to be of the same unpacked array kind (queue, dynamic, or fixed-size). This weaker
condition applies only to the slowest-varying dimension. Any faster-varying dimensions must meet the
requirements for equivalence (see 6.22.2) for the entire arrays to be assignment compatible.
Assignment shall be done by assigning each element of the source array to the corresponding element of the
target array. Correspondence between elements is determined by the left-to-right order of elements in each
array. For example, if array is declared as and array is declared as , the
A int A[7:0] B int B[1:8]
assignment will assign element to element , and so on. If the target of the assignment is
A = B; B[1] A[7]
a queue or dynamic array, it shall be resized to have the same number of elements as the source expression
and assignment shall then follow the same left-to-right element correspondence as previously described.
int A[10:1]; // fixed-size array of 10 elements
int B[0:9]; // fixed-size array of 10 elements
int C[24:1]; // fixed-size array of 24 elements
A = B; // ok. Compatible type and same size
A = C; // type check error: different sizes
An array of wires can be assigned to an array of variables, and vice versa, if the source and target arrays’
data types are assignment compatible.
152
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
logic [7:0] V1[10:1];
logic [7:0] V2[10];
wire [7:0] W[9:0]; // data type is logic [7:0] W[9:0]
assign W = V1;
initial #10 V2 = W;
When a dynamic array or queue is assigned to a fixed-size array, the size of the source array cannot be
determined until run time. An attempt to copy a dynamic array or queue into a fixed-size array target having
a different number of elements shall result in a run-time error and no operation shall be performed. Example
code showing assignment of a dynamic array to a fixed-size array follows.
int A[2][100:1];
int B[] = new[100]; // dynamic array of 100 elements
int C[] = new[8]; // dynamic array of 8 elements
int D [3][][]; // multidimensional array with dynamic subarrays
D[2] = new [2]; // initialize one of D's dynamic subarrays
D[2][0] = new [100];
A[1] = B; // OK. Both are arrays of 100 ints
A[1] = C; // type check error: different sizes (100 vs. 8 ints)
A = D[2]; // A[0:1][100:1] and subarray D[2][0:1][0:99] both
// comprise 2 subarrays of 100 ints
Examples showing assignment to a dynamic array follow. (See 7.5.1 for additional assignment examples
involving the dynamic array constructor).
new
int A[100:1]; // fixed-size array of 100 elements
int B[]; // empty dynamic array
int C[] = new[8]; // dynamic array of size 8
B = A; // ok. B has 100 elements
B = C; // ok. B has 8 elements
The previous last statement is equivalent to:
B = new[ C.size ] (C);
Similarly, the source of an assignment can be a complex expression involving array slices or concatenations.
For example:
string d[1:5] = '{ "a", "b", "c", "d", "e" };
string p[];
p = { d[1:3], "hello", d[4:5] };
The preceding example creates the dynamic array with contents , , , , , .
p "a" "b" "c" "hello" "d" "e"
7.7 Arrays as arguments to subroutines
Arrays can be passed as arguments to subroutines. The rules that govern array argument passing by value are
the same as for array assignment (see 7.6). When an array argument is passed by value, a copy of the array is
passed to the called subroutine. This is true for all array types: fixed-size, dynamic, queue, or associative.
The rules that govern whether an array actual argument can be associated with a given formal argument are
the same as the rules for whether a source array’s values can be assigned to a destination array (see 7.6). If a
dimension of a formal is unsized (unsized dimensions can occur in dynamic arrays, queues, and formal
153
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
arguments of import DPI functions), then it matches any size of the actual argument’s corresponding
dimension.
For example, the declaration
task fun(int a[3:1][3:1]);
declares task that takes one argument, a two-dimensional array with each dimension of size 3. A call to
fun
must pass a two-dimensional array and with the same dimension size 3 for all the dimensions. For
fun
example, given the preceding description for , consider the following actuals:
fun
int b[3:1][3:1]; // OK: same type, dimension, and size
int b[1:3][0:2]; // OK: same type, dimension, & size (different ranges)
logic b[3:1][3:1]; // error: incompatible element type
event b[3:1][3:1]; // error: incompatible type
int b[3:1]; // error: incompatible number of dimensions
int b[3:1][4:1]; // error: incompatible size (3 vs. 4)
A subroutine that accepts a fixed-size array can also be passed a dynamic array or queue with compatible
type and equal size.
For example, the declaration
task t( string arr[4:1] );
declares a task that accepts one argument, an array of 4 strings. This task can accept the following actual
arguments:
string b[4:1]; // OK: same type and size
string b[5:2]; // OK: same type and size (different range)
string b[] = new[4]; // OK: same type, number of dimensions, and
// dimension size; requires run-time check
A subroutine that accepts a dynamic array or queue can be passed a dynamic array, queue, or fixed-size
array of a compatible type.
For example, the declaration
task t ( string arr[] );
declares a task that accepts one argument, a dynamic array of strings. This task can accept any
one-dimensional unpacked array of strings or any one-dimensional dynamic array or queue of strings.
The rules that govern dynamic array and queue formal arguments also govern the behavior of unpacked
dimensions of DPI open array formal arguments (see 7.6). DPI open arrays can also have a solitary unsized,
packed dimension (see 34.5.6.1). A dynamic array or queue shall not be passed as an actual argument if the
DPI formal argument has unsized dimensions and an output direction mode.
154
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
7.8 Associative arrays
Dynamic arrays are useful for dealing with contiguous collections of variables whose number changes
dynamically. When the size of the collection is unknown or the data space is sparse, an associative array is a
better option. Associative arrays do not have any storage allocated until it is used, and the index expression
is not restricted to integral expressions, but can be of any type.
An associative array implements a lookup table of the elements of its declared type. The data type to be used
as an index serves as the lookup key and imposes an ordering.
The syntax to declare an associative array is as follows:
data_type array_id [ index_type ];
where
is the data type of the array elements. Can be any type allowed for fixed-size arrays.
data_type
is the name of the array being declared.
array_id
is the data-type to be used as an index or is . If is specified, then the array is indexed by
index_type * *
any integral expression of arbitrary size. An index type restricts the indexing expressions to a
particular type. It shall be illegal for to declare a type.
index_type
Examples of associative array declarations are as follows:
integer i_array[*]; // associative array of integer (unspecified
// index)
bit [20:0] array_b[string]; // associative array of 21-bit vector,
// indexed by string
event ev_array[myClass]; // associative array of event indexed by class
// myClass
Array elements in associative arrays are allocated dynamically. An entry for a nonexistent associative array
element shall be allocated when it is used as the target of an assignment or actual to an argument passed by
reference. The associative array maintains the entries that have been assigned values and their relative order
according to the index data type. Associative array elements are unpacked. In other words, other than for
copying or comparing arrays, an individual element must be selected out of the array before it can be used in
most expressions.
7.8.1 Wildcard index type
For example:
int array_name [*];
Associative arrays that specify a wildcard index type have the following properties:
— The array may be indexed by any integral expression. Because the index expressions may be of
different sizes, the same numerical value can have multiple representations, each of a different size.
SystemVerilog resolves this ambiguity by removing the leading zeros and computing the minimal
length and using that representation for the value.
— Nonintegral index values are illegal and result in an error.
— A 4-state index value containing or is invalid.
X Z
— Indexing expressions are self-determined and treated as unsigned.
155
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— A string literal index is automatically cast to a bit vector of equivalent size.
— The ordering is numerical (smallest to largest).
— Associative arrays that specify a wildcard index type shall not be used in a loop (see
foreach
12.7.3) or with an array manipulation method (see 7.12) that returns an index value or array of
values.
7.8.2 String index
For example:
int array_name [ string ];
Associative arrays that specify a string index have the following properties:
— Indices can be strings or string literals of any length. Other types are illegal and shall result in a type
check error.
— An empty string index is valid.
""
— The ordering is lexicographical (lesser to greater).
7.8.3 Class index
For example:
int array_name [ some_Class ];
Associative arrays that specify a class index have the following properties:
— Indices can be objects of that particular type or derived from that type. Any other type is illegal and
shall result in a type check error.
— A null index is valid.
— The ordering is deterministic but arbitrary.
7.8.4 Integral index
For example:
int array_name1 [ integer ];
typedef bit signed [4:1] SNibble;
int array_name2 [ SNibble ];
typedef bit [4:1] UNibble;
int array_name3 [ UNibble ];
Associative arrays that specify an index of integral data type shall have the following properties:
— The index expression shall be evaluated in terms of a cast to the index type, except that an implicit
cast from a real or shortreal data type shall be illegal.
— A 4-state index expression containing or is invalid.
X Z
— The ordering is signed or unsigned numerical, depending on the signedness of the index type.
7.8.5 Other user-defined types
For example:
typedef struct {byte B; int I[*];} Unpkt;
int array_name [ Unpkt ];
156
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
In general, associative arrays that specify an index of any type have the following properties:
— Declared indices shall have the equality operator defined for its type to be legal. This includes all of
the dynamically sized types as legal index types. However, or data types, or a
real shortreal
type containing a or , shall be an illegal index type.
real shortreal
— An index expression that is or contains or in any of its elements is invalid.
X Z
— An index expression that is or contains an empty value or for any of its elements does not
null
make the index invalid.
— If the relational operator is defined for the index type, the ordering is as defined in the preceding
clauses. If not, the relative ordering of any two entries in such an associative array can vary, even
between successive runs of the same tool. However, the relative ordering shall remain the same
within the same simulation run while no indices have been added or deleted.
7.8.6 Accessing invalid indices
If a read operation uses an index that is a 4-state expression with one or more or bits, or an attempt is
x z
made to read a nonexistent entry, then a warning shall be issued and the nonexistent entry value for the array
type shall be returned, as shown in Table7-1 (see 7.4.6). A user-specified default shall not issue a warning
and returns the value specified in 7.9.11.
If an invalid index is used during a write operation, the write shall be ignored, and a warning shall be issued.
7.8.7 Allocating associative array elements
An entry for a nonexistent associative array element shall be allocated when it is used as the target of an
assignment or actual to an argument passed by reference. Some constructs perform both a read and write
operation as part of a single statement, such as with an increment operation. In those cases, the nonexistent
element shall be allocated with its default or user-specified initial value before any reference to that element.
For example:
int a[int] = '{default:1};
typedef struct { int x=1,y=2; } xy_t;
xy_t b[int];
begin
a[1]++;
b[2].x = 5;
end
Assume the references to and are nonexistent elements before these statements execute. Upon
a[1] b[2]
executing , will be allocated and initialized to 1. After the increment, will be 2. Upon
a[1]++ a[1] a[1]
executing , will be allocated and will be 1 and will be 2. After executing
b[2].x = 5 b[2] b[2].x b[2].y
the assignment, will be updated to 5.
b[2].x
7.9 Associative array methods
In addition to the indexing operators, several built-in methods are provided, which allow users to analyze
and manipulate associative arrays, as well as iterate over its indices or keys.
7.9.1 Num() and size()
The syntax for the and methods is as follows:
num() size()
function int num();
157
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
function int size();
The and methods return the number of entries in the associative array. If the array is empty,
num() size()
they return 0.
int imem[int];
imem[ 3 ] = 1;
imem[ 16'hffff ] = 2;
imem[ 4'b1000 ] = 3;
$display( "%0d entries\n", imem.num ); // prints "3 entries"
7.9.2 Delete()
The syntax for the method is as follows:
delete()
function void delete( [input index] );
where is an optional index of the appropriate type for the array in question.
index
If the is specified, then the method removes the entry at the specified index. If the entry to
index delete()
be deleted does not exist, the method issues no warning.
If the is not specified, then the method removes all the elements in the array.
index delete()
int map[ string ];
map[ "hello" ] = 1;
map[ "sad" ] = 2;
map[ "world" ] = 3;
map.delete( "sad" ); // remove entry whose index is "sad" from "map"
map.delete; // remove all entries from the associative array "map"
7.9.3 Exists()
The syntax for the method is as follows:
exists()
function int exists( input index );
where is an index of the appropriate type for the array in question.
index
The function checks whether an element exists at the specified index within the given array. It
exists()
returns 1 if the element exists; otherwise, it returns 0.
if ( map.exists( "hello" ))
map[ "hello" ] += 1;
else
map[ "hello" ] = 0;
7.9.4 First()
The syntax for the method is as follows:
first()
function int first( ref index );
where is an index of the appropriate type for the array in question. Associative arrays that specify a
index
wildcard index type shall not be allowed.
158
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The method assigns to the given index variable the value of the first (smallest) index in the
first()
associative array. It returns 0 if the array is empty; otherwise, it returns 1.
string s;
if ( map.first( s ) )
$display( "First entry is : map[ %s ] = %0d\n", s, map[s] );
7.9.5 Last()
The syntax for the method is as follows:
last()
function int last( ref index );
where is an index of the appropriate type for the array in question. Associative arrays that specify a
index
wildcard index type shall not be allowed.
The method assigns to the given index variable the value of the last (largest) index in the associative
last()
array. It returns 0 if the array is empty; otherwise, it returns 1.
string s;
if ( map.last( s ) )
$display( "Last entry is : map[ %s ] = %0d\n", s, map[s] );
7.9.6 Next()
The syntax for the method is as follows:
next()
function int next( ref index );
where is an index of the appropriate type for the array in question. Associative arrays that specify a
index
wildcard index type shall not be allowed.
The method finds the smallest index whose value is greater than the given index argument.
next()
If there is a next entry, the index variable is assigned the index of the next entry, and the function returns 1.
Otherwise, the index is unchanged, and the function returns 0.
string s;
if ( map.first( s ) )
do
$display( "%s : %d\n", s, map[ s ] );
while ( map.next( s ) );
7.9.7 Prev()
The syntax for the method is as follows:
prev()
function int prev( ref index );
where is an index of the appropriate type for the array in question. Associative arrays that specify a
index
wildcard index type shall not be allowed.
The function finds the largest index whose value is smaller than the given index argument. If there
prev()
is a previous entry, the index variable is assigned the index of the previous entry, and the function returns 1.
Otherwise, the index is unchanged, and the function returns 0.
159
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
string s;
if ( map.last( s ) )
do
$display( "%s : %d\n", s, map[ s ] );
while ( map.prev( s ) );
7.9.8 Arguments to traversal methods
The argument that is passed to any of the four associative array traversal methods , ,
first() last()
, and shall be assignment compatible with the index type of the array. If the argument has
next() prev()
an integral type that is smaller than the size of the corresponding array index type, then the function returns
–1 and shall truncate in order to fit into the argument. For example:
string aa[int];
byte ix;
int status;
aa[ 1000 ] = "a";
status = aa.first( ix );
// status is –1
// ix is 232 (least significant 8 bits of 1000)
7.9.9 Associative array assignment
Associative arrays can be assigned only to another associative array of a compatible type and with the same
index type. Other types of arrays cannot be assigned to an associative array, nor can associative arrays be
assigned to other types of arrays, whether fixed-size or dynamic.
Assigning an associative array to another associative array causes the target array to be cleared of any
existing entries, and then each entry in the source array is copied into the target array.
7.9.10 Associative array arguments
Associative arrays can be passed as arguments only to associative arrays of a compatible type and with the
same index type. Other types of arrays, whether fixed-size or dynamic, cannot be passed to subroutines that
accept an associative array as an argument. Likewise, associative arrays cannot be passed to subroutines that
accept other types of arrays.
Passing an associative array by value causes a local copy of the associative array to be created.
7.9.11 Associative array literals
Associative array literals use the syntax with an optional default index. Like all other
'{index:value}
arrays, an associative array can be written one entry at a time, or the whole array contents can be replaced
using an array literal.
For example:
// an associative array of strings indexed by 2-state integers,
// default is "hello".
string words [int] = '{default: "hello"};
// an associative array of 4-state integers indexed by strings, default is –1
integer tab [string] = '{"Peter":20, "Paul":22, "Mary":23, default:-1 };
160
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If a default value is specified, then reading a nonexistent element shall yield the specified default value, and
no warning shall be issued. Otherwise, the value specified by Table7-1 (see 7.4.6) shall be returned.
Defining a default value shall not affect the operation of the associative array methods (see 7.9).
7.10 Queues
A queue is a variable-size, ordered collection of homogeneous elements. A queue supports constant-time
access to all its elements as well as constant-time insertion and removal at the beginning or the end of the
queue. Each element in a queue is identified by an ordinal number that represents its position within the
queue, with 0 representing the first, and representing the last. A queue is analogous to a one-dimensional
$
unpacked array that grows and shrinks automatically. Thus, like arrays, queues can be manipulated using the
indexing, concatenation, slicing operator syntax, and equality operators.
Queues are declared using the same syntax as unpacked arrays, but specifying as the array size. The
$
maximum size of a queue can be limited by specifying its optional right bound (last index).
Queue values may be written using assignment patterns or unpacked array concatenations (see 10.9, 10.10).
The syntax for declaring queues is shown in Syntax7-4.
variable_dimension ::= // from A.2.5
unsized_dimension
| unpacked_dimension
| associative_dimension
| queue_dimension
queue_dimension ::= [ constant_expression ]
[ $ : ]
Syntax7-4—Declaration of queue dimension (excerpt from AnnexA)
constant_expression shall evaluate to a positive integer value.
For example:
byte q1[$]; // A queue of bytes
string names[$] = { "Bob" }; // A queue of strings with one element
integer Q[$] = { 3, 2, 7 }; // An initialized queue of integers
bit q2[$:255]; // A queue whose maximum size is 256 bits
If an initial value is not provided in the declaration, the queue variable is initialized to the empty queue. The
empty queue can be denoted by an empty unpacked array concatenation , as described in 10.10.
{}
7.10.1 Queue operators
Queues shall support the same operations that can be performed on unpacked arrays. In addition, queues
shall support the following operations:
— A queue shall resize itself to accommodate any queue value that is written to it, except that its
maximum size may be bounded as described in 7.10.
— In a queue slice expression such as , the slice bounds may be arbitrary integral expressions
Q[a:b]
and, in particular, are not required to be constant expressions.
— Queues shall support methods as described in 7.10.2.
161
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Unlike arrays, the empty queue, , is a valid queue and the result of some queue operations. The following
{}
rules govern queue operators:
— yields a queue with elements.
Q[ a : b ] b - a + 1
• If , then yields the empty queue .
a > b Q[a:b] {}
• yields a queue with one item, the one at position . Thus,
Q[ n : n ] n Q[ n : n ] === {
.
Q[n] }
• If lies outside ’s range ( ), then yields the empty queue .
n Q n < 0 or n > $ Q[n:n] {}
• If either or are 4-state expressions containing or values, it yields the empty queue .
a b X Z {}
— where is the same as .
Q[ a : b ] a < 0 Q[ 0 : b ]
— where is the same as .
Q[ a : b ] b > $ Q[ a : $ ]
— An invalid index value (i.e., a 4-state expression whose value has one or more or bits, or a value
x z
that lies outside 0...$) shall cause a read operation to return the value appropriate for a nonexistent
array entry of the queue’s element type (as described in Table7-1 in 7.4.6).
— An invalid index (i.e., a 4-state expression with ’s or ’s, or a value that lies outside 0...$+1) shall
X Z
cause a write operation to be ignored and a run-time warning to be issued; however, writing to
is legal.
Q[$+1]
— A queue declared with a right bound using the syntax is known as a bounded queue and shall
[$:N]
be limited to have indices not greater than N (its size shall not exceed N+1). The additional rules
governing bounded queues are described in 7.10.5.
7.10.2 Queue methods
In addition to the array operators, queues provide several built-in methods. Assume these declarations for
the examples that follow:
typedef mytype element_t; // mytype is any legal type for a queue
typedef element_t queue_t[$];
element_t e;
queue_t Q;
int i;
7.10.2.1 Size()
The prototype for the method is as follows:
size()
function int size();
The method returns the number of items in the queue. If the queue is empty, it returns 0.
size()
for ( int j = 0; j < Q.size; j++ ) $display( Q[j] );
7.10.2.2 Insert()
The prototype of the method is as follows:
insert()
function void insert(input integer index, input element_t item);
The method inserts the given item at the specified index position.
insert()
If the index argument has any bits with unknown ( ) value, or is negative, or is greater than the current
x/z
size of the queue, then the method call shall have no effect on the queue and may cause a warning to be
issued.
162
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
NOTE—The index argument is of type rather than so that values in the caller’s actual argument
integer int x/z
value can be detected.
7.10.2.3 Delete()
The prototype for the method is as follows:
delete()
function void delete( [input integer index] );
where is an optional index.
index
If the index is not specified, then the method deletes all the elements in the queue, leaving the
delete()
queue empty.
If the index is specified, then the method deletes the item at the specified index position. If the
delete()
index argument has any bits with unknown ( ) value, or is negative, or is greater than or equal to the
x/z
current size of the queue, then the method call shall have no effect on the queue and may cause a warning to
be issued.
7.10.2.4 Pop_front()
The prototype of the method is as follows:
pop_front()
function element_t pop_front();
The method removes and returns the first element of the queue.
pop_front()
If this method is called on an empty queue:
— Its return value shall be the same as that obtained by attempting to read a nonexistent array element
of the same type as the queue's elements (as described in Table7-1, in 7.4.6);
— It shall have no effect on the queue and may cause a warning to be issued.
7.10.2.5 Pop_back()
The prototype of the method is as follows:
pop_back()
function element_t pop_back();
The method removes and returns the last element of the queue.
pop_back()
If this method is called on an empty queue:
— Its return value shall be the same as that obtained by attempting to read a nonexistent array element
of the same type as the queue's elements (as described in Table7-1 in 7.4.6);
— It shall have no effect on the queue and may cause a warning to be issued.
7.10.2.6 Push_front()
The prototype of the method is as follows:
push_front()
function void push_front(input element_t item);
The method inserts the given element at the front of the queue.
push_front()
163
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
7.10.2.7 Push_back()
The prototype of the method is as follows:
push_back()
function void push_back(input element_t item);
The method inserts the given element at the end of the queue.
push_back()
7.10.3 Persistence of references to elements of a queue
As described in 13.5.2, it is possible for an element of a queue to be passed by reference to a task that
continues to hold the reference while other operations are performed on the queue. Some operations on the
queue shall cause any such reference to become outdated (as defined in 13.5.2). This subclause defines the
situations in which a reference to a queue element shall become outdated.
When any of the queue methods described in 7.10.2 updates a queue, a reference to any existing element that
is not deleted by the method shall not become outdated. All elements that are removed from the queue by the
method shall become outdated references.
When the target of an assignment is an entire queue, references to any element of the original queue shall
become outdated.
As a consequence of this clause, inserting elements in a queue using unpacked array concatenation syntax,
as illustrated in the examples in 7.10.4, will cause all references to any element of the existing queue to
become outdated. Use of the , , and methods will outdate any reference to the
delete pop_front pop_back
popped or deleted element, but will leave references to all other elements of the queue unaffected. By
contrast, use of the , , and methods on a queue can never give rise to
insert push_back push_front
outdated references (except that or on a bounded queue would cause the highest-
insert push_front
numbered element of the queue to be deleted if the new size of the queue were to exceed the queue’s bound).
7.10.4 Updating a queue using assignment and unpacked array concatenation
As described in 7.10, a queue variable may be updated by assignment. Together with unpacked array
concatenation, this offers a flexible alternative to the queue methods described in 7.10.2 when performing
operations on a queue variable.
The following examples show queue assignment operations that exhibit behaviors similar to those of queue
methods. In each case the resulting value of the queue variable shall be the same as if the queue method had
been applied, but any reference to elements of the queue will become outdated by the assignment operation
(see 7.10.3):
int q[$] = { 2, 4, 8 };
int e, pos;
// assignment // method call yielding the
// // same value in variable q
// ----------------------------- // -------------------------
q = { q, 6 }; // q.push_back(6)
q = { e, q }; // q.push_front(e)
q = q[1:$]; // void'(q.pop_front()) or q.delete(0)
q = q[0:$-1]; // void'(q.pop_back()) or
// q.delete(q.size-1)
q = { q[0:pos-1], e, q[pos:$] }; // q.insert(pos, e)
q = { q[0:pos], e, q[pos+1:$] }; // q.insert(pos+1, e)
q = {}; // q.delete()
164
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Some useful operations that cannot be implemented as a single queue method call are illustrated in the
following examples. As in the preceding examples, assignment to the queue variable outdates any reference
to its elements.
q = q[2:$]; // a new queue lacking the first two items
q = q[1:$-1]; // a new queue lacking the first and last items
7.10.5 Bounded queues
A bounded queue shall not have an element whose index is higher than the queue’s declared upper bound.
Operations on bounded queues shall behave exactly as if the queue were unbounded except that if, after any
operation that writes to a bounded queue variable, that variable has any elements beyond its bound, then all
such out-of-bounds elements shall be discarded and a warning shall be issued.
NOTE—Implementations may meet this requirement in any way that achieves the same result. In particular, they are not
required to write the out-of-bounds elements before discarding them.
7.11 Array querying functions
SystemVerilog provides system functions to return information about an array. These are , ,
$left $right
, , , , , and . These functions are
$low $high $increment $size $dimensions $unpacked_dimensions
described in 20.7.
7.12 Array manipulation methods
SystemVerilog provides several built-in methods to facilitate array searching, ordering, and reduction.
The general syntax to call these array methods is as follows:
array_method_call ::=
expression array_method_name { attribute_instance } [ iterator_argument ]
. ( )
[ expression ]
with( )
Syntax7-5—Array method call syntax (not in AnnexA)
The optional clause accepts an expression enclosed in parentheses. In contrast, the clause used
with with
by the randomize method (see 18.7) accepts a set of constraints enclosed in braces.
If the expression contained in the clause includes any side effects, the results may be unpredictable.
with
Array manipulation methods iterate over the array elements, which are then used to evaluate the expression
specified by the clause. The iterator_argument optionally specifies the name of the variable used by
with
the expression to designate the element of the array at each iteration. If it is not specified, the name
with
is used by default. The scope for the iterator_argument is the expression. Specifying an
item with
iterator_argument without also specifying a clause shall be illegal.
with
7.12.1 Array locator methods
Array locator methods operate on any unpacked array, including queues, but their return type is a queue.
These locator methods allow searching an array for elements (or their indices) that satisfy a given
expression. Array locator methods traverse the array in an unspecified order.
165
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Index locator methods return a queue of for all arrays except associative arrays, which return a queue of
int
the same type as the associative index type. Associative arrays that specify a wildcard index type shall not be
allowed.
If no elements satisfy the given expression or the array is empty (in the case of a queue or dynamic array),
then an empty queue is returned. Otherwise, these methods return a queue containing all items that satisfy
the expression. Index locator methods return a queue with the indices of all items that satisfy the expression.
The optional expression specified by the clause shall evaluate to a Boolean value.
with
The following locator methods are supported (the clause is mandatory):
with
— returns all the elements satisfying the given expression.
find()
— returns the indices of all the elements satisfying the given expression.
find_index()
— returns the first element satisfying the given expression.
find_first()
— returns the index of the first element satisfying the given expression.
find_first_index()
— returns the last element satisfying the given expression.
find_last()
— returns the index of the last element satisfying the given expression.
find_last_index()
The first or last element is defined as being closest to the leftmost or rightmost indexed element,
respectively, except for an associative array, which shall use the element closest to the index returned by the
first or last method for the associative array index type.
For the following locator methods, the clause (and its expression) may be omitted if the relational
with
operators ( , , ) are defined for the element type of the given array. If a clause is specified, the
< > == with
relational operators ( , , ) shall be defined for the type of the expression.
< > ==
— returns the element with the minimum value or whose expression evaluates to a minimum.
min()
— returns the element with the maximum value or whose expression evaluates to a maximum.
max()
— returns all elements with unique values or whose expression evaluates to a unique value.
unique()
The queue returned contains one and only one entry for each of the values found in the array. The
ordering of the returned elements is unrelated to the ordering of the original array.
— returns the indices of all elements with unique values or whose expression
unique_index()
evaluates to a unique value. The queue returned contains one and only one entry for each of the
values found in the array. The ordering of the returned elements is unrelated to the ordering of the
original array. The index returned for duplicate valued entries may be the index for one of the
duplicates.
Examples:
string SA[10], qs[$];
int IA[int], qi[$];
// Find all items greater than 5
qi = IA.find( x ) with ( x > 5 );
qi = IA.find( x ); // shall be an error
// Find indices of all items equal to 3
qi = IA.find_index with ( item == 3 );
// Find first item equal to Bob
qs = SA.find_first with ( item == "Bob" );
// Find last item equal to Henry
qs = SA.find_last( y ) with ( y == "Henry" );
166
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
// Find index of last item greater than Z
qi = SA.find_last_index( s ) with ( s > "Z" );
// Find smallest item
qi = IA.min;
// Find string with largest numerical value
qs = SA.max with ( item.atoi );
// Find all unique string elements
qs = SA.unique;
// Find all unique strings in lowercase
qs = SA.unique( s ) with ( s.tolower );
7.12.2 Array ordering methods
Array ordering methods reorder the elements of any unpacked array (fixed or dynamically sized) except for
associative arrays.
The prototype for the ordering methods is as follows:
function void ordering_method ( array_type iterator = item );
The following ordering methods are supported:
— reverses the order of the elements in the array. Specifying a clause shall be a com-
reverse() with
piler error.
— sorts the array in ascending order, optionally using the expression in the clause. The
sort() with
clause (and its expression) is optional when the relational operators ( , , ) are defined for
with < > ==
the array element type. If a clause is specified, the relational operators ( , , ) shall be
with < > ==
defined for the type of the expression.
— sorts the array in descending order, optionally using the expression in the clause.
rsort() with
The clause (and its expression) is optional when the relational operators ( , , ) are defined
with < > ==
for the array element type. If a clause is specified, the relational operators ( , , ) shall be
with < > ==
defined for the type of the expression.
— randomizes the order of the elements in the array. Specifying a clause shall be a
shuffle() with
compiler error.
Examples:
string s[] = { "hello", "sad", "world" };
s.reverse; // s becomes { "world", "sad", "hello" };
int q[$] = { 4, 5, 3, 1 };
q.sort; // q becomes { 1, 3, 4, 5 }
struct { byte red, green, blue; } c [512];
c.sort with ( item.red ); // sort c using the red field only
c.sort( x ) with ( {x.blue, x.green} ); // sort by blue then green
7.12.3 Array reduction methods
Array reduction methods may be applied to any unpacked array of integral values to reduce the array to a
single value. The expression within the optional clause is used to specify the values to use in the
with
reduction. The values produced by evaluating this expression for each array element are used by the
167
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
reduction method. This is in contrast to the array locator methods (see 7.12.1) where the clause is used
with
as a selection criteria.
The prototype for these methods is as follows:
function expression_or_array_type reduction_method (array_type iterator = item);
The method returns a single value of the same type as the array element type or, if specified, the type of the
expression in the clause. The clause may be omitted if the corresponding arithmetic or Boolean
with with
reduction operation is defined for the array element type. If a clause is specified, the corresponding
with
arithmetic or Boolean reduction operation shall be defined for the type of the expression.
The following reduction methods are supported:
— returns the sum of all the array elements or, if a clause is specified, returns the sum of
sum() with
the values yielded by evaluating the expression for each array element.
— returns the product of all the array elements or, if a clause is specified, returns the
product() with
product of the values yielded by evaluating the expression for each array element.
— returns the bitwise AND ( & ) of all the array elements or, if a clause is specified,
and() with
returns the bitwise AND of the values yielded by evaluating the expression for each array element.
— returns the bitwise OR ( | ) of all the array elements or, if a clause is specified, returns the
or() with
bitwise OR of the values yielded by evaluating the expression for each array element.
— returns the bitwise XOR ( ^ ) of all the array elements or, if a clause is specified,
xor() with
returns the bitwise XOR of the values yielded by evaluating the expression for each array element.
Examples:
byte b[] = { 1, 2, 3, 4 };
int y;
y = b.sum ; // y becomes 10 => 1 + 2 + 3 + 4
y = b.product ; // y becomes 24 => 1 * 2 * 3 * 4
y = b.xor with ( item + 4 ); // y becomes 12 => 5 ^ 6 ^ 7 ^ 8
logic [7:0] m [2][2] = '{ '{5, 10}, '{15, 20} };
int y;
y = m.sum with (item.sum with (item));// y becomes 50 => 5+10+15+20
logic bit_arr [1024];
int y;
y = bit_arr.sum with ( int'(item) ); // forces result to be 32-bit
The last example shows how the result of calling on a bit array can be forced to be a 32-bit quantity. By
sum
default, the result of calling would be of type in this example. Summing the values of 1024 bits
sum logic
could overflow the result. This overflow can be avoided by using a clause. When specified, the
with with
clause is used to determine the type of the result. Casting to an in the clause causes the
item int with
array elements to be extended to 32 bits before being summed. The result of calling in this example is
sum
32 bits since the width of the reduction method result shall be the same as the width of the expression in the
clause.
with
7.12.4 Iterator index querying
The expressions used by array manipulation methods sometimes need the actual array indices at each
iteration, not just the array element. The index method of an iterator returns the index value of the specified
dimension. The prototype of the index method is as follows:
168
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
function int_or_index_type index ( int dimension = 1 );
The array dimensions are numbered as defined in 20.7. The slowest varying is dimension 1. Successively
faster varying dimensions have sequentially higher dimension numbers. If the dimension is not specified, the
first dimension is used by default.
The return type of the index method is an for all array iterator items except associative arrays, which
int
return an index of the same type as the associative index type. Associative arrays that specify a wildcard
index type shall not be allowed.
For example:
int arr[];
int q[$];
...
// find all items equal to their position (index)
q = arr.find with ( item == item.index );
169
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
8. Classes
8.1 General
This clause describes the following:
— Class definitions
— Virtual classes and methods
— Polymorphism
— Parameterized classes
— Interface classes
— Memory management
8.2 Overview
A class is a type that includes data and subroutines (functions and tasks) that operate on those data. A class’s
data are referred to as class properties, and its subroutines are called methods; both are members of the class.
The class properties and methods, taken together, define the contents and capabilities of some kind of object.
For example, a packet might be an object. It might have a command field, an address, a sequence number, a
time stamp, and a packet payload. In addition, there are various things that can be done with a packet:
initialize the packet, set the command, read the packet’s status, or check the sequence number. Each packet
is different, but as a class, packets have certain intrinsic properties that can be captured in a definition.
class Packet ;
//data or class properties
bit [3:0] command;
bit [40:0] address;
bit [4:0] master_id;
integer time_requested;
integer time_issued;
integer status;
typedef enum { ERR_OVERFLOW = 10, ERR_UNDERFLOW = 1123} PCKT_TYPE;
const integer buffer_size = 100;
const integer header_size;
// initialization
function new();
command = 4'd0;
address = 41'b0;
master_id = 5'bx;
header_size = 10;
endfunction
// methods
// public access entry points
task clean();
command = 0; address = 0; master_id = 5'bx;
endtask
task issue_request( int delay );
// send request to bus
endtask
function integer current_status();
170
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
current_status = status;
endfunction
endclass
The object-oriented class extension allows objects to be created and destroyed dynamically. Class instances,
or objects, can be passed around via object handles, which provides a safe-pointer capability. An object can
be declared as an argument with direction , , , or . In each case, the argument
input output inout ref
copied is the object handle, not the contents of the object.
8.3 Syntax
class_declaration ::= // from A.1.2
[ ] [ lifetime ] class_identifier [ parameter_port_list ]
virtual class
[ class_type [ list_of_arguments ] ]
extends ( )
[ interface_class_type { interface_class_type } ]
implements , ;
{ class_item }
[ class_identifier]
endclass :
interface_class_type ::= ps_class_identifier [ parameter_value_assignment ]
class_item ::= // from A.1.9
{ attribute_instance } class_property
| { attribute_instance } class_method
| { attribute_instance } class_constraint
| { attribute_instance } class_declaration
| { attribute_instance } covergroup_declaration
| local_parameter_declaration
;
| parameter_declaration7
;
|
;
class_property ::=
{ property_qualifier } data_declaration
| { class_item_qualifier } data_type const_identifier [ constant_expression ]
const = ;
class_method ::=
{ method_qualifier } task_declaration
| { method_qualifier } function_declaration
| { class_item_qualifier } method_prototype
purevirtual ;
| { method_qualifier } method_prototype
extern ;
| { method_qualifier } class_constructor_declaration
| { method_qualifier } class_constructor_prototype
extern
class_constructor_prototype ::=
[ [ tf_port_list ] ]
function new ( ) ;
class_constraint ::=
constraint_prototype
| constraint_declaration
class_item_qualifier8 ::=
static
|
protected
|
local
property_qualifier8 ::=
random_qualifier
| class_item_qualifier
171
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
random_qualifier8 ::=
rand
|
randc
method_qualifier8 ::=
[ ]
pure virtual
| class_item_qualifier
method_prototype ::=
task_prototype
| function_prototype
7) In a parameter_declaration that is a class_item, the keyword shall be a synonym for the
parameter
keyword.
localparam
8) In any one declaration, only one of or is allowed, only one of or is allowed,
protected local rand randc
and and/or can appear only once.
static virtual
Syntax8-1—Class syntax (excerpt from AnnexA)
8.4 Objects (class instance)
A class defines a data type. An object is an instance of that class. An object is used by first declaring a
variable of that class type (that holds an object handle) and then creating an object of that class (using the
function) and assigning it to the variable.
new
Packet p; // declare a variable of class Packet
p = new; // initialize variable to a new allocated object
// of the class Packet
The variable is said to hold an object handle to an object of class .
p Packet
Uninitialized object handles are set by default to the special value . An uninitialized object can be
null
detected by comparing its handle with .
null
For example: The following task checks whether the object is initialized. If it is not, it creates a new
task1
object via the function.
new
class obj_example;
...
endclass
task task1(integer a, obj_example myexample);
if (myexample == null) myexample = new;
endtask
Accessing non-static members (see 8.9) or virtual methods (see 8.20) via a object handle is illegal. The
null
result of an illegal access via a null object is indeterminate, and implementations may issue an error.
SystemVerilog objects are referenced using an object handle. There are some differences between a C
pointer and a SystemVerilog object handle (see Table8-1). C pointers give programmers a lot of latitude in
how a pointer can be used. The rules governing the usage of SystemVerilog object handles are much more
restrictive. A C pointer can be incremented, for example, but a SystemVerilog object handle cannot. In
addition to object handles, 6.14 introduces the data type for use with the DPI (see Clause35).
chandle
172
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table8-1—Comparison of pointer and handle types
SV object
Operation C pointer SV chandle
handle
Arithmetic operations (such as incrementing) Allowed Not allowed Not allowed
For arbitrary data types Allowed Not allowed Not allowed
Dereference when Error Error, see Not allowed
null
text above
Casting Allowed Limited Not allowed
Assignment to an address of a data type Allowed Not allowed Not allowed
Unreferenced objects are garbage collected No Yes No
Default value Undefined
null null
For classes (C++) Allowed Not allowed
Only the following operators are valid on object handles:
— Equality ( ), inequality ( ) with another class object or with . One of the objects being
== != null
compared must be assignment compatible with the other.
— Case equality ( ), case inequality ( ) with another class object or with (same semantics
=== !== null
as and ).
== !=
— Conditional operator (see 11.4.11).
— Assignment of a class object whose class data type is assignment compatible with the target class
object.
— Assignment of .
null
8.5 Object properties and object parameter data
There are no restrictions on the data type of a class property. The class properties of an object can be used by
qualifying class property names with an instance name. Using the earlier example (see 8.2), the properties
for the object can be used as follows:
Packet p
Packet p = new;
int var1;
p.command = INIT;
p.address = $random;
packet_time = p.time_requested;
var1 = p.buffer_size;
Class enum names, in addition to being accessed using a class scope resolution operator, can also be
accessed by qualifying the class enum name with an instance name.
initial $display (p.ERR_OVERFLOW);
The parameter data values of an object can also be accessed by qualifying the class value parameter or local
value parameter name with an instance name. Such an expression is not a constant expression. Accessing
data types using a class handle is not allowed. For example:
173
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
class vector #(parameter width = 7, type T = int);
endclass
vector #(3) v = new;
initial $display (vector #(3)::T'(3.45)); // Typecasting
initial $display ((v.T)'(3.45)); //ILLEGAL
initial $display (v.width);
8.6 Object methods
An object’s methods can be accessed using the same syntax used to access class properties:
Packet p = new;
status = p.current_status();
The preceding assignment to cannot be written as follows:
status
status = current_status(p);
The focus in object-oriented programming is the object, in this case the packet, not the function call. Also,
objects are self-contained, with their own methods for manipulating their own properties. Therefore, the
object does not have to be passed as an argument to . A class’s properties are freely
current_status()
and broadly available to the methods of the class, but each method only accesses the properties associated
with its object, i.e., its instance.
The lifetime of methods declared as part of a class type shall be automatic. It shall be illegal to declare a
class method with a static lifetime.
8.7 Constructors
SystemVerilog does not require the complex memory allocation and deallocation of C++. Construction of an
object is straightforward; and garbage collection, as in Java, is implicit and automatic. There can be no
memory leaks or other subtle behaviors, which are so often the bane of C++ programmers.
SystemVerilog provides a mechanism for initializing an instance at the time the object is created. When an
object is created, for example,
Packet p = new;
the system executes the function associated with the class:
new
class Packet;
integer command;
function new();
command = IDLE;
endfunction
endclass
As shown previously, is now being used in two very different contexts with very different semantics.
new
The variable declaration creates an object of class . In the course of creating this instance, the
Packet new
function is invoked, in which any specialized initialization required can be done. The function is also
new
called the class constructor.
174
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The operation is defined as a function with no return type, and like any other function, it shall be
new
nonblocking. Even though does not specify a return type, the left-hand side of the assignment
new
determines the return type.
If a class does not provide an explicit user-defined method, an implicit method shall be provided
new new
automatically. The method of a derived class shall first call its base class constructor [ as
new super.new()
described in 8.15]. After the base class constructor call (if any) has completed, each property defined in the
class shall be initialized to its explicit default value or its uninitialized value if no default is provided. After
the properties are initialized, the remaining code in a user-defined constructor shall be evaluated. The default
constructor has no additional effect after the property initialization. The value of a property prior to its
initialization shall be undefined.
Example:
class C;
int c1 = 1;
int c2 = 1;
int c3 = 1;
function new(int a);
c2 = 2;
c3 = a;
endfunction
endclass
class D extends C;
int d1 = 4;
int d2 = c2;
int d3 = 6;
function new;
super.new(d3);
endfunction
endclass
After the construction of an object of type is complete, the properties are as follows:
D
— has the value 1
c1
— has the value 2 since the constructor assignment happens after the property initialization
c2
— has an undefined value since the constructor call from passes in the value of , which is
c3 D d3
undefined when the call is made
super.new(d3)
— has the value 4
d1
— has the value 2 since the call is complete when is initialized
d2 super.new d2
— has the value 6
d3
It is also possible to pass arguments to the constructor, which allows run-time customization of an object:
Packet p = new(STARTUP, $random, $time);
where the initialization task in might now look like the following:
new Packet
function new(int cmd = IDLE, bit[12:0] adrs = 0, int cmd_time );
command = cmd;
address = adrs;
time_requested = cmd_time;
endfunction
175
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.