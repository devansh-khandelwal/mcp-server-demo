IE EE Standard for SystemVerilog—
Unified Hardware Design,
Specification, and Verification
Language
IEEE Computer Society
and the
IEEE Standards Association Corporate Advisory Group
Sponsored by the
Design Automation Standards Committee
IEEE
IEEE Std 1800™-2017
3 Park Avenue
(Revision of
New York, NY 10016-5997
IEEE Std 1800-2012)
USA
Authorized licensed use limited to: Siemens AG GBS B&S SOL GMS. Downloaded on December 03,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800™-2017
(Revision of
IEEE Std 1800-2012)
IEEE Standard for SystemVerilog—
Unified Hardware Design,
Specification, and Verification
Language
Sponsor
Design Automation Standards Committee
of the
IEEE Computer Society
and the
IEEE Standards Association Corporate Advisory Group
Approved 6 December 2017
IEEE-SA Standards Board
Authorized licensed use limited to: Siemens AG GBS B&S SOL GMS. Downloaded on December 03,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Abstract: The definition of the language syntax and semantics for SystemVerilog, which is a unified
hardware design, specification, and verification language, is provided. This standard includes
support for modeling hardware at the behavioral, register transfer level (RTL), and gate-level
abstraction levels, and for writing testbenches using coverage, assertions, object-oriented
programming, and constrained random verification. The standard also provides application
programming interfaces (APIs) to foreign programming languages.
Keywords: assertions, design automation, design verification, hardware description language,
HDL, HDVL, IEEE 1800™, PLI, programming language interface, SystemVerilog, Verilog®, VPI
The Institute of Electrical and Electronics Engineers, Inc.
3 Park Avenue, New York, NY 10016-5997, USA
Copyright © 2018 by The Institute of Electrical and Electronics Engineers, Inc.
All rights reserved. Published 21 February 2018. Printed in the United States of America.
IEEE, 802, and POSIX are registered trademarks in the U.S. Patent & Trademark Office, owned by The Institute of
Electrical and Electronics Engineers, Incorporated.
Verilog is a registered trademark of Cadence Design Systems, Inc.
Print: ISBN 978-1-5044-4510-8 STDPD22888
PDF: ISBN 978-1-5044-4509-2 STDGT22888
IEEE prohibits discrimination, harassment, and bullying.
For more information, visit http://www.ieee.org/web/aboutus/whatis/policies/p9-26.html.
No part of this publication may be reproduced in any form, in an electronic retrieval system or otherwise, without the prior written permission
of the publisher.
2
Copyright © 2018 IEEE. All rights reserved.
Authorized licensed use limited to: Siemens AG GBS B&S SOL GMS. Downloaded on December 03,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Important Notices and Disclaimers Concerning IEEE Standards Documents
IEEE documents are made available for use subject to important notices and legal disclaimers. These notices
and disclaimers, or a reference to this page, appear in all standards and may be found under the heading
“Important Notices and Disclaimers Concerning IEEE Standards Documents.” They can also be obtained on
request from IEEE or viewed at http://standards.ieee.org/IPR/disclaimers.html.
Notice and Disclaimer of Liability Concerning the Use of IEEE Standards
Documents
IEEE Standards documents (standards, recommended practices, and guides), both full-use and trial-use, are
developed within IEEE Societies and the Standards Coordinating Committees of the IEEE Standards
Association (“IEEE-SA”) Standards Board. IEEE (“the Institute”) develops its standards through a
consensus development process, approved by the American National Standards Institute (“ANSI”), which
brings together volunteers representing varied viewpoints and interests to achieve the final product. IEEE
Standards are documents developed through scientific, academic, and industry-based technical working
groups. Volunteers in IEEE working groups are not necessarily members of the Institute and participate
without compensation from IEEE. While IEEE administers the process and establishes rules to promote
fairness in the consensus development process, IEEE does not independently evaluate, test, or verify the
accuracy of any of the information or the soundness of any judgments contained in its standards.
IEEE Standards do not guarantee or ensure safety, security, health, or environmental protection, or ensure
against interference with or from other devices or networks. Implementers and users of IEEE Standards
documents are responsible for determining and complying with all appropriate safety, security,
environmental, health, and interference protection practices and all applicable laws and regulations.
IEEE does not warrant or represent the accuracy or content of the material contained in its standards, and
expressly disclaims all warranties (express, implied and statutory) not included in this or any other
document relating to the standard, including, but not limited to, the warranties of: merchantability; fitness
for a particular purpose; non-infringement; and quality, accuracy, effectiveness, currency, or completeness
of material. In addition, IEEE disclaims any and all conditions relating to: results; and workmanlike effort.
IEEE standards documents are supplied “AS IS” and “WITH ALL FAULTS.”
Use of an IEEE standard is wholly voluntary. The existence of an IEEE standard does not imply that there
are no other ways to produce, test, measure, purchase, market, or provide other goods and services related to
the scope of the IEEE standard. Furthermore, the viewpoint expressed at the time a standard is approved and
issued is subject to change brought about through developments in the state of the art and comments
received from users of the standard.
In publishing and making its standards available, IEEE is not suggesting or rendering professional or other
services for, or on behalf of, any person or entity nor is IEEE undertaking to perform any duty owed by any
other person or entity to another. Any person utilizing any IEEE Standards document, should rely upon his
or her own independent judgment in the exercise of reasonable care in any given circumstances or, as
appropriate, seek the advice of a competent professional in determining the appropriateness of a given IEEE
standard.
IN NO EVENT SHALL IEEE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO:
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE PUBLICATION, USE OF, OR RELIANCE
UPON ANY STANDARD, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE AND
REGARDLESS OF WHETHER SUCH DAMAGE WAS FORESEEABLE.
3
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Translations
The IEEE consensus development process involves the review of documents in English only. In the event
that an IEEE standard is translated, only the English version published by IEEE should be considered the
approved IEEE standard.
Official statements
A statement, written or oral, that is not processed in accordance with the IEEE-SA Standards Board
Operations Manual shall not be considered or inferred to be the official position of IEEE or any of its
committees and shall not be considered to be, or be relied upon as, a formal position of IEEE. At lectures,
symposia, seminars, or educational courses, an individual presenting information on IEEE standards shall
make it clear that his or her views should be considered the personal views of that individual rather than the
formal position of IEEE.
Comments on standards
Comments for revision of IEEE Standards documents are welcome from any interested party, regardless of
membership affiliation with IEEE. However, IEEE does not provide consulting information or advice
pertaining to IEEE Standards documents. Suggestions for changes in documents should be in the form of a
proposed change of text, together with appropriate supporting comments. Since IEEE standards represent a
consensus of concerned interests, it is important that any responses to comments and questions also receive
the concurrence of a balance of interests. For this reason, IEEE and the members of its societies and
Standards Coordinating Committees are not able to provide an instant response to comments or questions
except in those cases where the matter has previously been addressed. For the same reason, IEEE does not
respond to interpretation requests. Any person who would like to participate in revisions to an IEEE
standard is welcome to join the relevant IEEE working group.
Comments on standards should be submitted to the following address:
Secretary, IEEE-SA Standards Board
445 Hoes Lane
Piscataway, NJ 08854 USA
Laws and regulations
Users of IEEE Standards documents should consult all applicable laws and regulations. Compliance with the
provisions of any IEEE Standards document does not imply compliance to any applicable regulatory
requirements. Implementers of the standard are responsible for observing or referring to the applicable
regulatory requirements. IEEE does not, by the publication of its standards, intend to urge action that is not
in compliance with applicable laws, and these documents may not be construed as doing so.
Copyrights
IEEE draft and approved standards are copyrighted by IEEE under U.S. and international copyright laws.
They are made available by IEEE and are adopted for a wide variety of both public and private uses. These
include both use, by reference, in laws and regulations, and use in private self-regulation, standardization,
and the promotion of engineering practices and methods. By making these documents available for use and
adoption by public authorities and private users, IEEE does not waive any rights in copyright to the
documents.
4
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Photocopies
Subject to payment of the appropriate fee, IEEE will grant users a limited, non-exclusive license to
photocopy portions of any individual standard for company or organizational internal use or individual, non-
commercial use only. To arrange for payment of licensing fees, please contact Copyright Clearance Center,
Customer Service, 222 Rosewood Drive, Danvers, MA 01923 USA; +1 978 750 8400. Permission to
photocopy portions of any individual standard for educational classroom use can also be obtained through
the Copyright Clearance Center.
Updating of IEEE Standards documents
Users of IEEE Standards documents should be aware that these documents may be superseded at any time
by the issuance of new editions or may be amended from time to time through the issuance of amendments,
corrigenda, or errata. An official IEEE document at any point in time consists of the current edition of the
document together with any amendments, corrigenda, or errata then in effect.
Every IEEE standard is subjected to review at least every ten years. When a document is more than ten years
old and has not undergone a revision process, it is reasonable to conclude that its contents, although still of
some value, do not wholly reflect the present state of the art. Users are cautioned to check to determine that
they have the latest edition of any IEEE standard.
In order to determine whether a given document is the current edition and whether it has been amended
through the issuance of amendments, corrigenda, or errata, visit the IEEE-SA Website at http://
ieeexplore.ieee.org or contact IEEE at the address listed previously. For more information about the IEEE
SA or IEEE’s standards development process, visit the IEEE-SA Website at http://standards.ieee.org.
Errata
Errata, if any, for all IEEE standards can be accessed on the IEEE-SA Website at the following URL: http://
standards.ieee.org/findstds/errata/index.html. Users are encouraged to check this URL for errata
periodically.
Patents
Attention is called to the possibility that implementation of this standard may require use of subject matter
covered by patent rights. By publication of this standard, no position is taken by the IEEE with respect to the
existence or validity of any patent rights in connection therewith. If a patent holder or patent applicant has
filed a statement of assurance via an Accepted Letter of Assurance, then the statement is listed on the IEEE-
SA Website at http://standards.ieee.org/about/sasb/patcom/patents.html. Letters of Assurance may indicate
whether the Submitter is willing or unwilling to grant licenses under patent rights without compensation or
under reasonable rates, with reasonable terms and conditions that are demonstrably free of any unfair
discrimination to applicants desiring to obtain such licenses.
Essential Patent Claims may exist for which a Letter of Assurance has not been received. The IEEE is not
responsible for identifying Essential Patent Claims for which a license may be required, for conducting
inquiries into the legal validity or scope of Patents Claims, or determining whether any licensing terms or
conditions provided in connection with submission of a Letter of Assurance, if any, or in any licensing
agreements are reasonable or non-discriminatory. Users of this standard are expressly advised that
determination of the validity of any patent rights, and the risk of infringement of such rights, is entirely their
own responsibility. Further information may be obtained from the IEEE Standards Association.
5
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Participants
The SystemVerilog Language Working Group is entity based. At the time this standard was completed,
the SystemVerilog Working Group had the following membership:
Karen Pieper, Accellera Systems Initiative, Chair
Neil Korpusik, Oracle Corporation, Vice Chair, Technical Chair
Dennis Brophy, Mentor, a Siemens Business, Secretary
Shalom Bresticker, Accellera Systems Initiative, Editor
Dave Rich, Mentor, a Siemens Business Matt Maidment, Intel Corporation
Dmitry Korchemny, Synopsys, Inc. Scott Little, Mentor, a Siemens Business
Michiel Ligthart, Design Automation, Inc. Charles Dawson, Cadence Design Systems, Inc.
Work on this standard was divided among primary committees.
The Design and Testbench Committee (SV-BC) was responsible for the specification of the design and
testbench features of SystemVerilog.
Matt Maidment, Intel Corporation, Chair
Brad Pierce, Synopsys, Inc., Co-Chair
Shalom Bresticker, Accellera Systems Initiative Justin Refice, NVIDIA Corporation
Jonathan Bromley, Oracle Corporation Dave Rich, Mentor, a Siemens Business
Eric Coffin, Mentor, a Siemens Business Ray Ryan, Mentor, a Siemens Business
Mark Hartoog, Synopsys, Inc. Arturo Salz, Synopsys, Inc.
Neil Korpusik, Oracle Corporation Steven Sharp, Cadence Design Systems, Inc.
Francoise Martinolle, Cadence Design Systems, Inc. Mark Strickland, Cisco Systems, Inc.
C. Venkat Ramana Rao, Mentor, a Siemens Business Brandon Tipp, Intel Corporation
The Assertions Committee (SV-AC) was responsible for the specification of the assertion features of
SystemVerilog.
Dmitry Korchemny, Synopsys, Inc., Chair
Erik Seligman, Intel Corporation, Co-Chair
Mehbub Ali, Intel Corporation Ben Cohen, Accellera Systems Initiative
Shalom Bresticker, Accellera Systems Initiative Manisha Kulshrestha, Mentor Graphics Corporation
Eduard Cerny, Synopsys, Inc. Anupam Prabhakar, Mentor Graphics Corporation
Ang Boon Chong, Intel Corporation Samik Sengupta, Synopsys, Inc.
The Discrete Committee (SV-DC) was responsible for defining features to support modeling of analog/
mixed-signal circuit components in the discrete domain.
Scott Little, Mentor, a Siemens Business, Chair
Scott Cranston, Cadence Design Systems, Inc., Co-Chair
Kevin Cameron, Samsung Arturo Salz, Synopsys, Inc.
Shekar Chetput, Cadence Design Systems, Inc. Aaron Spratt, Cadence Design Systems, Inc.
Dave Cronauer, Synopsys, Inc. Martin Vlach, Mentor, a Siemens Business
Mark Hartoog, Synopsys, Inc. Gordon Vreugdenhil, Mentor, a Siemens Business
6
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

The following members of the entity balloting committee voted on this standard. Balloters may have voted
for approval, disapproval, or abstention.
Accellera Systems Initiative, Inc. Oracle, Inc.
Cadence Design Systems, Inc. Siemens Corporation
Cisco Systems, Inc. Synopsys, Inc.
Intel Corporation Verific Design Automation, Inc.
When the IEEE-SA Standards Board approved this standard on 6 December 2017, it had the following
membership:
Jean-Philippe Faure, Chair
Gary Hoffman, Vice Chair
John D. Kulick, Past Chair
Konstantinos Karachalios, Secretary
Chuck Adams Thomas Koshy Robby Robson
Masayuki Ariyoshi Joseph L. Koepfinger* Dorothy Stanley
Ted Burse Kevin Lu Adrian Stephens
Stephen Dukes Daleep Mohla Mehmet Ulema
Doug Edwards Damir Novosel Phil Wennblom
J. Travis Griffith Ronald C. Petersen Howard Wolfman
Michael Janezic Annette D. Reilly Yu Yuan
*Member Emeritus
7
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Introduction
This introduction is not part of IEEE Std 1800-2017, IEEE Standard for SystemVerilog—Unified Hardware Design,
Specification, and Verification Language.
The purpose of this standard is to provide the electronic design automation (EDA), semiconductor, and
system design communities with a well-defined and official IEEE unified hardware design, specification,
and verification standard language. The language is designed to coexist and enhance the hardware
description and verification languages (HDVLs) presently used by designers while providing the capabilities
lacking in those languages.
SystemVerilog is a unified hardware design, specification, and verification language based on the Accellera
SystemVerilog 3.1a extensions to the Verilog hardware description language (HDL) [B4], published in
2004. Accellera is a consortium of EDA, semiconductor, and system companies. IEEE Std1800 enables a
productivity boost in design and validation and covers design, simulation, validation, and formal
assertion-based verification flows.
SystemVerilog enables the use of a unified language for abstract and detailed specification of the design,
specification of assertions, coverage, and testbench verification based on manual or automatic
methodologies. SystemVerilog offers application programming interfaces (APIs) for coverage and
assertions, and a direct programming interface (DPI) to access proprietary functionality. SystemVerilog
offers methods that allow designers to continue to use present design languages when necessary to leverage
existing designs and intellectual property (IP). This standardization project will provide the VLSI design
engineers with a well-defined IEEE standard, which meets their requirements in design and validation, and
which enables a step function increase in their productivity. This standardization project will also provide
the EDA industry with a standard to which they can adhere and that they can support in order to deliver their
solutions in this area.
8
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Contents
Part One: Design and Verification Constructs
1. Overview...........................................................................................................................................38
1.1 Scope......................................................................................................................................38
1.2 Purpose...................................................................................................................................38
1.3 Content summary...................................................................................................................38
1.4 Special terms..........................................................................................................................39
1.5 Conventions used in this standard.........................................................................................39
1.6 Syntactic description..............................................................................................................40
1.7 Use of color in this standard..................................................................................................40
1.8 Contents of this standard........................................................................................................41
1.9 Deprecated clauses.................................................................................................................44
1.10 Examples................................................................................................................................44
1.11 Prerequisites...........................................................................................................................44
2. Normative references........................................................................................................................45
3. Design and verification building blocks...........................................................................................47
3.1 General...................................................................................................................................47
3.2 Design elements.....................................................................................................................47
3.3 Modules.................................................................................................................................47
3.4 Programs................................................................................................................................48
3.5 Interfaces................................................................................................................................49
3.6 Checkers.................................................................................................................................50
3.7 Primitives...............................................................................................................................50
3.8 Subroutines............................................................................................................................50
3.9 Packages.................................................................................................................................50
3.10 Configurations.......................................................................................................................51
3.11 Overview of hierarchy...........................................................................................................51
3.12 Compilation and elaboration..................................................................................................52
3.13 Name spaces..........................................................................................................................54
3.14 Simulation time units and precision.......................................................................................55
4. Scheduling semantics........................................................................................................................59
4.1 General...................................................................................................................................59
4.2 Execution of a hardware model and its verification environment.........................................59
4.3 Event simulation....................................................................................................................59
4.4 Stratified event scheduler.......................................................................................................60
4.5 SystemVerilog simulation reference algorithm.....................................................................65
4.6 Determinism...........................................................................................................................65
4.7 Nondeterminism.....................................................................................................................66
4.8 Race conditions......................................................................................................................66
9
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

4.9 Scheduling implication of assignments.................................................................................66
4.10 PLI callback control points....................................................................................................68
5. Lexical conventions..........................................................................................................................69
5.1 General...................................................................................................................................69
5.2 Lexical tokens........................................................................................................................69
5.3 White space............................................................................................................................69
5.4 Comments..............................................................................................................................69
5.5 Operators................................................................................................................................69
5.6 Identifiers, keywords, and system names..............................................................................70
5.7 Numbers.................................................................................................................................71
5.8 Time literals...........................................................................................................................76
5.9 String literals..........................................................................................................................76
5.10 Structure literals.....................................................................................................................78
5.11 Array literals..........................................................................................................................79
5.12 Attributes...............................................................................................................................79
5.13 Built-in methods....................................................................................................................81
6. Data types.........................................................................................................................................83
6.1 General...................................................................................................................................83
6.2 Data types and data objects....................................................................................................83
6.3 Value set................................................................................................................................83
6.4 Singular and aggregate types.................................................................................................84
6.5 Nets and variables..................................................................................................................85
6.6 Net types................................................................................................................................86
6.7 Net declarations.....................................................................................................................97
6.8 Variable declarations...........................................................................................................100
6.9 Vector declarations..............................................................................................................102
6.10 Implicit declarations............................................................................................................103
6.11 Integer data types.................................................................................................................104
6.12 Real, shortreal, and realtime data types...............................................................................105
6.13 Void data type......................................................................................................................105
6.14 Chandle data type.................................................................................................................105
6.15 Class.....................................................................................................................................106
6.16 String data type....................................................................................................................106
6.17 Event data type.....................................................................................................................112
6.18 User-defined types...............................................................................................................112
6.19 Enumerations.......................................................................................................................114
6.20 Constants..............................................................................................................................119
6.21 Scope and lifetime...............................................................................................................126
6.22 Type compatibility...............................................................................................................128
6.23 Type operator.......................................................................................................................131
6.24 Casting.................................................................................................................................132
6.25 Parameterized data types.....................................................................................................137
10
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

7. Aggregate data types.......................................................................................................................139
7.1 General.................................................................................................................................139
7.2 Structures.............................................................................................................................139
7.3 Unions..................................................................................................................................141
7.4 Packed and unpacked arrays................................................................................................145
7.5 Dynamic arrays....................................................................................................................149
7.6 Array assignments................................................................................................................152
7.7 Arrays as arguments to subroutines.....................................................................................153
7.8 Associative arrays................................................................................................................155
7.9 Associative array methods...................................................................................................157
7.10 Queues.................................................................................................................................161
7.11 Array querying functions.....................................................................................................165
7.12 Array manipulation methods...............................................................................................165
8. Classes............................................................................................................................................170
8.1 General.................................................................................................................................170
8.2 Overview..............................................................................................................................170
8.3 Syntax..................................................................................................................................171
8.4 Objects (class instance)........................................................................................................172
8.5 Object properties and object parameter data........................................................................173
8.6 Object methods....................................................................................................................174
8.7 Constructors.........................................................................................................................174
8.8 Typed constructor calls........................................................................................................176
8.9 Static class properties...........................................................................................................177
8.10 Static methods......................................................................................................................177
8.11 This......................................................................................................................................177
8.12 Assignment, renaming, and copying....................................................................................178
8.13 Inheritance and subclasses...................................................................................................180
8.14 Overridden members............................................................................................................180
8.15 Super....................................................................................................................................181
8.16 Casting.................................................................................................................................182
8.17 Chaining constructors..........................................................................................................182
8.18 Data hiding and encapsulation.............................................................................................183
8.19 Constant class properties.....................................................................................................184
8.20 Virtual methods....................................................................................................................184
8.21 Abstract classes and pure virtual methods...........................................................................186
8.22 Polymorphism: dynamic method lookup.............................................................................187
8.23 Class scope resolution operator ::........................................................................................187
8.24 Out-of-block declarations....................................................................................................189
8.25 Parameterized classes..........................................................................................................191
8.26 Interface classes...................................................................................................................194
8.27 Typedef class.......................................................................................................................203
8.28 Classes and structures..........................................................................................................203
8.29 Memory management..........................................................................................................204
11
Authorized licensed use limited to: Siemens AG GBSC Bo&pSy rSigOhLt ©G M20S1. 8D oIEwEnlEo.a dAelld r iognh tDse rceesmebrveer d0.3,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

9. Processes.........................................................................................................................................205
9.1 General.................................................................................................................................205
9.2 Structured procedures..........................................................................................................205
9.3 Block statements..................................................................................................................209
9.4 Procedural timing controls...................................................................................................215
9.5 Process execution threads....................................................................................................224
9.6 Process control.....................................................................................................................225
9.7 Fine-grain process control...................................................................................................229
10. Assignment statements...................................................................................................................232
10.1 General.................................................................................................................................232
10.2 Overview..............................................................................................................................232
10.3 Continuous assignments......................................................................................................233
10.4 Procedural assignments........................................................................................................236
10.5 Variable declaration assignment (variable initialization)....................................................241
10.6 Procedural continuous assignments.....................................................................................241
10.7 Assignment extension and truncation..................................................................................243
10.8 Assignment-like contexts.....................................................................................................244
10.9 Assignment patterns.............................................................................................................245
10.10 Unpacked array concatenation.............................................................................................249
10.11 Net aliasing..........................................................................................................................252
11. Operators and expressions..............................................................................................................254
11.1 General.................................................................................................................................254
11.2 Overview..............................................................................................................................254
11.3 Operators..............................................................................................................................255
11.4 Operator descriptions...........................................................................................................259
11.5 Operands..............................................................................................................................279
11.6 Expression bit lengths..........................................................................................................282
11.7 Signed expressions...............................................................................................................285
11.8 Expression evaluation rules.................................................................................................286
11.9 Tagged union expressions and member access....................................................................287
11.10 String literal expressions......................................................................................................288
11.11 Minimum, typical, and maximum delay expressions..........................................................290
11.12 Let construct........................................................................................................................291
12. Procedural programming statements..............................................................................................298
12.1 General.................................................................................................................................298
12.2 Overview..............................................................................................................................298
12.3 Syntax..................................................................................................................................298
12.4 Conditional if–else statement...............................................................................................299
12.5 Case statement.....................................................................................................................304
12.6 Pattern matching conditional statements.............................................................................309
12.7 Loop statements...................................................................................................................313
12.8 Jump statements...................................................................................................................317
12
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

13. Tasks and functions (subroutines)..................................................................................................319
13.1 General.................................................................................................................................319
13.2 Overview..............................................................................................................................319
13.3 Tasks....................................................................................................................................319
13.4 Functions..............................................................................................................................323
13.5 Subroutine calls and argument passing................................................................................329
13.6 Import and export functions.................................................................................................334
13.7 Task and function names.....................................................................................................334
13.8 Parameterized tasks and functions.......................................................................................334
14. Clocking blocks..............................................................................................................................336
14.1 General.................................................................................................................................336
14.2 Overview..............................................................................................................................336
14.3 Clocking block declaration..................................................................................................336
14.4 Input and output skews........................................................................................................338
14.5 Hierarchical expressions......................................................................................................339
14.6 Signals in multiple clocking blocks.....................................................................................340
14.7 Clocking block scope and lifetime.......................................................................................340
14.8 Multiple clocking blocks example.......................................................................................340
14.9 Interfaces and clocking blocks.............................................................................................341
14.10 Clocking block events..........................................................................................................342
14.11 Cycle delay: ##....................................................................................................................342
14.12 Default clocking...................................................................................................................343
14.13 Input sampling.....................................................................................................................344
14.14 Global clocking....................................................................................................................345
14.15 Synchronous events.............................................................................................................349
14.16 Synchronous drives..............................................................................................................349
15. Interprocess synchronization and communication..........................................................................354
15.1 General.................................................................................................................................354
15.2 Overview..............................................................................................................................354
15.3 Semaphores..........................................................................................................................354
15.4 Mailboxes.............................................................................................................................356
15.5 Named events.......................................................................................................................359
16. Assertions........................................................................................................................................364
16.1 General.................................................................................................................................364
16.2 Overview..............................................................................................................................364
16.3 Immediate assertions............................................................................................................364
16.4 Deferred assertions..............................................................................................................367
16.5 Concurrent assertions overview...........................................................................................374
16.6 Boolean expressions............................................................................................................377
16.7 Sequences.............................................................................................................................378
16.8 Declaring sequences............................................................................................................382
16.9 Sequence operations............................................................................................................390
13
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

16.10 Local variables.....................................................................................................................413
16.11 Calling subroutines on match of a sequence........................................................................419
16.12 Declaring properties.............................................................................................................420
16.13 Multiclock support...............................................................................................................446
16.14 Concurrent assertions...........................................................................................................456
16.15 Disable iff resolution...........................................................................................................473
16.16 Clock resolution...................................................................................................................475
16.17 Expect statement..................................................................................................................481
16.18 Clocking blocks and concurrent assertions..........................................................................482
17. Checkers..........................................................................................................................................484
17.1 Overview..............................................................................................................................484
17.2 Checker declaration.............................................................................................................484
17.3 Checker instantiation...........................................................................................................487
17.4 Context inference.................................................................................................................490
17.5 Checker procedures..............................................................................................................491
17.6 Covergroups in checkers......................................................................................................493
17.7 Checker variables.................................................................................................................494
17.8 Functions in checkers...........................................................................................................500
17.9 Complex checker example...................................................................................................501
18. Constrained random value generation............................................................................................503
18.1 General.................................................................................................................................503
18.2 Overview..............................................................................................................................503
18.3 Concepts and usage..............................................................................................................503
18.4 Random variables................................................................................................................506
18.5 Constraint blocks.................................................................................................................509
18.6 Randomization methods......................................................................................................528
18.7 In-line constraints—randomize() with.................................................................................530
18.8 Disabling random variables with rand_mode()...................................................................532
18.9 Controlling constraints with constraint_mode()..................................................................534
18.10 Dynamic constraint modification.........................................................................................535
18.11 In-line random variable control...........................................................................................535
18.12 Randomization of scope variables—std::randomize().........................................................536
18.13 Random number system functions and methods.................................................................538
18.14 Random stability..................................................................................................................540
18.15 Manually seeding randomize...............................................................................................542
18.16 Random weighted case—randcase......................................................................................543
18.17 Random sequence generation—randsequence.....................................................................544
19. Functional coverage........................................................................................................................553
19.1 General.................................................................................................................................553
19.2 Overview..............................................................................................................................553
19.3 Defining the coverage model: covergroup...........................................................................554
19.4 Using covergroup in classes................................................................................................556
19.5 Defining coverage points.....................................................................................................558
14
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

19.6 Defining cross coverage.......................................................................................................569
19.7 Specifying coverage options................................................................................................578
19.8 Predefined coverage methods..............................................................................................582
19.9 Predefined coverage system tasks and system functions.....................................................585
19.10 Organization of option and type_option members..............................................................585
19.11 Coverage computation.........................................................................................................586
20. Utility system tasks and system functions......................................................................................591
20.1 General.................................................................................................................................591
20.2 Simulation control system tasks..........................................................................................592
20.3 Simulation time system functions........................................................................................592
20.4 Timescale system tasks........................................................................................................594
20.5 Conversion functions...........................................................................................................597
20.6 Data query functions............................................................................................................598
20.7 Array query functions..........................................................................................................600
20.8 Math functions.....................................................................................................................603
20.9 Bit vector system functions..................................................................................................604
20.10 Severity tasks.......................................................................................................................605
20.11 Elaboration system tasks......................................................................................................606
20.12 Assertion control system tasks.............................................................................................608
20.13 Sampled value system functions..........................................................................................614
20.14 Coverage system functions..................................................................................................615
20.15 Probabilistic distribution functions......................................................................................615
20.16 Stochastic analysis tasks and functions...............................................................................617
20.17 Programmable logic array modeling system tasks..............................................................619
20.18 Miscellaneous tasks and functions.......................................................................................623
21. Input/output system tasks and system functions.............................................................................624
21.1 General.................................................................................................................................624
21.2 Display system tasks............................................................................................................624
21.3 File input/output system tasks and system functions...........................................................635
21.4 Loading memory array data from a file...............................................................................645
21.5 Writing memory array data to a file.....................................................................................649
21.6 Command line input.............................................................................................................650
21.7 Value change dump (VCD) files.........................................................................................653
22. Compiler directives.........................................................................................................................674
22.1 General.................................................................................................................................674
22.2 Overview .............................................................................................................................674
22.3 `resetall.................................................................................................................................674
22.4 `include................................................................................................................................675
22.5 `define, `undef, and `undefineall .........................................................................................675
22.6 `ifdef, `else, `elsif, `endif, `ifndef........................................................................................681
22.7 `timescale.............................................................................................................................684
22.8 `default_nettype...................................................................................................................685
22.9 `unconnected_drive and `nounconnected_drive..................................................................686
15
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

22.10 `celldefine and `endcelldefine..............................................................................................686
22.11 `pragma................................................................................................................................686
22.12 `line......................................................................................................................................687
22.13 `__FILE__ and `__LINE__.................................................................................................688
22.14 `begin_keywords, `end_keywords.......................................................................................689
Part Two: Hierarchy Constructs
23. Modules and hierarchy....................................................................................................................696
23.1 General.................................................................................................................................696
23.2 Module definitions...............................................................................................................696
23.3 Module instances (hierarchy)...............................................................................................708
23.4 Nested modules....................................................................................................................719
23.5 Extern modules....................................................................................................................720
23.6 Hierarchical names..............................................................................................................721
23.7 Member selects and hierarchical names..............................................................................725
23.8 Upwards name referencing..................................................................................................727
23.9 Scope rules ..........................................................................................................................729
23.10 Overriding module parameters............................................................................................731
23.11 Binding auxiliary code to scopes or instances.....................................................................738
24. Programs.........................................................................................................................................742
24.1 General.................................................................................................................................742
24.2 Overview..............................................................................................................................742
24.3 The program construct.........................................................................................................742
24.4 Eliminating testbench races.................................................................................................746
24.5 Blocking tasks in cycle/event mode.....................................................................................746
24.6 Programwide space and anonymous programs....................................................................747
24.7 Program control tasks..........................................................................................................747
25. Interfaces.........................................................................................................................................748
25.1 General.................................................................................................................................748
25.2 Overview..............................................................................................................................748
25.3 Interface syntax....................................................................................................................749
25.4 Ports in interfaces.................................................................................................................753
25.5 Modports..............................................................................................................................754
25.6 Interfaces and specify blocks...............................................................................................760
25.7 Tasks and functions in interfaces.........................................................................................761
25.8 Parameterized interfaces......................................................................................................767
25.9 Virtual interfaces..................................................................................................................769
25.10 Access to interface objects...................................................................................................774
26. Packages..........................................................................................................................................775
26.1 General.................................................................................................................................775
26.2 Package declarations............................................................................................................775
16
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

26.3 Referencing data in packages..............................................................................................776
26.4 Using packages in module headers......................................................................................780
26.5 Search order rules................................................................................................................781
26.6 Exporting imported names from packages..........................................................................783
26.7 The std built-in package.......................................................................................................784
27. Generate constructs.........................................................................................................................786
27.1 General.................................................................................................................................786
27.2 Overview..............................................................................................................................786
27.3 Generate construct syntax....................................................................................................786
27.4 Loop generate constructs.....................................................................................................788
27.5 Conditional generate constructs...........................................................................................792
27.6 External names for unnamed generate blocks.....................................................................795
28. Gate-level and switch-level modeling............................................................................................797
28.1 General.................................................................................................................................797
28.2 Overview..............................................................................................................................797
28.3 Gate and switch declaration syntax.....................................................................................797
28.4 and, nand, nor, or, xor, and xnor gates.................................................................................803
28.5 buf and not gates..................................................................................................................804
28.6 bufif1, bufif0, notif1, and notif0 gates.................................................................................805
28.7 MOS switches......................................................................................................................806
28.8 Bidirectional pass switches..................................................................................................807
28.9 CMOS switches...................................................................................................................808
28.10 pullup and pulldown sources...............................................................................................809
28.11 Logic strength modeling......................................................................................................809
28.12 Strengths and values of combined signals...........................................................................811
28.13 Strength reduction by nonresistive devices.........................................................................823
28.14 Strength reduction by resistive devices...............................................................................823
28.15 Strengths of net types...........................................................................................................823
28.16 Gate and net delays..............................................................................................................824
29. User-defined primitives..................................................................................................................828
29.1 General.................................................................................................................................828
29.2 Overview..............................................................................................................................828
29.3 UDP definition.....................................................................................................................828
29.4 Combinational UDPs...........................................................................................................832
29.5 Level-sensitive sequential UDPs.........................................................................................833
29.6 Edge-sensitive sequential UDPs..........................................................................................833
29.7 Sequential UDP initialization..............................................................................................834
29.8 UDP instances......................................................................................................................836
29.9 Mixing level-sensitive and edge-sensitive descriptions.......................................................837
29.10 Level-sensitive dominance..................................................................................................838
17
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

30. Specify blocks.................................................................................................................................839
30.1 General.................................................................................................................................839
30.2 Overview..............................................................................................................................839
30.3 Specify block declaration.....................................................................................................839
30.4 Module path declarations.....................................................................................................840
30.5 Assigning delays to module paths.......................................................................................849
30.6 Mixing module path delays and distributed delays.............................................................853
30.7 Detailed control of pulse filtering behavior.........................................................................854
31. Timing checks.................................................................................................................................863
31.1 General.................................................................................................................................863
31.2 Overview..............................................................................................................................863
31.3 Timing checks using a stability window..............................................................................866
31.4 Timing checks for clock and control signals.......................................................................873
31.5 Edge-control specifiers........................................................................................................882
31.6 Notifiers: user-defined responses to timing violations........................................................883
31.7 Enabling timing checks with conditioned events................................................................885
31.8 Vector signals in timing checks...........................................................................................886
31.9 Negative timing checks........................................................................................................887
32. Backannotation using the standard delay format............................................................................892
32.1 General.................................................................................................................................892
32.2 Overview..............................................................................................................................892
32.3 The SDF annotator...............................................................................................................892
32.4 Mapping of SDF constructs to SystemVerilog....................................................................892
32.5 Multiple annotations............................................................................................................897
32.6 Multiple SDF files...............................................................................................................898
32.7 Pulse limit annotation..........................................................................................................898
32.8 SDF to SystemVerilog delay value mapping.......................................................................899
32.9 Loading timing data from an SDF file.................................................................................900
33. Configuring the contents of a design..............................................................................................902
33.1 General.................................................................................................................................902
33.2 Overview..............................................................................................................................902
33.3 Libraries...............................................................................................................................903
33.4 Configurations.....................................................................................................................905
33.5 Using libraries and configs..................................................................................................911
33.6 Configuration examples.......................................................................................................912
33.7 Displaying library binding information...............................................................................914
33.8 Library mapping examples..................................................................................................914
34. Protected envelopes........................................................................................................................917
34.1 General.................................................................................................................................917
34.2 Overview..............................................................................................................................917
18
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

34.3 Processing protected envelopes...........................................................................................917
34.4 Protect pragma directives.....................................................................................................919
34.5 Protect pragma keywords.....................................................................................................921
Part Three: Application Programming Interfaces
35. Direct programming interface.........................................................................................................938
35.1 General.................................................................................................................................938
35.2 Overview..............................................................................................................................938
35.3 Two layers of DPI................................................................................................................939
35.4 Global name space of imported and exported functions......................................................940
35.5 Imported tasks and functions...............................................................................................941
35.6 Calling imported functions..................................................................................................948
35.7 Exported functions...............................................................................................................950
35.8 Exported tasks......................................................................................................................951
35.9 Disabling DPI tasks and functions.......................................................................................951
36. Programming language interface (PLI/VPI) overview...................................................................953
36.1 General.................................................................................................................................953
36.2 PLI purpose and history.......................................................................................................953
36.3 User-defined system task and system function names.........................................................954
36.4 User-defined system task and system function arguments..................................................955
36.5 User-defined system task and system function types..........................................................955
36.6 User-supplied PLI applications............................................................................................955
36.7 PLI include files...................................................................................................................955
36.8 VPI sizetf, compiletf, and calltf routines.............................................................................955
36.9 PLI mechanism....................................................................................................................956
36.10 VPI access to SystemVerilog objects and simulation objects.............................................958
36.11 List of VPI routines by functional category.........................................................................959
36.12 VPI backwards compatibility features and limitations........................................................961
37. VPI object model diagrams.............................................................................................................966
37.1 General.................................................................................................................................966
37.2 VPI Handles.........................................................................................................................966
37.3 VPI object classifications.....................................................................................................967
37.4 Key to data model diagrams................................................................................................973
37.5 Module ...............................................................................................................................976
37.6 Interface ............................................................................................................................977
37.7 Modport ..............................................................................................................................977
37.8 Interface task or function declaration .................................................................................977
37.9 Program .............................................................................................................................978
37.10 Instance ...............................................................................................................................979
37.11 Instance arrays ....................................................................................................................981
37.12 Scope ...................................................................................................................................982
37.13 IO declaration .....................................................................................................................983
37.14 Ports ....................................................................................................................................984
19
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

37.15 Reference objects ................................................................................................................985
37.16 Nets......................................................................................................................................987
37.17 Variables ............................................................................................................................991
37.18 Packed array variables ........................................................................................................994
37.19 Variable select .....................................................................................................................995
37.20 Memory................................................................................................................................996
37.21 Variable drivers and loads ..................................................................................................996
37.22 Object Range........................................................................................................................997
37.23 Typespec ............................................................................................................................998
37.24 Structures and unions.........................................................................................................1000
37.25 Named events ....................................................................................................................1001
37.26 Parameter, spec param, def param, param assign ............................................................1002
37.27 Virtual interface.................................................................................................................1003
37.28 Interface typespec..............................................................................................................1005
37.29 Class definition .................................................................................................................1006
37.30 Class typespec ...................................................................................................................1007
37.31 Class variables and class objects.......................................................................................1009
37.32 Constraint, constraint ordering, distribution .....................................................................1011
37.33 Primitive, prim term...........................................................................................................1012
37.34 UDP...................................................................................................................................1013
37.35 Intermodule path................................................................................................................1013
37.36 Constraint expression ........................................................................................................1014
37.37 Module path, path term .....................................................................................................1015
37.38 Timing check.....................................................................................................................1016
37.39 Task and function declaration ...........................................................................................1017
37.40 Task and function call .......................................................................................................1018
37.41 Frames ...............................................................................................................................1020
37.42 Threads ..............................................................................................................................1021
37.43 Delay terminals..................................................................................................................1021
37.44 Net drivers and loads.........................................................................................................1022
37.45 Continuous assignment......................................................................................................1023
37.46 Clocking block ..................................................................................................................1024
37.47 Assertion ...........................................................................................................................1025
37.48 Concurrent assertions ......................................................................................................1026
37.49 Property declaration ..........................................................................................................1027
37.50 Property specification .....................................................................................................1028
37.51 Sequence declaration ........................................................................................................1029
37.52 Sequence expression .........................................................................................................1030
37.53 Immediate assertions .........................................................................................................1031
37.54 Multiclock sequence expression .....................................................................................1032
37.55 Let .....................................................................................................................................1032
37.56 Simple expressions ...........................................................................................................1033
37.57 Expressions .....................................................................................................................1034
37.58 Atomic statement ..............................................................................................................1037
37.59 Dynamic prefixing.............................................................................................................1038
37.60 Event statement .................................................................................................................1039
37.61 Process ..............................................................................................................................1039
37.62 Assignment .......................................................................................................................1040
37.63 Event control .....................................................................................................................1040
37.64 While, repeat......................................................................................................................1041
20
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

37.65 Waits .................................................................................................................................1041
37.66 Delay control......................................................................................................................1041
37.67 Repeat control....................................................................................................................1042
37.68 Forever...............................................................................................................................1042
37.69 If, if–else............................................................................................................................1042
37.70 Case, pattern ......................................................................................................................1043
37.71 Expect ...............................................................................................................................1044
37.72 For .....................................................................................................................................1044
37.73 Do-while, foreach..............................................................................................................1044
37.74 Alias statement ..................................................................................................................1045
37.75 Disables..............................................................................................................................1045
37.76 Return statement ...............................................................................................................1045
37.77 Assign statement, deassign, force, release.........................................................................1046
37.78 Callback.............................................................................................................................1046
37.79 Time queue........................................................................................................................1047
37.80 Active time format.............................................................................................................1047
37.81 Attribute ............................................................................................................................1048
37.82 Iterator................................................................................................................................1049
37.83 Generates ..........................................................................................................................1050
38. VPI routine definitions..................................................................................................................1052
38.1 General...............................................................................................................................1052
38.2 vpi_chk_error()..................................................................................................................1052
38.3 vpi_compare_objects().......................................................................................................1053
38.4 vpi_control()......................................................................................................................1055
38.5 vpi_flush()..........................................................................................................................1056
38.6 vpi_get().............................................................................................................................1056
38.7 vpi_get64().........................................................................................................................1057
38.8 vpi_get_cb_info()...............................................................................................................1057
38.9 vpi_get_data()....................................................................................................................1058
38.10 vpi_get_delays().................................................................................................................1059
38.11 vpi_get_str().......................................................................................................................1061
38.12 vpi_get_systf_info()...........................................................................................................1062
38.13 vpi_get_time()....................................................................................................................1063
38.14 vpi_get_userdata().............................................................................................................1064
38.15 vpi_get_value()..................................................................................................................1064
38.16 vpi_get_value_array() .......................................................................................................1070
38.17 vpi_get_vlog_info()...........................................................................................................1074
38.18 vpi_handle().......................................................................................................................1075
38.19 vpi_handle_by_index()......................................................................................................1076
38.20 vpi_handle_by_multi_index()............................................................................................1076
38.21 vpi_handle_by_name()......................................................................................................1077
38.22 vpi_handle_multi().............................................................................................................1078
38.23 vpi_iterate()........................................................................................................................1078
38.24 vpi_mcd_close().................................................................................................................1079
38.25 vpi_mcd_flush().................................................................................................................1080
38.26 vpi_mcd_name()................................................................................................................1080
38.27 vpi_mcd_open().................................................................................................................1081
21
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

38.28 vpi_mcd_printf()................................................................................................................1082
38.29 vpi_mcd_vprintf()..............................................................................................................1083
38.30 vpi_printf().........................................................................................................................1083
38.31 vpi_put_data()....................................................................................................................1084
38.32 vpi_put_delays()................................................................................................................1086
38.33 vpi_put_userdata().............................................................................................................1089
38.34 vpi_put_value()..................................................................................................................1089
38.35 vpi_put_value_array() ......................................................................................................1092
38.36 vpi_register_cb()................................................................................................................1096
38.37 vpi_register_systf()............................................................................................................1104
38.38 vpi_release_handle()..........................................................................................................1108
38.39 vpi_remove_cb()................................................................................................................1108
38.40 vpi_scan()...........................................................................................................................1109
38.41 vpi_vprintf().......................................................................................................................1110
39. Assertion API................................................................................................................................1111
39.1 General...............................................................................................................................1111
39.2 Overview............................................................................................................................1111
39.3 Static information..............................................................................................................1111
39.4 Dynamic information.........................................................................................................1112
39.5 Control functions...............................................................................................................1116
40. Code coverage control and API....................................................................................................1120
40.1 General...............................................................................................................................1120
40.2 Overview............................................................................................................................1120
40.3 SystemVerilog real-time coverage access.........................................................................1121
40.4 FSM recognition................................................................................................................1126
40.5 VPI coverage extensions....................................................................................................1129
41. Data read API................................................................................................................................1134
Part Four: Annexes
Annex A (normative) Formal syntax.........................................................................................................1136
Annex B (normative) Keywords................................................................................................................1182
Annex C (normative) Deprecation.............................................................................................................1184
Annex D (informative) Optional system tasks and system functions........................................................1188
Annex E (informative) Optional compiler directives................................................................................1195
Annex F (normative) Formal semantics of concurrent assertions.............................................................1197
Annex G (normative) Std package.............................................................................................................1220
22
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Annex H (normative) DPI C layer.............................................................................................................1222
Annex I (normative) svdpi.h......................................................................................................................1255
Annex J (normative) Inclusion of foreign language code..........................................................................1264
Annex K (normative) vpi_user.h...............................................................................................................1268
Annex L (normative) vpi_compatibility.h.................................................................................................1285
Annex M (normative) sv_vpi_user.h.........................................................................................................1288
Annex N (normative) Algorithm for probabilistic distribution functions.................................................1298
Annex O (informative) Encryption/decryption flow.................................................................................1306
Annex P (informative) Glossary................................................................................................................1310
Annex Q (informative) Bibliography........................................................................................................1313
23
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

List of figures
Figure4-1—Event scheduling regions..........................................................................................................64
Figure6-1—Simulation values of a trireg and its driver...............................................................................89
Figure6-2—Simulation results of a capacitive network...............................................................................90
Figure6-3—Simulation results of charge sharing.........................................................................................91
Figure7-1—VInt type with packed qualifier..............................................................................................144
Figure7-2—Instr type with packed qualifier..............................................................................................145
Figure9-1—Intra-assignment repeat event control utilizing a clock edge..................................................224
Figure14-1—Sample and drive times including skew with respect to the positive edge of the clock.......339
Figure16-1—Sampling a variable in a simulation time step......................................................................376
Figure16-2—Concatenation of sequences..................................................................................................381
Figure16-3—Value change expressions.....................................................................................................396
Figure16-4—Future value change..............................................................................................................401
Figure16-5—ANDing (and) two sequences...............................................................................................403
Figure16-6—ANDing (and) two sequences, including a time range.........................................................404
Figure16-7—ANDing (and) two Boolean expressions..............................................................................404
Figure16-8—Intersecting two sequences....................................................................................................405
Figure16-9—ORing (or) two Boolean expressions....................................................................................406
Figure16-10—ORing (or) two sequences...................................................................................................407
Figure16-11—ORing (or) two sequences, including a time range.............................................................407
Figure16-12—Match with throughout restriction fails...............................................................................410
Figure16-13—Match with throughout restriction succeeds.......................................................................410
Figure16-14—Conditional sequence matching..........................................................................................427
Figure16-15—Conditional sequences.........................................................................................................428
Figure16-16—Results without the condition..............................................................................................428
Figure16-17—Clocking blocks and concurrent assertion..........................................................................483
Figure17-1—Nondeterministic free checker variable................................................................................495
Figure18-1—Example of randc..................................................................................................................509
Figure18-2—Global constraints.................................................................................................................518
Figure18-3—Truth tables for conjunction, disjunction, and negation rules...............................................523
Figure21-1—Creating the 4-state VCD file................................................................................................653
Figure21-2—Creating the extended VCD file............................................................................................663
Figure23-1—Hierarchy in a model.............................................................................................................723
Figure23-2—Scopes available to upward name referencing......................................................................730
Figure28-1—Schematic diagram of interconnections in array of instances...............................................803
Figure28-2—Scale of strengths..................................................................................................................811
Figure28-3—Combining unequal strengths................................................................................................811
Figure28-4—Combination of signals of equal strength and opposite values.............................................812
Figure28-5—Weak x signal strength..........................................................................................................812
Figure28-6—Bufifs with control inputs of x..............................................................................................813
24
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Figure28-7—Strong H range of values.......................................................................................................813
Figure28-8—Strong L range of values.......................................................................................................813
Figure28-9—Combined signals of ambiguous strength.............................................................................814
Figure28-10—Range of strengths for an unknown signal..........................................................................814
Figure28-11—Ambiguous strengths from switch networks.......................................................................814
Figure28-12—Range of two strengths of a defined value..........................................................................815
Figure28-13—Range of three strengths of a defined value........................................................................815
Figure28-14—Unknown value with a range of strengths...........................................................................815
Figure28-15—Strong X range....................................................................................................................816
Figure28-16—Ambiguous strength from gates..........................................................................................816
Figure28-17—Ambiguous strength signal from a gate..............................................................................816
Figure28-18—Weak 0................................................................................................................................817
Figure28-19—Ambiguous strength in combined gate signals...................................................................817
Figure28-20—Elimination of strength levels.............................................................................................818
Figure28-21—Result showing a range and the elimination of strength levels of two values....................819
Figure28-22—Result showing a range and the elimination of strength levels of one value......................820
Figure28-23—A range of both values........................................................................................................820
Figure28-24—Wired logic with unambiguous strength signals.................................................................821
Figure28-25—Wired logic and ambiguous strengths.................................................................................822
Figure28-26—Trireg net with capacitance.................................................................................................827
Figure29-1—Module schematic and simulation times of initial value propagation..................................836
Figure30-1—Module path delays...............................................................................................................841
Figure30-2—Difference between parallel and full connection paths.........................................................847
Figure30-3—Module path delays longer than distributed delays...............................................................853
Figure30-4—Module path delays shorter than distributed delays..............................................................854
Figure30-5—Example of pulse filtering.....................................................................................................854
Figure30-6—On-detect versus on-event.....................................................................................................857
Figure30-7—Current event cancellation problem and correction..............................................................859
Figure30-8—NAND gate with nearly simultaneous input switching where
one event is scheduled prior to another that has not matured......................................................................860
Figure30-9—NAND gate with nearly simultaneous input switching with
output event scheduled at same time...........................................................................................................861
Figure31-1—Sample $timeskew................................................................................................................875
Figure31-2—Sample $timeskew with remain_active_flag set...................................................................876
Figure31-3—Sample $fullskew..................................................................................................................878
Figure31-4—Data constraint interval, positive setup/hold.........................................................................887
Figure31-5—Data constraint interval, negative setup/hold........................................................................888
Figure31-6—Timing check violation windows..........................................................................................891
Figure37-1—Example of object relationships diagram..............................................................................968
Figure37-2—Accessing a class of objects using tags.................................................................................969
Figure38-1—s_vpi_error_info structure definition..................................................................................1053
25
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Figure38-2—s_cb_data structure definition.............................................................................................1058
Figure38-3—s_vpi_delay structure definition..........................................................................................1059
Figure38-4—s_vpi_time structure definition...........................................................................................1059
Figure38-5—s_vpi_systf_data structure definition..................................................................................1062
Figure38-6—s_vpi_time structure definition...........................................................................................1063
Figure38-7—s_vpi_value structure definition..........................................................................................1065
Figure38-8—s_vpi_vecval structure definition........................................................................................1065
Figure38-9—s_vpi_strengthval structure definition.................................................................................1065
Figure38-10—s_vpi_vlog_info structure definition.................................................................................1074
Figure38-11—s_vpi_delay structure definition........................................................................................1087
Figure38-12—s_vpi_time structure definition.........................................................................................1087
Figure38-13—s_vpi_value structure definition........................................................................................1091
Figure38-14—s_vpi_time structure definition.........................................................................................1091
Figure38-15—s_vpi_vecval structure definition......................................................................................1092
Figure38-16—s_vpi_strengthval structure definition...............................................................................1092
Figure38-17—s_cb_data structure definition...........................................................................................1096
Figure38-18—s_vpi_systf_data structure definition................................................................................1105
Figure39-1—Assertions with global clocking future sampled value functions.......................................1116
Figure40-1—Hierarchical instance example............................................................................................1124
Figure40-2—FSM specified with pragmas...............................................................................................1129
26
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

List of tables
Table3-1—Time unit strings.........................................................................................................................55
Table6-2—Truth table for wire and tri nets .................................................................................................87
Table6-3—Truth table for wand and triand nets..........................................................................................88
Table6-4—Truth table for wor and trior nets...............................................................................................88
Table6-5—Truth table for tri0 net ...............................................................................................................92
Table6-6—Truth table for tri1 net................................................................................................................92
Table6-7—Default variable initial values...................................................................................................102
Table6-8—Integer data types......................................................................................................................104
Table6-10—Enumeration element ranges..................................................................................................116
Table6-11—Differences between specparams and parameters..................................................................125
Table9-2—Detecting posedge and negedge...............................................................................................217
Table9-3—Intra-assignment timing control equivalence...........................................................................223
Table11-2—Operator precedence and associativity...................................................................................257
Table11-3—Arithmetic operators defined .................................................................................................260
Table11-4—Power operator rules...............................................................................................................261
Table11-5—Unary operators defined ........................................................................................................261
Table11-6—Examples of modulus and power operators...........................................................................261
Table11-7—Data type interpretation by arithmetic operators....................................................................262
Table11-8—Definitions of relational operators .........................................................................................263
Table11-9—Definitions of equality operators............................................................................................264
Table11-10—Wildcard equality and wildcard inequality operators...........................................................264
Table11-11—Bitwise binary AND operator...............................................................................................266
Table11-12—Bitwise binary OR operator..................................................................................................266
Table11-13—Bitwise binary exclusive OR operator..................................................................................267
Table11-14—Bitwise binary exclusive NOR operator...............................................................................267
Table11-15—Bitwise unary negation operator...........................................................................................267
Table11-16—Reduction unary AND operator...........................................................................................268
Table11-17—Reduction unary OR operator...............................................................................................268
Table11-18—Reduction unary exclusive OR operator..............................................................................268
Table11-19—Results of unary reduction operations..................................................................................268
Table11-20—Ambiguous condition results for conditional operator ........................................................270
Table11-21—Bit lengths resulting from self-determined expressions.......................................................283
Table16-2—Global clocking future sampled value functions....................................................................401
Table16-3—Sequence and property operator precedence and associativity..............................................423
Table18-2—Ordered constraint c legal value probability..........................................................................519
Table18-3—rand_mode argument..............................................................................................................533
27
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Table18-4—constraint_mode argument.....................................................................................................534
Table19-2—Coverage options per syntactic level......................................................................................580
Table19-3—Coverage group type (static) options......................................................................................581
Table19-4—Coverage type options............................................................................................................582
Table19-5—Predefined coverage methods.................................................................................................583
Table20-2—$timeformat units_number arguments....................................................................................595
Table20-3—$timeformat default value for arguments...............................................................................596
Table20-4—SystemVerilog to C real math function cross-listing.............................................................603
Table20-5—Values for control_type for assertion control tasks................................................................609
Table20-6—Values for assertion_type for assertion control tasks.............................................................609
Table20-7—Values for directive_type for assertion control tasks.............................................................610
Table20-8—VPI callbacks for assertion control tasks...............................................................................613
Table20-9—Types of queues of $q_type values .......................................................................................617
Table20-10—Argument values for $q_exam system task..........................................................................618
Table20-11—Status code values ...............................................................................................................619
Table20-12—PLA modeling system tasks ................................................................................................620
Table21-2—Escape sequences for format specifications...........................................................................626
Table21-3—Format specifications for real numbers..................................................................................628
Table21-4—Logic value component of strength format............................................................................631
Table21-5—Mnemonics for strength levels...............................................................................................631
Table21-6—Explanation of strength formats.............................................................................................632
Table21-7—Types for file descriptors........................................................................................................636
Table21-8—$fscanf input field characters..................................................................................................641
Table21-9—Rules for left-extending vector values....................................................................................659
Table21-10—How the VCD can shorten values........................................................................................659
Table21-11—Keyword commands.............................................................................................................660
Table21-12—VCD type mapping...............................................................................................................672
Table22-2—IEEE 1364-2001 additional reserved keywords ...................................................................692
Table22-3—IEEE 1364-2005 additional reserved keywords ....................................................................692
Table22-4—IEEE 1800-2005 additional reserved keywords ....................................................................693
Table22-5—IEEE 1800-2009 additional reserved keywords ...................................................................693
Table22-6—IEEE 1800-2012 additional reserved keywords ....................................................................694
Table28-2—Valid gate types for strength specifications...........................................................................799
Table28-3—Truth tables for multiple input logic gates ............................................................................804
Table28-4—Truth tables for multiple output logic gates ..........................................................................805
Table28-5—Truth tables for three-state logic gates...................................................................................806
Table28-6—Truth tables for MOS switches ..............................................................................................807
Table28-7—Strength levels for scalar net signal values............................................................................810
28
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Table28-8—Strength reduction rules..........................................................................................................823
Table28-9—Rules for propagation delays..................................................................................................824
Table29-2—Initial statements in UDPs and modules.................................................................................834
Table29-3—Mixing of level-sensitive and edge-sensitive entries.............................................................838
Table30-2—Associating path delay expressions with transitions..............................................................850
Table30-3—Calculating delays for x transitions .......................................................................................852
Table31-2—$hold arguments ....................................................................................................................867
Table31-3—$setuphold arguments ............................................................................................................868
Table31-4—$removal arguments...............................................................................................................870
Table31-5—$recovery arguments..............................................................................................................871
Table31-6—$recrem arguments.................................................................................................................872
Table31-7—$skew arguments ...................................................................................................................874
Table31-8—$timeskew arguments.............................................................................................................875
Table31-9—$fullskew arguments...............................................................................................................877
Table31-10—$width arguments.................................................................................................................879
Table31-11—$period arguments................................................................................................................880
Table31-12—$nochange arguments...........................................................................................................881
Table31-13—Notifier value responses to timing violations ......................................................................883
Table32-2—Mapping of SDF timing check constructs to SystemVerilog.................................................894
Table32-3—SDF annotation of interconnect delays..................................................................................896
Table32-4—SDF to SystemVerilog delay value mapping.........................................................................899
Table32-5—mtm_spec argument...............................................................................................................900
Table32-6—scale_type argument...............................................................................................................901
Table34-2—Encoding algorithm identifiers...............................................................................................924
Table34-3—Encryption algorithm identifiers............................................................................................926
Table34-4—Message digest algorithm identifiers......................................................................................931
Table36-2—VPI routines for system task or system function callbacks....................................................960
Table36-3—VPI routines for traversing SystemVerilog hierarchy............................................................960
Table36-4—VPI routines for accessing properties of objects....................................................................960
Table36-5—VPI routines for accessing objects from properties................................................................960
Table36-6—VPI routines for delay processing..........................................................................................960
Table36-7—VPI routines for logic and strength value processing.............................................................960
Table36-8—VPI routines for simulation time processing..........................................................................961
Table36-9—VPI routines for miscellaneous utilities.................................................................................961
Table36-10—Summary of VPI incompatibilities across versions.............................................................962
Table38-2—Size of the s_vpi_delay->da array........................................................................................1060
Table38-3—Return value field of the s_vpi_value structure union.........................................................1066
Table38-4—Size of the s_vpi_delay->da array........................................................................................1087
29
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Table38-5—Value format field of cb_data_p->value->format................................................................1098
Table38-6—cbStmt callbacks...................................................................................................................1100
Table40-2—Instance coverage permutations...........................................................................................1123
Table40-3—Assertion coverage results....................................................................................................1131
Table B.1—Reserved keywords................................................................................................................1182
Table D.1—Argument return value for $countdriver function..................................................................1189
Table H.1—Mapping data types................................................................................................................1227
Table N.1—SystemVerilog to C function cross-listing.............................................................................1298
30
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

List of syntax excerpts
Syntax5-1—Syntax for system tasks and system functions (excerpt from AnnexA)..................................71
Syntax5-2—Syntax for integer and real numbers (excerpt from AnnexA).................................................72
Syntax5-3—Syntax for attributes (excerpt from AnnexA)..........................................................................80
Syntax6-1—Syntax for net type declarations (excerpt from AnnexA).......................................................92
Syntax6-2—Syntax for net declarations (excerpt from AnnexA)...............................................................97
Syntax6-3—Syntax for variable declarations (excerpt from AnnexA).....................................................101
Syntax6-4—User-defined types (excerpt from AnnexA)..........................................................................112
Syntax6-5—Enumerated types (excerpt from AnnexA)............................................................................114
Syntax6-6—Parameter declaration syntax (excerpt from AnnexA)..........................................................120
Syntax6-7—Casting (excerpt from AnnexA)............................................................................................132
Syntax7-1—Structure declaration syntax (excerpt from AnnexA)...........................................................139
Syntax7-2—Union declaration syntax (excerpt from AnnexA)................................................................142
Syntax7-3—Dynamic array new constructor syntax (excerpt from AnnexA)..........................................150
Syntax7-4—Declaration of queue dimension (excerpt from AnnexA).....................................................161
Syntax7-5—Array method call syntax (not in AnnexA)...........................................................................165
Syntax8-1—Class syntax (excerpt from AnnexA)....................................................................................172
Syntax8-2—Calling a constructor (excerpt from AnnexA).......................................................................176
Syntax8-3—Class syntax (excerpt from AnnexA)....................................................................................195
Syntax9-1—Syntax for structured procedures (excerpt from AnnexA)....................................................205
Syntax9-2—Syntax for sequential block (excerpt from AnnexA)............................................................210
Syntax9-3—Syntax for parallel block (excerpt from AnnexA).................................................................211
Syntax9-4—Delay and event control syntax (excerpt from AnnexA).......................................................216
Syntax9-5—Syntax for wait statement (excerpt from AnnexA)...............................................................221
Syntax9-6—Syntax for intra-assignment delay and event control (excerpt from AnnexA).....................222
Syntax9-7—Syntax for process control statements (excerpt from AnnexA)............................................225
Syntax10-1—Syntax for continuous assignment (excerpt from AnnexA)................................................233
Syntax10-2—Blocking assignment syntax (excerpt from AnnexA).........................................................237
Syntax10-3—Nonblocking assignment syntax (excerpt from AnnexA)...................................................238
Syntax10-4—Syntax for procedural continuous assignments (excerpt from AnnexA)............................241
Syntax10-5—Assignment patterns syntax (excerpt from AnnexA)..........................................................246
Syntax10-6—Syntax for net aliasing (excerpt from AnnexA)..................................................................252
Syntax11-1—Operator syntax (excerpt from AnnexA).............................................................................255
Syntax11-2—Conditional operator syntax (excerpt from AnnexA)..........................................................269
Syntax11-3—Inside expression syntax (excerpt from AnnexA)...............................................................273
Syntax11-4—Streaming concatenation syntax (excerpt from AnnexA)...................................................274
Syntax11-5—With expression syntax (excerpt from AnnexA).................................................................277
Syntax11-6—Tagged union syntax (excerpt from AnnexA).....................................................................287
Syntax11-7—Syntax for min:typ:max expression (excerpt from AnnexA)..............................................291
Syntax11-8—Let syntax (excerpt from AnnexA).....................................................................................292
31
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Syntax12-1—Procedural statement syntax (excerpt from AnnexA).........................................................299
Syntax12-2—Syntax for if–else statement (excerpt from AnnexA)..........................................................299
Syntax12-3—Syntax for case statements (excerpt from AnnexA)............................................................304
Syntax12-4—Pattern syntax (excerpt from AnnexA)...............................................................................309
Syntax12-5—Loop statement syntax (excerpt from AnnexA)..................................................................313
Syntax12-6—Jump statement syntax (excerpt from AnnexA)..................................................................317
Syntax13-1—Task syntax (excerpt from AnnexA)...................................................................................320
Syntax13-2—Function syntax (excerpt from AnnexA).............................................................................324
Syntax13-3—Task or function call syntax (excerpt from AnnexA)..........................................................330
Syntax14-1—Clocking block syntax (excerpt from AnnexA)..................................................................337
Syntax14-2—Cycle delay syntax (excerpt from AnnexA)........................................................................343
Syntax14-3—Default clocking syntax (excerpt from AnnexA)................................................................344
Syntax14-4—Global clocking syntax (excerpt from AnnexA).................................................................345
Syntax14-5—Synchronous drive syntax (excerpt from AnnexA).............................................................350
Syntax15-1—Event trigger syntax (excerpt from AnnexA)......................................................................360
Syntax15-2—Wait_order event sequencing syntax (excerpt from AnnexA)............................................361
Syntax16-1—Immediate assertion syntax (excerpt from AnnexA)...........................................................365
Syntax16-2—Deferred immediate assertion syntax (excerpt from AnnexA)............................................368
Syntax16-3—Sequence syntax (excerpt from AnnexA)............................................................................379
Syntax16-4—Sequence concatenation syntax (excerpt from AnnexA)....................................................380
Syntax16-5—Sequence declaration syntax (excerpt from AnnexA).........................................................383
Syntax16-6—Sequence repetition syntax (excerpt from AnnexA)...........................................................391
Syntax16-7—And operator syntax (excerpt from AnnexA)......................................................................402
Syntax16-8—Intersect operator syntax (excerpt from AnnexA)...............................................................404
Syntax16-9—Or operator syntax (excerpt from AnnexA)........................................................................405
Syntax16-10—First_match operator syntax (excerpt from AnnexA).......................................................408
Syntax16-11—Throughout construct syntax (excerpt from AnnexA)......................................................409
Syntax16-12—Within construct syntax (excerpt from AnnexA)..............................................................411
Syntax16-13—Assertion variable declaration syntax (excerpt from AnnexA).........................................413
Syntax16-14—Variable assignment syntax (excerpt from AnnexA)........................................................414
Syntax16-15—Subroutine call in sequence syntax (excerpt from AnnexA).............................................419
Syntax16-16—Property construct syntax (excerpt from AnnexA)...........................................................421
Syntax16-17—Implication syntax (excerpt from AnnexA)......................................................................425
Syntax16-18—Followed-by syntax (excerpt from AnnexA)....................................................................429
Syntax16-19—Property statement case syntax (excerpt from AnnexA)...................................................439
Syntax16-20—Concurrent assert construct syntax (excerpt from AnnexA).............................................457
Syntax16-21—Default clocking and default disable syntax (excerpt from AnnexA)...............................473
Syntax16-22—Expect statement syntax (excerpt from AnnexA).............................................................481
Syntax17-1—Checker declaration syntax (excerpt from AnnexA)...........................................................485
Syntax17-2—Checker instantiation syntax (excerpt from AnnexA).........................................................488
32
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Syntax18-1—Random variable declaration syntax (excerpt from AnnexA).............................................506
Syntax18-2—Constraint syntax (excerpt from AnnexA)..........................................................................510
Syntax18-3—Constraint distribution syntax (excerpt from AnnexA).......................................................512
Syntax18-4—Uniqueness constraint syntax (excerpt from AnnexA).......................................................513
Syntax18-5—Constraint implication syntax (excerpt from AnnexA).......................................................514
Syntax18-6—If–else constraint syntax (excerpt from AnnexA)...............................................................515
Syntax18-7—Foreach iterative constraint syntax (excerpt from AnnexA)...............................................516
Syntax18-8—Solve...before constraint ordering syntax (excerpt from AnnexA).....................................520
Syntax18-9—Static constraint syntax (excerpt from AnnexA).................................................................520
Syntax18-10—Inline constraint syntax (excerpt from AnnexA)...............................................................530
Syntax18-11—Scope randomize function syntax (not in AnnexA)..........................................................537
Syntax18-12—Randcase syntax (excerpt from AnnexA)..........................................................................543
Syntax18-13—Randsequence syntax (excerpt from AnnexA)..................................................................544
Syntax18-14—Random production weights syntax (excerpt from AnnexA)...........................................546
Syntax18-15—If–else conditional random production syntax (excerpt from AnnexA)...........................546
Syntax18-16—Case random production syntax (excerpt from AnnexA)..................................................547
Syntax18-17—Repeat random production syntax (excerpt from AnnexA)..............................................547
Syntax18-18—Rand join random production syntax (excerpt from AnnexA)..........................................548
Syntax18-19—Random production syntax (excerpt from AnnexA).........................................................550
Syntax19-1—Covergroup syntax (excerpt from AnnexA)........................................................................554
Syntax19-2—Coverage point syntax (excerpt from AnnexA)..................................................................559
Syntax19-3—Transition bin syntax (excerpt from AnnexA)....................................................................563
Syntax19-4—Cross coverage syntax (excerpt from AnnexA)..................................................................570
Syntax20-1—Syntax for simulation control tasks (not in AnnexA)..........................................................592
Syntax20-2—Syntax for time system functions (not in AnnexA).............................................................592
Syntax20-3—Syntax for $printtimescale (not in AnnexA).......................................................................594
Syntax20-4—Syntax for $timeformat (not in AnnexA)............................................................................595
Syntax20-5—Type name function syntax (not in AnnexA)......................................................................598
Syntax20-6—Size function syntax (not in AnnexA).................................................................................599
Syntax20-7—Range function syntax (not in AnnexA)..............................................................................600
Syntax20-8—Array querying function syntax (not in AnnexA)...............................................................601
Syntax20-9—Bit vector system function syntax (not in AnnexA)............................................................604
Syntax20-10—Severity system task syntax (not in AnnexA)...................................................................605
Syntax20-11—Elaboration system task syntax (excerpt from AnnexA)...................................................606
Syntax20-12—Assertion control syntax (not in AnnexA)........................................................................608
Syntax20-13—Sampled value system function syntax (not in AnnexA)..................................................615
Syntax20-14—Syntax for $random (not in AnnexA)................................................................................616
Syntax20-15—Syntax for probabilistic distribution functions (not in AnnexA)......................................616
Syntax20-16—Syntax for PLA modeling system task (not in AnnexA)...................................................619
Syntax20-17—$system function syntax (not in AnnexA).........................................................................623
33
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Syntax21-1—Syntax for $display and $write system tasks (not in AnnexA)...........................................625
Syntax21-2—Syntax for $strobe system tasks (not in AnnexA)...............................................................634
Syntax21-3—Syntax for $monitor system tasks (not in AnnexA)............................................................634
Syntax21-4—Syntax for $fopen and $fclose system tasks (not in AnnexA)............................................635
Syntax21-5—Syntax for file output system tasks (not in AnnexA)..........................................................637
Syntax21-6—Syntax for formatting data tasks (not in AnnexA)..............................................................638
Syntax21-7—Syntax for file read system functions (not in AnnexA).......................................................639
Syntax21-8—Syntax for file positioning system functions (not in AnnexA)...........................................643
Syntax21-9—Syntax for file flush system task (not in AnnexA)..............................................................644
Syntax21-10—Syntax for file I/O error detection system function (not in AnnexA)...............................645
Syntax21-11—Syntax for end-of-file file detection system function (not in AnnexA)............................645
Syntax21-12—Syntax for memory load system tasks (not in AnnexA)...................................................645
Syntax21-13—$writemem system task syntax (not in AnnexA)..............................................................649
Syntax21-14—Syntax for $dumpfile task (not in AnnexA)......................................................................653
Syntax21-15—Syntax for $dumpvars task (not in AnnexA).....................................................................654
Syntax21-16—Syntax for $dumpoff and $dumpon tasks (not in AnnexA)..............................................655
Syntax21-17—Syntax for $dumpall task (not in AnnexA).......................................................................655
Syntax21-18—Syntax for $dumplimit task (not in AnnexA)....................................................................656
Syntax21-19—Syntax for $dumpflush task (not in AnnexA)...................................................................656
Syntax21-20—Syntax for output 4-state VCD file (not in AnnexA)........................................................658
Syntax21-21—Syntax for $dumpports task (not in AnnexA)...................................................................663
Syntax21-22—Syntax for $dumpportsoff and $dumpportson system tasks (not in AnnexA)..................664
Syntax21-23—Syntax for $dumpportsall system task (not in AnnexA)...................................................665
Syntax21-24—Syntax for $dumpportslimit system task (not in AnnexA)................................................665
Syntax21-25—Syntax for $dumpportsflush system task (not in AnnexA)...............................................665
Syntax21-26—Syntax for $vcdclose keyword (not in AnnexA)...............................................................666
Syntax21-27—Syntax for output extended VCD file (not in AnnexA)....................................................667
Syntax21-28—Syntax for extended VCD node information (not in AnnexA).........................................668
Syntax21-29—Syntax for value change section (not in AnnexA)............................................................669
Syntax22-1—Syntax for include compiler directive (not in AnnexA)......................................................675
Syntax22-2—Syntax for text macro definition (not in AnnexA)..............................................................676
Syntax22-3—Syntax for text macro usage (not in AnnexA).....................................................................677
Syntax22-4—Syntax for undef compiler directive (not in AnnexA)........................................................681
Syntax22-5—Syntax for conditional compilation directives (not in AnnexA).........................................681
Syntax22-6—Syntax for timescale compiler directive (not in AnnexA)..................................................684
Syntax22-7—Syntax for default_nettype compiler directive (not in AnnexA).........................................686
Syntax22-8—Syntax for pragma compiler directive (not in AnnexA)......................................................687
Syntax22-9—Syntax for line compiler directive (not in AnnexA)............................................................688
Syntax22-10—Syntax for begin_keywords and end_keywords compiler directives (not in AnnexA).....689
Syntax23-1—Module declaration syntax (excerpt from AnnexA)............................................................697
34
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Syntax23-2—Non-ANSI style module header declaration syntax (excerpt from AnnexA).....................698
Syntax23-3—Non-ANSI style port declaration syntax (excerpt from AnnexA).......................................699
Syntax23-4—ANSI style list_of_port_declarations syntax (excerpt from AnnexA)................................702
Syntax23-5—Module item syntax (excerpt from AnnexA)......................................................................708
Syntax23-6—Module instance syntax (excerpt from AnnexA)................................................................709
Syntax23-7—Syntax for hierarchical path names (excerpt from AnnexA)...............................................722
Syntax23-8—Syntax for upward name referencing (not in AnnexA).......................................................727
Syntax23-9—Bind construct syntax (excerpt from AnnexA)...................................................................739
Syntax24-1—Program declaration syntax (excerpt from AnnexA)..........................................................743
Syntax25-1—Interface syntax (excerpt from AnnexA).............................................................................750
Syntax25-2—Modport clocking declaration syntax (excerpt from AnnexA)...........................................759
Syntax25-3—Virtual interface declaration syntax (excerpt from AnnexA)..............................................769
Syntax26-1—Package declaration syntax (excerpt from AnnexA)...........................................................776
Syntax26-2—Package import syntax (excerpt from AnnexA)..................................................................777
Syntax26-3—Package import in header syntax (excerpt from AnnexA)..................................................781
Syntax26-4—Package export syntax (excerpt from AnnexA)..................................................................783
Syntax26-5—Std package import syntax (not in AnnexA).......................................................................785
Syntax27-1—Syntax for generate constructs (excerpt from AnnexA)......................................................788
Syntax28-1—Syntax for gate instantiation (excerpt from AnnexA).........................................................798
Syntax29-1—Syntax for UDPs (excerpt from AnnexA)...........................................................................829
Syntax29-2—Syntax for UDP instances (excerpt from AnnexA).............................................................836
Syntax30-1—Syntax for specify block (excerpt from AnnexA)...............................................................839
Syntax30-2—Syntax for module path declaration (excerpt from AnnexA)..............................................840
Syntax30-3—Syntax for simple module path (excerpt from AnnexA).....................................................841
Syntax30-4—Syntax for edge-sensitive path declaration (excerpt from AnnexA)...................................842
Syntax30-5—Syntax for state-dependent paths (excerpt from AnnexA)..................................................843
Syntax30-6—Syntax for path delay value (excerpt from AnnexA)..........................................................850
Syntax30-7—Syntax for PATHPULSE$ pulse control (excerpt from AnnexA)......................................855
Syntax30-8—Syntax for pulse style declarations (excerpt from AnnexA)...............................................857
Syntax30-9—Syntax for showcancelled declarations (excerpt from AnnexA).........................................858
Syntax31-1—Syntax for system timing checks (excerpt from AnnexA)..................................................864
Syntax31-2—Syntax for time check conditions and timing check events (excerpt from AnnexA)..........865
Syntax31-3—Syntax for $setup (excerpt from AnnexA)..........................................................................866
Syntax31-4—Syntax for $hold (excerpt from AnnexA)...........................................................................867
Syntax31-5—Syntax for $setuphold (excerpt from AnnexA)...................................................................868
Syntax31-6—Syntax for $removal (excerpt from AnnexA).....................................................................870
Syntax31-7—Syntax for $recovery (excerpt from AnnexA).....................................................................870
Syntax31-8—Syntax for $recrem (excerpt from AnnexA).......................................................................871
Syntax31-9—Syntax for $skew (excerpt from AnnexA)..........................................................................873
Syntax31-10—Syntax for $timeskew (excerpt from AnnexA).................................................................874
35
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

Syntax31-11—Syntax for $fullskew (excerpt from AnnexA)...................................................................877
Syntax31-12—Syntax for $width (excerpt from AnnexA).......................................................................879
Syntax31-13—Syntax for $period (excerpt from AnnexA)......................................................................880
Syntax31-14—Syntax for $nochange (excerpt from AnnexA).................................................................881
Syntax31-15—Syntax for edge-control specifier (excerpt from AnnexA)................................................882
Syntax31-16—Syntax for controlled timing check events (excerpt from AnnexA).................................885
Syntax32-1—Syntax for $sdf_annotate system task (not in AnnexA)......................................................900
Syntax33-1—Syntax for cell (excerpt from AnnexA)...............................................................................903
Syntax33-2—Syntax for declaring library in library map file (excerpt from AnnexA)............................904
Syntax33-3—Syntax for include command (excerpt from AnnexA)........................................................905
Syntax33-4—Syntax for configurations (excerpt from AnnexA).............................................................906
Syntax35-1—DPI import declaration syntax (excerpt from AnnexA)......................................................945
Syntax35-2—DPI export declaration syntax (excerpt from AnnexA)......................................................950
36
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Part One:
Design and Verification Constructs
37
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
IEEE Standard for SystemVerilog—
Unified Hardware Design,
Specification, and Verification
Language
1. Overview
1.1 Scope
This standard provides the definition of the language syntax and semantics for the IEEE 1800™
SystemVerilog language, which is a unified hardware design, specification, and verification language. The
standard includes support for behavioral, register transfer level (RTL), and gate-level hardware descriptions;
testbench, coverage, assertion, object-oriented, and constrained random constructs; and also provides
application programming interfaces (APIs) to foreign programming languages.
1.2 Purpose
This standard develops the IEEE 1800 SystemVerilog language in order to meet the increasing usage of the
language in specification, design, and verification of hardware. This revision corrects errors and clarifies
aspects of the language definition in IEEE Std 1800-2012.1 This revision also provides enhanced features
that ease design, improve verification, and enhance cross-language interactions.
1.3 Content summary
This standard serves as a complete specification of the SystemVerilog language. This standard contains the
following:
— The formal syntax and semantics of all SystemVerilog constructs
— Simulation system tasks and system functions, such as text output display commands
— Compiler directives, such as text substitution macros and simulation time scaling
— The Programming Language Interface (PLI) mechanism
— The formal syntax and semantics of the SystemVerilog Verification Procedural Interface (VPI)
— An Application Programming Interface (API) for coverage access not included in VPI
1Information on references can be found in Clause2.
38
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Direct programming interface (DPI) for interoperation with the C programming language
— VPI, API, and DPI header files
— Concurrent assertion formal semantics
— The formal syntax and semantics of standard delay format (SDF) constructs
— Informative usage examples
NOTE—An earlier standard, IEEE Std 1800-2009, represented a merger of two previous standards:
IEEEStd1364™-2005 and IEEE Std 1800-2005. In these previous standards, Verilog® was the base language and
defined a completely self-contained standard. SystemVerilog defined a number of significant extensions to Verilog, but
IEEE Std 1800-2005 was not a self-contained standard; IEEE Std 1800-2005 referred to, and relied on, IEEE Std 1364-
2005. These two standards were designed to be used as one language. Merging the base Verilog language into the
SystemVerilog standard enabled users to have all information regarding syntax and semantics in a single document.2, 3
1.4 Special terms
Throughout this standard, the following terms apply:
— SystemVerilog 3.1a refers to the Accellera SystemVerilog 3.1a Language Reference Manual [B4],
aprecursor to IEEE Std 1800-2005.4
— Verilog refers to IEEE Std 1364-2005 for the Verilog hardware description language (HDL).
— Language Reference Manual (LRM) refers to the document describing a Verilog or SystemVerilog
standard.
— Tool refers to a software implementation that reads SystemVerilog source code, such as a logic
simulator.
NOTE—In IEEE Std 1800-2005, SystemVerilog referred to just the extensions to the IEEE 1364-2005 Verilog language
and did not include the Verilog base language.
1.5 Conventions used in this standard
This standard is organized into clauses, each of which focuses on a specific area of the language. There are
subclauses within each clause to discuss individual constructs and concepts. The discussion begins with an
introduction and an optional rationale for the construct or the concept, followed by syntax and semantic
descriptions, followed by examples and notes.
The terminology conventions used throughout this standard are as follows:
— The word shall is used to indicate mandatory requirements strictly to be followed in order to
conform to the standard and from which no deviation is permitted (shall equals is required to).
— The word should is used to indicate that among several possibilities one is recommended as
particularly suitable, without mentioning or excluding others; or that a certain course of action is
preferred but not necessarily required; or that (in the negative form) a certain course of action is
deprecated but not prohibited (should equals is recommended that).
— The word may is used to indicate a course of action permissible within the limits of the standard
(may equals is permitted to).
— The word can is used for statements of possibility and capability, whether material, physical, or
causal (can equals is able to).
2Notes in text, tables, and figures are given for information only and do not contain requirements needed to implement the standard.
3Verilog is a registered trademark of Cadence Design Systems, Inc.
4The numbers in brackets correspond to those of the bibliography in AnnexQ.
39
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
1.6 Syntactic description
The main text uses the following conventions:
— Italicized font when a term is being defined
— font for examples, file names, and references to constants, especially , , , and
Constant-width 0 1 x
values
z
— font for SystemVerilog keywords, when referring to the actual
Boldface constant-width
keyword
The formal syntax of SystemVerilog is described using Backus-Naur Form (BNF). The following
conventions are used:
— Lowercase words, some containing embedded underscores, denote syntactic categories. For
example:
module_declaration
— Boldface-red characters denote reserved keywords, operators, and punctuation marks as a required
part of the syntax. For example:
module => ;
— A vertical bar (|) that is not in boldface-red separates alternative items. For example:
unary_operator::=
+ | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~
— Square brackets ([]) that are not in boldface-red enclose optional items. For example:
function_declaration ::= [ lifetime ] function_body_declaration
function
— Braces ({}) that are not in boldface-red enclose a repeated item. The item may appear zero or more
times; the repetitions occur from left to right as with an equivalent left-recursive rule. Thus, the
following two rules are equivalent:
list_of_param_assignments ::= param_assignment { , param_assignment }
list_of_param_assignments ::=
param_assignment
| list_of_param_assignments , param_assignment
A qualified term in the syntax is a term such as array_identifier for which the “array” portion represents
some semantic intent and the “identifier” term indicates that the qualified term reduces to the “identifier”
term in the syntax. The syntax does not completely define the semantics of such qualified terms; for example
while an identifier that would qualify semantically as an array_identifier is created by a declaration, such
declaration forms are not explicitly described using array_identifier in the syntax.
1.7 Use of color in this standard
This standard uses a minimal amount of color to enhance readability. The coloring is not essential and does
not affect the accuracy of this standard when viewed in pure black and white. The places where color is used
are the following:
— Cross references that are hyperlinked to other portions of this standard are shown in underlined-blue
text (hyperlinking works when this standard is viewed interactively as a PDF file).
— Syntactic keywords and tokens in the formal language definitions are shown in
boldface-red
.
text
— Some figures use a minimal amount of color to enhance readability.
40
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
1.8 Contents of this standard
A synopsis of the clauses and annexes is presented as a quick reference. All clauses and several of the
annexes are normative parts of this standard. Some annexes are included for informative purposes only.
Part One: Design and Verification Constructs
Clause1 describes the contents of this standard and the conventions used in this standard.
Clause2 lists references to other standards that are required in order to implement this standard.
Clause3 introduces the major building blocks that make up a SystemVerilog design and verification
environment: modules, programs, interfaces, checkers, packages, and configurations. This clause also
discusses primitives, name spaces, the compilation space, and the concept of simulation time.
$unit
Clause4 describes the SystemVerilog simulation scheduling semantics.
Clause5 describes the lexical tokens used in SystemVerilog source text and their conventions.
Clause6 describes SystemVerilog data objects and types, including nets and variables, their declaration
syntax and usage rules, and charge strength of the values on nets. This clause also discusses strings and
string methods, enumerated types, user-defined types, constants, data scope and lifetime, and type
compatibility.
Clause7 describes SystemVerilog compound data types: structures, unions, arrays, including packed and
unpacked arrays, dynamic arrays, associative arrays, and queues. This clause also describes various array
methods.
Clause8 describes the object-oriented programming capabilities in SystemVerilog. Topics include defining
classes, interface classes, dynamically constructing objects, inheritance and subclasses, data hiding and
encapsulation, polymorphism, and parameterized classes.
Clause9 describes the SystemVerilog procedural blocks: , , , ,
initial always always_comb always_ff
, and . Sequential and parallel statement grouping, block names, statement labels, and
always_latch final
process control are also described.
Clause10 describes continuous assignments, blocking and nonblocking procedural assignments, and
procedural continuous assignments.
Clause11 describes the operators and operands that can be used in expressions.
Clause12 describes SystemVerilog procedural programming statements, such as decision statements and
looping constructs.
Clause13 describes tasks and functions, which are subroutines that can be called from more than one place
in a behavioral model.
Clause14 defines clocking blocks, input and output skews, cycle delays, and default clocking.
Clause15 describes interprocess communications using event types and event controls, and built-in
semaphore and mailbox classes.
Clause16 describes immediate and concurrent assertions, properties, sequences, sequence operations,
multiclock sequences, and clock resolution.
41
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Clause17 describes checkers. Checkers allow the encapsulation of assertions and modeling code to create a
single verification entity.
Clause18 describes generating random numbers, constraining random number generation, dynamically
changing constraints, seeding random number generators (RNGs), and randomized statement
case
execution.
Clause19 describes coverage groups, coverage points, cross coverage, coverage options, and coverage
methods.
Clause20 describes most of the built-in system tasks and system functions.
Clause21 describes additional system tasks and system functions that are specific to input/output (I/O)
operations.
Clause22 describes various compiler directives, including a directive for controlling reserved keyword
compatibility between versions of previous Verilog and SystemVerilog standards.
Part Two: Hierarchy Constructs
Clause23 describes how hierarchies are created in SystemVerilog using module instances and interface
instances, and port connection rules. This clause also discusses the top-level instances, nested
$root
modules, extern modules, identifier search rules, how parameter values can be overridden, and binding
auxiliary code to scopes or instances.
Clause24 describes the testbench program construct, the elimination of testbench race conditions, and
program control tasks.
Clause25 describes interface syntax, interface ports, modports, interface subroutines, parameterized
interfaces, virtual interfaces, and accessing objects within interfaces.
Clause26 describes user-defined packages and the std built-in package.
Clause27 describes the generate construct and how generated constructs can be used to do conditional or
multiple instantiations of procedural code or hierarchy.
Clause28 describes the gate- and switch-level primitives and logic strength modeling.
Clause29 describes how a user-defined primitive (UDP) can be defined and how these primitives are
included in SystemVerilog models.
Clause30 describes how to specify timing relationships between input and output ports of a module.
Clause31 describes how timing checks are used in specify blocks to determine whether signals obey the
timing constraints.
Clause32 describes the syntax and semantics of SDF constructs.
Clause33 describes how to configure the contents of a design.
Clause34 describes encryption and decryption of source text regions.
42
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Part Three: Application Programming Interfaces
Clause35 describes SystemVerilog’s direct programming interface (DPI), a direct interface to foreign
languages and the syntax for importing functions from a foreign language and exporting subroutines to a
foreign language.
Clause36 provides an overview of the programming language interface (PLI and VPI).
Clause37 presents the VPI data model diagrams, which document the VPI object relationships and access
methods.
Clause38 describes the VPI routines.
Clause39 describes the assertion API in SystemVerilog.
Clause40 describes the coverage API in SystemVerilog.
Part Four: Annexes
AnnexA (normative) defines the formal syntax of SystemVerilog, using BNF.
AnnexB (normative) lists the SystemVerilog keywords.
AnnexC (informative) lists constructs that have been deprecated from SystemVerilog. The annex also
discusses the possible deprecation of the statement and the procedural /
defparam assigndeassign
statements.
AnnexD (informative) describes system tasks and system functions that are frequently used, but that are not
required in this standard.
AnnexE (informative) describes compiler directives that are frequently used, but that are not required in this
standard.
AnnexF (normative) describes a formal semantics for SystemVerilog concurrent assertions.
AnnexG (normative) describes the SystemVerilog standard package, containing type definitions for
mailbox, semaphore, randomize, and process.
AnnexH (normative) defines the C language layer for the SystemVerilog DPI.
AnnexI (normative) defines the standard include file for use with SystemVerilog DPI
svdpi.h
applications.
AnnexJ (normative) describes common guidelines for the inclusion of foreign language code into a
SystemVerilog application.
AnnexK (normative) provides a listing of the contents of the file.
vpi_user.h
AnnexL (normative) provides a listing of the contents of the file, which extends
vpi_compatibility.h
the include file.
vpi_user.h
AnnexM (normative) provides a listing of the contents of the file, which extends the
sv_vpi_user.h
include file.
vpi_user.h
43
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
AnnexN (normative) provides the C source code for the SystemVerilog random distribution system
functions.
AnnexO (informative) describes various scenarios that can be used for intellectual property (IP) protection,
and it also shows how the relevant pragmas can be used to achieve the desired effect of securely protecting,
distributing, and decrypting the model.
AnnexP (informative) defines terms that are used in this standard.
AnnexQ (informative) lists reference documents that are related to this standard.
1.9 Deprecated clauses
AnnexC lists constructs that appeared in previous versions of either IEEE Std 1364 or IEEE Std 1800, but
that have been deprecated and do not appear in this standard. This annex also lists constructs that appear in
this standard, but that are under consideration for deprecation in a future version of this standard.
1.10 Examples
Small SystemVerilog code examples are shown throughout this standard. These examples are informative.
They are intended to illustrate the usage of SystemVerilog constructs in a simple context and do not define
the full syntax.
1.11 Prerequisites
Some clauses of this standard presuppose a working knowledge of the C programming language.
44
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
2. Normative references
The following referenced documents are indispensable for the application of this standard (i.e., they must be
understood and used, so each referenced document is cited in the text and its relationship to this document is
explained). For dated references, only the edition cited applies. For undated references, the latest edition of
the referenced document (including any amendments or corrigenda) applies.
Anderson, R., Biham, E., and Knudsen, L. “Serpent: A Proposal for the Advanced Encryption Standard,”
NIST AES Proposal, 1998.5
ANSI X9.52-1998, American National Standard for Financial Services—Triple Data Encryption Algorithm
Modes of Operation.6
ElGamal, T., “A Public-Key Cryptosystem and a Signature Scheme Based on Discrete Logarithms,” IEEE
Transactions on Information Theory, vol. IT-31, no. 4, pp. 469–472, July 1985.
FIPS 46-3 (October 1999), Data Encryption Standard (DES).7
FIPS 180-2 (August 2002), Secure Hash Standard (SHS).
FIPS 197 (November 2001), Advanced Encryption Standard (AES).
IEEE Std 754™, IEEE Standard for Floating-Point Arithmetic.8, 9
IEEE Std 1003.1™, IEEE Standard for Information Technology—Portable Operating System Interface
(POSIX®).
IEEE Std 1364™-1995, IEEE Standard Hardware Description Language Based on the Verilog® Hardware
Description Language.
IEEE Std 1364™-2001, IEEE Standard Verilog Hardware Description Language.
IEEE Std 1364™-2005, IEEE Standard for Verilog Hardware Description Language.
IEEE Std 1800™-2005, IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and
Verification Language.
IEEE Std 1800™-2009, IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and
Verification Language.
IEEE Std 1800™-2012, IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and
Verification Language.
IETF RFC 1319 (April 1992), The MD2 Message-Digest Algorithm.10
IETF RFC 1321 (April 1992), The MD5 Message-Digest Algorithm.
IETF RFC 2045 (November 1996), Multipurpose Internet Mail Extensions (MIME), Part One: Format of
Internet Message Bodies.
5This document is available at http://www.cl.cam.ac.uk/~rja14/Papers/serpent.tar.gz.
6ANSI publications are available from the American National Standards Institute (http://www.ansi.org/).
7FIPS publications are available from the National Technical Information Service (http://www.ntis.gov/).
8IEEE publications are available from The Institute of Electrical and Electronics Engineers (http://standards.ieee.org/).
9The IEEE standards or products referred to in this clause are trademarks of The Institute of Electrical and Electronics Engineers, Inc.
10IETF documents (i.e., RFCs) are available for download at http://www.rfc-archive.org/.
45
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
IETF RFC 2144 (May 1997), The CAST-128 Encryption Algorithm.
IETF RFC 2437 (October 1998), PKCS #1: RSA Cryptography Specifications, Version 2.0.
IETF RFC 2440 (November 1998), OpenPGP Message Format.
ISO/IEC 10118-3:2004, Information technology—Security techniques—Hash-functions—Part 3: Dedicated
hash-functions.11
Schneier, B., “Description of a New Variable-Length Key, 64-Bit Block Cipher (Blowfish),” Fast Software
Encryption, Cambridge Security Workshop Proceedings (December 1993), Springer-Verlag, 1994, pp. 191–
204.
Schneier, B., et al., The Twofish Encryption Algorithm: A 128-Bit Block Cipher, 1st ed., Wiley, 1999.
11ISO publications are available from the International Organization for Standardization (http://www.iso.org/). IEC publications are
available from the International Electrotechnical Commission (http://www.iec.ch). ISO/IEC publications are available from the
American National Standards Institute (http://www.ansi.org/)..
46
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLr igGhMt S©. D2o0w1n8lo IaEdEeEd .o An lDl reicgehmtsb erer s0e3,r2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
3. Design and verification building blocks
3.1 General
This clause describes the following:
— The purpose of modules, programs, interfaces, checkers, and primitives
— An overview of subroutines
— An overview of packages
— An overview of configurations
— An overview of design hierarchy
— Definition of compilation and elaboration
— Declaration name spaces
— Simulation time, time units, and time precision
This clause defines several important SystemVerilog terms and concepts that are used throughout this
document. The clause also provides an overview of the purpose and usage of the modeling blocks used to
represent a hardware design and its verification environment.
3.2 Design elements
A design element is a SystemVerilog module (see Clause23), program (see Clause24), interface (see
Clause25), checker (see Clause17), package (see Clause26), primitive (see Clause28) or configuration
(see Clause33). These constructs are introduced by the keywords , , ,
module program interface
, , , and , respectively.
checker package primitive config
Design elements are the primary building blocks used to model and build up a design and verification
environment. These building blocks are the containers for the declarations and procedural code that are
discussed in subsequent clauses of this document.
This clause describes the purpose of these building blocks. Full details on the syntax and semantics of these
blocks are defined in later clauses of this standard.
3.3 Modules
The basic building block in SystemVerilog is the module, enclosed between the keywords and
module
. Modules are primarily used to represent design blocks, but can also serve as containers for
endmodule
verification code and interconnections between verification blocks and design blocks. Some of the
constructs that modules can contain include the following:
— Ports, with port declarations
— Data declarations, such as nets, variables, structures, and unions
— Constant declarations
— User-defined type definitions
— Class definitions
— Imports of declarations from packages
— Subroutine definitions
— Instantiations of other modules, programs, interfaces, checkers, and primitives
— Instantiations of class objects
— Continuous assignments
47
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— Procedural blocks
— Generate blocks
— Specify blocks
Each of the constructs in the preceding list is discussed in detail in subsequent clauses of this standard.
NOTE—The preceding list is not all inclusive. Modules can contain additional constructs, which are also discussed in
subsequent clauses of this standard.
Following is a simple example of a module that represents a 2-to-1 multiplexer:
module mux2to1 (input wire a, b, sel, // combined port and type declaration
output logic y);
always_comb begin // procedural block
if (sel) y = a; // procedural statement
else y = b;
end
endmodule: mux2to1
Modules are presented in more detail in Clause23. See also 3.11 on creating design hierarchy with modules.
3.4 Programs
The program building block is enclosed between the keywords ... . This construct is
program endprogram
provided for modeling the testbench environment. The module construct works well for the description of
hardware. However, for the testbench, the emphasis is not on the hardware-level details such as wires,
structural hierarchy, and interconnects, but in modeling the complete environment in which a design is
verified.
The program block serves the following three basic purposes:
— It provides an entry point to the execution of testbenches.
— It creates a scope that encapsulates program-wide data, tasks, and functions.
— It provides a syntactic context that specifies scheduling in the Reactive region.
The program construct serves as a clear separator between design and testbench, and, more importantly, it
specifies specialized simulation execution semantics. Together with blocks (see Clause14), the
clocking
program construct provides for race-free interaction between the design and the testbench and enables
cycle-and transaction-level abstractions.
A program block can contain data declarations, class definitions, subroutine definitions, object instances,
and one or more initial or final procedures. It cannot contain always procedures, primitive instances, module
instances, interface instances, or other program instances.
The abstraction and modeling constructs of SystemVerilog simplify the creation and maintenance of
testbenches. The ability to instantiate and individually connect each program instance enables their use as
generalized models.
A sample program declaration is as follows:
program test (input clk, input [16:1] addr, inout [7:0] data);
initial begin
...
endprogram
48
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The program construct is discussed more fully in Clause24.
3.5 Interfaces
The interface construct, enclosed between the keywords ... , encapsulates the
interface endinterface
communication between design blocks, and between design and verification blocks, allowing a smooth
migration from abstract system-level design through successive refinement down to lower level register-
transfer and structural views of the design. By encapsulating the communication between blocks, the
interface construct also facilitates design reuse.
At its lowest level, an interface is a named bundle of nets or variables. The interface is instantiated in a
design and can be connected to interface ports of other instantiated modules, interfaces and programs. An
interface can be accessed through a port as a single item, and the component nets or variables referenced
where needed. A significant proportion of a design often consists of port lists and port connection lists,
which are just repetitions of names. The ability to replace a group of names by a single name can
significantly reduce the size of a description and improve its maintainability.
Additional power of the interface comes from its ability to encapsulate functionality as well as connectivity,
making an interface, at its highest level, more like a class template. An interface can have parameters,
constants, variables, functions, and tasks. The types of elements in an interface can be declared, or the types
can be passed in as parameters. The member variables and functions are referenced relative to the instance
name of the interface as instance members. Thus, modules that are connected via an interface can simply call
the subroutine members of that interface to drive the communication. With the functionality thus
encapsulated in the interface and isolated from the module, the abstraction level and/or granularity of the
communication protocol can be easily changed by replacing the interface with a different interface
containing the same members, but implemented at a different level of abstraction. The modules connected
via the interface do not need to change at all.
To provide direction information for module ports and to control the use of subroutines within particular
modules, the construct is provided. As the name indicates, the directions are those seen from the
modport
module.
In addition to subroutine methods, an interface can also contain processes (i.e., initial or always procedures)
and continuous assignments, which are useful for system-level modeling and testbench applications. This
allows the interface to include, for example, its own protocol checker, which automatically verifies that all
modules connected via the interface conform to the specified protocol. Other applications, such as functional
coverage recording and reporting, protocol checking, and assertions can also be built into the interface.
A simple example of an interface definition and usage is as follows:
interface simple_bus(input logic clk); // Define the interface
logic req, gnt;
logic [7:0] addr, data;
logic [1:0] mode;
logic start, rdy;
endinterface: simple_bus
module memMod(simple_bus a); // simple_bus interface port
logic avail;
// When memMod is instantiated in module top, a.req is the req
// signal in the sb_intf instance of the 'simple_bus' interface
always @(posedge a.clk) a.gnt <= a.req & avail;
endmodule
49
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
module cpuMod(simple_bus b); // simple_bus interface port
...
endmodule
module top;
logic clk = 0;
simple_bus sb_intf(.clk(clk)); // Instantiate the interface
memMod mem(.a(sb_intf)); // Connect interface to module instance
cpuMod cpu(.b(sb_intf)); // Connect interface to module instance
endmodule
See Clause25 for a full description of interfaces.
3.6 Checkers
The checker construct, enclosed by the keywords ... , represents a verification block
checker endchecker
encapsulating assertions along with the modeling code. The intended use of checkers is to serve as
verification library units or as building blocks for creating abstract auxiliary models used in formal
verification. The checker construct is discussed in detail in Clause17.
3.7 Primitives
The primitive building block is used to represent low-level logic gates and switches. SystemVerilog includes
a number of built-in primitive types. Designers can supplement the built-in primitives with user-defined
primitives (UDPs). A UDP is enclosed between the keywords ... . The built-in
primitive endprimitive
and UDP constructs allow modeling timing-accurate digital circuits, commonly referred to as gate-level
models. Gate-level modeling is discussed more fully in Clause28 through Clause31.
3.8 Subroutines
Subroutines provide a mechanism to encapsulate executable code that can be invoked from one or more
places. There are two forms of subroutines, tasks (13.3) and functions (13.4).
A task is called as a statement. A task can have any number of input, output, inout, and ref arguments, but
does not return a value. Tasks can block simulation time during execution. That is, the task exit can occur at
a later simulation time than when the task was called.
A function can return a value or can be defined as a void function, which does not return a value. A nonvoid
function call is used as an operand within an expression. A void function is called as a statement. A function
can have input, output, inout, and ref arguments. Functions must execute without blocking simulation time,
but can fork off processes that do block time.
3.9 Packages
Modules, interfaces, programs, and checkers provide a local name space for declarations. Identifiers
declared within a module, interface, program, or checker are local to that scope, and do not affect or conflict
with declarations in other building blocks.
50
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Packages provide a declaration space, which can be shared by other building blocks. Package declarations
can be imported into other building blocks, including other packages.
A package is defined between the keywords ... . For example:
package endpackage
package ComplexPkg;
typedef struct {
shortreal i, r;
} Complex;
function Complex add(Complex a, b);
add.r = a.r + b.r;
add.i = a.i + b.i;
endfunction
function Complex mul(Complex a, b);
mul.r = (a.r * b.r) - (a.i * b.i);
mul.i = (a.r * b.i) + (a.i * b.r);
endfunction
endpackage : ComplexPkg
The full syntax and semantics of packages are described in Clause26.
3.10 Configurations
SystemVerilog provides the ability to specify design configurations, which specify the binding information
of module instances to specific SystemVerilog source code. Configurations utilize libraries. A library is a
collection of modules, interfaces, programs, checkers, primitives, packages, and other configurations.
Separate library map files specify the source code location for the cells contained within the libraries. The
names of the library map files are typically specified as invocation options to simulators or other software
tools reading in SystemVerilog source code.
See Clause33 for details of configurations.
3.11 Overview of hierarchy
The basic building blocks of modules, programs, interfaces, checkers, and primitives are used to build up a
design hierarchy. Hierarchy is created by one building block instantiating another building block. When a
module contains an instance of another module, interface, program, or checker, a new level of hierarchy is
created. Communication through levels of hierarchy is primarily through connections to the ports of the
instantiated module, interface, program, or checker.
Following is a simple example of two module declarations that utilize some simple declarations. Module
contains an instance of module , creating a design with two levels of hierarchy.
top mux2to1
module top; // module with no ports
logic in1, in2, select; // variable declarations
wire out1; // net declaration
mux2to1 m1 (.a(in1), .b(in2), .sel(select), .y(out1)); // module instance
endmodule: top
module mux2to1 (input wire a, b, sel, // combined port and type declaration
output logic y);
51
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
// netlist using built-in primitive instances
not g1 (sel_n, sel);
and g2 (a_s, a, sel_n);
and g3 (b_s, b, sel);
or g4 (y, a_s, b_s);
endmodule: mux2to1
Modules can instantiate other modules, programs, interfaces, checkers, and primitives, creating a hierarchy
tree. Interfaces can also instantiate other building blocks and create a hierarchy tree. Programs and checkers
can instantiate other checkers. Primitives cannot instantiate other building blocks; they are leaves in a
hierarchy tree.
Normally, a module or program that is elaborated but not explicitly instantiated is implicitly instantiated
once at the top of the hierarchy tree and becomes a top-level hierarchy block (see 23.3 and 24.3).
SystemVerilog permits multiple top-level blocks.
Identifiers within any level of hierarchy can be referenced from any other level of hierarchy using
hierarchical path names (see 23.6).
Instantiation syntax and design hierarchy are presented in more detail in Clause23.
3.12 Compilation and elaboration
Compilation is the process of reading in SystemVerilog source code, decrypting encrypted code, and
analyzing the source code for syntax and semantic errors. Implementations may execute compilation in one
or more passes. Implementations may save compiled results in a proprietary intermediate format, or may
pass the compiled results directly to an elaboration phase. Not all syntax and semantics can be checked
during the compilation process. Some checking can only be done during or at the completion of elaboration.
SystemVerilog supports both single file and multiple file compilation through the use of compilation units
(see 3.12.1).
Elaboration is the process of binding together the components that make up a design. These components can
include module instances, program instances, interface instances, checker instances, primitive instances, and
the top level of the design hierarchy. Elaboration occurs after parsing the source code and before simulation;
and it involves expanding instantiations, computing parameter values, resolving hierarchical names,
establishing net connectivity and in general preparing the design for simulation. See 23.10.4 for additional
details on the elaboration process.
Although this standard defines the results of compilation and elaboration, the compilation and elaboration
steps are not required to be distinct phases in an implementation. Throughout this standard the terms
compilation, compile, and compiler normally refer to the combined compilation and elaboration process. So
for example, when the standard refers to a “compile time error,” an implementation is permitted to report the
error at any time prior to the start of simulation.
This standard does not normally specify requirements regarding the order of compilation for design
elements. The two exceptions are the rules regarding “compilation units” (see 3.12.1) where actual file
boundaries during compilation are significant, and the rules regarding references to package items (see 26.3)
where the compilation of a package is required to precede references to it.
3.12.1 Compilation units
SystemVerilog supports separate compilation using compiled units. The following terms and definitions are
provided:
52
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— compilation unit: A collection of one or more SystemVerilog source files compiled together.
— compilation-unit scope: A scope that is local to the compilation unit. It contains all declarations
that lie outside any other scope.
— $unit: The name used to explicitly access the identifiers in the compilation-unit scope.
The exact mechanism for defining which files constitute a compilation unit is tool-specific. However,
compliant tools shall provide use models that allow both of the following cases:
a) All files on a given compilation command line make a single compilation unit (in which case the
declarations within those files are accessible following normal visibility rules throughout the entire
set of files).
b) Each file is a separate compilation unit (in which case the declarations in each compilation-unit
scope are accessible only within its corresponding file).
The contents of files included using one or more directives become part of the compilation unit
`include
of the file within which they are included.
If there is a declaration that is incomplete at the end of a file, then the compilation unit including that file
will extend through each successive file until there are no incomplete declarations at the end of the group of
files.
There are other possible mappings of files to compilation units, and the mechanisms for defining them are
tool-specific and may not be portable.
Although the compilation-unit scope is not a package, it can contain any item that can be defined within a
package (see 26.2) and bind constructs as well (see 23.11). These items are in the compilation-unit scope
name space (see 3.13).
The following items are visible in all compilation units: modules, primitives, programs, interfaces, and
packages. Items defined in the compilation-unit scope cannot be accessed by name from outside the
compilation unit. The items in a compilation-unit scope can be accessed using the PLI, which must provide
an iterator to traverse all the compilation units.
Items in a compilation-unit scope can have hierarchical references to identifiers. For upwards name
referencing (see 23.8), the compilation-unit scope is treated like a top-level design unit. This means that if
these are not references to identifiers created within the compilation-unit scope or made visible by import of
a package into the compilation unit scope, they are treated as full path names starting at the top of the design
( , described in 23.3.1).
$root
Within a separately compiled unit, compiler directives once seen by a tool apply to all subsequent source
text. However, compiler directives from one separately compiled unit shall not affect other compilation
units. This may result in a difference of behavior between compiling the units separately or as a single
compilation unit containing the entire source.
When an identifier is referenced within a scope
— First, the nested scope is searched (see 23.9) (including nested module declarations), including any
identifiers made available through package import declarations.
— Next, the portion of the compilation-unit scope defined prior to the reference is searched (including
any identifiers made available through package import declarations).
— Finally, if the identifier follows hierarchical name resolution rules, the instance hierarchy is
searched (see 23.8 and 23.9).
53
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An llD reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
is the name of the scope that encompasses a compilation unit. Its purpose is to allow the
$unit
unambiguous reference to declarations at the outermost level of a compilation unit (i.e., those in the
compilation-unit scope). This is done via the same scope resolution operator used to access package items
(see 26.3).
For example:
bit b;
task t;
int b;
b = 5 + $unit::b; // $unit::b is the one outside
endtask
Other than for task and function names (see 23.8.1), references shall only be made to names already defined
in the compilation unit. The use of an explicit prefix only provides for name disambiguation and
$unit::
does not add the ability to refer to later compilation unit items.
For example:
task t;
int x;
x = 5 + b; // illegal - "b" is defined later
x = 5 + $unit::b; // illegal - $unit adds no special forward referencing
endtask
bit b;
The compilation-unit scope allows users to easily share declarations (e.g., types) across the unit of
compilation, but without having to declare a package from which the declarations are subsequently
imported. Because it has no name, the compilation-unit scope cannot be used with an import declaration,
and the identifiers declared within the scope are not accessible via hierarchical references. Within a
particular compilation unit, however, the special name can be used to explicitly access the
$unit
declarations of its compilation-unit scope.
3.13 Name spaces
SystemVerilog has eight name spaces for identifiers: two are global (definitions name space and package
name space), two are global to the compilation unit (compilation unit name space and text macro name
space), and four are local. The eight name spaces are described as follows:
a) The definitions name space unifies all the non-nested , , , and
module primitive program
identifiers defined outside all other declarations. Once a name is used to define a
interface
module, primitive, program, or interface within one compilation unit, the name shall not be used
again (in any compilation unit) to declare another non-nested module, primitive, program, or
interface outside all other declarations.
b) The package name space unifies all the identifiers defined among all compilation units.
package
Once a name is used to define a package within one compilation unit, the name shall not be used
again to declare another package within any compilation unit.
c) The compilation-unit scope name space exists outside the , , ,
module interface package
, , and constructs. It unifies the definitions of the functions, tasks,
checker program primitive
checkers, parameters, named events, net declarations, variable declarations, and user-defined types
within the compilation-unit scope.
d) The text macro name space is global within the compilation unit. Because text macro names are
introduced and used with a leading character, they remain unambiguous with any other name
‘
space. The text macro names are defined in the linear order of appearance in the set of input files that
54
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
make up the compilation unit. Subsequent definitions of the same name override the previous
definitions for the balance of the input files.
e) The module name space is introduced by the , , , , ,
module interface package program checker
and constructs. It unifies the definition of modules, interfaces, programs, checkers,
primitive
functions, tasks, named blocks, instance names, parameters, named events, net declarations, variable
declarations, and user-defined types within the enclosing construct.
f) The block name space is introduced by named or unnamed blocks, the , , and
specify function
constructs. It unifies the definitions of the named blocks, functions, tasks, parameters, named
task
events, variable type of declaration, and user-defined types within the enclosing construct.
g) The port name space is introduced by the , , , and
module interface primitive program
constructs. It provides a means of structurally defining connections between two objects that are in
two different name spaces. The connection can be unidirectional (either or ) or
input output
bidirectional ( or ). The port name space overlaps the module and the block name spaces.
inout ref
Essentially, the port name space specifies the type of connection between names in different name
spaces. The port type of declarations includes , , , and . A port name
input output inout ref
introduced in the port name space can be reintroduced in the module name space by declaring a
variable or a net with the same name as the port name.
h) The attribute name space is enclosed by the and constructs attached to a language element
(* *)
(see 5.12). An attribute name can be defined and used only in the attribute name space. Any other
type of name cannot be defined in this name space.
Within a name space, it shall be illegal to redeclare a name already declared by a prior declaration.
3.14 Simulation time units and precision
An important aspect of simulation is time. The term simulation time is used to refer to the time value
maintained by the simulator to model the actual time it would take for the system description being
simulated. The term time is used interchangeably with simulation time.
Time values are used in design elements to represent propagation delays and the amount of simulation time
between when procedural statements execute. Time values have two components, a time unit and a time
precision.
— The time unit represents the unit of measurement for times and delays, and can be specified in units
ranging from 100 second units down to 1 femtosecond units.
— The time precision specifies the degree of accuracy for delays.
Both the time units and time precision are represented using one of the character strings: , , , , ,
s ms us ns ps
and with an order of magnitude of 1, 10, or 100. The definition of these character strings is given in
fs
Table3-1.
Table3-1—Time unit strings
Character string Unit of measurement
seconds
s
milliseconds
ms
microseconds
us
nanoseconds
ns
picoseconds
ps
femtoseconds
fs
55
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
NOTE—While s, ms, ns, ps, and fs are the usual SI unit symbols for second, millisecond, nanosecond, picosecond, and
femtosecond, due to lack of the Greek letter  (mu) in coding character sets, “us” represents the SI unit symbol for
microsecond, properly s.
The time precision of a design element shall be at least as precise as the time unit; it cannot be a longer unit
of time than the time unit.
3.14.1 Time value rounding
Within a design element, such as a module, program or interface, the time precision specifies how delay
values are rounded before being used in simulation.
The time precision is relative to the time units. If the precision is the same as the time units, then delay
values are rounded off to whole numbers (integers). If the precision is one order of magnitude smaller than
the time units, then delay values are rounded off to one decimal place. For example, if the time unit specified
is and the precision is , then delay values are rounded off to one decimal place ( is
1ns 100ps 100ps
equivalent to ). Thus, a delay of would be rounded off to .
0.1ns 2.75ns 2.8ns
The time values in a design element are accurate to within the unit of time precision specified for that design
element, even if there is a smaller time precision specified elsewhere in the design.
3.14.2 Specifying time units and precision
The time unit and time precision can be specified in the following two ways:
— Using the compiler directive
`timescale
— Using the keywords and
timeunit timeprecision
3.14.2.1 The timescale compiler directive
`
The compiler directive specifies the default time unit and precision for all design elements that
`timescale
follow this directive and that do not have and constructs specified within the
timeunit timeprecision
design element. The directive remains in effect from when it is encountered in the source code
`timescale
until another compiler directive is read. The directive only affects the current
`timescale `timescale
compilation unit; it does not span multiple compilation units (see 3.12.1).
The general syntax for the directive is (see 22.7 for more details):
`timescale
`timescale time_unit / time_precision
The following example specifies a time unit of 1 ns with a precision of 10ps (2 decimal places of accuracy).
The compiler directive affects both module and . A second directive replaces the first
A B `timescale
directive, specifying a time unit of 1ps and precision of 1ps (zero decimal places of accuracy) for module
C.
`timescale 1ns / 10ps
module A (...);
...
endmodule
module B (...);
...
endmodule
`timescale 1ps/1ps
module C (...);
56
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
...
endmodule
The directive can result in file order dependency problems. If the previous three modules were
`timescale
compiled in the order of , , (as shown) then module would simulate with time units in nanoseconds. If
A B C B
the same three files were compiled in the order of , , then module would simulate with time units in
C B A
picoseconds. This could cause very different simulation results, depending on the time values specified in
module .
B
3.14.2.2 The timeunit and timeprecision keywords
The time unit and precision can be declared by the and keywords, respectively,
timeunit timeprecision
and set to a time literal (see 5.8). The time precision may also be declared using an optional second argument
to the keyword using the slash separator. For example:
timeunit
module D (...);
timeunit 100ps;
timeprecision 10fs;
...
endmodule
module E (...);
timeunit 100ps / 10fs; // timeunit with optional second argument
...
endmodule
Defining the and constructs within the design element removes the file order
timeunit timeprecision
dependency problems with compiler directives.
There shall be at most one time unit and one time precision for any module, program, package, or interface
definition or in any compilation-unit scope. This shall define a time scope. If specified, the and
timeunit
declarations shall precede any other items in the current time scope. The and
timeprecision timeunit
declarations can be repeated as later items, but must match the previous declaration within
timeprecision
the current time scope.
3.14.2.3 Precedence of timeunit, timeprecision, and timescale
`
If a is not specified within a module, program, package, or interface definition, then the time unit
timeunit
shall be determined using the following rules of precedence:
a) If the module or interface definition is nested, then the time unit shall be inherited from the
enclosing module or interface (programs and packages cannot be nested).
b) Else, if a directive has been previously specified (within the compilation unit), then
`timescale
the time unit shall be set to the units of the last directive.
`timescale
c) Else, if the compilation-unit scope specifies a time unit (outside all other declarations), then the time
unit shall be set to the time units of the compilation unit.
d) Else, the default time unit shall be used.
The time unit of the compilation-unit scope can only be set by a declaration, not a
timeunit `timescale
directive. If it is not specified, then the default time unit shall be used.
If a is not specified in the current time scope, then the time precision shall be determined
timeprecision
following the same precedence as with time units.
The default time unit and precision are implementation-specific.
57
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
It shall be an error if some design elements have a time unit and precision specified and others do not.
3.14.3 Simulation time unit
The global time precision, also called the simulation time unit, is the minimum of all the
timeprecision
statements, all the time precision arguments to declarations, and the smallest time precision
timeunit
argument of all the compiler directives in the design.
`timescale
The time unit is equal to the global time precision. Unlike other time units, which represent physical
step
units, a cannot be used to set or modify either the precision or the time unit.
step
58
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
4. Scheduling semantics
4.1 General
This clause describes the following:
— Event-based simulation scheduling semantics
— SystemVerilog’s stratified event scheduling algorithm
— Determinism and nondeterminism of event ordering
— Possible sources of race conditions
— PLI callback control points
4.2 Execution of a hardware model and its verification environment
The balance of the clauses of this standard describe the behavior of each of the elements of the language.
This clause gives an overview of the interactions between these elements, especially with respect to the
scheduling and execution of events.
The elements that make up the SystemVerilog language can be used to describe the behavior, at varying
levels of abstraction, of electronic hardware. SystemVerilog is a parallel programming language. The
execution of certain language constructs is defined by parallel execution of blocks or processes. It is
important to understand what execution order is guaranteed to the user and what execution order is
indeterminate.
Although SystemVerilog is used for more than simulation, the semantics of the language is defined for
simulation, and everything else is abstracted from this base definition.
4.3 Event simulation
The SystemVerilog language is defined in terms of a discrete event execution model. The discrete event
simulation is described in more detail in this clause to provide a context to describe the meaning and valid
interpretation of SystemVerilog constructs. These resulting definitions provide the standard SystemVerilog
reference algorithm for simulation, which all compliant simulators shall implement. Within the following
event execution model definitions, there is a great deal of choice, and differences in some details of
execution are to be expected between different simulators. In addition, SystemVerilog simulators are free to
use different algorithms from those described in this clause, provided the user-visible effect is consistent
with the reference algorithm.
A SystemVerilog description consists of connected threads of execution or processes. Processes are objects
that can be evaluated, that can have state, and that can respond to changes on their inputs to produce outputs.
Processes are concurrently scheduled elements, such as procedures. Examples of processes
initial
include, but are not limited to, primitives; , , , , and
initial always always_comb always_latch
procedures; continuous assignments; asynchronous tasks; and procedural assignment
always_ff
statements.
Every change in state of a net or variable in the system description being simulated is considered an update
event.
Processes are sensitive to update events. When an update event is executed, all the processes that are
sensitive to that event are considered for evaluation in an arbitrary order. The evaluation of a process is also
an event, known as an evaluation event.
59
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Evaluation events also include PLI callbacks, which are points in the execution model where PLI application
routines can be called from the simulation kernel.
In addition to events, another key aspect of a simulator is time. The term simulation time is used to refer to
the time value maintained by the simulator to model the actual time it would take for the system description
being simulated. The term time is used interchangeably with simulation time in this clause.
To fully support clear and predictable interactions, a single time slot is divided into multiple regions where
events can be scheduled that provide for an ordering of particular types of execution. This allows properties
and checkers to sample data when the design under test is in a stable state. Property expressions can be
safely evaluated, and testbenches can react to both properties and checkers with zero delay, all in a
predictable manner. This same mechanism also allows for nonzero delays in the design, clock propagation,
and/or stimulus and response code to be mixed freely and consistently with cycle-accurate descriptions.
4.4 Stratified event scheduler
A compliant SystemVerilog simulator shall maintain some form of data structure that allows events to be
dynamically scheduled, executed, and removed as the simulator advances through time. The data structure is
normally implemented as a time-ordered set of linked lists, which are divided and subdivided in a well-
defined manner.
The first division is by time. Every event has one and only one simulation execution time, which at any
given point during simulation can be the current time or some future time. All scheduled events at a specific
time define a time slot. Simulation proceeds by executing and removing all events in the current simulation
time slot before moving on to the next nonempty time slot, in time order. This procedure guarantees that the
simulator never goes backwards in time.
A time slot is divided into a set of ordered regions, as follows:
a) Preponed
b) Pre-Active
c) Active
d) Inactive
e) Pre-NBA
f) NBA
g) Post-NBA
h) Pre-Observed
i) Observed
j) Post-Observed
k) Reactive
l) Re-Inactive
m) Pre-Re-NBA
n) Re-NBA
o) Post-Re-NBA
p) Pre-Postponed
q) Postponed
The purpose of dividing a time slot into these ordered regions is to provide predictable interactions between
the design and testbench code.
60
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
NOTE—These regions essentially encompass the IEEE 1364-2005 reference model for simulation, with exactly the
same level of determinism. In other words, legacy Verilog code should continue to run correctly without modification
within the SystemVerilog mechanism.
3.4.1 Active region sets and reactive region sets
There are two important groupings of event regions that are used to help define the scheduling of
SystemVerilog activity, the active region set and the reactive region set. Events scheduled in the Active,
Inactive, Pre-NBA,NBA, and Post-NBA regions are active region set events. Events scheduled in the
Reactive, Re-Inactive, Pre- Re-NBA, Re-NBA, and Post-Re-NBA regions are reactive region set events.
The Active, Inactive, Pre-NBA,NBA, Post-NBA, Pre-Observed,Observed, Post-Observed, Reactive, Re-
Inactive, Pre-Re-NBA, Re-NBA, Post-Re-NBA, and Pre-Postponed regions are known as the iterative
regions.
In addition to the active region set and reactive region set, all of the event regions of each time slot can be
categorized as simulation regions (see 3.4.2) or PLI regions (see 3.4.3).
3.4.2 Simulation regions
The simulation regions of a time slot are the Preponed, Active, Inactive, NBA, Observed, Reactive, Re-
Inactive, Re-NBA and Postponed regions. The flow of execution of the event regions is specified in
Figure4-1.
4.4.2.1 Preponed events region
The sampling delay provides the ability to sample data immediately before entering the current time
#1step
slot. sampling is identical to taking the data samples in the Preponed region of the current time slot.
#1step
Sampling in the Preponed region is equivalent to sampling in the previous Postponed region.
Preponed region PLI events are also scheduled in this region (see 4.4.3.1).
4.4.2.2 Active events region
The Active region holds the current active region set events being evaluated and can be processed in any
order.
4.4.2.3 Inactive events region
The Inactive region holds the events to be evaluated after all the Active events are processed.
If events are being executed in the active region set, an explicit delay control requires the process to be
#0
suspended and an event to be scheduled into the Inactive region of the current time slot so that the process
can be resumed in the next Inactive to Active iteration.
4.4.2.4 NBA events region
The NBA (nonblocking assignment update) region holds the events to be evaluated after all the Inactive
events are processed.
If events are being executed in the active region set, a nonblocking assignment creates an event in the NBA
region scheduled for the current or a later simulation time.
61
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
4.4.2.5 Observed events region
The Observed region is for evaluation of property expressions when they are triggered. During property
evaluation, pass/fail code shall be scheduled in the Reactive region of the current time slot. PLI callbacks are
not allowed in the Observed region.
4.4.2.6 Reactive events region
The Reactive region holds the current reactive region set events being evaluated and can be processed in any
order.
The code specified by blocking assignments in checkers, program blocks and the code in action blocks of
concurrent assertions are scheduled in the Reactive region. The Reactive region is the reactive region set
dual of the Active region (see 4.4.2.2).
4.4.2.7 Re-Inactive events region
The Re-Inactive region holds the events to be evaluated after all the Reactive events are processed.
If events are being executed in the reactive region set, an explicit #0 delay control requires the process to be
suspended and an event to be scheduled into the Re-Inactive region of the current time slot so that the
process can be resumed in the next Re-Inactive to Reactive iteration. The Re-Inactive region is the reactive
region set dual of the Inactive region (see 4.4.2.3).
4.4.2.8 Re-NBA events region
The Re-NBA region holds the events to be evaluated after all the Re-Inactive events are processed.
If events are being executed in the reactive region set, a nonblocking assignment creates an event in the Re-
NBA update region scheduled for the current or a later simulation time. The Re-NBA region is the reactive
region set dual of the NBA region (see 4.4.2.4).
4.4.2.9 Postponed events region
, , and other similar events are scheduled in the Postponed region.
$monitor $strobe
No new value changes are allowed to happen in the current time slot once the Postponed region is reached.
Within this region, it is illegal to write values to any net or variable or to schedule an event in any previous
region within the current time slot.
Postponed region PLI events are also scheduled in this region (see 4.4.3.10).
3.4.3 PLI regions
In addition to the simulation regions, where PLI callbacks can be scheduled, there are additional PLI-
specific regions. The PLI regions of a time slot are the Preponed, Pre-Active, Pre-NBA, Post-NBA,
Pre-Observed, Post-Observed, Pre-Re-NBA, Post-Re-NBA and Pre-Postponed regions. The flow of
execution of the PLI regions is specified in Figure4-1.
4.4.3.1 Preponed PLI region
The Preponed region provides for a PLI callback control point that allows PLI application routines to access
data at the current time slot before any net or variable has changed state. Within this region, it is illegal to
write values to any net or variable or to schedule an event in any other region within the current time slot.
62
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,v20e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
NOTE—The PLI currently does not schedule callbacks in the Preponed region.
4.4.3.2 Pre-Active PLI region
The Pre-Active region provides for a PLI callback control point that allows PLI application routines to read
and write values and create events before events in the Active region are evaluated (see 4.5).
4.4.3.3 Pre-NBA PLI region
The Pre-NBA region provides for a PLI callback control point that allows PLI application routines to read
and write values and create events before the events in the NBA region are evaluated (see 4.5).
4.4.3.4 Post-NBA PLI region
The Post-NBA region provides for a PLI callback control point that allows PLI application routines to read
and write values and create events after the events in the NBA region are evaluated (see 4.5).
4.4.3.5 Pre-Observed PLI region
The Pre-Observed region provides for a PLI callback control point that allows PLI application routines to
read values after the active region set has stabilized. Within this region, it is illegal to write values to any net
or variable or to schedule an event within the current time slot.
4.4.3.6 Post-Observed PLI region
The Post-Observed region provides for a PLI callback control point that allows PLI application routines to
read values after properties are evaluated (in the Observed or an earlier region).
NOTE—The PLI currently does not schedule callbacks in the Post-Observed region.
4.4.3.7 Pre-Re-NBA PLI region
The Pre-Re-NBA region provides for a PLI callback control point that allows PLI application routines to
read and write values and create events before the events in the Re-NBA region are evaluated (see 4.5).
4.4.3.8 Post-Re-NBA PLI region
The Post-Re-NBA region provides for a PLI callback control point that allows PLI application routines to
read and write values and create events after the events in the Re- NBA region are evaluated (see 4.5).
4.4.3.9 Pre-Postponed PLI region
The Pre-Postponed region provides a PLI callback control point that allows PLI application routines to read
and write values and create events after processing all other regions except the Postponed region.
4.4.3.10 Postponed PLI region
The Postponed region provides a PLI callback control point that allows PLI application routines to create
read-only events after processing all other regions. PLI and other similar events are
cbReadOnlySynch
scheduled in the Postponed region.
The SystemVerilog flow of time slots and event regions is shown in Figure4-1.
63
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
time slot
from previous
time slot
Preponed
Pre-Active
Active
Inactive
Legend:
region
Pre-NBA
PLI region NBA
Post-NBA
Pre-Observed
Observed
Post-Observed
Reactive
Re-Inactive
Pre-Re-NBA
Re-NBA
Post-Re-NBA
Pre-Postponed to next
time slot
Postponed
Figure4-1—Event scheduling regions
64
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
4.5 SystemVerilog simulation reference algorithm
execute_simulation {
T = 0;
initialize the values of all nets and variables;
schedule all initialization events into time zero slot;
while (some time slot is nonempty) {
move to the first nonempty time slot and set T;
execute_time_slot (T);
}
}
execute_time_slot {
execute_region (Preponed);
execute_region (Pre-Active);
while (any region in [Active ... Pre-Postponed] is nonempty) {
while (any region in [Active ... Post-Observed] is nonempty) {
execute_region (Active);
R = first nonempty region in [Active ... Post-Observed];
if (R is nonempty)
move events in R to the Active region;
}
while (any region in [Reactive ... Post-Re-NBA] is nonempty) {
execute_region (Reactive);
R = first nonempty region in [Reactive ... Post-Re-NBA];
if (R is nonempty)
move events in R to the Reactive region;
}
if (all regions in [Active ... Post-Re-NBA] are empty)
execute_region (Pre-Postponed);
}
execute_region (Postponed);
}
execute_region {
while (region is nonempty) {
E = any event from region;
remove E from the region;
if (E is an update event) {
update the modified object;
schedule evaluation event for any process sensitive to the object;
} else { /* E is an evaluation event */
evaluate the process associated with the event and possibly
schedule further events for execution;
}
}
}
The Iterative regions and their order are Active, Inactive, Pre-NBA,NBA, Post-NBA, Pre-Observed,
Observed, Post-Observed, Reactive, Re-Inactive, Pre-Re-NBA, Re-NBA, Post-Re-NBA, and Pre-
Postponed. As shown in the algorithm, once the Reactive, Re-Inactive, Pre-Re-NBA, Re-NBA, or Post-Re-
NBA regions are processed, iteration over the other regions does not resume until these five regions are
empty.
4.6 Determinism
This standard guarantees a certain scheduling order:
65
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
a) Statements within a begin-end block shall be executed in the order in which they appear in that
begin-end block. Execution of statements in a particular begin-end block can be suspended in favor
of other processes in the model; however, in no case shall the statements in a begin-end block be
executed in any order other than that in which they appear in the source.
b) NBAs shall be performed in the order the statements were executed (see 10.4.2).
Consider the following example:
module test;
logic a;
initial begin
a <= 0;
a <= 1;
end
endmodule
When this block is executed, there will be two events added to the NBA region. The previous rule requires
that they be entered in the event region in execution order, which, in a sequential begin-end block, is source
order. This rule requires that they be taken from the NBA region and performed in execution order as well.
Hence, at the end of simulation time , the variable will be assigned 0 and then 1.
0 a
4.7 Nondeterminism
One source of nondeterminism is the fact that active events can be taken off the Active or Reactive event
region and processed in any order. Another source of nondeterminism is that statements without time-
control constructs in procedural blocks do not have to be executed as one event. Time control statements are
the # expression and @ expression constructs (see 9.4). At any time while evaluating a procedural statement,
the simulator may suspend execution and place the partially completed event as a pending event in the event
region. The effect of this is to allow the interleaving of process execution, although the order of interleaved
execution is nondeterministic and not under control of the user.
4.8 Race conditions
Because the execution of expression evaluation and net update events may be intermingled, race conditions
are possible: For example:
assign p = q;
initial begin
q = 1;
#1 q = 0;
$display(p);
end
The simulator is correct in displaying either a 1 or a 0. The assignment of 0 to enables an update event for
q
. The simulator may either continue and execute the task or execute the update for , followed
p $display p
by the task.
$display
4.9 Scheduling implication of assignments
Assignments are translated into processes and events as detailed in 4.9.1 through 4.9.7.
66
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
4.9.1 Continuous assignment
A continuous assignment statement (see 10.3) corresponds to a process, sensitive to the source elements in
the expression. When the value of the expression changes, it causes an active update event to be added to the
event region, using current values to determine the target. A continuous assignment process is also evaluated
at time zero in order to propagate constant values. This includes implicit continuous assignments inferred
from port connections (see 3.9.6).
4.9.2 Procedural continuous assignment
A procedural continuous assignment (which is the or statement; see 10.6) corresponds to a
assign force
process that is sensitive to the source elements in the expression. When the value of the expression changes,
it causes an active update event to be added to the event region, using current values to determine the target.
A or a statement deactivates any corresponding or statement(s).
deassign release assign force
4.9.3 Blocking assignment
A blocking assignment statement (see 10.4.1) with an intra-assignment delay computes the right-hand side
value using the current values, then causes the executing process to be suspended and scheduled as a future
event. If the delay is 0, the process is scheduled as an Inactive event for the current time. If a blocking
assignment with zero delay is executed from a Reactive region, the process is scheduled as a Re-Inactive
event.
When the process is returned (or if it returns immediately if no delay is specified), the process performs the
assignment to the left-hand side and enables any events based upon the update of the left-hand side. The
values at the time the process resumes are used to determine the target(s). Execution may then continue with
the next sequential statement or with other Active or Reactive events.
4.9.4 Nonblocking assignment
A nonblocking assignment statement (see 10.4.2) always computes the updated value and schedules the
update as an NBA update event, either in the current time step if the delay is zero or as a future event if the
delay is nonzero. The values in effect when the update is placed in the event region are used to compute both
the right-hand value and the left-hand target.
4.9.5 Switch (transistor) processing
The event-driven simulation algorithm described in 4.5 depends on unidirectional signal flow and can
process each event independently. The inputs are read, the result is computed, and the update is scheduled.
SystemVerilog provides switch-level modeling in addition to behavioral and gate-level modeling. Switches
provide bidirectional signal flow and require coordinated processing of nodes connected by switches.
The source elements that model switches are various forms of transistors, called , , ,
tran tranif0 tranif1
, , and .
rtran rtranif0 rtranif1
Switch processing shall consider all the devices in a bidirectional switch-connected net before it can
determine the appropriate value for any node on the net because the inputs and outputs interact. A simulator
can do this using a relaxation technique. The simulator can process tran at any time. It can process a subset
of tran-connected events at a particular time, intermingled with the execution of other active events.
Further refinement is required when some transistors have gate value . A conceptually simple technique is
x
to solve the network repeatedly with these transistors set to all possible combinations of fully conducting
67
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
and nonconducting transistors. Any node that has a unique logic level in all cases has steady-state response
equal to this level. All other nodes have steady-state response .
x
3.9.6 Port connections
Ports connect processes through implicit continuous assignment statements or implicit bidirectional
connections. Bidirectional connections are analogous to an always-enabled connection between the
tran
two nets, but without any strength reduction.
Ports can always be represented as declared objects connected, as follows:
— If an input port, then a continuous assignment from an outside expression to a local (input) net or
variable
— If an output port, then a continuous assignment from a local output expression to an outside net or
variable
— If an inout port, then a non-strength-reducing transistor connecting the local net to an outside net
Primitive terminals, including UDP terminals, are different from module ports. Primitive output and inout
terminals shall be connected directly to 1-bit nets or 1-bit structural net expressions (see 23.3.3), with no
intervening process that could alter the strength. Changes from primitive evaluations are scheduled as active
update events in the connected nets. Input terminals connected to 1-bit nets or 1-bit structural net
expressions are also connected directly, with no intervening process that could affect the strength. Input
terminals connected to other kinds of expressions are represented as implicit continuous assignments from
the expression to an implicit net that is connected to the input terminal.
4.9.7 Subroutines
Subroutine argument passing is by value, and it copies in on invocation and copies out on return. The copy-
out-on-the-return function behaves in the same manner as does any blocking assignment.
4.10 PLI callback control points
There are two kinds of PLI callbacks: those that are executed immediately when some specific activity
occurs, and those that are explicitly registered as a one-shot evaluation event.
Table4-1 provides the mapping from the various PLI callbacks.
Table4-1—PLI callbacks
Callback Event region
cbAfterDelay Pre-Active
cbNextSimTime Pre-Active
cbReadWriteSynch Pre-NBA or Post-NBA
cbAtStartOfSimTime Pre-Active
cbNBASynch Pre-NBA
cbAtEndOfSimTime Pre-Postponed
cbReadOnlySynch Postponed
68
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
5. Lexical conventions
5.1 General
This clause describes the following:
— Lexical tokens (white space, comments, operators)
— Integer, real, string, array, structure, and time literals
— Built-in method calls
— Attributes
5.2 Lexical tokens
SystemVerilog source text files shall be a stream of lexical tokens. A lexical token shall consist of one or
more characters. The layout of tokens in a source file shall be free format; that is, spaces and newline
characters shall not be syntactically significant other than being token separators, except for escaped
identifiers (see 5.6.1).
The types of lexical tokens in the language are as follows:
— White space
— Comment
— Operator
— Number
— String literal
— Identifier
— Keyword
5.3 White space
White space shall contain the characters for spaces, tabs, newlines, and formfeeds. These characters shall be
ignored except when they serve to separate other lexical tokens. However, blanks and tabs shall be
considered significant characters in string literals (see 5.9).
5.4 Comments
SystemVerilog has two forms to introduce comments. A one-line comment shall start with the two
characters and end with a newline character. A block comment shall start with and end with . Block
// /* */
comments shall not be nested. The one-line comment token shall not have any special meaning in a block
//
comment.
5.5 Operators
Operators are single-, double-, or triple-character sequences and are used in expressions. Clause11
discusses the use of operators in expressions.
Unary operators shall appear to the left of their operand. Binary operators shall appear between their
operands. A conditional operator shall have two operator characters that separate three operands.
69
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
5.6 Identifiers, keywords, and system names
An identifier is used to give an object a unique name so it can be referenced. An identifier is either a simple
identifier or an escaped identifier (see 5.6.1). A simple identifier shall be any sequence of letters, digits,
dollar signs ( ), and underscore characters ( ).
$ _
The first character of a simple identifier shall not be a digit or ; it can be a letter or an underscore.
$
Identifiers shall be case sensitive.
For example:
shiftreg_a
busa_index
error_condition
merge_ab
_bus3
n$657
Implementations may set a limit on the maximum length of identifiers, but the limit shall be at least
1024characters. If an identifier exceeds the implementation-specific length limit, an error shall be reported.
5.6.1 Escaped identifiers
Escaped identifiers shall start with the backslash character ( ) and end with white space (space, tab,
\
newline). They provide a means of including any of the printable ASCII characters in an identifier (the
decimal values 33 through 126, or 21 through 7E in hexadecimal).
Neither the leading backslash character nor the terminating white space is considered to be part of the
identifier. Therefore, an escaped identifier is treated the same as a nonescaped identifier .
\cpu3 cpu3
For example:
\busa+index
\-clock
\***error-condition***
\net1/\net2
\{a,b}
\a*(b+c)
5.6.2 Keywords
Keywords are predefined nonescaped identifiers that are used to define the language constructs. A
SystemVerilog keyword preceded by an escape character is not interpreted as a keyword.
All keywords are defined in lowercase only. AnnexB gives a list of all defined keywords. Subclause 22.14
discusses compatibility of reserved keywords with previous versions of IEEE Std 1364 and IEEE Std 1800.
5.6.3 System tasks and system functions
The dollar sign ( ) introduces a language construct that enables development of user-defined system tasks
$
and system functions. System constructs are not design semantics, but refer to simulator functionality. A
name following the is interpreted as a system task or a system function.
$
The syntax for system tasks and system functions is given in Syntax5-1.
70
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
system_tf_call ::= // from A.8.2
system_tf_identifier [ list_of_arguments ]
( )
| system_tf_identifier data_type [ expression ]
( , )
| system_tf_identifier expression { [ expression ] } [ [ clocking_event ] ]
( , , )
system_tf_identifier50 ::= [ - - - ]{ [ - - - ] } // from A.9.3
$ a zA Z0 9_$ a zA Z0 9_$
50) The $ character in a system_tf_identifier shall not be followed by white_space. A system_tf_identifier shall not be
escaped.
Syntax5-1—Syntax for system tasks and system functions (excerpt from AnnexA)
SystemVerilog defines a standard set of system tasks and system functions in this document (see Clause20
and Clause21). Additional user-defined system tasks and system functions can be defined using the PLI, as
described in Clause36. Software implementations can also specify additional system tasks and system
functions, which may be tool-specific (see AnnexD for some common additional system tasks and system
functions). Additional system tasks and system functions are not part of this standard.
For example:
$display ("display a message");
$finish;
5.6.4 Compiler directives
The character (the ASCII value 0x60, called grave accent) introduces a language construct used to
`
implement compiler directives. The compiler behavior dictated by a compiler directive shall take effect as
soon as the compiler reads the directive. The directive shall remain in effect for the rest of the compilation
unless a different compiler directive specifies otherwise. A compiler directive in one description file can,
therefore, control compilation behavior in multiple description files. The effects of a compiler directive are
limited to a compilation unit (see 3.12.1) and shall not affect other compilation units.
For example:
`define wordsize
SystemVerilog defines a standard set of compiler directives in this document (see Clause22). Software
implementations can also specify additional compiler directives, which may be tool-specific (see AnnexE
for some common additional compiler directives). Additional compiler directives are not part of this
standard.
5.7 Numbers
Constant numbers can be specified as integer constants (see 5.7.1) or real constants (see 5.7.2). The formal
syntax for numbers is listed in Syntax5-2.
primary_literal ::= number | time_literal | unbased_unsized_literal | string_literal // from A.8.4
time_literal44 ::=
unsigned_number time_unit
| fixed_point_number time_unit
71
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
time_unit ::= | | | | |
s ms us ns ps fs
number ::= // from A.8.7
integral_number
| real_number
integral_number ::=
decimal_number
| octal_number
| binary_number
| hex_number
decimal_number ::=
unsigned_number
| [ size ] decimal_base unsigned_number
| [ size ] decimal_base x_digit { }
_
| [ size ] decimal_base z_digit { }
_
binary_number ::= [ size ] binary_base binary_value
octal_number ::= [ size ] octal_base octal_value
hex_number ::= [ size ] hex_base hex_value
sign ::= |
+ -
size ::= non_zero_unsigned_number
non_zero_unsigned_number33 ::= non_zero_decimal_digit { | decimal_digit}
_
real_number33 ::=
fixed_point_number
| unsigned_number [ unsigned_number ] exp [ sign ] unsigned_number
.
fixed_point_number33 ::= unsigned_number unsigned_number
.
exp ::= |
e E
unsigned_number33 ::= decimal_digit { | decimal_digit }
_
binary_value33 ::= binary_digit { | binary_digit }
_
octal_value33 ::= octal_digit { | octal_digit }
_
hex_value33 ::= hex_digit { | hex_digit }
_
decimal_base33 ::= [ | ] | [ | ]
' sS d ' sS D
binary_base33 ::= [ | ] | [ | ]
' sS b ' sS B
octal_base33 ::= [ | ] | [ | ]
' sS o ' sS O
hex_base33 ::= [ | ] | [ | ]
' sS h ' sS H
non_zero_decimal_digit ::= | | | | | | | |
1 2 3 4 5 6 7 8 9
decimal_digit ::= | | | | | | | | |
0 1 2 3 4 5 6 7 8 9
binary_digit ::= x_digit | z_digit | |
0 1
octal_digit ::= x_digit | z_digit | | | | | | | |
0 1 2 3 4 5 6 7
hex_digit ::= x_digit | z_digit | | | | | | | | | | | | | | | | | | | | | |
0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F
x_digit ::= |
x X
z_digit ::= | |
z Z ?
unbased_unsized_literal ::= | | z_or_x 48
'0 '1 '
string_literal ::= { Any_ASCII_Characters } // from A.8.8
" "
33) Embedded spaces are illegal.
44) The unsigned number or fixed-point number in time_literal shall not be followed by a white_space.
48) The apostrophe ( ) in unbased_unsized_literal shall not be followed by white_space.
'
Syntax5-2—Syntax for integer and real numbers (excerpt from AnnexA)
72
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
5.7.1 Integer literal constants
Integer literal constants can be specified in decimal, hexadecimal, octal, or binary format.
There are two forms to express integer literal constants. The first form is a simple decimal number, which
shall be specified as a sequence of digits through , optionally starting with a plus or minus unary
0 9
operator. The second form specifies a based literal constant, which shall be composed of up to three
tokens—an optional size constant, an apostrophe character ( , ASCII 0x27) followed by a base format
'
character, and the digits representing the value of the number. It shall be legal to macro-substitute these three
tokens.
The first token, a size constant, shall specify the size of the integer literal constant in terms of its exact
number of bits. It shall be specified as a nonzero unsigned decimal number. For example, the size
specification for two hexadecimal digits is eight because one hexadecimal digit requires 4 bits.
The second token, a , shall consist of a case insensitive letter specifying the base for the
base_format
number, optionally preceded by the single character (or ) to indicate a signed quantity, preceded by the
s S
apostrophe character. Legal base specifications are , , , , , , , or for the bases decimal,
d D h H o O b B
hexadecimal, octal, and binary, respectively.
The apostrophe character and the base format character shall not be separated by any white space.
The third token, an unsigned number, shall consist of digits that are legal for the specified base format. The
unsigned number token shall immediately follow the base format, optionally preceded by white space. The
hexadecimal digits to shall be case insensitive.
a f
Simple decimal numbers without the size and the base format shall be treated as signed integers, whereas the
numbers specified with the base format shall be treated as signed integers if the designator is included or
s
as unsigned integers if the base format only is used. The designator does not affect the bit pattern
s
specified, only its interpretation.
A plus or minus operator preceding the size constant is a unary plus or minus operator. A plus or minus
operator between the base format and the number is an illegal syntax.
Negative numbers shall be represented in two’s-complement form.
An represents the unknown value in hexadecimal, octal, and binary literal constants. A represents the
x z
high-impedance value. See 6.3 for a discussion of the SystemVerilog value set. An shall set 4 bits to
x
unknown in the hexadecimal base, 3 bits in the octal base, and 1 bit in the binary base. Similarly, a shall set
z
4 bits, 3bits, and 1 bit, respectively, to the high-impedance value.
If the size of the unsigned number is smaller than the size specified for the literal constant, the unsigned
number shall be padded to the left with zeros. If the leftmost bit in the unsigned number is an or a , then
x z
an or a shall be used to pad to the left, respectively. If the size of the unsigned number is larger than the
x z
size specified for the literal constant, the unsigned number shall be truncated from the left.
The number of bits that make up an unsized number (which is a simple decimal number or a number with a
base specifier but no size specification) shall be at least 32. Unsized unsigned literal constants where the
high-order bit is unknown ( or ) or three-state ( or ) shall be extended to the size of the expression
X x Z z
containing the literal constant.
NOTE—In IEEE Std 1364-1995, in unsized literal constants where the high-order bit is unknown or three-state, the or
x
was only extended to 32 bits.
z
73
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.