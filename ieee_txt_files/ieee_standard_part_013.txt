IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
H.6.1 Types of formal arguments
The WYSIWYG principle verifies the types of formal arguments of imported functions: an actual argument
is required to be of the type specified for the formal argument, with the exception of open arrays (for which
unspecified ranges are statically unknown). Formal arguments, other than open arrays, are fully defined by
imported declaration; they shall have ranges of packed or unpacked arrays exactly as specified in the
imported declaration. Only the SystemVerilog declaration site of the imported function is relevant for such
formal arguments.
Formal arguments defined as open arrays in the C layer are passed by handle (see H.12). Their unpacked
dimensions match those of the corresponding actual argument, while their packed dimension is a linearized,
normalized version of all the actual argument’s packed dimensions. The unsized ranges of open arrays are
determined at a call site; the rest of the type information is specified at the import declaration. See also
H.7.1.
Therefore, if a formal argument is declared as , then the import declaration specifies that
bit [15:8] b []
the formal argument is an unpacked array of packed bit array with bounds to , while the actual argument
15 8
used at a particular call site defines the bounds for the unpacked part for that call.
H.6.2 Input arguments
Formal arguments specified in SystemVerilog as shall not be modified by the foreign language code.
input
See also 35.5.1.2.
H.6.3 Output arguments
The initial values of formal arguments specified in SystemVerilog as are undetermined and
output
implementation dependent. See also 35.5.1.2.
H.6.4 Value changes for output and inout arguments
The SystemVerilog simulator is responsible for handling value changes for and arguments.
output inout
Such changes shall be detected and handled after the control returns from C code to SystemVerilog code.
H.6.5 Context and noncontext tasks and functions
Also refer to 35.5.3.
Some DPI imported subroutines or other interface functions called from them require that the context of
their call be known. It takes special instrumentation of their call instances to provide such context; for
example, a variable referring to the “current instance” might need to be set. To avoid any unnecessary
overhead, imported tasks and function calls in SystemVerilog code are not instrumented unless the imported
tasks or function is specified as context in its SystemVerilog import declaration.
The SystemVerilog context of DPI export subroutines must be known when they are called by
SystemVerilog subroutines, or they are called by DPI imports. When an import invokes the
svSetScope
utility prior to calling the export, it sets the context explicitly. Otherwise, the context will be the context of
the instantiated scope where the import declaration is located. Because imports with diverse instantiated
scopes can export the same subroutine, multiple instances of such an export can exist after elaboration. Prior
to any invocations of , these export instances would have different contexts, which would
svSetScope
reflect their imported caller’s instantiated scope.
1225
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
For the sake of simulation performance, a noncontext imported subroutine call shall not block
SystemVerilog compiler optimizations. An imported subroutine not specified as context shall not access any
data objects from SystemVerilog other than its actual arguments. Only the actual arguments can be affected
(read or written) by its call. Therefore, a call of noncontext imported subroutine is not a barrier for
optimizations. A context imported subroutine, however, can access (read or write) any SystemVerilog data
objects by calling VPI or by calling an embedded export subroutine. Therefore, a call to a context subroutine
is a barrier for SystemVerilog compiler optimizations.
Only the calls of context imported tasks and functions are properly instrumented and cause conservative
optimizations; therefore, only those tasks and functions can safely call all functions from other APIs,
including VPI functions or exported SystemVerilog functions. For imported subroutines not specified as
context, the effects of calling VPI or SystemVerilog functions can be unpredictable; and such calls can crash
if the callee requires a context that has not been properly set.
Special DPI utility functions exist that allow imported subroutines to retrieve and operate on their context.
For example, the C implementation of an imported subroutine can use to retrieve an
svGetScope()
corresponding to the instance scope of its corresponding SystemVerilog import declaration. See
svScope
H.9 for more details.
H.6.6 Memory management
See also 35.5.1.4.
The memory spaces owned and allocated by C code and SystemVerilog code are disjoined. Each side is
responsible for its own allocated memory. Specifically, C code shall not free the memory allocated by
SystemVerilog code (or the SystemVerilog compiler) nor expect SystemVerilog code to free the memory
allocated by C code (or the C compiler). This does not exclude scenarios in which C code allocates a block
of memory and then passes a handle (i.e., a pointer) to that block to SystemVerilog code, which in turn calls
a C function that directly (if it is the standard function ) or indirectly frees that block.
free
NOTE—In this last scenario, a block of memory is allocated and freed in C code, even when the standard functions
and are called directly from SystemVerilog code.
malloc free
H.7 Data types
This subclause defines the data types of the C layer of the DPI.
H.7.1 Limitations
Packed arrays can have an arbitrary number of dimensions although they are eventually always equivalent to
a one-dimensional packed array and treated as such. If the packed part of an array in the type of a formal
argument in SystemVerilog is specified as multidimensional, the SystemVerilog compiler linearizes it.
Although the original ranges are generally preserved for open arrays, if the actual argument has a
multidimensional packed part of the array, it shall be linearized and normalized into an equivalent
one-dimensional packed array. (See H.7.5).
NOTE—The actual argument can have both packed and unpacked parts of an array; either can be multidimensional.
1226
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
H.7.2 Duality of types: SystemVerilog types versus C types
A value that crosses the DPI is specified in SystemVerilog code as a value of SystemVerilog type, while the
same value shall be specified in C code as a value of C type. Therefore, each data type that is passed through
the DPI requires two matching type definitions: the SystemVerilog definition and C definition.
The user needs to provide such matching definitions. Specifically, for each SystemVerilog type used in the
import declarations or export declarations in SystemVerilog code, the user shall provide the equivalent type
definition in C reflecting the argument passing mode for the particular type of SystemVerilog value and the
direction ( , , or ) of the formal SystemVerilog argument.
input output inout
H.7.3 Data representation
DPI imposes the following additional restrictions on the representation of SystemVerilog data types:
— SystemVerilog types that are not packed and that do not contain packed elements have C-compatible
representation.
— Basic integer and real data types are represented as defined in H.7.4.
— Packed types, including , and appropriate user-defined types, are represented using
time integer
the canonical format defined in H.7.7.
— Enumeration types are represented by C base types that correspond to the enumeration types’
SystemVerilog base types (see TableH.1). and base types are represented as 4-state
integer time
packed arrays. The base type determines whether an enumeration type is considered a small value
(see 35.5.5). DPI supports all the SystemVerilog enumeration base types (see 6.19 and A.2.2.1).
Enumerated names are not available on the C side of the interface.
— Unpacked arrays embedded in a structure have C-compatible layout regardless of the type of
elements. Similarly, stand-alone arrays passed as actuals to a sized formal argument have
C-compatible representation.
— For a stand-alone array passed as an actual to an open array formal
• If the element type is a 2- or 4-state scalar or packed type, then the representation is in canonical
form.
• Otherwise, the representation is C compatible. Therefore, an element of an array shall have the
same representation as an individual value of the same type. Hence, an array’s elements can be
accessed from C code via normal C array indexing similarly to doing so for individual values.
— The natural order of elements for each dimension in the layout of an unpacked array shall be used,
i.e., elements with lower indices go first. For SystemVerilog range , the element with
[L:R]
SystemVerilog index has the C index and the element with SystemVerilog index
min(L,R) 0
has the C index .
max(L,R) abs(L-R)
H.7.4 Basic types
TableH.1 defines the mapping between the basic SystemVerilog data types and the corresponding C types.
Table H.1—Mapping data types
SystemVerilog type C type
byte char
shortint short int
int int
1227
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Table H.1—Mapping data types (continued)
SystemVerilog type C type
longint long long
real double
shortreal float
chandle void *
string const char *
a
bit unsignedchar
a
logic /reg unsignedchar
aEncodings for and are given in file .
bit logic svdpi.h reg
parameters can use the same encodings as parameters.
logic
The DPI also supports the SystemVerilog and C unsigned integer data types that correspond to the mappings
TableH.1 shows for their signed equivalents.
The mode arguments of type and are not equivalent to
input byteunsigned shortintunsigned
or , respectively, because the former are passed as C types and
bit[7:0] bit[15:0] unsignedchar
and the latter are both passed by reference as types. A similar lack of
unsignedshort svBitVecVal
equivalence applies to passing such parameters by reference for and modes, e.g.,
output inout
is passed as C type while is passed by reference as
byte unsigned unsigned char* bit[7:0]
.
svBitVecVal*
In addition to declaring DPI formal arguments of packed and arrays, it is also possible to declare
bit logic
formal arguments of packed and types. DPI handles these types as if they were declared with
struct union
equivalent one-dimensional packed array syntax. See 6.22.2. The tag value for both 2- and 4-state packed
unions is a 2-state value, stored in the MSBs of the canonical form for 2-state packed arrays
svBitVecVal
and in the most significant field bits of the canonical form for 4-state packed arrays.
aval svLogicVecVal
See 7.3.2 for tag values and size, H.7.7 and H.10.1.2 for canonical forms.
Refer to H.7.8 for details on unpacked aggregate types that are composed of the basic types described in this
subclause.
The SystemVerilog rand and randc qualifiers can appear in DPI struct and union formal argument
declarations and can be associated with SystemVerilog actual arguments to DPI imports. In both cases these
qualifiers do not affect processing on the C side and the arguments associated with them are subjected to
DPI type coercion principles (see H.6).
The handling of string types varies depending on the argument passing mode. Refer to H.8.10 for further
details.
H.7.5 Normalized and linearized ranges
Packed arrays are treated as one-dimensional; the unpacked part of an array can have an arbitrary number of
dimensions. Normalized ranges mean indexing for the packed part and indexing for a
[n-1:0] [0:n-1]
dimension of the unpacked part of an array. Normalized ranges are used for accessing all array arguments,
except for the unpacked dimensions of open arrays. The canonical representation of packed arrays also uses
normalized ranges.
1228
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Linearizing a SystemVerilog array with multiple packed dimensions consists of treating an array with
dimension sizes ( ) as if it had a single dimension with size ( ) and had been stored as a
i, j, k i * j * k
one-dimensional array. The one-dimensional array has the same layout as the corresponding
multidimensional array stored in row-major order. User C code can take the original dimensions into
account when referencing a linearized array element. For example, the bit in a SystemVerilog packed 2-state
array with dimension sizes ( ) and a SystemVerilog reference (where the
i, j, k myArray[l][m][n]
ranges for , , and have been normalized) maps to linearized C array
l m n
.
bit (n + (m * k) + (l * j * k))
H.7.6 Mapping between SystemVerilog ranges and C ranges
The range of a sized dimension in an open array formal argument is specified by the import or export
declaration. Each unsized, unpacked dimension has the same range as the corresponding dimension of the
actual argument. An open array formal argument’s unsized, packed dimension has the linearized,
normalized range of all the actual’s packed dimensions (see H.7.5). Utility functions provide the original
ranges of open array unpacked dimensions and the normalized range of the packed dimension (see H.12.2).
For all types of formal argument other than open arrays, the SystemVerilog ranges are defined in the
corresponding SystemVerilog import or export declaration. Normalized ranges are used for accessing such
arguments in C code. C ranges for multiple packed dimensions are linearized and normalized. The mapping
between SystemVerilog ranges and C ranges is defined as follows:
a) If a packed part of an array has more than one dimension, it is linearized as specified by the
equivalence of packed types (see H.7.5 and 6.22.2).
b) A packed array of range is normalized as ; its MSB has a normalized index
[L:R] [abs(L-R):0]
and its LSB has a normalized index .
abs(L-R) 0
c) The natural order of elements for each dimension in the layout of an unpacked array shall be used,
i.e., elements with lower indices go first. For SystemVerilog range , the element with
[L:R]
SystemVerilog index has the C index and the element with SystemVerilog index
min(L,R) 0
has the C index .
max(L,R) abs(L-R)
The above range mapping from SystemVerilog to C applies to calls made in both directions, i.e.,
SystemVerilog calls to C and C calls to SystemVerilog.
For example, if is used in SystemVerilog, it needs to be
logic[2:3][1:3][2:0]b[1:10][31:0]
defined in C as if it were declared in SystemVerilog in the following normalized form:
logic[17:0]b
.
[0:9][0:31]
H.7.7 Canonical representation of packed arrays
The DPI defines the canonical representation of packed 2-state (type ) and 4-state arrays (type
svBitVecVal
). is fully equivalent to type , which is used to represent
svLogicVecVal svLogicVecVal s_vpi_vecval
4-state logic in VPI.
A packed array is represented as an array of one or more elements (of type for 2-state values
svBitVecVal
and for 4-state values), each element representing a group of 32 bits. The first element of
svLogicVecVal
an array contains the 32 LSBs, next element contains the 32 more significant bits, and so on. The last
element can contain a number of unused bits. The contents of these unused bits are undetermined, and the
user is responsible for the masking or the sign extension (depending on the sign) for the unused bits.
1229
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
H.7.8 Unpacked aggregate arguments
Imported and exported DPI tasks and functions can make use of unpacked aggregate types as formal or
actual arguments. Aggregate types include unpacked arrays and structures. Such types can be composed of
packed elements, unpacked elements, or combinations of either kind of element, including subaggregates.
Refer to TableH.1 for a list of legal basic types that can be used as nonaggregate elements in aggregate
types. Also refer to 35.5.6.
In the case of an unpacked type that consists purely of unpacked elements (including subaggregates), the
layout presented to the C programmer is guaranteed to be compatible with the C compiler’s layout on the
given operating system. It is also possible for unpacked aggregate types to include packed elements.
H.8 Argument passing modes
This subclause defines the ways to pass arguments in the C layer of the DPI.
H.8.1 Overview
Imported and exported function arguments are generally passed by some form of a reference, with the
exception of small values of SystemVerilog input arguments (see H.8.7), which are passed by value.
Similarly, the function result, which is restricted to small values, is passed by value, i.e., directly returned.
Formal arguments, except open arrays, are passed by direct reference or value and, therefore, are directly
accessible in C code. Formal arguments declared in SystemVerilog as open arrays are passed by a handle
(type ) and are accessible via library functions.
svOpenArrayHandle
H.8.2 Calling SystemVerilog tasks and functions from C
There is no difference in argument passing between calls from SystemVerilog to C and calls from C to
SystemVerilog. Tasks and functions exported from SystemVerilog cannot have open arrays as arguments.
Apart from this restriction, the same types of formal arguments can be declared in SystemVerilog for
exported tasks and functions and imported tasks and functions. A subroutine exported from SystemVerilog
shall have the same function header in C as would an imported function with the same function result type
and same formal argument list. In the case of arguments passed by reference, an actual argument to
SystemVerilog subroutine called from C shall be allocated using the same layout of data as SystemVerilog
uses for that type of argument; the caller is responsible for the allocation. It can be done while preserving the
binary compatibility (see H.12.5 and H.13).
Calling a SystemVerilog task from C is the same as calling a SystemVerilog function from C with the
exception that the return type of an exported task is an value that has a special meaning related to
int
statements. See 35.9 for details on disable processing by DPI imported tasks and functions.
disable
H.8.3 Argument passing by value
Only small values of formal input arguments (see H.8.7) are passed by value. Function results are also
directly passed by value. The user needs to provide the C type equivalent to the SystemVerilog type of a
formal argument if an argument is passed by value.
1230
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
H.8.4 Argument passing by reference
For arguments passed by reference, a reference (a pointer) to the actual data object is passed. In the case of
packed data, a reference to a canonical data object is passed. The actual argument is usually allocated by a
caller. The caller can also pass a reference to an object already allocated somewhere else, for example, its
own formal argument passed by reference.
If an argument of type is passed by reference, the formal argument shall be of type . Packed arrays are
T T*
passed using a pointer to the appropriate canonical type definition, either or
svLogicVecVal*
.
svBitVecVal*
There shall be no assumptions made in DPI C applications about the lifetime of pass-by-reference
arguments. If it is required to store a pass-by-reference argument's value across multiple DPI calls, then the
value must be copied into memory owned and managed by the C application.
H.8.5 Allocating actual arguments for SystemVerilog-specific types
This is relevant only for calling exported SystemVerilog subroutines from C code. The caller is responsible
for allocating any actual arguments that are passed by reference.
Static allocation requires knowledge of the relevant data type. If such a type involves SystemVerilog packed
arrays, corresponding C arrays of canonical data types (either or ) must be
svLogicVecVal svBitVecVal
allocated and initialized before being passed by reference to the exported SystemVerilog subroutine.
H.8.6 Argument passing by handle—open arrays
Arguments specified as open (unsized) arrays are always passed by a handle, regardless of the direction of
the SystemVerilog formal argument, and are accessible via library functions. The actual implementation of a
handle is tool-specific and transparent to the user. A handle is represented by the generic pointer
void
( ed to ). Arguments passed by handle shall always have a qualifier
* typedef svOpenArrayHandle const
because the user shall not modify the contents of a handle.
H.8.7 Input arguments
arguments of imported functions implemented in C shall always have a qualifier.
input const
arguments, with the exception of open arrays, are passed by value or by reference, depending on the
input
size. Small values of formal input arguments are passed by value. The following data types are considered
small:
— , , , , ,
byte shortint int longint real shortreal
— Scalar and
bit logic
— ,
chandle string
arguments of other types are passed by reference.
input
H.8.8 Inout and output arguments
and arguments, with the exception of open arrays, are always passed by reference.
inout output
Specifically, packed arrays are passed, accordingly, as or . The same
svBitVecVal* svLogicVecVal*
rules about unused bits apply as in H.7.7.
1231
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
H.8.9 Function result
Types of a function result are restricted to the following SystemVerilog data types (see TableH.1 for the
corresponding C type):
— , , , , , , ,
byte shortint int longint real shortreal chandle string
— Scalar values of type and
bit logic
Encodings for and are given in file . Refer to H.10.1.1.
bit logic svdpi.h
H.8.10 String arguments
The layout of SystemVerilog string objects is implementation dependent. However, when a string value is
passed from SystemVerilog to C, implementations shall lay out all characters in memory per C string
conventions, including a trailing null character present at the end of the C string. Similarly, users shall make
sure that any C strings passed to SystemVerilog are properly null-terminated.
The direction mode for string arguments applies to the pointer to the string (i.e., the variable
const char*
in TableH.1), not to the characters that compose the string.
Thus, the direction modes have the following meanings for imported tasks and functions:
— An mode string is accessed through a pointer value that is provided by SystemVerilog and
input
that shall not be freed by the DPI C application. There shall be no assumptions made in the C
application about the lifetime of this string storage. No user changes to this pointer value are
propagated back to the SystemVerilog sphere.
— An mode string does not arrive at the C interface with a meaningful value. It is represented
output
by a variable. Upon return to SystemVerilog, the DPI application shall have written
constchar**
a valid and initialized address into the variable. SystemVerilog shall
constchar* constchar**
not free memory accessed through this address.
— An mode string arrives at the C interface with a valid string address value stored in a
inout const
variable. The string’s storage shall not be freed by the DPI C application. There shall be no
char**
assumptions made in the C application about the lifetime of the string storage. Any changes to the
string shall be effected by the C application providing a new pointer value, which points to new
string contents and which SystemVerilog shall not attempt to free. The C application provides a new
string pointer value by writing the string’s address into the variable. If the pointer
const char**
value is modified by the C application, SystemVerilog copies the indicated string contents into its
memory space and undertakes any actions sensitive to this change.
The direction modes have the following meanings for exported tasks and functions:
— An mode string is passed to SystemVerilog through a pointer. SystemVerilog
input constchar*
only reads from the string. It shall not modify the characters that compose the string.
— An mode string is represented by a variable. No meaningful initial value is
output constchar**
stored in the pointer variable. SystemVerilog shall write a valid string address into the output
const
variable. The user shall not make any assumptions about the lifetime of the output string’s
char**
storage, and the C code shall not free the string memory. If it is desired to refer to the string’s value
at some point in the future, the user shall copy the string value to memory owned by the C domain.
— An mode string is represented by a variable that contains a pointer to
inout const char**
memory allocated and initialized by the user. SystemVerilog only reads from the user’s string
storage, and it will not attempt to modify or free this storage. If SystemVerilog needs to effect a
change in the value of the inout mode string, then a valid SystemVerilog string address is written
into the variable. The user shall not make any assumptions about the lifetime of this
constchar**
string storage, nor should the SystemVerilog storage be freed by C code. If it is desired to refer to
the modified string value at some point in the future, the user shall copy the string value to memory
owned by the C domain.
1232
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
H.8.10.1 String types in aggregate arguments
When strings are contained in aggregate arguments, those string members shall also be represented by
variables. All the same stipulations apply to string members of aggregate arguments as apply
const char*
to stand-alone string arguments.
NOTE—With arrays of string arguments, there is no need for the extra level of indirection that occurs with stand-alone
string output and inout arguments. By the rules specified in H.7.8, all arrays of string arguments are represented in C as
, regardless of their directionality.
const char**
H.9 Context tasks and functions
Some DPI imported tasks and functions require that the context of their call be known. For example, those
calls can be associated with instances of C models that have a one-to-one correspondence with instances of
SystemVerilog modules that are making the calls. Alternatively, a DPI imported subroutine might need to
access or modify simulator data structures using VPI calls or by making a call back into SystemVerilog via
an export subroutine. Context knowledge is required for such calls to function properly. It can take special
instrumentation of their call to provide such context.
To avoid any unnecessary overhead, imported subroutine calls in SystemVerilog code are not instrumented
unless the imported subroutine is specified as context in its SystemVerilog import declaration. A DPI-C
context call chain is a sequence of C subroutine invocations that starts with a SystemVerilog entity calling a
DPI-C import declared with the keyword and continues in C, unbroken by a call back into
context
SystemVerilog. A small set of DPI utility functions is available to assist programmers when working with
context subroutines (see H.9.3). The behavior of DPI utility functions that manipulate context is undefined
when they are invoked by any subroutine that is not part of a DPI context call chain (see 35.5.3). Similarly,
the behavior of exported subroutines is undefined when they are invoked by a DPI call chain that lacks the
context characteristic.
H.9.1 Overview of DPI and VPI context
Both DPI subroutines and VPI functions might need to understand their context. However, the meaning of
the term is different for the two categories of subroutines.
DPI imported tasks and functions are essentially proxies for native SystemVerilog tasks and functions.
Native SystemVerilog tasks and functions always operate in the scope of their declaration site. For example,
a native SystemVerilog function can be declared in a module , which is instantiated as . The
f() m top.i1_m
instance of can be called via hierarchical reference from code in a distant design region.
top.i1_m f()
Function is said to execute in the context (i.e., instantiated scope) of because it has
f() top.i1_m
unqualified visibility only for variables local to that specific instance of . Function does not have
m f()
unqualified visibility for any variables in the calling code’s scope.
DPI imported tasks and functions follow the same model as native SystemVerilog tasks and functions. They
execute in the context of their surrounding declarative scope, rather than the context of their call sites. This
type of context is termed DPI context.
This is in contrast to VPI functions. Such functions execute in a context associated with their call sites. The
VPI programming model relies on C code’s ability to retrieve a context handle associated with the
associated system task’s call site and then to work with the context handle to glean information about
arguments, items in the call site’s surrounding declarative scope, etc. This type of context is termed VPI
context.
1233
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
The SystemVerilog context of DPI export tasks and functions must be known when they are called,
including when they are called by imports. When an import invokes the utility prior to calling
svSetScope
the export, it sets the context explicitly. Otherwise, the context will be the context of the instantiated scope
where the import declaration is located. Because imports with diverse instantiated scopes can export the
same subroutine, multiple instances of such an export can exist after elaboration. Prior to any invocations of
, these export instances would have different contexts, which would reflect their imported
svSetScope
caller’s instantiated scope.
H.9.2 Context of imported and exported tasks and functions
DPI imported and exported tasks and functions can be declared in a , , ,
module program interface
, compilation unit scope, or declarative scope.
package generate
A context imported subroutine executes in the context of the instantiated scope surrounding its declaration.
In other words, such tasks and functions can see other variables in that scope without qualification. As
explained in H.9.1, this should not be confused with the context of the task’s or function’s call site, which
can actually be anywhere in the SystemVerilog design hierarchy. The context of an imported or exported
subroutine corresponds to the fully qualified name of the subroutine, minus the subroutine name itself.
The context property is transitive through imported and exported context tasks and functions declared in the
same scope. In other words, if an imported subroutine is running in a certain context and if it in turn calls an
exported subroutine that is available in the same context, the exported subroutine can be called without any
use of . For example, consider a SystemVerilog call to a native function , which in turn
svSetScope() f()
calls a native function . Now replace the native function with an equivalent imported context C
g() f()
function, . The system shall behave identically regardless if or is in the call chain above .
f'() f() f'() g()
has the proper execution context in both cases.
g()
When control passes across the boundary between SystemVerilog and a DPI import call chain with the
context property, the value of the import’s context is potentially either set or reset (see 35.5.3). Therefore,
user code behavior is undefined for DPI import C code that circumvents SystemVerilog exports unwinding
across the boundary to their import caller (e.g., by using C and constructs).
setjmp longjmp
H.9.3 Working with DPI context tasks and functions in C code
DPI defines a small set of functions to help programmers work with DPI context tasks and functions. The
term scope is used in the subroutine names for consistency with other SystemVerilog terminology. The
terms scope and context are equivalent for DPI tasks and functions. A DPI context imported subroutine is
declared with the keyword. A DPI-C context call chain is a sequence of calls to C subroutines that
context
begins with a SystemVerilog entity calling a DPI context import and continues in C, unbroken by a call back
into SystemVerilog.
There are functions that allow the user to retrieve and manipulate the current operational scope. The
behavior of these functions is undefined if they are invoked by an entity other than a member of a DPI
context call chain. The behavior of exported subroutines is undefined when they are invoked by a member of
a DPI call chain that lacks the context characteristic.
There are also functions that provide users with the power to set data specific to C models into the
SystemVerilog simulator for later retrieval. These are the “put” and “get” user data functions, which are
similar to facilities provided in VPI.
The put and get user data functions are flexible and allow for a number of use models. Users might wish to
share user data across multiple context imported functions defined in the same SystemVerilog scope. Users
1234
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
might wish to have unique data storage on a per-function basis. Shared or unique data storage is controllable
by a user-defined key.
To achieve shared data storage, a related set of context imported tasks and functions should all use the same
user key. To achieve unique data storage, a context import subroutine should use a unique key, and it is a
requirement on the user that such a key be truly unique from all other keys that could possibly be used by C
code. This includes completely unknown C code that could be running in the same simulation. It is
suggested that taking addresses of static C symbols (such as a function pointer or an address of some static C
data) always be done for user key generation. Generating keys based on arbitrary integers is not a safe
practice.
It is never possible to share user data storage across different contexts. For example, if a SystemVerilog
module declares a context imported subroutine , and is instantiated more than once in the
m f m
SystemVerilog design, then shall execute under different values of . No such executing instances
f svScope
of can share user data with each other, at least not using the system-provided user data storage area
f
accessible via .
svPutUserData()
A user wanting to share a data area across multiple contexts must do so by allocating the common data area
and then storing the pointer to it individually for each of the contexts in question via multiple calls to
. This is because, although a common user key can be used, the data must be associated
svPutUserData()
with the individual scopes (denoted by ) of those contexts.
svScope
/* Functions for working with DPI context functions */
/* Retrieve the active instance scope currently associated with the executing
* imported function.
* Unless a prior call to svSetScope has occurred, this is the scope of the
* function's declaration site, not call site.
* The return value is undefined if this function is invoked from a noncontext
* imported function.
*/
svScope svGetScope();
/* Set context for subsequent export function execution.
* This function must be called before calling an export function, unless
* the export function is called while executing an import function. In that
* case the export function shall inherit the scope of the surrounding import
* function. This is known as the “default scope”.
* The return is the previous active scope (per svGetScope)
*/
svScope svSetScope(const svScope scope);
/* Gets the fully qualified name of a scope handle */
const char* svGetNameFromScope(const svScope);
/* Retrieve svScope to instance scope of an arbitrary function declaration.
* (can be either module, program, interface, or generate scope)
* The return value shall be NULL for unrecognized scope names.
*/
svScope svGetScopeFromName(const char* scopeName);
/* Store an arbitrary user data pointer for later retrieval by svGetUserData()
* The userKey is generated by the user. It must be guaranteed by the user to
* be unique from all other userKey's for all unique data storage requirements
* It is recommended that the address of static functions or variables in the
* user's C code be used as the userKey.
* It is illegal to pass in NULL values for either the scope or userData
* arguments. It is also an error to call svPutUserData() with an invalid
1235
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
* svScope. This function returns -1 for all error cases, 0 upon success. It is
* suggested that userData values of 0 (NULL) not be used as otherwise it can
* be impossible to discern error status returns when calling svGetUserData()
*/
int svPutUserData(const svScope scope, void *userKey, void* userData);
/* Retrieve an arbitrary user data pointer that was previously
* stored by a call to svPutUserData(). See the comment above
* svPutUserData() for an explanation of userKey, as well as
* restrictions on NULL and illegal svScope and userKey values.
* This function returns NULL for all error cases, and a non-Null
* user data pointer upon success.
* This function also returns NULL in the event that a prior call
* to svPutUserData() was never made.
*/
void* svGetUserData(const svScope scope, void* userKey);
/* Returns the file and line number in the SV code from which the import call
* was made. If this information available, returns TRUE and updates fileName
* and lineNumber to the appropriate values. Behavior is unpredictable if
* fileName or lineNumber are not appropriate pointers. If this information is
* not available return FALSE and contents of fileName and lineNumber not
* modified. Whether this information is available or not is implementation-
* specific. Note that the string provided (if any) is owned by the SV
* implementation and is valid only until the next call to any SV function.
* Applications must not modify this string or free it
*/
int svGetCallerInfo(const char **fileName, int *lineNumber);
H.9.4 Example 1—Using DPI context functions
SV side:
// Declare an imported context sensitive C function with cname "MyCFunc"
import "DPI-C" context MyCFunc = function integer MapID(int portID);
C side:
// Define the function and model class on the C++ side:
class MyCModel {
private:
int locallyMapped(int portID); // Does something interesting...
public:
// Constructor
MyCModel(const char* instancePath) {
svScope svScope = svGetScopeByName(instancePath);
// Associate "this" with the corresponding SystemVerilog scope
// for fast retrieval during run time.
svPutUserData(svScope, (void*) MyCFunc, this);
}
friend int MyCFunc(int portID);
};
// Implementation of imported context function callable in SV
int MyCFunc(int portID) {
1236
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
// Retrieve SV instance scope (i.e., this function's context).
svScope = svGetScope();
// Retrieve and make use of user data stored in SV scope
MyCModel* me = (MyCModel*)svGetUserData(svScope, (void*) MyCFunc);
return me->locallyMapped(portID);
}
H.9.5 Relationship between DPI and VPI
DPI allows C code to run in the context of a SystemVerilog simulation; thus it is natural for users to consider
using VPI C code from within imported tasks and functions.
There is no specific relationship defined between DPI and VPI. Programmers must make no assumptions
about how DPI and the other interfaces interact. For example, a is not equivalent to an
vpiHandle
, and the two must not be interchanged and passed between functions defined in the
svOpenArrayHandle
two different interfaces.
If a user wants to call VPI functions from within an imported subroutine, the imported subroutine must be
flagged with the context qualifier.
Not all VPI functionality is available from within DPI context imported tasks and functions. For example, a
SystemVerilog imported subroutine is not a system task, and thus making the following call from within an
imported subroutine would result in an error:
/* Get handle to system task call site in preparation for argument scan */
vpiHandle myHandle = vpi_handle(vpiSysTfCall, NULL);
Similarly, callbacks and other activities associated with system tasks are not supported inside DPI imported
tasks and functions. Users should use VPI if they wish to accomplish such actions.
However, the following kind of code will work reliably from within DPI context imported tasks and
functions:
/* Prepare to scan all top-level modules */
vpiHandle myHandle = vpi_iterate(vpiModule, NULL);
H.10 Include files
The C layer of the DPI defines one include file, . This file is implementation independent and
svdpi.h
defines the canonical representation, all basic types, and all interface functions. The actual file is shown in
AnnexI.
H.10.1 Include file svdpi.h
Applications that use the DPI with C code usually need this main include file. The include file
svdpi.h
defines the types for canonical representation of 2-state ( ) and 4-state ( ) values and passing
bit logic
references to SystemVerilog data objects, provides function headers, and defines a number of helper macros
and constants.
This standard fully defines the file. The content of does not depend on any particular
svdpi.h svdpi.h
implementation or platform; all simulators shall use the same file. Subclauses H.10.1.1, H.10.1.2, and
H.10.1.3 (and H.13) detail the contents of the file.
svdpi.h
1237
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
H.10.1.1 Scalars of type bit and logic
/* canonical representation */
#define sv_0 0
#define sv_1 1
#define sv_z 2 /* representation of 4-st scalar z */
#define sv_x 3 /* representation of 4-st scalar x */
/* common type for 'bit' and 'logic' scalars. */
typedef unsigned char svScalar;
typedef svScalar svBit; /* scalar */
typedef svScalar svLogic; /* scalar */
H.10.1.2 Canonical representation of packed arrays
/*
* DPI representation of packed arrays.
* 2-state and 4-state vectors, exactly the same as PLI's avalue/bvalue.
*/
#ifndef VPI_VECVAL
#define VPI_VECVAL
typedef struct t_vpi_vecval {
uint32_t aval;
uint32_t bval;
} s_vpi_vecval, *p_vpi_vecval;
#endif
/* (a chunk of) packed logic array */
typedef s_vpi_vecval svLogicVecVal;
/* (a chunk of) packed bit array */
typedef uint32_t svBitVecVal;
/* Number of chunks required to represent the given width packed array */
#define SV_PACKED_DATA_NELEMS(WIDTH) (((WIDTH) + 31) >> 5)
/*
* Because the contents of the unused bits is undetermined,
* the following macros can be handy.
*/
#define SV_MASK(N) (~(-1 << (N)))
#define SV_GET_UNSIGNED_BITS(VALUE, N) \
((N) == 32 ? (VALUE) : ((VALUE) & SV_MASK(N)))
#define SV_GET_SIGNED_BITS(VALUE, N) \
((N) == 32 ? (VALUE) : \
(((VALUE) & (1 << (N))) ? ((VALUE) | ~SV_MASK(N)) : ((VALUE) & SV_MASK(N))))
H.10.1.3 Implementation-dependent representation
The function returns a string indicating which DPI standard is supported by the simulator
svDpiVersion()
and in particular which canonical value representation is being provided. For example, a tool that is based on
IEEE Std 1800-2005, i.e., the VPI-based canonical value, shall return the string . Simulators
"1800-2005"
implementing to the prior Accellera SV3.1a standard [B4], and thus using the value
svLogicVec32
representation, shall return the string .
"SV3.1a"
/* Returns either version string "1800-2005" or "SV3.1a" */
1238
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
const char* svDpiVersion();
/* a handle to a scope (an instance of a module or an interface) */
typedef void *svScope;
/* a handle to a generic object (actually, unsized array) */
typedef void* svOpenArrayHandle;
H.10.2 Example 2—Simple packed array application
SystemVerilog:
typedef struct {int x; int y;} pair;
import "DPI-C" function void f1(input int i1, pair i2,
output logic [63:0] o3);
export "DPI-C" function exported_sv_func;
function void exported_sv_func(input int i, output int o [0:7]);
begin ... end
endfunction
C:
#include "svdpi.h"
typedef struct {int x; int y;} pair;
extern void exported_sv_func(int, int *); /* imported from SystemVerilog */
void f1(const int i1, const pair *i2, svLogicVecVal* o3)
{
int tab[8];
printf("%d\n", i1);
o3[0].aval = i2->x;
o3[0].bval = 0;
o3[1].aval = i2->y;
o3[1].b = 0;
/* call SystemVerilog */
exported_sv_func(i1, tab); /* tab passed by reference */
...
}
H.10.3 Example 3—Application with complex mix of types
SystemVerilog:
typedef struct {int a; bit [6:1][1:8] b [65:2]; int c;} triple;
// troublesome mix of C types and packed arrays
import "DPI-C" function void f1(input triple t);
export "DPI-C" function exported_sv_func;
function void exported_sv_func(input int i, output logic [63:0] o);
begin ... end
endfunction
1239
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
C:
#include "svdpi.h"
typedef struct {
int a;
svBitVecVal b[64][SV_PACKED_DATA_NELEMS(6*8)];
int c;
} triple;
/* Note that 'b' is defined as for 'bit [6*8-1:0] b [63:0]' */
extern void exported_sv_func(int, svLogicVecVal*); /* imported from
SystemVerilog */
void f1(const triple *t)
{
int i;
svBitVecVal aB;
svLogicVecVal aL[SV_PACKED_DATA_NELEMS(64)];
/* aB holds results of part-select from packed bit array 'b' in
struct triple. */
/* aL holds the packed logic array filled in by the export function. */
printf("%d %d\n", t->a, t->c);
for (i = 0; i < 64; i++) {
/* Read least significant byte of each word of b into aB, then
process... */
svGetPartselBit(&aB, t->b[i], 0, 8);
...
}
...
/* Call SystemVerilog */
exported_sv_func(2, aL); /* Export function writes data into
output arg "aL" */
...
}
H.11 Arrays
Normalized ranges are used for accessing SystemVerilog arrays, with the exception of formal arguments
specified as open arrays.
H.11.1 Example 4—Using packed 2-state arguments
This example shows two alternatives for working with 2-state packed data types. The first argument shows
classical -to- correspondence per TableH.1. The second argument demonstrates that a DPI formal
int int
argument can be of a C-compatible type and that arbitrary 2-state bit vector actual arguments can be
associated with that C-compatible formal argument. The third argument shows a portable technique for
handling an arbitrary width 2-state vector. This technique is less efficient than techniques involving
C-compatible formal arguments, but it is required when 2-state vectors exceed 64 bits in length.
// SV code
module m;
1240
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
parameter W = 33;
int abv1;
bit [29:0] abv2;
bit [W-1:0] abv3;
// Two ways of handling 2-state packed array arguments
import "DPI-C" function void f7 (input int unsigned fbv1,
input int unsigned fbv2,
input [W-1:0] fbv3);
initial
f7(abv1, abv2, abv3);
endmodule
/* C code */
void f7(unsigned int fbv1, unsigned int fbv2,
const svBitVecVal* fbv3)
{
printf("fbv1 is %d, fbv2 is %d\n", fbv1, fbv2);
/* Use of the 2-state svdpi utilities is needed to transform fbv3 into a
C representation */
}
H.11.2 Multidimensional arrays
Multiple packed dimensions of a SystemVerilog array are linearized (see H.7.5). Unpacked arrays can have
an arbitrary number of dimensions.
H.11.3 Example 5—Using packed struct and union arguments
This example shows how packed and arguments correspond to one-dimensional packed
struct union
array arguments.
// SV code
module m;
typedef bit [2:0] A;
typedef struct packed { bit a; bit b; bit c; } S;
typedef union packed { A a; S s; } U;
S s;
U u;
A a;
// Import function takes three arguments
import "DPI-C" function void f8(input A fa, input S fs, input U fu);
initial begin
s.a = 1'b1;
s.b = 1'b0;
s.c = 1'b0;
a = 3'b100;
u.a = 3'b100;
f8(a, s, u);
end
1241
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
endmodule
/* C code */
void f8(
const svBitVecVal* fa,
const svBitVecVal* fs,
const svBitVecVal* fu)
{
printf("fa is %d, fs is %d, fu is %d\n", *fa, *fs, *fu);
}
The output of the printf will be “ ”.
fa is 4, fs is 4, fu is 4
H.11.4 Direct access to unpacked arrays
Unpacked arrays, with the exception of formal arguments specified as open arrays, shall have the same
layout as used by a C compiler; they are accessed using C indexing (see H.7.6).
H.11.5 Utility functions for working with the canonical representation
Packed arrays are accessible via canonical representation. This C layer interface provides utility functions
for working with bit-selects and limited (up to 32-bit) part-selects in the canonical representation.
A part-select is a slice of a packed array of types or . Array slices are not supported for unpacked
bit logic
arrays. Functions for part-selects only allow access (read/write) to a narrow subrange of up to 32 bits. If the
specified range of a part-select is not fully contained within the normalized range of an array, the behavior is
undetermined.
DPI utilities behave in the following way, given part-select arguments of width and starting index . A
w i
utility puts part-select source bits into destination bits without changing the values
[w-1:0] [(i+w-1):i]
of destination bits that surround the part-select. A utility gets part-select source bits and
[(i+w-1):i]
copies them into destination bits . If , destination bits shall be left unchanged by
[w-1:0] w < 32 [31:w]
the get part-select operation.
/*
* Bit-select utility functions.
*
* Packed arrays are assumed to be indexed n-1:0,
* where 0 is the index of LSB
*/
/* s=source, i=bit-index */
svBit svGetBitselBit(const svBitVecVal* s, int i);
svLogic svGetBitselLogic(const svLogicVecVal* s, int i);
/* d=destination, i=bit-index, s=scalar */
void svPutBitselBit(svBitVecVal* d, int i, svBit s);
void svPutBitselLogic(svLogicVecVal* d, int i, svLogic s);
/*
* Part-select utility functions.
*
* A narrow (<=32 bits) part-select is extracted from the
* source representation and written into the destination word.
*
* Normalized ranges and indexing [n-1:0] are used for both arrays.
1242
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
*
* s=source, d=destination, i=starting bit index, w=width
* like for variable part-selects; limitations: w <= 32
*/
void svGetPartselBit(svBitVecVal* d, const svBitVecVal* s, int i, int w);
void svGetPartselLogic(svLogicVecVal* d, const svLogicVecVal* s, int i, int w);
void svPutPartselBit(svBitVecVal* d, const svBitVecVal s, int i, int w);
void svPutPartselLogic(svLogicVecVal* d, const svLogicVecVal s, int i, int w);
H.12 Open arrays
Formal arguments specified as open arrays allows passing actual arguments of different sizes (i.e., different
range and/or different number of elements), which facilitates writing more general C code that can handle
SystemVerilog arrays of different sizes. The elements of an open array can be accessed in C by using the
same range of indices and the same indexing as in SystemVerilog. Plus, inquiries about the dimensions and
the original boundaries of SystemVerilog actual arguments are supported for open arrays.
Both the sole packed dimension (see H.7.1) and multiple unpacked dimensions can be unsized (see
35.5.6.1).
All formal arguments declared in SystemVerilog as open arrays are passed by
handle
, regardless of the direction of a SystemVerilog formal argument. Such
(type svOpenArrayHandle)
arguments are accessible via interface functions that accept the handle. For example, the array address is
provided by a call to .
svGetArrayPtr
For inout or output mode open array arguments the space available for user C code output is determined by
the actual argument’s size. The result of user C code writing more data to an open array address than the
actual argument’s capacity can accommodate is undefined.
H.12.1 Actual ranges
Formal arguments defined as open arrays have sizes and ranges determined by the actual argument on a per-
call basis. The programmer shall always have a choice about whether to specify a formal argument as a sized
array or as an open (unsized) array.
For sized formal array dimensions, all indices are normalized on the C side (i.e., and up); the programmer
0
needs to know the size of an array and be capable of determining how the ranges of the actual argument map
onto C-style ranges (see H.7.6).
Tip: Programmers can decide to use style ranges in SystemVerilog.
[n:0]name[0:k]
For unsized, unpacked formal array dimensions, the actual argument’s original range and indices are
available via query functions (see H.12.2). For unsized, packed formal array dimensions, the query functions
provide a linearized, normalized form of the actual’s packed dimensions. Thus, the actual argument’s
original indices can be retrieved from query functions and used as arguments to copying and access
functions (see H.12.4 and H.12.5). Similarly, the normalized indices of the actual argument’s packed
dimensions can be retrieved and used with the standard functions for accessing packed array canonical
representations (see H.11.5).
If a formal argument is specified as a sized array, then it shall be passed by reference, with no overhead, and
is directly accessible as a normalized array. If a formal argument is specified as an open (unsized) array, then
it shall be passed by handle, with some overhead, and is mostly indirectly accessible, again with some
overhead.
1243
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
NOTE—This provides some degree of flexibility and allows the programmer to control the trade-off of performance
versus convenience.
The following example shows the use of sized versus unsized arrays in SystemVerilog code:
// both unpacked arrays are 64 by 8 elements, packed 16-bit each
logic [15: 0] a_64x8 [63:0][7:0];
logic [31:16] b_64x8 [64:1][-1:-8];
import "DPI-C" function void f1(input logic [] i [][]);
// 2-dimensional unsized unpacked array of unsized packed logic
import "DPI-C" function void f2(input logic [31:16] i [64:1][-1:-8]);
// 2-dimensional sized unpacked array of sized packed logic
f1(a_64x8);
f1(b_64x8); // C code can use normalized packed and original unpacked
// ranges [15:0][64:1][-1:-8]
f2(b_64x8); // C code must use normalized ranges [15:0][0:63][0:7]
H.12.2 Array querying functions
These functions are modeled upon the SystemVerilog array querying functions and use the same semantics
(see 20.7).
If the dimension is , then the query refers to the packed part (which is one-dimensional) of an array, and
0
dimensions refer to the unpacked part of an array.
> 0
/* h= handle to open array, d=dimension */
int svLeft(const svOpenArrayHandle h, int d);
int svRight(const svOpenArrayHandle h, int d);
int svLow(const svOpenArrayHandle h, int d);
int svHigh(const svOpenArrayHandle h, int d);
int svIncrement(const svOpenArrayHandle h, int d);
int svSize(const svOpenArrayHandle h, int d);
int svDimensions(const svOpenArrayHandle h);
H.12.3 Access functions
There are library functions available for copying data between open array handles and canonical form
buffers provided by the C programmer. Likewise, there are functions to obtain the actual address of
SystemVerilog data objects or of an individual element of an unpacked array.
Depending on the type of an element of an unpacked array, different access methods shall be used when
working with elements, as follows:
— Packed arrays ( or ) are accessed via copying to or from the canonical representation.
bit logic
— Scalars (1-bit value of type or ) are accessed (read or written) directly.
bit logic
— Other types of values (e.g., structures) are accessed via generic pointers; a library function calculates
an address, and the user needs to provide the appropriate casting.
— Scalars and packed arrays are accessible via pointers only if the implementation supports this
functionality (per array), e.g., one array can be represented in a form that allows such access, while
another array might use a compacted representation that renders this functionality unfeasible (both
occurring within the same simulator).
1244
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
SystemVerilog allows arbitrary dimensions and, hence, an arbitrary number of indices. To facilitate this,
variable argument list functions shall be used. For the sake of performance, specialized versions of all
indexing functions are provided for one, two, or three indices.
H.12.4 Access to actual representation
The following functions provide an actual address of the whole array or of its individual elements. These
functions shall be used for accessing elements of arrays of types compatible with C. These functions are also
useful for vendors because they provide access to the actual representation for all types of arrays.
If the actual layout of the SystemVerilog array passed as an argument for an open unpacked array is different
from the C layout, then it is not possible to access such an array as a whole; therefore, the address and size of
such an array shall be undefined ( , to be exact). Nonetheless, the addresses of individual elements of an
0
array shall be always supported.
NOTE—No specific representation of an array is assumed here; hence, all functions use a generic pointer .
void *
/* a pointer to the actual representation of the whole array of any type */
/* NULL if not in C layout */
void *svGetArrayPtr(const svOpenArrayHandle);
int svSizeOfArray(const svOpenArrayHandle); /* total size in bytes or 0 if not
in C layout */
/* Return a pointer to an element of the array
or NULL if index outside the range or null pointer */
void *svGetArrElemPtr(const svOpenArrayHandle, int indx1, ...);
/* specialized versions for 1-, 2- and 3-dimensional arrays: */
void *svGetArrElemPtr1(const svOpenArrayHandle, int indx1);
void *svGetArrElemPtr2(const svOpenArrayHandle, int indx1, int indx2);
void *svGetArrElemPtr3(const svOpenArrayHandle, int indx1, int indx2,
int indx3);
Access to an individual array element via pointer makes sense only if the representation of such an element
is the same as it would be for an individual value of the same type. Representation of array elements of type
or packed value is implementation dependent; the above functions shall return if the
scalar NULL
representation of the array elements differs from the representation of individual values of the same type.
H.12.5 Access to elements via canonical representation
This group of functions is meant for accessing elements that are packed arrays ( or ).
bit logic
The following functions copy a whole packed array (a single vector) from a canonical representation to an
element of an open array or they copy in the other direction. The actual argument’s original SystemVerilog
ranges are used to index the open array. The user is responsible for ensuring that the canonical
representation has an adequate size for the copy operation.
/* functions for translation between simulator and canonical representations*/
/* s=source, d=destination */
/* From user space into simulator storage */
void svPutBitArrElemVecVal(const svOpenArrayHandle d, const svBitVecVal* s,
int indx1, ...);
void svPutBitArrElem1VecVal(const svOpenArrayHandle d, const svBitVecVal* s,
int indx1);
1245
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
void svPutBitArrElem2VecVal(const svOpenArrayHandle d, const svBitVecVal* s,
int indx1, int indx2);
void svPutBitArrElem3VecVal(const svOpenArrayHandle d, const svBitVecVal* s,
int indx1, int indx2, int indx3);
void svPutLogicArrElemVecVal(const svOpenArrayHandle d, const svLogicVecVal* s,
int indx1, ...);
void svPutLogicArrElem1VecVal(const svOpenArrayHandle d, const svLogicVecVal* s,
int indx1);
void svPutLogicArrElem2VecVal(const svOpenArrayHandle d, const svLogicVecVal* s,
int indx1, int indx2);
void svPutLogicArrElem3VecVal(const svOpenArrayHandle d, const svLogicVecVal* s,
int indx1, int indx2, int indx3);
/* From simulator storage into user space */
void svGetBitArrElemVecVal(svBitVecVal* d, const svOpenArrayHandle s,
int indx1, ...);
void svGetBitArrElem1VecVal(svBitVecVal* d, const svOpenArrayHandle s,
int indx1);
void svGetBitArrElem2VecVal(svBitVecVal* d, const svOpenArrayHandle s,
int indx1, int indx2);
void svGetBitArrElem3VecVal(svBitVecVal* d, const svOpenArrayHandle s,
int indx1, int indx2, int indx3);
void svGetLogicArrElemVecVal(svLogicVecVal* d, const svOpenArrayHandle s,
int indx1, ...);
void svGetLogicArrElem1VecVal(svLogicVecVal* d, const svOpenArrayHandle s,
int indx1);
void svGetLogicArrElem2VecVal(svLogicVecVal* d, const svOpenArrayHandle s,
int indx1, int indx2);
void svGetLogicArrElem3VecVal(svLogicVecVal* d, const svOpenArrayHandle s,
int indx1, int indx2, int indx3);
H.12.6 Access to scalar elements (bit and logic)
Another group of functions is needed for scalars (i.e., when an element of an array is a simple scalar, , or
bit
):
logic
svBit svGetBitArrElem (const svOpenArrayHandle s, int indx1, ...);
svBit svGetBitArrElem1(const svOpenArrayHandle s, int indx1);
svBit svGetBitArrElem2(const svOpenArrayHandle s, int indx1, int indx2);
svBit svGetBitArrElem3(const svOpenArrayHandle s, int indx1, int indx2,
int indx3);
svLogic svGetLogicArrElem (const svOpenArrayHandle s, int indx1, ...);
svLogic svGetLogicArrElem1(const svOpenArrayHandle s, int indx1);
svLogic svGetLogicArrElem2(const svOpenArrayHandle s, int indx1, int indx2);
svLogic svGetLogicArrElem3(const svOpenArrayHandle s, int indx1, int indx2,
int indx3);
void svPutLogicArrElem (const svOpenArrayHandle d, svLogic value, int indx1,
...);
void svPutLogicArrElem1(const svOpenArrayHandle d, svLogic value, int indx1);
void svPutLogicArrElem2(const svOpenArrayHandle d, svLogic value, int indx1,
int indx2);
void svPutLogicArrElem3(const svOpenArrayHandle d, svLogic value, int indx1,
int indx2, int indx3);
void svPutBitArrElem (const svOpenArrayHandle d, svBit value, int indx1, ...);
void svPutBitArrElem1(const svOpenArrayHandle d, svBit value, int indx1);
void svPutBitArrElem2(const svOpenArrayHandle d, svBit value, int indx1,
int indx2);
1246
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
void svPutBitArrElem3(const svOpenArrayHandle d, svBit value, int indx1,
int indx2, int indx3);
H.12.7 Access to array elements of other types
If an array’s elements are of a type compatible with C, there is no need to use canonical representation. In
such situations, the elements are accessed via pointers, i.e., the actual address of an element shall be
computed first and then used to access the desired element.
H.12.8 Example 6—Two-dimensional open array
SystemVerilog:
typedef struct {int i; ... } MyType;
import "DPI-C" function void f1(input MyType i [][]);
/* 2-dimensional unsized unpacked array of MyType */
MyType a_10x5 [11:20][6:2];
MyType a_64x8 [64:1][-1:-8];
f1(a_10x5);
f1(a_64x8);
C:
#include "svdpi.h"
typedef struct {int i; ... } MyType;
void f1(const svOpenArrayHandle h)
{
MyType my_value;
int i, j;
int lo1 = svLow(h, 1);
int hi1 = svHigh(h, 1);
int lo2 = svLow(h, 2);
int hi2 = svHigh(h, 2);
for (i = lo1; i <= hi1; i++) {
for (j = lo2; j <= hi2; j++) {
my_value = *(MyType *)svGetArrElemPtr2(h, i, j);
...
*(MyType *)svGetArrElemPtr2(h, i, j) = my_value;
...
}
...
}
}
1247
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
H.12.9 Example 7—Open array
SystemVerilog:
typedef struct { ... } MyType;
import "DPI-C" function void f1(input MyType i [], output MyType o []);
MyType source [11:20];
MyType target [11:20];
f1(source, target);
C:
#include "svdpi.h"
typedef struct { ... } MyType;
void f1(const svOpenArrayHandle hin, const svOpenArrayHandle hout)
{
int count = svSize(hin, 1);
MyType *s = (MyType *)svGetArrayPtr(hin);
MyType *d = (MyType *)svGetArrayPtr(hout);
if (s && d) { /* both arrays have C layout */
/* an efficient solution using pointer arithmetic */
while (count--)
*d++ = *s++;
/* even more efficient:
memcpy(d, s, svSizeOfArray(hin));
*/
} else { /* less efficient yet implementation independent */
int i = svLow(hin, 1);
int j = svLow(hout, 1);
while (i <= svHigh(hin, 1)) {
*(MyType *)svGetArrElemPtr1(hout, j++) =
*(MyType *)svGetArrElemPtr1(hin, i++);
}
}
}
H.12.10 Example 8—Access to packed arrays
SystemVerilog:
import "DPI-C" function void f1(input logic [127:0]);
import "DPI-C" function void f2(input logic [127:0] i []); // open array of
// 128-bit
1248
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
C:
#include "svdpi.h"
/* Copy out one 128-bit packed vector */
void f1(const svLogicVecVal* packed_vec_128_bit)
{
svLogicVecVal arr[SV_PACKED_DATA_NELEMS(128)]; /* canonical rep */
memcpy(arr, packed_vec_128_bit, sizeof(arr));
...
}
* Copy out each word of an open array of 128-bit packed vectors */
void f2(const svOpenArrayHandle h)
{
int i;
svLogicVecVal arr[SV_PACKED_DATA_NELEMS(128)]; /* canonical rep */
for (i = svLow(h, 1); i <= svHigh(h, 1); i++) {
const svLogicVecVal* ptr = (svLogicVecVal*)svGetArrElemPtr1(h, i);
memcpy(arr, ptr, sizeof(arr));
...
}
...
}
H.13 SV3.1a-compatible access to packed data (deprecated functionality)
The functionality described in this subclause is deprecated and need not be implemented by an IEEE 1800
simulator. The functionality provides backwards compatibility with Accellera SystemVerilog 3.1a (SV3.1a)
[B4] regarding the semantics of packed array arguments. This subclause will describe the SV3.1a semantics.
The main difference between SV3.1a and IEEE 1800 semantics is that in SV3.1a, packed data arguments are
passed by opaque handle types and . An implementation
svLogicPackedArrRef svBitPackedArrRef
need not do any conversion or marshalling of data into the canonical format. The C programmer is provided
a set of utility functions that copies data between actual vendor format and canonical format. Other utilities
are provided that put and get bit-selects and part-selects from actual vendor representation.
H.13.1 Determining the compatibility level of an implementation
Function is provided to allow the determination of an implementation’s support for this
svDpiVersion()
standard. In simulators that only support the SV3.1a standard, users must make use of the opaque handle
types for all 2-state and 4-state arguments. See H.10.1.3.
When using an IEEE 1800 implementation, it is possible for users to make use of SV3.1a-compatible
semantics on a per-function basis. Import and export declarations annotated with the syntax shall
"DPI"
yield the argument passing semantics on the C side of the interface. Import and export declarations
SV3.1a
annotated with the syntax shall yield the IEEE 1800 argument passing semantics. See 35.4 and
"DPI-C"
35.5.4.
The file may contain definitions and function prototypes for use with SV3.1a-compliant packed
svdpi.h
data access. IEEE 1800 implementations are not obligated to provide these definitions and prototypes in the
include file.
1249
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
If an IEEE 1800 implementation does not support the functionality in this subclause, it is possible that the
DPI C code may not successfully bind to the implementation.
H.13.2 svdpi.h definitions for SV3.1a-style packed data processing
The following definitions are used to define SV3.1a-style canonical access to packed data:
/* 2-state and 4-state vectors, modeled upon PLI's avalue/bvalue */
#define SV_CANONICAL_SIZE(WIDTH) (((WIDTH)+31)>>5)
typedef uint32_t
svBitVec32; /* (a chunk of) packed bit array */
typedef struct { unsigned int c; unsigned int d;}
svLogicVec32; /* (a chunk of) packed logic array */
The following definitions describe implementation-dependent packed data representation:
/* reference to a standalone packed array */
typedef void* svBitPackedArrRef;
typedef void* svLogicPackedArrRef;
/* total size in bytes of the simulator's representation of a packed array */
/* width in bits */
int svSizeOfBitPackedArr(int width);
int svSizeOfLogicPackedArr(int width);
The following functions provide translation between actual vendor representation and canonical
representation. The functions copy the whole array in either direction. The user is responsible for providing
the correct width and for allocating an array in the canonical representation. The contents of the unused bits
are undetermined.
Although the put and get functionality provided for and packed arrays is sufficient, yet basic, it
bit logic
requires unnecessary copying of the whole packed array when perhaps only some bits are needed. For the
sake of convenience and improved performance, bit-selects and limited (up to 32 bits) part-selects are also
supported.
/* s=source, d=destination, w=width */
/* actual <-- canonical */
void svPutBitVec32 (svBitPackedArrRef d, const svBitVec32* s, int w);
void svPutLogicVec32 (svLogicPackedArrRef d, const svLogicVec32* s, int w);
/* canonical <-- actual */
void svGetBitVec32 (svBitVec32* d, const svBitPackedArrRef s, int w);
void svGetLogicVec32 (svLogicVec32* d, const svLogicPackedArrRef s, int w);
The following functions provide support for bit-select processing on actual vendor data representation:
/* Packed arrays are assumed to be indexed n-1:0, where 0 is the index of
LSB */
/* functions for bit-select */
/* s=source, i=bit-index */
svBit svGetSelectBit(const svBitPackedArrRef s, int i);
svLogic svGetSelectLogic(const svLogicPackedArrRef s, int i);
/* d=destination, i=bit-index, s=scalar */
1250
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
void svPutSelectBit(svBitPackedArrRef d, int i, svBit s);
void svPutSelectLogic(svLogicPackedArrRef d, int i, svLogic s);
Limited (up to 32-bit) part-selects are supported. A part-select is a slice of a packed array of types or
bit
. Array slices are not supported for unpacked arrays. Functions for part-selects only allow access
logic
(read/write) to a narrow subrange of up to 32 bits. Canonical representation shall be used for such narrow
vectors. If the specified range of a part-select is not fully contained within the normalized range of an array,
the behavior is undetermined.
/*
* functions for part-select
*
* a narrow (<=32 bits) part-select is copied between
* the implementation representation and a single chunk of
* canonical representation
* Normalized ranges and indexing [n-1:0] are used for both arrays:
* the array in the implementation representation and the canonical array.
*
* s=source, d=destination, i=starting bit index, w=width
* like for variable part-selects; limitations: w <= 32
*
* In part-select operations, the data are copied to or from the
* canonical representation part ('chunk') designated by range [w-1:0]
* and the implementation representation part designated by range [w+i-1:i].
*/
/* canonical <-- actual */
void svGetPartSelectBit(svBitVec32* d, const svBitPackedArrRef s, int i,
int w);
svBitVec32 svGetBits(const svBitPackedArrRef s, int i, int w);
svBitVec32 svGet32Bits(const svBitPackedArrRef s, int i); // 32-bits
uint64_t svGet64Bits(const svBitPackedArrRef s, int i); // 64-bits
void svGetPartSelectLogic(svLogicVec32* d, const svLogicPackedArrRef s, int i,
int w);
/* actual <-- canonical */
void svPutPartSelectBit(svBitPackedArrRef d, const svBitVec32 s, int i,
int w);
void svPutPartSelectLogic(svLogicPackedArrRef d, const svLogicVec32 s, int i,
int w);
H.13.3 Source-level compatibility include file svdpi_src.h
Only two symbols are defined: the macros that allow declaring variables to represent the SystemVerilog
packed arrays of type or . Applications that do not need this file to compile are deemed binary
bit logic
compatible. In other words, the DPI C code does not need to be recompiled to run on different simulators.
Applications that make use of must be recompiled for each simulator on which they are to be
svdpi_src.h
run.
#define SV_BIT_PACKED_ARRAY(WIDTH,NAME) ...
#define SV_LOGIC_PACKED_ARRAY(WIDTH,NAME) ...
The actual definitions are implementation-specific, but shall not define an array type (see definition in 6.2.5
in ISO/IEC 9899:1999 [B3]). For example, a SystemVerilog simulator might define the latter macro as
follows:
#define SV_LOGIC_PACKED_ARRAY(WIDTH,NAME) \
struct { svLogicVec32 __unnamed [SV_CANONICAL_SIZE(WIDTH)]; } NAME
1251
Authorized licensed use limited to: Siemens AG GBS B&CSo SpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
H.13.4 Example 9—Deprecated SV3.1a binary-compatible application
SystemVerilog:
typedef struct {int x; int y;} pair;
import "DPI" function void f1(input int i1, pair i2, output logic [63:0] o3);
export "DPI" function exported_sv_func;
function void exported_sv_func(input int i, output int o [0:7]);
begin ... end
endfunction
C:
include "svdpi.h"
typedef struct {int x; int y;} pair;
extern void exported_sv_func(int, int *); /* imported from SystemVerilog */
void f1(const int i1, const pair *i2, svLogicPackedArrRef* o3)
{
svLogicVec32 arr[SV_CANONICAL_SIZE(64)]; /* 2 chunks needed */
int tab[8];
printf("%d\n", i1);
arr[0].c = i2->x;
arr[0].d = 0;
arr[1].c = i2->y;
arr[1].d = 0;
svPutLogicVec32(o3, arr, 64);
/* call SystemVerilog */
exported_sv_func(i1, tab); /* tab passed by reference */
...
}
H.13.5 Example 10—Deprecated SV3.1a source-compatible application
SystemVerilog:
typedef struct {int a; bit [6:1][1:8] b [65:2]; int c;} triple;
// troublesome mix of C types and packed arrays
import "DPI" function void f1(input triple t);
export "DPI" function exported_sv_func;
function void exported_sv_func(input int i, output logic [63:0] o);
begin ... end
endfunction
C:
#include "svdpi.h"
#include "svdpi_src.h"
typedef struct {
int a;
SV_BIT_PACKED_ARRAY(6*8, b) [64]; /* implementation-specific
representation */
1252
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
int c;
} triple;
/* Note that 'b' is defined as for 'bit [6*8-1:0] b [63:0]' */
extern void exported_sv_func(int, svLogicPackedArrRef); /* imported from
SystemVerilog */
void f1(const triple *t)
{
int j;
/* canonical representation */
svBitVec32 aB[SV_CANONICAL_SIZE(6*8)]; /* 6*8 packed bits */
svLogicVec32 aL[SV_CANONICAL_SIZE(64)];
/* implementation-specific representation */
SV_LOGIC_PACKED_ARRAY(64, my_tab);
printf("%d %d\n", t->a, t->c);
for (i = 0; i < 64; i++) {
svGetBitVec32(aB, (svBitPackedArrRef)&(t->b[i]), 6*8);
...
}
...
/* call SystemVerilog */
exported_sv_func(2, (svLogicPackedArrRef)&my_tab); /* by reference */
svGetLogicVec32(aL, (svLogicPackedArrRef)&my_tab, 64);
...
}
H.13.6 Example 11—Deprecated SV3.1a binary-compatible calls of export functions
This example demonstrates that the source compatibility include file is not needed if a C
svdpi_src.h
function dynamically allocates the data structure for simulator representation of a packed array to be passed
to an exported SystemVerilog function.
SystemVerilog:
export "DPI" function myfunc;
...
function void myfunc (output logic [31:0] r); ...
...
C:
#include "svdpi.h"
extern void myfunc (svLogicPackedArrRef r); /* exported from SV */
/* output logic packed 32-bits */
...
svLogicVec32 my_r[SV_CANONICAL_SIZE(32)];
/* my array, canonical representation */
/* allocate memory for logic packed 32-bits in simulator's representation */
svLogicPackedArrRef r =
(svLogicPackedArrRef)malloc(svSizeOfLogicPackedArr(32));
myfunc(r);
/* canonical <-- actual */
1253
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
svGetLogicVec32(my_r, r, 32);
/* shall use only the canonical representation from now on */
free(r); /* do not need any more */
...
1254
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex I
(normative)
svdpi.h
I.1 General
This annex lists the contents of the include file.
svdpi.h
I.2 Overview
This is a normative include file that shall be provided by all SystemVerilog simulators. However, there is
deprecated functionality at the bottom of the file that need not be provided. This functionality is clearly
delimited by comments in the file.
Implementations shall define the types and , but the exact method of doing so is not
uint8_t uint32_t
prescribed by this standard. The section in the include file shown below is a suggested way of defining
and for a wide variety of SystemVerilog platforms.
uint8_t uint32_t
I.3 Source code
/*
* svdpi.h
*
* SystemVerilog Direct Programming Interface (DPI).
*
* This file contains the constant definitions, structure definitions,
* and routine declarations used by SystemVerilog DPI.
*/
#ifndef INCLUDED_SVDPI
#define INCLUDED_SVDPI
#ifdef __cplusplus
extern "C" {
#endif
/* Define size-critical types on all OS platforms. */
#if defined (_MSC_VER)
typedef unsigned __int64 uint64_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int8 uint8_t;
typedef signed __int64 int64_t;
typedef signed __int32 int32_t;
typedef signed __int8 int8_t;
#elif defined(__MINGW32__)
#include <stdint.h>
#elif defined(__linux)
#include <inttypes.h>
#else
#include <sys/types.h>
#endif
1255
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
/* Use to import a symbol into dll */
#if (defined(_MSC_VER) || defined(__MINGW32__) || defined(__CYGWIN__))
#define DPI_DLLISPEC __declspec(dllimport)
#else
#define DPI_DLLISPEC
#endif
/* Use to export a symbol from dll */
#if (defined(_MSC_VER) || defined(__MINGW32__) || defined(__CYGWIN__))
#define DPI_DLLESPEC __declspec(dllexport)
#else
#define DPI_DLLESPEC
#endif
/* Use to mark a function as external */
#ifndef DPI_EXTERN
#define DPI_EXTERN
#endif
#ifndef DPI_PROTOTYPES
#define DPI_PROTOTYPES
/* object is defined imported by the application */
#define XXTERN DPI_EXTERN DPI_DLLISPEC
/* object is exported by the application */
#define EETERN DPI_EXTERN DPI_DLLESPEC
#endif
/* canonical representation */
#define sv_0 0
#define sv_1 1
#define sv_z 2
#define sv_x 3
/* common type for 'bit' and 'logic' scalars. */
typedef uint8_t svScalar;
typedef svScalar svBit; /* scalar */
typedef svScalar svLogic; /* scalar */
/*
* DPI representation of packed arrays.
* 2-state and 4-state vectors, exactly the same as PLI's avalue/bvalue.
*/
#ifndef VPI_VECVAL
#define VPI_VECVAL
typedef struct t_vpi_vecval {
uint32_t aval;
uint32_t bval;
} s_vpi_vecval, *p_vpi_vecval;
#endif
/* (a chunk of) packed logic array */
typedef s_vpi_vecval svLogicVecVal;
/* (a chunk of) packed bit array */
typedef uint32_t svBitVecVal;
/* Number of chunks required to represent the given width packed array */
1256
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define SV_PACKED_DATA_NELEMS(WIDTH) (((WIDTH) + 31) >> 5)
/*
* Because the contents of the unused bits is undetermined,
* the following macros can be handy.
*/
#define SV_MASK(N) (~(-1 << (N)))
#define SV_GET_UNSIGNED_BITS(VALUE, N) \
((N) == 32 ? (VALUE) : ((VALUE) & SV_MASK(N)))
#define SV_GET_SIGNED_BITS(VALUE, N) \
((N) == 32 ? (VALUE) : \
(((VALUE) & (1 << (N))) ? ((VALUE) | ~SV_MASK(N)) : ((VALUE) & SV_MASK(N))))
/*
* Implementation-dependent representation.
*/
/*
* Return implementation version information string ("1800-2005" or "SV3.1a").
*/
XXTERN const char* svDpiVersion( void );
/* a handle to a scope (an instance of a module or interface) */
XXTERN typedef void* svScope;
/* a handle to a generic object (actually, unsized array) */
XXTERN typedef void* svOpenArrayHandle;
/*
* Bit-select utility functions.
*
* Packed arrays are assumed to be indexed n-1:0,
* where 0 is the index of LSB
*/
/* s=source, i=bit-index */
XXTERN svBit svGetBitselBit(const svBitVecVal* s, int i);
XXTERN svLogic svGetBitselLogic(const svLogicVecVal* s, int i);
/* d=destination, i=bit-index, s=scalar */
XXTERN void svPutBitselBit(svBitVecVal* d, int i, svBit s);
XXTERN void svPutBitselLogic(svLogicVecVal* d, int i, svLogic s);
/*
* Part-select utility functions.
*
* A narrow (<=32 bits) part-select is extracted from the
* source representation and written into the destination word.
*
* Normalized ranges and indexing [n-1:0] are used for both arrays.
*
* s=source, d=destination, i=starting bit index, w=width
* like for variable part-selects; limitations: w <= 32
*/
XXTERN void svGetPartselBit(svBitVecVal* d, const svBitVecVal* s, int i, int w);
XXTERN void svGetPartselLogic(svLogicVecVal* d, const svLogicVecVal* s, int i, int
w);
1257
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
XXTERN void svPutPartselBit(svBitVecVal* d, const svBitVecVal s, int i, int w);
XXTERN void svPutPartselLogic(svLogicVecVal* d, const svLogicVecVal s, int i, int w);
/*
* Open array querying functions
* These functions are modeled upon the SystemVerilog array
* querying functions and use the same semantics.
*
* If the dimension is 0, then the query refers to the
* packed part of an array (which is one-dimensional).
* Dimensions > 0 refer to the unpacked part of an array.
*/
/* h= handle to open array, d=dimension */
XXTERN int svLeft(const svOpenArrayHandle h, int d);
XXTERN int svRight(const svOpenArrayHandle h, int d);
XXTERN int svLow(const svOpenArrayHandle h, int d);
XXTERN int svHigh(const svOpenArrayHandle h, int d);
XXTERN int svIncrement(const svOpenArrayHandle h, int d);
XXTERN int svSize(const svOpenArrayHandle h, int d);
XXTERN int svDimensions(const svOpenArrayHandle h);
/*
* Pointer to the actual representation of the whole array of any type
* NULL if not in C layout
*/
XXTERN void *svGetArrayPtr(const svOpenArrayHandle);
/* total size in bytes or 0 if not in C layout */
XXTERN int svSizeOfArray(const svOpenArrayHandle);
/*
* Return a pointer to an element of the array
* or NULL if index outside the range or null pointer
*/
XXTERN void *svGetArrElemPtr(const svOpenArrayHandle, int indx1, ...);
/* specialized versions for 1-, 2- and 3-dimensional arrays: */
XXTERN void *svGetArrElemPtr1(const svOpenArrayHandle, int indx1);
XXTERN void *svGetArrElemPtr2(const svOpenArrayHandle, int indx1, int indx2);
XXTERN void *svGetArrElemPtr3(const svOpenArrayHandle, int indx1, int indx2,
int indx3);
/*
* Functions for copying between simulator storage and user space.
* These functions copy the whole packed array in either direction.
* The user is responsible for allocating an array to hold the
* canonical representation.
*/
/* s=source, d=destination */
/* From user space into simulator storage */
XXTERN void svPutBitArrElemVecVal(const svOpenArrayHandle d, const svBitVecVal* s,
int indx1, ...);
XXTERN void svPutBitArrElem1VecVal(const svOpenArrayHandle d, const svBitVecVal* s,
int indx1);
XXTERN void svPutBitArrElem2VecVal(const svOpenArrayHandle d, const svBitVecVal* s,
int indx1, int indx2);
XXTERN void svPutBitArrElem3VecVal(const svOpenArrayHandle d, const svBitVecVal* s,
int indx1, int indx2, int indx3);
1258
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
XXTERN void svPutLogicArrElemVecVal(const svOpenArrayHandle d, const svLogicVecVal*
s,
int indx1, ...);
XXTERN void svPutLogicArrElem1VecVal(const svOpenArrayHandle d, const svLogicVecVal*
s,
int indx1);
XXTERN void svPutLogicArrElem2VecVal(const svOpenArrayHandle d, const svLogicVecVal*
s,
int indx1, int indx2);
XXTERN void svPutLogicArrElem3VecVal(const svOpenArrayHandle d, const svLogicVecVal*
s,
int indx1, int indx2, int indx3);
/* From simulator storage into user space */
XXTERN void svGetBitArrElemVecVal(svBitVecVal* d, const svOpenArrayHandle s,
int indx1, ...);
XXTERN void svGetBitArrElem1VecVal(svBitVecVal* d, const svOpenArrayHandle s,
int indx1);
XXTERN void svGetBitArrElem2VecVal(svBitVecVal* d, const svOpenArrayHandle s,
int indx1, int indx2);
XXTERN void svGetBitArrElem3VecVal(svBitVecVal* d, const svOpenArrayHandle s,
int indx1, int indx2, int indx3);
XXTERN void svGetLogicArrElemVecVal(svLogicVecVal* d, const svOpenArrayHandle s,
int indx1, ...);
XXTERN void svGetLogicArrElem1VecVal(svLogicVecVal* d, const svOpenArrayHandle s,
int indx1);
XXTERN void svGetLogicArrElem2VecVal(svLogicVecVal* d, const svOpenArrayHandle s,
int indx1, int indx2);
XXTERN void svGetLogicArrElem3VecVal(svLogicVecVal* d, const svOpenArrayHandle s,
int indx1, int indx2, int indx3);
XXTERN svBit svGetBitArrElem(const svOpenArrayHandle s, int indx1, ...);
XXTERN svBit svGetBitArrElem1(const svOpenArrayHandle s, int indx1);
XXTERN svBit svGetBitArrElem2(const svOpenArrayHandle s, int indx1, int indx2);
XXTERN svBit svGetBitArrElem3(const svOpenArrayHandle s, int indx1, int indx2,
int indx3);
XXTERN svLogic svGetLogicArrElem(const svOpenArrayHandle s, int indx1, ...);
XXTERN svLogic svGetLogicArrElem1(const svOpenArrayHandle s, int indx1);
XXTERN svLogic svGetLogicArrElem2(const svOpenArrayHandle s, int indx1, int indx2);
XXTERN svLogic svGetLogicArrElem3(const svOpenArrayHandle s, int indx1, int indx2,
int indx3);
XXTERN void svPutLogicArrElem(const svOpenArrayHandle d, svLogic value, int indx1,
...);
XXTERN void svPutLogicArrElem1(const svOpenArrayHandle d, svLogic value, int indx1);
XXTERN void svPutLogicArrElem2(const svOpenArrayHandle d, svLogic value, int indx1,
int indx2);
XXTERN void svPutLogicArrElem3(const svOpenArrayHandle d, svLogic value, int indx1,
int indx2, int indx3);
XXTERN void svPutBitArrElem(const svOpenArrayHandle d, svBit value, int indx1, ...);
XXTERN void svPutBitArrElem1(const svOpenArrayHandle d, svBit value, int indx1);
XXTERN void svPutBitArrElem2(const svOpenArrayHandle d, svBit value, int indx1,
int indx2);
XXTERN void svPutBitArrElem3(const svOpenArrayHandle d, svBit value, int indx1,
int indx2, int indx3);
/* Functions for working with DPI context */
/*
1259
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
* Retrieve the active instance scope currently associated with the executing
* imported function. Unless a prior call to svSetScope has occurred, this
* is the scope of the function's declaration site, not call site.
* Returns NULL if called from C code that is *not* an imported function.
*/
XXTERN svScope svGetScope( void );
/*
* Set context for subsequent export function execution.
* This function must be called before calling an export function, unless
* the export function is called while executing an import function. In that
* case the export function shall inherit the scope of the surrounding import
* function. This is known as the "default scope".
* The return is the previous active scope (per svGetScope)
*/
XXTERN svScope svSetScope(const svScope scope);
/* Gets the fully qualified name of a scope handle */
XXTERN const char* svGetNameFromScope(const svScope);
/*
* Retrieve svScope to instance scope of an arbitrary function declaration.
* (can be either module, program, interface, or generate scope)
* The return value shall be NULL for unrecognized scope names.
*/
XXTERN svScope svGetScopeFromName(const char* scopeName);
/*
* Store an arbitrary user data pointer for later retrieval by svGetUserData()
* The userKey is generated by the user. It must be guaranteed by the user to
* be unique from all other userKey's for all unique data storage requirements
* It is recommended that the address of static functions or variables in the
* user's C code be used as the userKey.
* It is illegal to pass in NULL values for either the scope or userData
* arguments. It is also an error to call svPutUserData() with an invalid
* svScope. This function returns -1 for all error cases, 0 upon success. It is
* suggested that userData values of 0 (NULL) not be used as otherwise it can
* be impossible to discern error status returns when calling svGetUserData()
*/
XXTERN int svPutUserData(const svScope scope, void *userKey, void* userData);
/*
* Retrieve an arbitrary user data pointer that was previously
* stored by a call to svPutUserData(). See the comment above
* svPutUserData() for an explanation of userKey, as well as
* restrictions on NULL and illegal svScope and userKey values.
* This function returns NULL for all error cases, 0 upon success.
* This function also returns NULL in the event that a prior call
* to svPutUserData() was never made.
*/
XXTERN void* svGetUserData(const svScope scope, void* userKey);
/*
* Returns the file and line number in the SV code from which the import call
* was made. If this information available, returns TRUE and updates fileName
* and lineNumber to the appropriate values. Behavior is unpredictable if
* fileName or lineNumber are not appropriate pointers. If this information is
* not available return FALSE and contents of fileName and lineNumber not
* modified. Whether this information is available or not is implementation-
* specific. Note that the string provided (if any) is owned by the SV
* implementation and is valid only until the next call to any SV function.
1260
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
* Applications must not modify this string or free it
*/
XXTERN int svGetCallerInfo(const char** fileName, int *lineNumber);
/*
* Returns 1 if the current execution thread is in the disabled state.
* Disable protocol must be adhered to if in the disabled state.
*/
XXTERN int svIsDisabledState( void );
/*
* Imported functions call this API function during disable processing to
* acknowledge that they are correctly participating in the DPI disable protocol.
* This function must be called before returning from an imported function that is
* in the disabled state.
*/
XXTERN void svAckDisabledState( void );
/*
**********************************************************
* DEPRECATED PORTION OF FILE STARTS FROM HERE.
* IEEE-1800-compliant tools may not provide
* support for the following functionality.
**********************************************************
*/
/*
* Canonical representation of packed arrays
* 2-state and 4-state vectors, modeled upon PLI's avalue/bvalue
*/
#define SV_CANONICAL_SIZE(WIDTH) (((WIDTH)+31)>>5)
typedef unsigned int svBitVec32;/* (a chunk of) packed bit array */
typedef struct { unsigned int c; unsigned int d;}
svLogicVec32; /* (a chunk of) packed logic array */
/* reference to a standalone packed array */
typedef void* svBitPackedArrRef;
typedef void* svLogicPackedArrRef;
/*
* total size in bytes of the simulator's representation of a packed array
* width in bits
*/
XXTERN int svSizeOfBitPackedArr(int width);
XXTERN int svSizeOfLogicPackedArr(int width);
/* Translation between the actual representation and the canonical representation */
/* s=source, d=destination, w=width */
/* actual <-- canonical */
XXTERN void svPutBitVec32(svBitPackedArrRef d, const svBitVec32* s, int w);
XXTERN void svPutLogicVec32(svLogicPackedArrRef d, const svLogicVec32* s, int w);
/* canonical <-- actual */
XXTERN void svGetBitVec32(svBitVec32* d, const svBitPackedArrRef s, int w);
XXTERN void svGetLogicVec32(svLogicVec32* d, const svLogicPackedArrRef s, int w);
/*
* Bit-select functions
1261
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
* Packed arrays are assumed to be indexed n-1:0,
* where 0 is the index of LSB
*/
/* s=source, i=bit-index */
XXTERN svBit svGetSelectBit(const svBitPackedArrRef s, int i);
XXTERN svLogic svGetSelectLogic(const svLogicPackedArrRef s, int i);
/* d=destination, i=bit-index, s=scalar */
XXTERN void svPutSelectBit(svBitPackedArrRef d, int i, svBit s);
XXTERN void svPutSelectLogic(svLogicPackedArrRef d, int i, svLogic s);
/*
* functions for part-select
*
* a narrow (<=32 bits) part-select is copied between
* the implementation representation and a single chunk of
* canonical representation
* Normalized ranges and indexing [n-1:0] are used for both arrays:
* the array in the implementation representation and the canonical array.
*
* s=source, d=destination, i=starting bit index, w=width
* like for variable part-selects; limitations: w <= 32
*/
/* canonical <-- actual */
XXTERN void svGetPartSelectBit(svBitVec32* d, const svBitPackedArrRef s,
int i, int w);
XXTERN svBitVec32 svGetBits(const svBitPackedArrRef s, int i, int w);
XXTERN svBitVec32 svGet32Bits(const svBitPackedArrRef s, int i); /* 32-bits */
XXTERN uint64_t svGet64Bits(const svBitPackedArrRef s, int i);
/* 64-bits */
XXTERN void svGetPartSelectLogic(svLogicVec32* d, const svLogicPackedArrRef s,
int i, int w);
/* actual <-- canonical */
XXTERN void svPutPartSelectBit(svBitPackedArrRef d, const svBitVec32 s,
int i, int w);
XXTERN void svPutPartSelectLogic(svLogicPackedArrRef d, const svLogicVec32 s,
int i, int w);
/*
* Functions for open array translation between simulator and canonical
* representations. These functions copy the whole packed array in either
* direction. The user is responsible for allocating an array in the
* canonical representation.
*/
/* s=source, d=destination */
/* actual <-- canonical */
XXTERN void svPutBitArrElemVec32(const svOpenArrayHandle d, const svBitVec32* s,
int indx1, ...);
XXTERN void svPutBitArrElem1Vec32(const svOpenArrayHandle d, const svBitVec32* s,
int indx1);
XXTERN void svPutBitArrElem2Vec32(const svOpenArrayHandle d, const svBitVec32* s,
int indx1, int indx2);
XXTERN void svPutBitArrElem3Vec32(const svOpenArrayHandle d, const svBitVec32* s,
int indx1, int indx2, int indx3);
XXTERN void svPutLogicArrElemVec32(const svOpenArrayHandle d, const svLogicVec32* s,
int indx1, ...);
1262
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
XXTERN void svPutLogicArrElem1Vec32(const svOpenArrayHandle d, const svLogicVec32* s,
int indx1);
XXTERN void svPutLogicArrElem2Vec32(const svOpenArrayHandle d, const svLogicVec32* s,
int indx1, int indx2);
XXTERN void svPutLogicArrElem3Vec32(const svOpenArrayHandle d, const svLogicVec32* s,
int indx1, int indx2, int indx3);
/* canonical <-- actual */
XXTERN void svGetBitArrElemVec32(svBitVec32* d, const svOpenArrayHandle s,
int indx1, ...);
XXTERN void svGetBitArrElem1Vec32(svBitVec32* d, const svOpenArrayHandle s,
int indx1);
XXTERN void svGetBitArrElem2Vec32(svBitVec32* d, const svOpenArrayHandle s,
int indx1, int indx2);
XXTERN void svGetBitArrElem3Vec32(svBitVec32* d, const svOpenArrayHandle s,
int indx1, int indx2, int indx3);
XXTERN void svGetLogicArrElemVec32(svLogicVec32* d, const svOpenArrayHandle s,
int indx1, ...);
XXTERN void svGetLogicArrElem1Vec32(svLogicVec32* d, const svOpenArrayHandle s,
int indx1);
XXTERN void svGetLogicArrElem2Vec32(svLogicVec32* d, const svOpenArrayHandle s,
int indx1, int indx2);
XXTERN void svGetLogicArrElem3Vec32(svLogicVec32* d, const svOpenArrayHandle s,
int indx1, int indx2, int indx3);
/*
**********************************************************
* DEPRECATED PORTION OF FILE ENDS HERE.
**********************************************************
*/
#undef DPI_EXTERN
#ifdef DPI_PROTOTYPES
#undef DPI_PROTOTYPES
#undef XXTERN
#undef EETERN
#endif
#ifdef __cplusplus
}
#endif
#endif
1263
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex J
(normative)
Inclusion of foreign language code
J.1 General
This annex describes common guidelines for the inclusion of foreign language code into a SystemVerilog
application. The intention of these guidelines is to enable the redistribution of C binaries in shared object
form.
J.2 Overview
Foreign language code is functionality that is included into SystemVerilog using the DPI. As a result, all
statements of this annex apply only to code included using this interface; code included by using other
interfaces (e.g., VPI) is outside the scope of this standard. Due to the nature of the DPI, most foreign
language code is usually created from C or C++ source code, although nothing precludes the creation of
appropriate object code from other languages. This annex adheres to this rule: its content is independent
from the actual language used.
In general, foreign language code is provided in the form of object code compiled for the actual platform.
The capability to include foreign language code in object-code form shall be supported by all simulators as
specified here.
This annex defines how to
— Specify the location of the corresponding files within the file system.
— Specify the files to be loaded (in case of object code).
— Provide the object code (as a shared library or archive).
Although this annex defines guidelines for a common inclusion methodology, it requires multiple
implementations (usually two) of the corresponding facilities. This takes into account that multiple users can
have different viewpoints and different requirements on the inclusion of foreign language code.
— A vendor that wants to provide its intellectual property (IP) in the form of foreign language code
often requires a self-contained method for the integration, which still permits an integration by a
third party. This use case is often covered by a bootstrap file approach.
— A project team that specifies a common, standard set of foreign language code might change the
code depending on technology, selected cells, back-annotation data, and other items. This use case is
often covered by a set of tool switches, although it might also use the bootstrap file approach.
— An user might want to switch between selections or provide additional code. This use case is
covered by providing a set of tool switches to define the corresponding information, although it
might also use the bootstrap file approach.
NOTE—This annex defines a set of switch names to be used for a particular functionality. This is of informative nature;
the actual naming of switches is not part of this standard. Further, it might not be possible to use certain character
configurations in all operating systems or shells. Therefore, any switch name defined within this standard is a
recommendation on how to name a switch, but not a requirement of the language.
1264
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
J.3 Location independence
All path names specified within this annex are intended to be location independent, which is accomplished
by using the switch . It can receive a single directory path name as the value, which is then
-sv_root
prepended to any relative path name that has been specified. In absence of this switch, or when processing
relative file names before any specification, the current working directory of the user shall be
-sv_root
used as the default value.
J.4 Object code inclusion
Compiled object code is required for cases where the compilation and linking of source code are fully
handled by the user; thus, the created object code only need be loaded to integrate the foreign language code
into a SystemVerilog application. All SystemVerilog applications shall support the integration of foreign
language code in object code form. FigureJ.1 depicts the inclusion of object code and its relations to the
various steps involved in this integration process.
Performed by the user Object code
inclusion
Source System-
Object
code Verilog
code
application
Compile Link Load
Figure J.1—Inclusion of object code into a SystemVerilog application
Compiled object code can be specified by one of the following two methods:
a) By an entry in a bootstrap file; see J.4.1 for more details on this file and its content. Its location shall
be specified with one instance of the switch pathname. This switch can be used
-sv_liblist
multiple times to define the usage of multiple bootstrap files.
b) By specifying the file with one instance of the switch pathname_without_
-sv_lib
extension (i.e., the file name shall be specified without the platform-specific extension). The
SystemVerilog application is responsible for appending the appropriate extension for the actual
platform. This switch can be used multiple times to define multiple libraries holding object code.
Both methods shall be provided and made available concurrently to permit any mixture of their usage. Every
location can be an absolute path name or a relative path name, where the value of the switch is
-sv_root
used to identify an appropriate prefix for relative path names (see J.3 for more details on forming path
names).
The following conditions also apply:
— The compiled object code itself shall be provided in the form of a shared library having the
appropriate extension for the actual platform.
NOTE—Shared libraries use, for example, for Solaris and for HP-UX; other operating systems might use
.so .sl
different extensions. In any case, the SystemVerilog application needs to identify the appropriate extension.
— The provider of the compiled code is responsible for any external references specified within these
objects. Appropriate data need to be provided to resolve all open dependencies with the correct
information.
1265
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
— The provider of the compiled code shall avoid interferences with other software and select the
appropriate software version (e.g., in cases where two versions of the same library are referenced).
Similar problems can arise when there are dependencies on the expected run-time environment in
the compiled object code (e.g., in cases where C++ global objects or static initializers are used).
— The SystemVerilog application need only load object code within a shared library that is referenced
by the SystemVerilog code or by registration functions; loading of additional functions included
within a shared library can interfere with other parts.
In the case of multiple occurrences of the same file (files having the same path name or that can easily be
identified as being identical, e.g., by comparing the inodes of the files to detect cases where links are used to
refer the same file), the above order also identifies the precedence of loading. A file located by method a)
(previously shown in this subclause) shall override files specified by method b).
All compiled object code needs to be loaded in the specification order similarly to the preceding scheme;
first the content of the bootstrap file is processed starting with the first line, then the set of
-sv_lib
switches is processed in order of their occurrence. Any library shall only be loaded once.
J.4.1 Bootstrap file
The object code bootstrap file has the following syntax:
a) The first line contains the string .
#!SV_LIBRARIES
b) An arbitrary amount of entries follow, one entry per line, where every entry holds exactly one
library location. Each entry consists only of the pathname_without_extension of the object
code file to be loaded and can be surrounded by an arbitrary number of blanks; at least one blank
shall precede the entry in the line. The value pathname_without_extension is equivalent to
the value of the switch .
-sv_lib
c) Any amount of comment lines can be interspersed between the entry lines; a comment line starts
with the character after an arbitrary (including zero) amount of blanks and is terminated with a
#
newline character.
J.4.2 Examples
a) If the path-name root has been set by the switch to and the following object
-sv_root /home/user
files need to be included:
/home/user/myclibs/lib1.so
/home/user/myclibs/lib3.so
/home/user/proj1/clibs/lib4.so
/home/user/proj3/clibs/lib2.so
then use either of the methods in FigureJ.2. Both methods are equivalent.
...
#!SV_LIBRARIES -sv_lib myclibs/lib1
myclibs/lib1 -sv_lib myclibs/lib3
myclibs/lib3 -sv_lib proj1/clibs/lib4
proj1/clibs/lib4 -sv_lib proj3/clibs/lib2
proj3/clibs/lib2 ...
Bootstrap file method Switch list method
Figure J.2—Using a simple bootstrap file or a switch list
1266
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
b) If the current working directory is , using the series of switches shown in FigureJ.3
/home/user
(left column) results in loading the following files (right column):
-sv_lib svLibrary1 /home/user/svLibrary1.so
-sv_lib svLibrary2 /home/user/svLibrary2.so
-sv_root /home/project2/shared_code
-sv_lib svLibrary3 /home/project2/shared_code/svLibrary3.so
-sv_root /home/project3/code
-sv_lib svLibrary4 /home/project3/code/svLibrary4.so
Switches Files
Figure J.3—Using a combination of and switches
-sv_lib -sv_root
c) Further, using the set of switches and contents of bootstrap files shown in FigureJ.4:
bootstrap1:
-sv_root /home/usr1 #! SV_LIBRARIES
-sv_liblist bootstrap1 lib1
lib2
-sv_root /home/usr2
bootstrap2:
-sv_liblist /home/mine/bootstrap2 #! SV_LIBRARIES
lib3
/common/libx
lib5
Figure J.4—Mixing and bootstrap files
-sv_root
results in loading the following files:
ext
/home/usr1/lib1.
ext
/home/usr1/lib2.
ext
/home/usr2/lib3.
ext
/common/libx.
ext
/home/usr2/lib5.
where ext stands for the actual extension of the corresponding file.
1267
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIEadEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex K
(normative)
vpi_user.h
K.1 General
This annex shows the contents of the include file. This is a normative include file that shall be
vpi_user.h
provided by all SystemVerilog simulators.
K.2 Source code
/*******************************************************************************
* vpi_user.h
*
* IEEE Std 1800 Programming Language Interface (PLI)
*
* This file contains the constant definitions, structure definitions, and
* routine declarations used by the SystemVerilog Verification Procedural
* Interface (VPI) access routines.
*
******************************************************************************/
/*******************************************************************************
* NOTE: the constant values 1 through 299 are reserved for use in this
* vpi_user.h file.
******************************************************************************/
#ifndef VPI_USER_H
#define VPI_USER_H
#include <stdarg.h>
#ifdef __cplusplus
extern "C" {
#endif
/*----------------------------------------------------------------------------*/
/*----------------------------- Portability Help -----------------------------*/
/*----------------------------------------------------------------------------*/
/* Define size-critical types on all OS platforms. */
#if defined (_MSC_VER)
typedef unsigned __int64 uint64_t;
typedef unsigned __int32 uint32_t;
typedef unsigned __int8 uint8_t;
typedef signed __int64 int64_t;
typedef signed __int32 int32_t;
typedef signed __int8 int8_t;
#elif defined(__MINGW32__)
#include <stdint.h>
#elif defined(__linux)
#include <inttypes.h>
#else
#include <sys/types.h>
1268
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#endif
/* Sized variables */
#ifndef SVPI_TYPES
#define SVPI_TYPES
typedef int64_t PLI_INT64;
typedef uint64_t PLI_UINT64;
#endif
#ifndef PLI_TYPES
#define PLI_TYPES
typedef int PLI_INT32;
typedef unsigned int PLI_UINT32;
typedef short PLI_INT16;
typedef unsigned short PLI_UINT16;
typedef char PLI_BYTE8;
typedef unsigned char PLI_UBYTE8;
#endif
/* Use to import a symbol */
#if (defined(_MSC_VER) || defined(__MINGW32__) || defined(__CYGWIN__))
#ifndef PLI_DLLISPEC
#define PLI_DLLISPEC __declspec(dllimport)
#define VPI_USER_DEFINED_DLLISPEC 1
#endif
#else
#ifndef PLI_DLLISPEC
#define PLI_DLLISPEC
#endif
#endif
/* Use to export a symbol */
#if (defined(_MSC_VER) || defined(__MINGW32__) || defined(__CYGWIN__))
#ifndef PLI_DLLESPEC
#define PLI_DLLESPEC __declspec(dllexport)
#define VPI_USER_DEFINED_DLLESPEC 1
#endif
#else
#ifndef PLI_DLLESPEC
#define PLI_DLLESPEC
#endif
#endif
/* Use to mark a function as external */
#ifndef PLI_EXTERN
#define PLI_EXTERN
#endif
/* Use to mark a variable as external */
#ifndef PLI_VEXTERN
#define PLI_VEXTERN extern
#endif
#ifndef PLI_PROTOTYPES
#define PLI_PROTOTYPES
#define PROTO_PARAMS(params) params
/* object is defined imported by the application */
1269
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define XXTERN PLI_EXTERN PLI_DLLISPEC
/* object is exported by the application */
#define EETERN PLI_EXTERN PLI_DLLESPEC
#endif
/********************************** TYPEDEFS **********************************/
typedef PLI_UINT32 *vpiHandle;
/******************************** OBJECT TYPES ********************************/
#define vpiAlways 1 /* always procedure*/
#define vpiAssignStmt 2 /* quasi-continuous assignment */
#define vpiAssignment 3 /* procedural assignment */
#define vpiBegin 4 /* block statement */
#define vpiCase 5 /* case statement */
#define vpiCaseItem 6 /* case statement item */
#define vpiConstant 7 /* numerical constant or string literal */
#define vpiContAssign 8 /* continuous assignment */
#define vpiDeassign 9 /* deassignment statement */
#define vpiDefParam 10 /* defparam */
#define vpiDelayControl 11 /* delay statement (e.g., #10) */
#define vpiDisable 12 /* named block disable statement */
#define vpiEventControl 13 /* wait on event, e.g., @e */
#define vpiEventStmt 14 /* event trigger, e.g., ->e */
#define vpiFor 15 /* for statement */
#define vpiForce 16 /* force statement */
#define vpiForever 17 /* forever statement */
#define vpiFork 18 /* fork-join block */
#define vpiFuncCall 19 /* function call */
#define vpiFunction 20 /* function */
#define vpiGate 21 /* primitive gate */
#define vpiIf 22 /* if statement */
#define vpiIfElse 23 /* if–else statement */
#define vpiInitial 24 /* initial procedure */
#define vpiIntegerVar 25 /* integer variable */
#define vpiInterModPath 26 /* intermodule wire delay */
#define vpiIterator 27 /* iterator */
#define vpiIODecl 28 /* input/output declaration */
#define vpiMemory 29 /* behavioral memory */
#define vpiMemoryWord 30 /* single word of memory */
#define vpiModPath 31 /* module path for path delays */
#define vpiModule 32 /* module instance */
#define vpiNamedBegin 33 /* named block statement */
#define vpiNamedEvent 34 /* event variable */
#define vpiNamedFork 35 /* named fork-join block */
#define vpiNet 36 /* scalar or vector net */
#define vpiNetBit 37 /* bit of vector net */
#define vpiNullStmt 38 /* a semicolon. Ie. #10 ; */
#define vpiOperation 39 /* behavioral operation */
#define vpiParamAssign 40 /* module parameter assignment */
#define vpiParameter 41 /* module parameter */
#define vpiPartSelect 42 /* part-select */
#define vpiPathTerm 43 /* terminal of module path */
#define vpiPort 44 /* module port */
#define vpiPortBit 45 /* bit of vector module port */
#define vpiPrimTerm 46 /* primitive terminal */
#define vpiRealVar 47 /* real variable */
#define vpiReg 48 /* scalar or vector reg */
#define vpiRegBit 49 /* bit of vector reg */
#define vpiRelease 50 /* release statement */
#define vpiRepeat 51 /* repeat statement */
1270
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiRepeatControl 52 /* repeat control in an assign stmt */
#define vpiSchedEvent 53 /* vpi_put_value() event */
#define vpiSpecParam 54 /* specparam */
#define vpiSwitch 55 /* transistor switch */
#define vpiSysFuncCall 56 /* system function call */
#define vpiSysTaskCall 57 /* system task call */
#define vpiTableEntry 58 /* UDP state table entry */
#define vpiTask 59 /* task */
#define vpiTaskCall 60 /* task call */
#define vpiTchk 61 /* timing check */
#define vpiTchkTerm 62 /* terminal of timing check */
#define vpiTimeVar 63 /* time variable */
#define vpiTimeQueue 64 /* simulation event queue */
#define vpiUdp 65 /* user-defined primitive */
#define vpiUdpDefn 66 /* UDP definition */
-
#define vpiUserSystf 67 /* user defined system task/function */
#define vpiVarSelect 68 /* variable array selection */
#define vpiWait 69 /* wait statement */
#define vpiWhile 70 /* while statement */
/********************** object types added with 1364-2001 *********************/
#define vpiAttribute 105 /* attribute of an object */
#define vpiBitSelect 106 /* Bit-select of parameter, var select */
#define vpiCallback 107 /* callback object */
#define vpiDelayTerm 108 /* Delay term which is a load or driver */
#define vpiDelayDevice 109 /* Delay object within a net */
#define vpiFrame 110 /* reentrant task/func frame */
#define vpiGateArray 111 /* gate instance array */
#define vpiModuleArray 112 /* module instance array */
#define vpiPrimitiveArray 113 /* vpiprimitiveArray type */
#define vpiNetArray 114 /* multidimensional net */
#define vpiRange 115 /* range declaration */
#define vpiRegArray 116 /* multidimensional reg */
#define vpiSwitchArray 117 /* switch instance array */
#define vpiUdpArray 118 /* UDP instance array */
#define vpiContAssignBit 128 /* Bit of a vector continuous assignment */
#define vpiNamedEventArray 129 /* multidimensional named event */
/********************** object types added with 1364-2005 *********************/
#define vpiIndexedPartSelect 130 /* Indexed part-select object */
#define vpiGenScopeArray 133 /* array of generated scopes */
#define vpiGenScope 134 /* A generated scope */
#define vpiGenVar 135 /* Object used to instantiate gen scopes */
/*********************************** METHODS **********************************/
/**************** methods used to traverse 1 to 1 relationships ***************/
#define vpiCondition 71 /* condition expression */
#define vpiDelay 72 /* net or gate delay */
#define vpiElseStmt 73 /* else statement */
#define vpiForIncStmt 74 /* increment statement in for loop */
#define vpiForInitStmt 75 /* initialization statement in for loop */
#define vpiHighConn 76 /* higher connection to port */
#define vpiLhs 77 /* left-hand side of assignment */
#define vpiIndex 78 /* index of var select, bit-select, etc. */
#define vpiLeftRange 79 /* left range of vector or part-select */
#define vpiLowConn 80 /* lower connection to port */
#define vpiParent 81 /* parent object */
#define vpiRhs 82 /* right-hand side of assignment */
#define vpiRightRange 83 /* right range of vector or part-select */
#define vpiScope 84 /* containing scope object */
#define vpiSysTfCall 85 /* task function call */
1271
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiTchkDataTerm 86 /* timing check data term */
#define vpiTchkNotifier 87 /* timing check notifier */
#define vpiTchkRefTerm 88 /* timing check reference term */
/************* methods used to traverse 1 to many relationships ***************/
#define vpiArgument 89 /* argument to (system) task/function */
#define vpiBit 90 /* bit of vector net or port */
#define vpiDriver 91 /* driver for a net */
#define vpiInternalScope 92 /* internal scope in module */
#define vpiLoad 93 /* load on net or reg */
#define vpiModDataPathIn 94 /* data terminal of a module path */
#define vpiModPathIn 95 /* Input terminal of a module path */
#define vpiModPathOut 96 /* output terminal of a module path */
#define vpiOperand 97 /* operand of expression */
#define vpiPortInst 98 /* connected port instance */
#define vpiProcess 99 /* process in module, program or interface */
#define vpiVariables 100 /* variables in module */
#define vpiUse 101 /* usage */
/******** methods which can traverse 1 to 1, or 1 to many relationships *******/
#define vpiExpr 102 /* connected expression */
#define vpiPrimitive 103 /* primitive (gate, switch, UDP) */
#define vpiStmt 104 /* statement in process or task */
/************************ methods added with 1364-2001 ************************/
#define vpiActiveTimeFormat 119 /* active $timeformat() system task */
#define vpiInTerm 120 /* To get to a delay device's drivers. */
#define vpiInstanceArray 121 /* vpiInstance arrays */
#define vpiLocalDriver 122 /* local drivers (within a module */
#define vpiLocalLoad 123 /* local loads (within a module */
#define vpiOutTerm 124 /* To get to a delay device's loads. */
#define vpiPorts 125 /* Module port */
#define vpiSimNet 126 /* simulated net after collapsing */
#define vpiTaskFunc 127 /* task/function */
/************************ methods added with 1364-2005 ************************/
#define vpiBaseExpr 131 /* Indexed part-select's base expression */
#define vpiWidthExpr 132 /* Indexed part-select's width expression */
/************************ methods added with 1800-2009 ************************/
#define vpiAutomatics 136 /* Automatic variables of a frame */
/********************************* PROPERTIES *********************************/
/************************** generic object properties *************************/
#define vpiUndefined -1 /* undefined property */
#define vpiType 1 /* type of object */
#define vpiName 2 /* local name of object */
#define vpiFullName 3 /* full hierarchical name */
#define vpiSize 4 /* size of gate, net, port, etc. */
#define vpiFile 5 /* File name in which the object is used*/
#define vpiLineNo 6 /* line number where the object is used */
/***************************** module properties ******************************/
#define vpiTopModule 7 /* top-level module (Boolean) */
#define vpiCellInstance 8 /* cell (Boolean) */
#define vpiDefName 9 /* module definition name */
#define vpiProtected 10 /* source protected module (Boolean) */
1272
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiTimeUnit 11 /* module time unit */
#define vpiTimePrecision 12 /* module time precision */
#define vpiDefNetType 13 /* default net type */
#define vpiUnconnDrive 14 /* unconnected port drive strength */
#define vpiHighZ 1 /* No default drive given */
#define vpiPull1 2 /* default pull1 drive */
#define vpiPull0 3 /* default pull0 drive */
#define vpiDefFile 15 /* File name where the module is defined*/
#define vpiDefLineNo 16 /* line number for module definition */
#define vpiDefDelayMode 47 /* Default delay mode for a module */
#define vpiDelayModeNone 1 /* no delay mode specified */
#define vpiDelayModePath 2 /* path delay mode */
#define vpiDelayModeDistrib 3 /* distributed delay mode */
#define vpiDelayModeUnit 4 /* unit delay mode */
#define vpiDelayModeZero 5 /* zero delay mode */
#define vpiDelayModeMTM 6 /* min:typ:max delay mode */
#define vpiDefDecayTime 48 /* Default decay time for a module */
/*************************** port and net properties **************************/
#define vpiScalar 17 /* scalar (Boolean) */
#define vpiVector 18 /* vector (Boolean) */
#define vpiExplicitName 19 /* port is explicitly named */
#define vpiDirection 20 /* direction of port: */
#define vpiInput 1 /* input */
#define vpiOutput 2 /* output */
#define vpiInout 3 /* inout */
#define vpiMixedIO 4 /* mixed input-output */
#define vpiNoDirection 5 /* no direction */
#define vpiConnByName 21 /* connected by name (Boolean) */
#define vpiNetType 22 /* net subtypes: */
#define vpiWire 1 /* wire net */
#define vpiWand 2 /* wire-and net */
#define vpiWor 3 /* wire-or net */
#define vpiTri 4 /* tri net */
#define vpiTri0 5 /* pull-down net */
#define vpiTri1 6 /* pull-up net */
#define vpiTriReg 7 /* three-state reg net */
#define vpiTriAnd 8 /* three-state wire-and net */
#define vpiTriOr 9 /* three-state wire-or net */
#define vpiSupply1 10 /* supply-1 net */
#define vpiSupply0 11 /* supply-0 net */
#define vpiNone 12 /* no default net type (1364-2001) */
#define vpiUwire 13 /* unresolved wire net (1364-2005) */
#define vpiExplicitScalared 23 /* explicitly scalared (Boolean) */
#define vpiExplicitVectored 24 /* explicitly vectored (Boolean) */
#define vpiExpanded 25 /* expanded vector net (Boolean) */
#define vpiImplicitDecl 26 /* implicitly declared net (Boolean) */
#define vpiChargeStrength 27 /* charge decay strength of net */
/* Defined as part of strengths section.
#define vpiLargeCharge 0x10
#define vpiMediumCharge 0x04
#define vpiSmallCharge 0x02
*/
#define vpiArray 28 /* variable array (Boolean) */
#define vpiPortIndex 29 /* Port index */
/************************ gate and terminal properties ************************/
#define vpiTermIndex 30 /* Index of a primitive terminal */
1273
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiStrength0 31 /* 0-strength of net or gate */
#define vpiStrength1 32 /* 1-strength of net or gate */
#define vpiPrimType 33 /* primitive subtypes: */
#define vpiAndPrim 1 /* and gate */
#define vpiNandPrim 2 /* nand gate */
#define vpiNorPrim 3 /* nor gate */
#define vpiOrPrim 4 /* or gate */
#define vpiXorPrim 5 /* xor gate */
#define vpiXnorPrim 6 /* xnor gate */
#define vpiBufPrim 7 /* buffer */
#define vpiNotPrim 8 /* not gate */
#define vpiBufif0Prim 9 /* zero-enabled buffer */
#define vpiBufif1Prim 10 /* one-enabled buffer */
#define vpiNotif0Prim 11 /* zero-enabled not gate */
#define vpiNotif1Prim 12 /* one-enabled not gate */
#define vpiNmosPrim 13 /* nmos switch */
#define vpiPmosPrim 14 /* pmos switch */
#define vpiCmosPrim 15 /* cmos switch */
#define vpiRnmosPrim 16 /* resistive nmos switch */
#define vpiRpmosPrim 17 /* resistive pmos switch */
#define vpiRcmosPrim 18 /* resistive cmos switch */
#define vpiRtranPrim 19 /* resistive bidirectional */
#define vpiRtranif0Prim 20 /* zero-enable resistive bidirectional */
#define vpiRtranif1Prim 21 /* one-enable resistive bidirectional */
#define vpiTranPrim 22 /* bidirectional */
#define vpiTranif0Prim 23 /* zero-enabled bidirectional */
#define vpiTranif1Prim 24 /* one-enabled bidirectional */
#define vpiPullupPrim 25 /* pullup */
#define vpiPulldownPrim 26 /* pulldown */
#define vpiSeqPrim 27 /* sequential UDP */
#define vpiCombPrim 28 /* combinational UDP */
/**************** path, path terminal, timing check properties ****************/
#define vpiPolarity 34 /* polarity of module path... */
#define vpiDataPolarity 35 /* ...or data path: */
#define vpiPositive 1 /* positive */
#define vpiNegative 2 /* negative */
#define vpiUnknown 3 /* unknown (unspecified) */
#define vpiEdge 36 /* edge type of module path: */
#define vpiNoEdge 0x00 /* no edge */
#define vpiEdge01 0x01 /* 0 -> 1 */
#define vpiEdge10 0x02 /* 1 -> 0 */
#define vpiEdge0x 0x04 /* 0 -> x */
#define vpiEdgex1 0x08 /* x -> 1 */
#define vpiEdge1x 0x10 /* 1 -> x */
#define vpiEdgex0 0x20 /* x -> 0 */
#define vpiPosedge (vpiEdgex1 | vpiEdge01 | vpiEdge0x)
#define vpiNegedge (vpiEdgex0 | vpiEdge10 | vpiEdge1x)
#define vpiAnyEdge (vpiPosedge | vpiNegedge)
#define vpiPathType 37 /* path delay connection subtypes: */
#define vpiPathFull 1 /* ( a *> b ) */
#define vpiPathParallel 2 /* ( a => b ) */
#define vpiTchkType 38 /* timing check subtypes: */
#define vpiSetup 1 /* $setup */
#define vpiHold 2 /* $hold */
#define vpiPeriod 3 /* $period */
#define vpiWidth 4 /* $width */
#define vpiSkew 5 /* $skew */
#define vpiRecovery 6 /* $recovery */
#define vpiNoChange 7 /* $nochange */
1274
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiSetupHold 8 /* $setuphold */
#define vpiFullskew 9 /* $fullskew -- added for 1364-2001 */
#define vpiRecrem 10 /* $recrem -- added for 1364-2001 */
#define vpiRemoval 11 /* $removal -- added for 1364-2001 */
#define vpiTimeskew 12 /* $timeskew -- added for 1364-2001 */
/**************************** expression properties ***************************/
#define vpiOpType 39 /* operation subtypes: */
#define vpiMinusOp 1 /* unary minus */
#define vpiPlusOp 2 /* unary plus */
#define vpiNotOp 3 /* unary not */
#define vpiBitNegOp 4 /* bitwise negation */
#define vpiUnaryAndOp 5 /* bitwise reduction AND */
#define vpiUnaryNandOp 6 /* bitwise reduction NAND */
#define vpiUnaryOrOp 7 /* bitwise reduction OR */
#define vpiUnaryNorOp 8 /* bitwise reduction NOR */
#define vpiUnaryXorOp 9 /* bitwise reduction XOR */
#define vpiUnaryXNorOp 10 /* bitwise reduction XNOR */
#define vpiSubOp 11 /* binary subtraction */
#define vpiDivOp 12 /* binary division */
#define vpiModOp 13 /* binary modulus */
#define vpiEqOp 14 /* binary equality */
#define vpiNeqOp 15 /* binary inequality */
#define vpiCaseEqOp 16 /* case (x and z) equality */
#define vpiCaseNeqOp 17 /* case inequality */
#define vpiGtOp 18 /* binary greater than */
#define vpiGeOp 19 /* binary greater than or equal */
#define vpiLtOp 20 /* binary less than */
#define vpiLeOp 21 /* binary less than or equal */
#define vpiLShiftOp 22 /* binary left shift */
#define vpiRShiftOp 23 /* binary right shift */
#define vpiAddOp 24 /* binary addition */
#define vpiMultOp 25 /* binary multiplication */
#define vpiLogAndOp 26 /* binary logical AND */
#define vpiLogOrOp 27 /* binary logical OR */
#define vpiBitAndOp 28 /* binary bitwise AND */
#define vpiBitOrOp 29 /* binary bitwise OR */
#define vpiBitXorOp 30 /* binary bitwise XOR */
#define vpiBitXNorOp 31 /* binary bitwise XNOR */
#define vpiBitXnorOp vpiBitXNorOp /* added with 1364-2001 */
#define vpiConditionOp 32 /* ternary conditional */
#define vpiConcatOp 33 /* n-ary concatenation */
#define vpiMultiConcatOp 34 /* repeated concatenation */
#define vpiEventOrOp 35 /* event OR */
#define vpiNullOp 36 /* null operation */
#define vpiListOp 37 /* list of expressions */
#define vpiMinTypMaxOp 38 /* min:typ:max: delay expression */
#define vpiPosedgeOp 39 /* posedge */
#define vpiNegedgeOp 40 /* negedge */
#define vpiArithLShiftOp 41 /* arithmetic left shift (1364-2001) */
#define vpiArithRShiftOp 42 /* arithmetic right shift (1364-2001) */
#define vpiPowerOp 43 /* arithmetic power op (1364-2001) */
#define vpiConstType 40 /* constant subtypes: */
#define vpiDecConst 1 /* decimal integer */
#define vpiRealConst 2 /* real */
#define vpiBinaryConst 3 /* binary integer */
#define vpiOctConst 4 /* octal integer */
#define vpiHexConst 5 /* hexadecimal integer */
#define vpiStringConst 6 /* string literal */
#define vpiIntConst 7 /* integer constant (1364-2001) */
#define vpiTimeConst 8 /* time constant */
1275
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiBlocking 41 /* blocking assignment (Boolean) */
#define vpiCaseType 42 /* case statement subtypes: */
#define vpiCaseExact 1 /* exact match */
#define vpiCaseX 2 /* ignore X's */
#define vpiCaseZ 3 /* ignore Z's */
#define vpiNetDeclAssign 43 /* assign part of decl (Boolean) */
/************************** task/function properties **************************/
#define vpiFuncType 44 /* function & system function type */
#define vpiIntFunc 1 /* returns integer */
#define vpiRealFunc 2 /* returns real */
#define vpiTimeFunc 3 /* returns time */
#define vpiSizedFunc 4 /* returns an arbitrary size */
#define vpiSizedSignedFunc 5 /* returns sized signed value */
/** alias 1364-1995 system function subtypes to 1364-2001 function subtypes ***/
#define vpiSysFuncType vpiFuncType
#define vpiSysFuncInt vpiIntFunc
#define vpiSysFuncReal vpiRealFunc
#define vpiSysFuncTime vpiTimeFunc
#define vpiSysFuncSized vpiSizedFunc
-
#define vpiUserDefn 45 /*user defined system task/func(Boolean)*/
#define vpiScheduled 46 /* object still scheduled (Boolean) */
/*********************** properties added with 1364-2001 **********************/
#define vpiActive 49 /* reentrant task/func frame is active */
#define vpiAutomatic 50 /* task/func obj is automatic */
#define vpiCell 51 /* configuration cell */
#define vpiConfig 52 /* configuration config file */
#define vpiConstantSelect 53 /* (Boolean) bit-select or part-select
indices are constant expressions */
#define vpiDecompile 54 /* decompile the object */
#define vpiDefAttribute 55 /* Attribute defined for the obj */
#define vpiDelayType 56 /* delay subtype */
#define vpiModPathDelay 1 /* module path delay */
#define vpiInterModPathDelay 2 /* intermodule path delay */
#define vpiMIPDelay 3 /* module input port delay */
#define vpiIteratorType 57 /* object type of an iterator */
#define vpiLibrary 58 /* configuration library */
#define vpiOffset 60 /* offset from LSB */
#define vpiResolvedNetType 61 /* net subtype after resolution, returns
same subtypes as vpiNetType */
#define vpiSaveRestartID 62 /* unique ID for save/restart data */
#define vpiSaveRestartLocation 63 /* name of save/restart data file */
/* vpiValid,vpiValidTrue,vpiValidFalse were deprecated in 1800-2009 */
#define vpiValid 64 /* reentrant task/func frame or automatic
variable is valid */
#define vpiValidFalse 0
#define vpiValidTrue 1
#define vpiSigned 65 /* TRUE for vpiIODecl and any object in
the expression class if the object
has the signed attribute */
#define vpiLocalParam 70 /* TRUE when a param is declared as a
localparam */
#define vpiModPathHasIfNone 71 /* Mod path has an ifnone statement */
/*********************** properties added with 1364-2005 **********************/
#define vpiIndexedPartSelectType 72 /* Indexed part-select type */
#define vpiPosIndexed 1 /* +: */
1276
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiNegIndexed 2 /* -: */
#define vpiIsMemory 73 /* TRUE for a one-dimensional reg array */
#define vpiIsProtected 74 /* TRUE for protected design information */
/*************** vpi_control() constants (added with 1364-2001) ***************/
#define vpiStop 66 /* execute simulator's $stop */
#define vpiFinish 67 /* execute simulator's $finish */
#define vpiReset 68 /* execute simulator's $reset */
#define vpiSetInteractiveScope 69 /* set simulator's interactive scope */
/**************************** I/O related defines *****************************/
#define VPI_MCD_STDOUT 0x00000001
/*************************** STRUCTURE DEFINITIONS ****************************/
/******************************* time structure *******************************/
typedef struct t_vpi_time
{
PLI_INT32 type; /* [vpiScaledRealTime, vpiSimTime,
vpiSuppressTime] */
PLI_UINT32 high, low; /* for vpiSimTime */
double real; /* for vpiScaledRealTime */
} s_vpi_time, *p_vpi_time;
/* time types */
#define vpiScaledRealTime 1
#define vpiSimTime 2
#define vpiSuppressTime 3
/****************************** delay structures ******************************/
typedef struct t_vpi_delay
{
struct t_vpi_time *da; /* pointer to application-allocated
array of delay values */
PLI_INT32 no_of_delays; /* number of delays */
PLI_INT32 time_type; /* [vpiScaledRealTime, vpiSimTime,
vpiSuppressTime] */
PLI_INT32 mtm_flag; /* true for mtm values */
PLI_INT32 append_flag; /* true for append */
PLI_INT32 pulsere_flag; /* true for pulsere values */
} s_vpi_delay, *p_vpi_delay;
/***************************** value structures *******************************/
/* vector value */
#ifndef VPI_VECVAL /* added in 1364-2005 */
#define VPI_VECVAL
typedef struct t_vpi_vecval
{
/* following fields are repeated enough times to contain vector */
PLI_UINT32 aval, bval; /* bit encoding: ab: 00=0, 10=1, 11=X, 01=Z */
} s_vpi_vecval, *p_vpi_vecval;
#endif
/* strength (scalar) value */
1277
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
typedef struct t_vpi_strengthval
{
PLI_INT32 logic; /* vpi[0,1,X,Z] */
PLI_INT32 s0, s1; /* refer to strength coding below */
} s_vpi_strengthval, *p_vpi_strengthval;
/* strength values */
#define vpiSupplyDrive 0x80
#define vpiStrongDrive 0x40
#define vpiPullDrive 0x20
#define vpiWeakDrive 0x08
#define vpiLargeCharge 0x10
#define vpiMediumCharge 0x04
#define vpiSmallCharge 0x02
#define vpiHiZ 0x01
/* generic value */
typedef struct t_vpi_value
{
PLI_INT32 format; /* vpi[[Bin,Oct,Dec,Hex]Str,Scalar,Int,Real,String,
Vector,Strength,Suppress,Time,ObjType]Val */
union
{
PLI_BYTE8 *str; /* string value */
PLI_INT32 scalar; /* vpi[0,1,X,Z] */
PLI_INT32 integer; /* integer value */
double real; /* real value */
struct t_vpi_time *time; /* time value */
struct t_vpi_vecval *vector; /* vector value */
struct t_vpi_strengthval *strength; /* strength value */
PLI_BYTE8 *misc; /* ...other */
} value;
} s_vpi_value, *p_vpi_value;
typedef struct t_vpi_arrayvalue
{
PLI_UINT32 format; /* vpi[Int,Real,Time,ShortInt,LongInt,ShortReal,
RawTwoState,RawFourState]Val */
PLI_UINT32 flags; /* array bit flags- vpiUserAllocFlag */
union
{
PLI_INT32 *integers; /* integer values */
PLI_INT16 *shortints; /* short integer values */
PLI_INT64 *longints; /* long integer values */
PLI_BYTE8 *rawvals; /* 2/4-state vector elements */
struct t_vpi_vecval *vectors; /* 4-state vector elements */
struct t_vpi_time *times; /* time values */
double *reals; /* real values */
float *shortreals; /* short real values */
} value;
} s_vpi_arrayvalue, *p_vpi_arrayvalue;
/* value formats */
#define vpiBinStrVal 1
#define vpiOctStrVal 2
#define vpiDecStrVal 3
#define vpiHexStrVal 4
#define vpiScalarVal 5
#define vpiIntVal 6
#define vpiRealVal 7
1278
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiStringVal 8
#define vpiVectorVal 9
#define vpiStrengthVal 10
#define vpiTimeVal 11
#define vpiObjTypeVal 12
#define vpiSuppressVal 13
#define vpiShortIntVal 14
#define vpiLongIntVal 15
#define vpiShortRealVal 16
#define vpiRawTwoStateVal 17
#define vpiRawFourStateVal 18
/* delay modes */
#define vpiNoDelay 1
#define vpiInertialDelay 2
#define vpiTransportDelay 3
#define vpiPureTransportDelay 4
/* force and release flags */
#define vpiForceFlag 5
#define vpiReleaseFlag 6
/* scheduled event cancel flag */
#define vpiCancelEvent 7
/* bit mask for the flags argument to vpi_put_value() */
#define vpiReturnEvent 0x1000
/* bit flags for vpi_get_value_array flags field */
#define vpiUserAllocFlag 0x2000
/* bit flags for vpi_put_value_array flags field */
#define vpiOneValue 0x4000
#define vpiPropagateOff 0x8000
/* scalar values */
#define vpi0 0
#define vpi1 1
#define vpiZ 2
#define vpiX 3
#define vpiH 4
#define vpiL 5
#define vpiDontCare 6
/*
#define vpiNoChange 7 Defined under vpiTchkType, but
can be used here.
*/
/*********************** system task/function structure ***********************/
typedef struct t_vpi_systf_data
{
PLI_INT32 type; /* vpiSysTask, vpiSysFunc */
PLI_INT32 sysfunctype; /* vpiSysTask, vpi[Int,Real,Time,Sized,
SizedSigned]Func */
PLI_BYTE8 *tfname; /* first character must be '$' */
PLI_INT32 (*calltf)(PLI_BYTE8 *);
1279
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
PLI_INT32 (*compiletf)(PLI_BYTE8 *);
PLI_INT32 (*sizetf)(PLI_BYTE8 *); /* for sized function callbacks only */
PLI_BYTE8 *user_data;
} s_vpi_systf_data, *p_vpi_systf_data;
#define vpiSysTask 1
#define vpiSysFunc 2
/* the subtypes are defined under the vpiFuncType property */
/**************** SystemVerilog execution information structure ***************/
typedef struct t_vpi_vlog_info
{
PLI_INT32 argc;
PLI_BYTE8 **argv;
PLI_BYTE8 *product;
PLI_BYTE8 *version;
} s_vpi_vlog_info, *p_vpi_vlog_info;
/*********************** PLI error information structure **********************/
typedef struct t_vpi_error_info
{
PLI_INT32 state; /* vpi[Compile,PLI,Run] */
PLI_INT32 level; /* vpi[Notice,Warning,Error,System,Internal] */
PLI_BYTE8 *message;
PLI_BYTE8 *product;
PLI_BYTE8 *code;
PLI_BYTE8 *file;
PLI_INT32 line;
} s_vpi_error_info, *p_vpi_error_info;
/* state when error occurred */
#define vpiCompile 1
#define vpiPLI 2
#define vpiRun 3
/* error severity levels */
#define vpiNotice 1
#define vpiWarning 2
#define vpiError 3
#define vpiSystem 4
#define vpiInternal 5
/**************************** callback structures *****************************/
/* normal callback structure */
typedef struct t_cb_data
{
PLI_INT32 reason; /* callback reason */
PLI_INT32 (*cb_rtn)(struct t_cb_data *); /* call routine */
vpiHandle obj; /* trigger object */
p_vpi_time time; /* callback time */
p_vpi_value value; /* trigger object value */
PLI_INT32 index; /* index of the memory word or
var select that changed */
PLI_BYTE8 *user_data;
} s_cb_data, *p_cb_data;
/****************************** CALLBACK REASONS ******************************/
1280
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
/***************************** Simulation related *****************************/
#define cbValueChange 1
#define cbStmt 2
#define cbForce 3
#define cbRelease 4
/******************************** Time related ********************************/
#define cbAtStartOfSimTime 5
#define cbReadWriteSynch 6
#define cbReadOnlySynch 7
#define cbNextSimTime 8
#define cbAfterDelay 9
/******************************* Action related *******************************/
#define cbEndOfCompile 10
#define cbStartOfSimulation 11
#define cbEndOfSimulation 12
#define cbError 13
#define cbTchkViolation 14
#define cbStartOfSave 15
#define cbEndOfSave 16
#define cbStartOfRestart 17
#define cbEndOfRestart 18
#define cbStartOfReset 19
#define cbEndOfReset 20
#define cbEnterInteractive 21
#define cbExitInteractive 22
#define cbInteractiveScopeChange 23
#define cbUnresolvedSystf 24
/**************************** Added with 1364-2001 ****************************/
#define cbAssign 25
#define cbDeassign 26
#define cbDisable 27
#define cbPLIError 28
#define cbSignal 29
/**************************** Added with 1364-2005 ****************************/
#define cbNBASynch 30
#define cbAtEndOfSimTime 31
/**************************** FUNCTION DECLARATIONS ***************************/
/* Include compatibility mode macro definitions. */
#include "vpi_compatibility.h"
/* callback related */
XXTERN vpiHandle vpi_register_cb PROTO_PARAMS((p_cb_data cb_data_p));
XXTERN PLI_INT32 vpi_remove_cb PROTO_PARAMS((vpiHandle cb_obj));
XXTERN void vpi_get_cb_info PROTO_PARAMS((vpiHandle object,
p_cb_data cb_data_p));
XXTERN vpiHandle vpi_register_systf PROTO_PARAMS((p_vpi_systf_data
systf_data_p));
XXTERN void vpi_get_systf_info PROTO_PARAMS((vpiHandle object,
p_vpi_systf_data
systf_data_p));
/* for obtaining handles */
1281
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
XXTERN vpiHandle vpi_handle_by_name PROTO_PARAMS((PLI_BYTE8 *name,
vpiHandle scope));
XXTERN vpiHandle vpi_handle_by_index PROTO_PARAMS((vpiHandle object,
PLI_INT32 indx));
/* for traversing relationships */
XXTERN vpiHandle vpi_handle PROTO_PARAMS((PLI_INT32 type,
vpiHandle refHandle));
XXTERN vpiHandle vpi_handle_multi PROTO_PARAMS((PLI_INT32 type,
vpiHandle refHandle1,
vpiHandle refHandle2,
... ));
XXTERN vpiHandle vpi_iterate PROTO_PARAMS((PLI_INT32 type,
vpiHandle refHandle));
XXTERN vpiHandle vpi_scan PROTO_PARAMS((vpiHandle iterator));
/* for processing properties */
XXTERN PLI_INT32 vpi_get PROTO_PARAMS((PLI_INT32 property,
vpiHandle object));
XXTERN PLI_INT64 vpi_get64 PROTO_PARAMS((PLI_INT32 property,
vpiHandle object));
XXTERN PLI_BYTE8 *vpi_get_str PROTO_PARAMS((PLI_INT32 property,
vpiHandle object));
/* delay processing */
XXTERN void vpi_get_delays PROTO_PARAMS((vpiHandle object,
p_vpi_delay delay_p));
XXTERN void vpi_put_delays PROTO_PARAMS((vpiHandle object,
p_vpi_delay delay_p));
/* value processing */
XXTERN void vpi_get_value PROTO_PARAMS((vpiHandle expr,
p_vpi_value value_p));
XXTERN vpiHandle vpi_put_value PROTO_PARAMS((vpiHandle object,
p_vpi_value value_p,
p_vpi_time time_p,
PLI_INT32 flags));
XXTERN void vpi_get_value_array PROTO_PARAMS((vpiHandle object,
p_vpi_arrayvalue arrayvalue_p,
PLI_INT32 *index_p,
PLI_UINT32 num));
XXTERN void vpi_put_value_array PROTO_PARAMS((vpiHandle object,
p_vpi_arrayvalue arrayvalue_p,
PLI_INT32 *index_p,
PLI_UINT32 num));
/* time processing */
XXTERN void vpi_get_time PROTO_PARAMS((vpiHandle object,
p_vpi_time time_p));
/* I/O routines */
XXTERN PLI_UINT32 vpi_mcd_open PROTO_PARAMS((PLI_BYTE8 *fileName));
XXTERN PLI_UINT32 vpi_mcd_close PROTO_PARAMS((PLI_UINT32 mcd));
XXTERN PLI_BYTE8 *vpi_mcd_name PROTO_PARAMS((PLI_UINT32 cd));
XXTERN PLI_INT32 vpi_mcd_printf PROTO_PARAMS((PLI_UINT32 mcd,
PLI_BYTE8 *format,
...));
1282
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
XXTERN PLI_INT32 vpi_printf PROTO_PARAMS((PLI_BYTE8 *format,
...));
/* utility routines */
XXTERN PLI_INT32 vpi_compare_objects PROTO_PARAMS((vpiHandle object1,
vpiHandle object2));
XXTERN PLI_INT32 vpi_chk_error PROTO_PARAMS((p_vpi_error_info
error_info_p));
/* vpi_free_object() was deprecated in 1800-2009 */
XXTERN PLI_INT32 vpi_free_object PROTO_PARAMS((vpiHandle object));
XXTERN PLI_INT32 vpi_release_handle PROTO_PARAMS((vpiHandle object));
XXTERN PLI_INT32 vpi_get_vlog_info PROTO_PARAMS((p_vpi_vlog_info
vlog_info_p));
/* routines added with 1364-2001 */
XXTERN PLI_INT32 vpi_get_data PROTO_PARAMS((PLI_INT32 id,
PLI_BYTE8 *dataLoc,
PLI_INT32 numOfBytes));
XXTERN PLI_INT32 vpi_put_data PROTO_PARAMS((PLI_INT32 id,
PLI_BYTE8 *dataLoc,
PLI_INT32 numOfBytes));
XXTERN void *vpi_get_userdata PROTO_PARAMS((vpiHandle obj));
XXTERN PLI_INT32 vpi_put_userdata PROTO_PARAMS((vpiHandle obj,
void *userdata));
XXTERN PLI_INT32 vpi_vprintf PROTO_PARAMS((PLI_BYTE8 *format,
va_list ap));
XXTERN PLI_INT32 vpi_mcd_vprintf PROTO_PARAMS((PLI_UINT32 mcd,
PLI_BYTE8 *format,
va_list ap));
XXTERN PLI_INT32 vpi_flush PROTO_PARAMS((void));
XXTERN PLI_INT32 vpi_mcd_flush PROTO_PARAMS((PLI_UINT32 mcd));
XXTERN PLI_INT32 vpi_control PROTO_PARAMS((PLI_INT32 operation,
...));
XXTERN vpiHandle vpi_handle_by_multi_index PROTO_PARAMS((vpiHandle obj,
PLI_INT32 num_index,
PLI_INT32 *index_array));
/****************************** GLOBAL VARIABLES ******************************/
PLI_VEXTERN PLI_DLLESPEC void (*vlog_startup_routines[])( void );
/* array of function pointers, last pointer should be null */
#undef PLI_EXTERN
#undef PLI_VEXTERN
#ifdef VPI_USER_DEFINED_DLLISPEC
#undef VPI_USER_DEFINED_DLLISPEC
#undef PLI_DLLISPEC
#endif
#ifdef VPI_USER_DEFINED_DLLESPEC
#undef VPI_USER_DEFINED_DLLESPEC
#undef PLI_DLLESPEC
#endif
#ifdef PLI_PROTOTYPES
#undef PLI_PROTOTYPES
#undef PROTO_PARAMS
#undef XXTERN
#undef EETERN
#endif
1283
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#ifdef __cplusplus
}
#endif
#endif /* VPI_USER_H */
1284
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex L
(normative)
vpi_compatibility.h
L.1 General
This include file contains special macro definitions required to support VPI compatibility mode
functionality (see 36.12, especially 36.12.2.1). It is automatically included by vpi_user.h (see AnnexK), and
therefore should not be included directly from user application code.
L.2 Source code
/*******************************************************************************
* vpi_compatibility.h
*
* IEEE 1800-2017 SystemVerilog Verification Procedural Interface (VPI)
*
* NOTE: THIS FILE IS INCLUDED BY vpi_user.h. DO NOT INCLUDE THIS FILE FROM
* USER APPLICATION CODE.
*
* This file contains the macro definitions used by the SystemVerilog PLI
* to implement backwards compatibility mode functionality.
*
******************************************************************************/
#ifdef VPI_COMPATIBILITY_H
#error "The vpi_compatibility.h file can only be included by vpi_user.h
directly."
#endif
#define VPI_COMPATIBILITY_H
/* Compatibility-mode variants of functions */
#if VPI_COMPATIBILITY_VERSION_1800v2017
#define VPI_COMPATIBILITY_VERSION_1800v2012
#endif
#if VPI_COMPATIBILITY_VERSION_1364v1995
#if VPI_COMPATIBILITY_VERSION_1364v2001 || VPI_COMPATIBILITY_VERSION_1364v2005
|| VPI_COMPATIBILITY_VERSION_1800v2005 || VPI_COMPATIBILITY_VERSION_1800v2009
|| VPI_COMPATIBILITY_VERSION_1800v2012
#error "Only one VPI_COMPATIBILITY_VERSION symbol definition is allowed."
#endif
#define vpi_compare_objects vpi_compare_objects_1364v1995
#define vpi_control vpi_control_1364v1995
#define vpi_get vpi_get_1364v1995
#define vpi_get_str vpi_get_str_1364v1995
#define vpi_get_value vpi_get_value_1364v1995
#define vpi_handle vpi_handle_1364v1995
#define vpi_handle_by_index vpi_handle_by_index_1364v1995
#define vpi_handle_by_multi_index vpi_handle_by_multi_index_1364v1995
#define vpi_handle_by_name vpi_handle_by_name_1364v1995
#define vpi_handle_multi vpi_handle_multi_1364v1995
#define vpi_iterate vpi_iterate_1364v1995
#define vpi_put_value vpi_put_value_1364v1995
#define vpi_register_cb vpi_register_cb_1364v1995
#define vpi_scan vpi_scan_1364v1995
#elif VPI_COMPATIBILITY_VERSION_1364v2001
#if VPI_COMPATIBILITY_VERSION_1364v1995 || VPI_COMPATIBILITY_VERSION_1364v2005
1285
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
|| VPI_COMPATIBILITY_VERSION_1800v2005 || VPI_COMPATIBILITY_VERSION_1800v2009
|| VPI_COMPATIBILITY_VERSION_1800v2012
#error "Only one VPI_COMPATIBILITY_VERSION symbol definition is allowed."
#endif
#define vpi_compare_objects vpi_compare_objects_1364v2001
#define vpi_control vpi_control_1364v2001
#define vpi_get vpi_get_1364v2001
#define vpi_get_str vpi_get_str_1364v2001
#define vpi_get_value vpi_get_value_1364v2001
#define vpi_handle vpi_handle_1364v2001
#define vpi_handle_by_index vpi_handle_by_index_1364v2001
#define vpi_handle_by_multi_index vpi_handle_by_multi_index_1364v2001
#define vpi_handle_by_name vpi_handle_by_name_1364v2001
#define vpi_handle_multi vpi_handle_multi_1364v2001
#define vpi_iterate vpi_iterate_1364v2001
#define vpi_put_value vpi_put_value_1364v2001
#define vpi_register_cb vpi_register_cb_1364v2001
#define vpi_scan vpi_scan_1364v2001
#elif VPI_COMPATIBILITY_VERSION_1364v2005
#if VPI_COMPATIBILITY_VERSION_1364v1995 || VPI_COMPATIBILITY_VERSION_1364v2001
|| VPI_COMPATIBILITY_VERSION_1800v2005 || VPI_COMPATIBILITY_VERSION_1800v2009
|| VPI_COMPATIBILITY_VERSION_1800v2012
#error "Only one VPI_COMPATIBILITY_VERSION symbol definition is allowed."
#endif
#define vpi_compare_objects vpi_compare_objects_1364v2005
#define vpi_control vpi_control_1364v2005
#define vpi_get vpi_get_1364v2005
#define vpi_get_str vpi_get_str_1364v2005
#define vpi_get_value vpi_get_value_1364v2005
#define vpi_handle vpi_handle_1364v2005
#define vpi_handle_by_index vpi_handle_by_index_1364v2005
#define vpi_handle_by_multi_index vpi_handle_by_multi_index_1364v2005
#define vpi_handle_by_name vpi_handle_by_name_1364v2005
#define vpi_handle_multi vpi_handle_multi_1364v2005
#define vpi_iterate vpi_iterate_1364v2005
#define vpi_put_value vpi_put_value_1364v2005
#define vpi_register_cb vpi_register_cb_1364v2005
#define vpi_scan vpi_scan_1364v2005
#elif VPI_COMPATIBILITY_VERSION_1800v2005
#if VPI_COMPATIBILITY_VERSION_1364v1995 || VPI_COMPATIBILITY_VERSION_1364v2001
|| VPI_COMPATIBILITY_VERSION_1364v2005 || VPI_COMPATIBILITY_VERSION_1800v2009
|| VPI_COMPATIBILITY_VERSION_1800v2012
#error "Only one VPI_COMPATIBILITY_VERSION symbol definition is allowed."
#endif
#define vpi_compare_objects vpi_compare_objects_1800v2005
#define vpi_control vpi_control_1800v2005
#define vpi_get vpi_get_1800v2005
#define vpi_get_str vpi_get_str_1800v2005
#define vpi_get_value vpi_get_value_1800v2005
#define vpi_handle vpi_handle_1800v2005
#define vpi_handle_by_index vpi_handle_by_index_1800v2005
#define vpi_handle_by_multi_index vpi_handle_by_multi_index_1800v2005
#define vpi_handle_by_name vpi_handle_by_name_1800v2005
#define vpi_handle_multi vpi_handle_multi_1800v2005
#define vpi_iterate vpi_iterate_1800v2005
#define vpi_put_value vpi_put_value_1800v2005
#define vpi_register_cb vpi_register_cb_1800v2005
#define vpi_scan vpi_scan_1800v2005
#elif VPI_COMPATIBILITY_VERSION_1800v2009
#if VPI_COMPATIBILITY_VERSION_1364v1995 || VPI_COMPATIBILITY_VERSION_1364v2001
|| VPI_COMPATIBILITY_VERSION_1364v2005 || VPI_COMPATIBILITY_VERSION_1800v2005
|| VPI_COMPATIBILITY_VERSION_1800v2012
#error "Only one VPI_COMPATIBILITY_VERSION symbol definition is allowed."
#endif
1286
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpi_compare_objects vpi_compare_objects_1800v2009
#define vpi_control vpi_control_1800v2009
#define vpi_get vpi_get_1800v2009
#define vpi_get_str vpi_get_str_1800v2009
#define vpi_get_value vpi_get_value_1800v2009
#define vpi_handle vpi_handle_1800v2009
#define vpi_handle_by_index vpi_handle_by_index_1800v2009
#define vpi_handle_by_multi_index vpi_handle_by_multi_index_1800v2009
#define vpi_handle_by_name vpi_handle_by_name_1800v2009
#define vpi_handle_multi vpi_handle_multi_1800v2009
#define vpi_iterate vpi_iterate_1800v2009
#define vpi_put_value vpi_put_value_1800v2009
#define vpi_register_cb vpi_register_cb_1800v2009
#define vpi_scan vpi_scan_1800v2009
#elif VPI_COMPATIBILITY_VERSION_1800v2012
#if VPI_COMPATIBILITY_VERSION_1364v1995 || VPI_COMPATIBILITY_VERSION_1364v2001
|| VPI_COMPATIBILITY_VERSION_1364v2005 || VPI_COMPATIBILITY_VERSION_1800v2005
|| VPI_COMPATIBILITY_VERSION_1800v2009
#error "Only one VPI_COMPATIBILITY_VERSION symbol definition is allowed."
#endif
#define vpi_compare_objects vpi_compare_objects_1800v2012
#define vpi_control vpi_control_1800v2012
#define vpi_get vpi_get_1800v2012
#define vpi_get_str vpi_get_str_1800v2012
#define vpi_get_value vpi_get_value_1800v2012
#define vpi_handle vpi_handle_1800v2012
#define vpi_handle_by_index vpi_handle_by_index_1800v2012
#define vpi_handle_by_multi_index vpi_handle_by_multi_index_1800v2012
#define vpi_handle_by_name vpi_handle_by_name_1800v2012
#define vpi_handle_multi vpi_handle_multi_1800v2012
#define vpi_iterate vpi_iterate_1800v2012
#define vpi_put_value vpi_put_value_1800v2012
#define vpi_register_cb vpi_register_cb_1800v2012
#define vpi_scan vpi_scan_1800v2012
#endif
1287
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex M
(normative)
sv_vpi_user.h
M.1 General
This annex shows the contents of the include file. This is a normative include file that
sv_vpi_user.h
shall be provided by all SystemVerilog simulators.
M.2 Source code
/***************************************************************************
* sv_vpi_user.h
*
* SystemVerilog VPI extensions.
*
* This file contains the constant definitions, structure definitions, and
* routine declarations used by the SystemVerilog Verification Procedural
* Interface (VPI) access routines.
*
**************************************************************************/
/***************************************************************************
* NOTE:
* The constant values 600 through 999 are reserved for use in this file.
* - the range 600-749 is reserved for SV VPI model extensions
* - the range 750-779 is reserved for the Coverage VPI
* - the range 800-899 is reserved for future use
* Overlaps in the numerical ranges are permitted for different categories
* of identifiers; e.g.
* - object types
* - properties
* - callbacks
**************************************************************************/
#ifndef SV_VPI_USER_H
#define SV_VPI_USER_H
#include "vpi_user.h"
#ifdef __cplusplus
extern "C" {
#endif
/****************************** OBJECT TYPES ******************************/
#define vpiPackage 600
#define vpiInterface 601
#define vpiProgram 602
#define vpiInterfaceArray 603
#define vpiProgramArray 604
#define vpiTypespec 605
1288
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiModport 606
#define vpiInterfaceTfDecl 607
#define vpiRefObj 608
#define vpiTypeParameter 609
/* variables */
#define vpiVarBit vpiRegBit
#define vpiLongIntVar 610
#define vpiShortIntVar 611
#define vpiIntVar 612
#define vpiShortRealVar 613
#define vpiByteVar 614
#define vpiClassVar 615
#define vpiStringVar 616
#define vpiEnumVar 617
#define vpiStructVar 618
#define vpiUnionVar 619
#define vpiBitVar 620
#define vpiLogicVar vpiReg
#define vpiArrayVar vpiRegArray
#define vpiClassObj 621
#define vpiChandleVar 622
#define vpiPackedArrayVar 623
#define vpiVirtualInterfaceVar 728
/* typespecs */
#define vpiLongIntTypespec 625
#define vpiShortRealTypespec 626
#define vpiByteTypespec 627
#define vpiShortIntTypespec 628
#define vpiIntTypespec 629
#define vpiClassTypespec 630
#define vpiStringTypespec 631
#define vpiChandleTypespec 632
#define vpiEnumTypespec 633
#define vpiEnumConst 634
#define vpiIntegerTypespec 635
#define vpiTimeTypespec 636
#define vpiRealTypespec 637
#define vpiStructTypespec 638
#define vpiUnionTypespec 639
#define vpiBitTypespec 640
#define vpiLogicTypespec 641
#define vpiArrayTypespec 642
#define vpiVoidTypespec 643
#define vpiTypespecMember 644
#define vpiPackedArrayTypespec 692
#define vpiSequenceTypespec 696
#define vpiPropertyTypespec 697
#define vpiEventTypespec 698
#define vpiInterfaceTypespec 906
#define vpiClockingBlock 650
#define vpiClockingIODecl 651
#define vpiClassDefn 652
#define vpiConstraint 653
#define vpiConstraintOrdering 654
#define vpiDistItem 645
1289
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiAliasStmt 646
#define vpiThread 647
#define vpiMethodFuncCall 648
#define vpiMethodTaskCall 649
/* concurrent assertions */
#define vpiAssert 686
#define vpiAssume 687
#define vpiCover 688
#define vpiRestrict 901
#define vpiDisableCondition 689
#define vpiClockingEvent 690
/* property decl, spec */
#define vpiPropertyDecl 655
#define vpiPropertySpec 656
#define vpiPropertyExpr 657
#define vpiMulticlockSequenceExpr 658
#define vpiClockedSeq 659
#define vpiClockedProp 902
#define vpiPropertyInst 660
#define vpiSequenceDecl 661
#define vpiCaseProperty 662 /* property case */
#define vpiCasePropertyItem 905 /* property case item */
#define vpiSequenceInst 664
#define vpiImmediateAssert 665
#define vpiImmediateAssume 694
#define vpiImmediateCover 695
#define vpiReturn 666
/* pattern */
#define vpiAnyPattern 667
#define vpiTaggedPattern 668
#define vpiStructPattern 669
/* do .. while */
#define vpiDoWhile 670
/* waits */
#define vpiOrderedWait 671
#define vpiWaitFork 672
/* disables */
#define vpiDisableFork 673
#define vpiExpectStmt 674
#define vpiForeachStmt 675
#define vpiReturnStmt 691
#define vpiFinal 676
#define vpiExtends 677
#define vpiDistribution 678
#define vpiSeqFormalDecl 679
#define vpiPropFormalDecl 699
#define vpiArrayNet vpiNetArray
#define vpiEnumNet 680
#define vpiIntegerNet 681
#define vpiLogicNet vpiNet
#define vpiTimeNet 682
#define vpiStructNet 683
#define vpiBreak 684
#define vpiContinue 685
#define vpiPackedArrayNet 693
#define vpiConstraintExpr 747
#define vpiElseConst 748
1290
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiImplication 749
#define vpiConstrIf 738
#define vpiConstrIfElse 739
#define vpiConstrForEach 736
#define vpiSoftDisable 733
#define vpiLetDecl 903
#define vpiLetExpr 904
/******************************** METHODS *********************************/
/************* methods used to traverse 1 to 1 relationships **************/
#define vpiActual 700
#define vpiTypedefAlias 701
#define vpiIndexTypespec 702
#define vpiBaseTypespec 703
#define vpiElemTypespec 704
#define vpiInputSkew 706
#define vpiOutputSkew 707
#define vpiGlobalClocking 708
#define vpiDefaultClocking 709
#define vpiDefaultDisableIff 710
#define vpiOrigin 713
#define vpiPrefix 714
#define vpiWith 715
#define vpiProperty 718
#define vpiValueRange 720
#define vpiPattern 721
#define vpiWeight 722
#define vpiConstraintItem 746
/************ methods used to traverse 1 to many relationships ************/
#define vpiTypedef 725
#define vpiImport 726
#define vpiDerivedClasses 727
#define vpiInterfaceDecl vpiVirtualInterfaceVar /* interface decl deprecated */
#define vpiMethods 730
#define vpiSolveBefore 731
#define vpiSolveAfter 732
#define vpiWaitingProcesses 734
#define vpiMessages 735
#define vpiLoopVars 737
#define vpiConcurrentAssertions 740
#define vpiMatchItem 741
#define vpiMember 742
#define vpiElement 743
/************* methods used to traverse 1 to many relationships ***************/
#define vpiAssertion 744
/*********** methods used to traverse both 1-1 and 1-many relations ***********/
1291
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiInstance 745
/**************************************************************************/
/************************ generic object properties ***********************/
/**************************************************************************/
#define vpiTop 600
#define vpiUnit 602
#define vpiJoinType 603
#define vpiJoin 0
#define vpiJoinNone 1
#define vpiJoinAny 2
#define vpiAccessType 604
#define vpiForkJoinAcc 1
#define vpiExternAcc 2
#define vpiDPIExportAcc 3
#define vpiDPIImportAcc 4
#define vpiArrayType 606
#define vpiStaticArray 1
#define vpiDynamicArray 2
#define vpiAssocArray 3
#define vpiQueueArray 4
#define vpiArrayMember 607
#define vpiIsRandomized 608
#define vpiLocalVarDecls 609
#define vpiOpStrong 656 /* strength of temporal operator */
#define vpiRandType 610
#define vpiNotRand 1
#define vpiRand 2
#define vpiRandC 3
#define vpiPortType 611
#define vpiInterfacePort 1
#define vpiModportPort 2
/* vpiPort is also a port type. It is defined in vpi_user.h */
#define vpiConstantVariable 612
#define vpiStructUnionMember 615
#define vpiVisibility 620
#define vpiPublicVis 1
#define vpiProtectedVis 2
#define vpiLocalVis 3
/* Return values for vpiConstType property */
#define vpiOneStepConst 9
#define vpiUnboundedConst 10
#define vpiNullConst 11
#define vpiAlwaysType 624
#define vpiAlwaysComb 2
#define vpiAlwaysFF 3
#define vpiAlwaysLatch 4
1292
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiDistType 625
#define vpiEqualDist 1 /* constraint equal distribution */
#define vpiDivDist 2 /* constraint divided distribution */
#define vpiPacked 630
#define vpiTagged 632
#define vpiRef 6 /* Return value for vpiDirection property */
#define vpiVirtual 635
#define vpiHasActual 636
#define vpiIsConstraintEnabled 638
#define vpiSoft 639
#define vpiClassType 640
#define vpiMailboxClass 1
#define vpiSemaphoreClass 2
#define vpiUserDefinedClass 3
#define vpiProcessClass 4
#define vpiMethod 645
#define vpiIsClockInferred 649
#define vpiIsDeferred 657
#define vpiIsFinal 670
#define vpiIsCoverSequence 659
#define vpiQualifier 650
#define vpiNoQualifier 0
#define vpiUniqueQualifier 1
#define vpiPriorityQualifier 2
#define vpiTaggedQualifier 4
#define vpiRandQualifier 8
#define vpiInsideQualifier 16
#define vpiInputEdge 651 /* returns vpiNoEdge, vpiPosedge,
vpiNegedge */
#define vpiOutputEdge 652 /* returns vpiNoEdge, vpiPosedge,
vpiNegedge */
#define vpiGeneric 653
/* Compatibility-mode property and values (object argument == NULL) */
#define vpiCompatibilityMode 654
#define vpiMode1364v1995 1
#define vpiMode1364v2001 2
#define vpiMode1364v2005 3
#define vpiMode1800v2005 4
#define vpiMode1800v2009 5
#define vpiPackedArrayMember 655
#define vpiStartLine 661
#define vpiColumn 662
#define vpiEndLine 663
#define vpiEndColumn 664
/* memory allocation scheme for transient objects */
#define vpiAllocScheme 658
#define vpiAutomaticScheme 1
#define vpiDynamicScheme 2
#define vpiOtherScheme 3
1293
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiObjId 660
#define vpiDPIPure 665
#define vpiDPIContext 666
#define vpiDPICStr 667
#define vpiDPI 1
#define vpiDPIC 2
#define vpiDPICIdentifier 668
#define vpiIsModPort 669
/******************************** Operators *******************************/
#define vpiImplyOp 50 /* -> implication operator */
#define vpiNonOverlapImplyOp 51 /* |=> nonoverlapped implication */
#define vpiOverlapImplyOp 52 /* |-> overlapped implication operator */
#define vpiAcceptOnOp 83 /* accept_on operator */
#define vpiRejectOnOp 84 /* reject_on operator */
#define vpiSyncAcceptOnOp 85 /* sync_accept_on operator */
#define vpiSyncRejectOnOp 86 /* sync_reject_on operator */
#define vpiOverlapFollowedByOp 87 /* overlapped followed_by operator */
#define vpiNonOverlapFollowedByOp 88 /* nonoverlapped followed_by operator */
#define vpiNexttimeOp 89 /* nexttime operator */
#define vpiAlwaysOp 90 /* always operator */
#define vpiEventuallyOp 91 /* eventually operator */
#define vpiUntilOp 92 /* until operator */
#define vpiUntilWithOp 93 /* until_with operator */
#define vpiUnaryCycleDelayOp 53 /* binary cycle delay (##) operator */
#define vpiCycleDelayOp 54 /* binary cycle delay (##) operator */
#define vpiIntersectOp 55 /* intersection operator */
#define vpiFirstMatchOp 56 /* first_match operator */
#define vpiThroughoutOp 57 /* throughout operator */
#define vpiWithinOp 58 /* within operator */
#define vpiRepeatOp 59 /* [=] nonconsecutive repetition */
#define vpiConsecutiveRepeatOp 60 /* [*] consecutive repetition */
#define vpiGotoRepeatOp 61 /* [->] goto repetition */
#define vpiPostIncOp 62 /* ++ post-increment */
#define vpiPreIncOp 63 /* ++ pre-increment */
#define vpiPostDecOp 64 /* -- post-decrement */
#define vpiPreDecOp 65 /* -- pre-decrement */
#define vpiMatchOp 66 /* match() operator */
#define vpiCastOp 67 /* type'() operator */
#define vpiIffOp 68 /* iff operator */
#define vpiWildEqOp 69 /* ==? operator */
#define vpiWildNeqOp 70 /* !=? operator */
#define vpiStreamLROp 71 /* left-to-right streaming {>>} operator */
#define vpiStreamRLOp 72 /* right-to-left streaming {<<} operator */
#define vpiMatchedOp 73 /* the .matched sequence operation */
#define vpiTriggeredOp 74 /* the .triggered sequence operation */
#define vpiAssignmentPatternOp 75 /* '{} assignment pattern */
#define vpiMultiAssignmentPatternOp 76 /* '{n{}} multi assignment pattern */
#define vpiIfOp 77 /* if operator */
#define vpiIfElseOp 78 /* if–else operator */
#define vpiCompAndOp 79 /* Composite and operator */
#define vpiCompOrOp 80 /* Composite or operator */
#define vpiImpliesOp 94 /* implies operator */
1294
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiInsideOp 95 /* inside operator */
#define vpiTypeOp 81 /* type operator */
#define vpiAssignmentOp 82 /* Normal assignment */
/*********************** task/function properties ***********************/
#define vpiOtherFunc 6 /* returns other types; for property vpiFuncType */
/* vpiValid and vpiValidUnknown were deprecated in 1800-2009 */
/*********************** value for vpiValid *****************************/
#define vpiValidUnknown 2 /* Validity of variable is unknown */
/************************** STRUCTURE DEFINITIONS *************************/
/***************************** structure *****************************/
/**************************** CALLBACK REASONS ****************************/
#define cbStartOfThread 600 /* callback on thread creation */
#define cbEndOfThread 601 /* callback on thread termination */
#define cbEnterThread 602 /* callback on reentering thread */
#define cbStartOfFrame 603 /* callback on frame creation */
#define cbEndOfFrame 604 /* callback on frame exit */
#define cbSizeChange 605 /* callback on array variable size change */
#define cbCreateObj 700 /* callback on class object creation */
#define cbReclaimObj 701 /* callback on class object reclaimed by
automatic memory management */
#define cbEndOfObject 702 /* callback on transient object deletion */
/************************* FUNCTION DECLARATIONS **************************/
/**************************************************************************/
/*************************** Coverage VPI *********************************/
/**************************************************************************/
/* coverage control */
#define vpiCoverageStart 750
#define vpiCoverageStop 751
#define vpiCoverageReset 752
#define vpiCoverageCheck 753
#define vpiCoverageMerge 754
#define vpiCoverageSave 755
/* coverage type properties */
#define vpiAssertCoverage 760
#define vpiFsmStateCoverage 761
#define vpiStatementCoverage 762
#define vpiToggleCoverage 763
/* coverage status properties */
#define vpiCovered 765
#define vpiCoverMax 766 /* preserved for backward compatibility */
#define vpiCoveredMax 766
#define vpiCoveredCount 767
/* assertion-specific coverage status properties */
#define vpiAssertAttemptCovered 770
#define vpiAssertSuccessCovered 771
#define vpiAssertFailureCovered 772
#define vpiAssertVacuousSuccessCovered 773
1295
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiAssertDisableCovered 774
#define vpiAssertKillCovered 777
/* FSM-specific coverage status properties */
#define vpiFsmStates 775
#define vpiFsmStateExpression 776
/* FSM handle types */
#define vpiFsm 758
#define vpiFsmHandle 759
/***************************************************************************/
/***************************** Assertion VPI *******************************/
/***************************************************************************/
/* assertion callback types */
#define cbAssertionStart 606
#define cbAssertionSuccess 607
#define cbAssertionFailure 608
#define cbAssertionVacuousSuccess 657
#define cbAssertionDisabledEvaluation 658
#define cbAssertionStepSuccess 609
#define cbAssertionStepFailure 610
#define cbAssertionLock 661
#define cbAssertionUnlock 662
#define cbAssertionDisable 611
#define cbAssertionEnable 612
#define cbAssertionReset 613
#define cbAssertionKill 614
#define cbAssertionEnablePassAction 645
#define cbAssertionEnableFailAction 646
#define cbAssertionDisablePassAction 647
#define cbAssertionDisableFailAction 648
#define cbAssertionEnableNonvacuousAction 649
#define cbAssertionDisableVacuousAction 650
/* assertion "system" callback types */
#define cbAssertionSysInitialized 615
#define cbAssertionSysOn 616
#define cbAssertionSysOff 617
#define cbAssertionSysKill 631
#define cbAssertionSysLock 659
#define cbAssertionSysUnlock 660
#define cbAssertionSysEnd 618
#define cbAssertionSysReset 619
#define cbAssertionSysEnablePassAction 651
#define cbAssertionSysEnableFailAction 652
#define cbAssertionSysDisablePassAction 653
#define cbAssertionSysDisableFailAction 654
#define cbAssertionSysEnableNonvacuousAction 655
#define cbAssertionSysDisableVacuousAction 656
/* assertion control constants */
#define vpiAssertionLock 645
#define vpiAssertionUnlock 646
#define vpiAssertionDisable 620
#define vpiAssertionEnable 621
#define vpiAssertionReset 622
1296
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
#define vpiAssertionKill 623
#define vpiAssertionEnableStep 624
#define vpiAssertionDisableStep 625
#define vpiAssertionClockSteps 626
#define vpiAssertionSysLock 647
#define vpiAssertionSysUnlock 648
#define vpiAssertionSysOn 627
#define vpiAssertionSysOff 628
#define vpiAssertionSysKill 632
#define vpiAssertionSysEnd 629
#define vpiAssertionSysReset 630
#define vpiAssertionDisablePassAction 633
#define vpiAssertionEnablePassAction 634
#define vpiAssertionDisableFailAction 635
#define vpiAssertionEnableFailAction 636
#define vpiAssertionDisableVacuousAction 637
#define vpiAssertionEnableNonvacuousAction 638
#define vpiAssertionSysEnablePassAction 639
#define vpiAssertionSysEnableFailAction 640
#define vpiAssertionSysDisablePassAction 641
#define vpiAssertionSysDisableFailAction 642
#define vpiAssertionSysEnableNonvacuousAction 643
#define vpiAssertionSysDisableVacuousAction 644
typedef struct t_vpi_assertion_step_info {
PLI_INT32 matched_expression_count;
vpiHandle *matched_exprs; /* array of expressions */
PLI_INT32 stateFrom, stateTo; /* identify transition */
} s_vpi_assertion_step_info, *p_vpi_assertion_step_info;
typedef struct t_vpi_attempt_info {
union {
vpiHandle failExpr;
p_vpi_assertion_step_info step;
} detail;
s_vpi_time attemptStartTime; /* Time attempt triggered */
} s_vpi_attempt_info, *p_vpi_attempt_info;
/* typedef for vpi_register_assertion_cb callback function */
typedef PLI_INT32(vpi_assertion_callback_func)(
PLI_INT32 reason, /* callback reason */
p_vpi_time cb_time, /* callback time */
vpiHandle assertion, /* handle to assertion */
p_vpi_attempt_info info, /* attempt related information */
PLI_BYTE8 *user_data /* user data entered upon registration */
);
vpiHandle vpi_register_assertion_cb(
vpiHandle assertion, /* handle to assertion */
PLI_INT32 reason, /* reason for which callbacks needed */
vpi_assertion_callback_func *cb_rtn,
PLI_BYTE8 *user_data /* user data to be supplied to cb */
);
#ifdef __cplusplus
}
#endif
#endif
1297
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex N
(normative)
Algorithm for probabilistic distribution functions
N.1 General
This annex lists the C source code for the SystemVerilog probabilistic distribution system functions.
TableN.1 shows the SystemVerilog system function names with their corresponding Cfunctions. See 20.15
for the syntactical definition of these system functions.
Table N.1—SystemVerilog to C function cross-listing
SystemVerilog function C function
rtl_dist_uniform
$dist_uniform
rtl_dist_normal
$dist_normal
rtl_dist_exponential
$dist_exponential
rtl_dist_poisson
$dist_poisson
rtl_dist_chi_square
$dist_chi_square
rtl_dist_t
$dist_t
rtl_dist_erlang
$dist_erlang
rtl_dist_uniform (seed, LONG_MIN, LONG_MAX)
$random
The algorithm for these functions is defined by the C code in N.2.
N.2 Source code
/*
* Algorithm for probabilistic distribution functions.
*
* IEEE Std 1800-2017 SystemVerilog Unified Hardware Design and Verification Language
*/
#include <limits.h>
static double uniform( long *seed, long start, long end );
static double normal( long *seed, long mean, long deviation);
static double exponential( long *seed, long mean);
static long poisson( long *seed, long mean);
static double chi_square( long *seed, long deg_of_free);
static double t( long *seed, long deg_of_free);
static double erlangian( long *seed, long k, long mean);
long
rtl_dist_chi_square( seed, df )
long *seed;
1298
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb erer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
long df;
{
double r;
long i;
if(df>0)
{
r=chi_square(seed,df);
if(r>=0)
{
i=(long)(r+0.5);
}
else
{
r = -r;
i=(long)(r+0.5);
i = -i;
}
}
else
{
print_error("WARNING: Chi_square distribution must ",
"have positive degree of freedom\n");
i=0;
}
return (i);
}
long
rtl_dist_erlang( seed, k, mean )
long *seed;
long k, mean;
{
double r;
long i;
if(k>0)
{
r=erlangian(seed,k,mean);
if(r>=0)
{
i=(long)(r+0.5);
}
else
{
r = -r;
i=(long)(r+0.5);
i = -i;
}
}
else
{
print_error("WARNING: k-stage erlangian distribution ",
"must have positive k\n");
i=0;
}
return (i);
}
1299
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
long
rtl_dist_exponential( seed, mean )
long *seed;
long mean;
{
double r;
long i;
if(mean>0)
{
r=exponential(seed,mean);
if(r>=0)
{
i=(long)(r+0.5);
}
else
{
r = -r;
i=(long)(r+0.5);
i = -i;
}
}
else
{
print_error("WARNING: Exponential distribution must ",
"have a positive mean\n");
i=0;
}
return (i);
}
long
rtl_dist_normal( seed, mean, sd )
long *seed;
long mean, sd;
{
double r;
long i;
r=normal(seed,mean,sd);
if(r>=0)
{
i=(long)(r+0.5);
}
else
{
r = -r;
i=(long)(r+0.5);
i = -i;
}
return (i);
}
long
rtl_dist_poisson( seed, mean )
1300
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
long *seed;
long mean;
{
long i;
if(mean>0)
{
i=poisson(seed,mean);
}
else
{
print_error("WARNING: Poisson distribution must have a ",
"positive mean\n");
i=0;
}
return (i);
}
long
rtl_dist_t( seed, df )
long *seed;
long df;
{
double r;
long i;
if(df>0)
{
r=t(seed,df);
if(r>=0)
{
i=(long)(r+0.5);
}
else
{
r = -r;
i=(long)(r+0.5);
i = -i;
}
}
else
{
print_error("WARNING: t distribution must have positive ",
"degree of freedom\n");
i=0;
}
return (i);
}
long
rtl_dist_uniform(seed, start, end)
long *seed;
long start, end;
{
double r;
long i;
if (start >= end) return(start);
if (end != LONG_MAX)
{
1301
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
end++;
r = uniform( seed, start, end );
if (r >= 0)
{
i = (long) r;
}
else
{
i = (long) (r-1);
}
if (i<start) i = start;
if (i>=end) i = end-1;
}
else if (start!=LONG_MIN)
{
start--;
r = uniform( seed, start, end) + 1.0;
if (r>=0)
{
i = (long) r;
}
else
{
i = (long) (r-1);
}
if (i<=start) i = start+1;
if (i>end) i = end;
}
else
{
r =(uniform(seed,start,end)+
2147483648.0)/4294967295.0;
r = r*4294967296.0-2147483648.0;
if (r>=0)
{
i = (long) r;
}
else
{
i = (long) (r-1);
}
}
return (i);
}
static double
uniform( seed, start, end )
long *seed, start, end;
{
union u_s
{
float s;
unsigned stemp;
} u;
double d = 0.00000011920928955078125;
double a,b,c;
1302
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
if ((*seed) == 0)
*seed = 259341593;
if (start >= end)
{
a = 0.0;
b = 2147483647.0;
}
else
{
a = (double) start;
b = (double) end;
}
*seed = 69069 * (*seed) + 1;
u.stemp = *seed;
/*
* This relies on IEEE floating point format
*/
u.stemp = (u.stemp >> 9) | 0x3f800000;
c = (double) u.s;
c = c+(c*d);
c = ((b - a) * (c - 1.0)) + a;
return (c);
}
static double
normal(seed,mean,deviation)
long *seed,mean,deviation;
{
double v1,v2,s;
double log(), sqrt();
s = 1.0;
while((s >= 1.0) || (s == 0.0))
{
v1 = uniform(seed,-1,1);
v2 = uniform(seed,-1,1);
s = v1 * v1 + v2 * v2;
}
s = v1 * sqrt(-2.0 * log(s) / s);
v1 = (double) deviation;
v2 = (double) mean;
return(s * v1 + v2);
}
static double
exponential(seed,mean)
long *seed,mean;
{
double log(),n;
n = uniform(seed,0,1);
if(n != 0)
{
n = -log(n) * mean;
1303
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
}
return(n);
}
static long
poisson(seed,mean)
long *seed,mean;
{
long n;
double p,q;
double exp();
n = 0;
q = -(double)mean;
p = exp(q);
q = uniform(seed,0,1);
while(p < q)
{
n++;
q = uniform(seed,0,1) * q;
}
return(n);
}
static double
chi_square(seed,deg_of_free)
long *seed,deg_of_free;
{
double x;
long k;
if(deg_of_free % 2)
{
x = normal(seed,0,1);
x = x * x;
}
else
{
x = 0.0;
}
for(k = 2; k <= deg_of_free; k = k + 2)
{
x = x + 2 * exponential(seed,1);
}
return(x);
}
static double
t(seed,deg_of_free)
long *seed,deg_of_free;
{
double sqrt(),x;
double chi2 = chi_square(seed,deg_of_free);
double div = chi2 / (double)deg_of_free;
double root = sqrt(div);
x = normal(seed,0,1) / root;
return(x);
}
static double
erlangian(seed,k,mean)
1304
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
long *seed,k,mean;
{
double x,log(),a,b;
long i;
x=1.0;
for(i=1;i<=k;i++)
{
x = x * uniform(seed,0,1);
}
a=(double)mean;
b=(double)k;
x= -a*log(x)/b;
return(x);
}
1305
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex O
(informative)
Encryption/decryption flow
O.1 General
This annex describes a number of scenarios that can be used for IP protection. It also shows how the relevant
pragmas are used to achieve the desired effect of securely protecting, distributing, and decrypting the model.
O.2 Overview
The data to be protected from inappropriate access or from unauthorized modification is placed within a
protect block. Information in the block, once encrypted, is also protected.
begin-end begin-end
O.3 Tool vendor secret key encryption system
In the secret key encryption system, the key is tool vendor proprietary and is embedded within the tool itself.
The same key is used for both encryption and decryption. [In the electronic design automation (EDA)
domain, this is the simplest scenario and is roughly equivalent to the historical technique.] It has
`protect
the drawback of being completely tool vendor-specific. Using this technique, the IP author can encrypt the
IP, and any IP consumer with appropriate licenses and the same tool vendor can utilize the IP.
O.3.1 Encryption input
The following pragmas are expected when using the tool vendor secret key encryption system. The pragmas
required in the encryption input for use of the secret key encryption system are as follows:
<key name> Where <key name> is a valid name of a tool’s embedded key.
data_keyname=
Surrounding the region(s) to be encrypted.
begin-end
Additional optional pragmas that may be included are as follows:
<string> To embed author name.
author=
<string> To embed arbitrary author information.
author_info=
<owner identity>This shall be the key owner of the provided name.
data_keyowner=
<method-specifier>A method appropriate for the given key name. This may be
data_method=
necessary if something other than the default number of rounds,
initialization vector, or key width is used.
<encoding-specifier> To specify a different encoding.
encoding=
If a message authorization code is desired to validate that the
digest_block
message has not been modified.
If the IP author desires a decryption license.
decrypt_license
If the IP author desires a run-time license.
runtime_license
1306
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
O.3.2 Encryption output
The encrypting tool should take the input file and copy all cleartext to the corresponding output sections. For
each protect begin-end block, it should generate the following:
To start the protected region.
begin_protected
<owner identity>
data_keyowner=
<key name>
data_keyname=
<method-specifier>
data_method=
<encoding-specifier>
encoding=
<string> If provided in the input.
author=
a <string> If provided in the input.
uthor_info=
Followed on the next line(s) by the encoded encrypted digest.
digest_block
Followed on the next line(s) by the encoded encrypted data
data_block
composed of the following:
decrypt_license
encrypt_license
<text found between >
begin-end
end_protected
O.4 IP author secret key encryption system
In this mechanism, the IP is encrypted with the public key (of a public/private key pair) of the IP author, and
the decrypting tool will have the IP author’s private key in its secure key database. The IP authors will have
to provide their private keys to the tools’ database so that the tool will be able to decrypt the design.
O.4.1 Encryption input
The following pragmas are expected when using the IP author secret key encryption system:
< provider’s key name>
data_keyname=
Surrounding the region(s) to be encrypted.
begin-end
Additional optional pragmas that may be included are as follows:
<string> To embed author name.
author=
<string> To embed arbitrary author information.
author_info=
<owner identity>This shall be the key owner of the provided name.
data_keyowner=
some_publ_priv_encryption_scheme_name <method-specifier>
data_method=
A method appropriate for the given key name. This may be
necessary if something other than the default number of rounds,
initialization vector, or key width is used.
<encoding-specifier> To specify a different encoding.
encoding=
If a message authorization code is desired to validate that the
digest_block
message has not been modified.
If the IP author desires a decryption license.
decrypt_license
If the IP author desires a run-time license.
runtime_license
1307
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
O.4.2 Encryption output
The encrypting tool should take the input file and copy all cleartext to the corresponding output sections. For
each protect block, it should generate the following:
begin-end
To start the protected region.
begin_protected
<owner identity>
data_keyowner=
<provider’s key name>
data_keyname=
some_publ_priv_encryption_scheme_name
data_method=
<encoding-specifier>
encoding=
<string> If provided in the input.
author=
<string> If provided in the input.
author_info=
Followed on the next line(s) by the encoded encrypted digest.
digest_block
Followed on the next line(s) by the encoded encrypted data
data_block
composed of the following:
decrypt_license
encrypt_license
<text found between >
begin-end
end_protected
O.5 Digital envelopes
In this mechanism, each recipient has a public and private key for an asymmetric encryption algorithm. The
sender encrypts the design using a symmetric key encryption algorithm and then encrypts the symmetric key
using the recipient’s public key. The encrypted symmetric key is recorded in a in the protected
key_block
envelope. The recipient is able to recover the symmetric key using the appropriate private key and then
decrypts the design with the symmetric key. This technique permits efficient encryption methods for the
design data, yet secret information is never transmitted without encryption. Digital envelopes can be created
using either tool secret key or IP author secret key protection schemes. The keys for the recipient user or tool
protect the transmission of the symmetric key that encrypts the design data. By using more than one
, a single protected envelope can be decrypted by tools from different vendors and/or different
key_block
users.
In the following example, the data_method and / are used to encrypt the
data_keyownerdata_keyname
. The key to encrypt the can be specified either by a /
data_block data_block data_keyowner
pair or by a pragma expression. In the first case, the encrypting tool
data_keyname data_decrypt_key
encrypts the and pragmas with the / and
data_keyowner data_keyname key_keymethodkey_keyname
puts them in the along with . Alternatively, with the
key_block data_method data_decrypt_key
pragma, the actual key is provided, which is then encrypted with / and stored in
key_methodkey_keyname
the .
key_block
In the first approach, the / should also be present with the decrypting tool.
data_keyownerdata_keyname
No such dependency exists with the second approach as the key is present in the file itself.
For better security in the first approach, the encrypting tool can actually read the /
data_keyowner
key and put it in the as . This step not only will remove
data_keyname key_block data_decrypt_key
the dependency mentioned above, but will also protect against the hit-and-trial breaking of the
data_block
with the existing keys at the IP user’s end.
1308
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
O.5.1 Encryption input
The following pragmas are expected when using the digital envelopes:
<owner identity>
key_keyowner=
some_encryption_scheme_name
key_method=
<provider’s key name>
key_keyname=
<provider’s key name>
data_keyname=
Surrounding the region(s) to be encrypted.
begin-end
Additional optional pragmas that may be included are as follows:
<string> To embed author name.
author=
<string> To embed arbitrary author information.
author_info=
<owner identity>This shall be the key owner of the provided name.
data_keyowner=
<method-specifier>A method appropriate for the given key name. This may be
data_method=
necessary if something other than the default number of rounds,
initialization vector, or key width is used
<encoding-specifier> To specify a different encoding.
encoding=
If a message authorization code is desired to validate that the
digest_block
message has not been modified.
If the IP author desires a decryption license.
decrypt_license
If the IP author desires a run-time license.
runtime_license
O.5.2 Encryption output
The encrypting tool should take the input file and copy all cleartext to the corresponding output sections. For
each protect block, it should generate the following:
begin-end
To start the protected region.
begin_protected
<owner identity>
key_keyowner=
some_encryption_scheme_name
key_method=
<provider’s key name>
key_keyname=
<encrypted encoded data>
key_block=
This contains the data_key_owner, data_method, and the symmetric
data_key itself in encrypted form.
<encoding-specifier>
encoding=
<string> If provided in the input.
author=
<string> If provided in the input.
author_info=
Followed on the next line(s) by the encoded encrypted digest.
digest_block
Followed on the next line(s) by the encoded encrypted data
data_block
composed of the following:
decrypt_license
encrypt_license
<text found between >
begin-end
end_protected
1309
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex P
(informative)
Glossary
For the purposes of this document, the following terms and definitions apply. The IEEE Standards
Dictionary Online should be consulted for terms not defined in this clause. 14
aggregate: A set or collection of singular values, e.g., an aggregate expression, data object, or data type. An
aggregate data type is any unpacked structure, unpacked union, or unpacked array data type. Aggregates
may be copied or compared as a whole, but not typically used in an expression as a whole.
assertion: An assertion statement.
assertion statement: A statement that specifies the verification function to be performed on an underlying
property. An assertion statement is of one of the following kinds:
— , to specify the property as an obligation for the design that is to be checked to verify that the
assert
property holds.
— , to specify the property as an assumption for the environment. Simulators check that the
assume
property holds, while formal tools use the information to generate input stimulus.
— , to monitor the property evaluation for coverage.
cover
— , to specify the property as a constraint on formal verification computations. Simulators
restrict
do not check the property.
The underlying property describes the behavioral criterion that is evaluated by the assertion statement. The
property may be an immediate condition, e.g., that the and signals are
read_enable write_enable
mutually exclusive, or it may be a temporal condition, e.g., that if a occurs, then a
read_request
occurs within two clock cycles. An assertion statement is either immediate, for which the
read_grant
underlying property must be an immediate condition, or concurrent, for which the underlying property may
be either an immediate or a temporal condition. There is no immediate assertion statement.
restrict
Assertion statements can generate automatic messages to report that the disposition of the evaluation of the
underlying property is of interest for the kind of the assertion statement, e.g., a failing evaluation disposition
for an or , or a passing disposition for a .
assert assume cover
NOTE—SystemVerilog provides special assertion constructs, which are discussed in Clause16. See 16.2 for a
discussion of assertion statements.
bit-stream data type: Any data type whose values can be represented as a serial stream of bits. To qualify
as a bit-stream data type, each and every bit of the values shall be individually addressable. In other words, a
bit-stream data type can be any data type except for a handle, , , , or .
chandle real shortreal event
canonical representation: A data representation format established by convention into which and from
which translations can be made with specialized representations.
constant: Either of two types of constants in SystemVerilog: elaboration constant or run-time constant.
Parameters and local parameters are elaboration constants. Their values are calculated before elaboration is
complete. Elaboration constants can be used to set the range of array types. Run-time constants are variables
that can only be set in an initialization expression using the qualifier.
const
14IEEE Standards Dictionary Online is available at: http://dictionary.ieee.org.
1310
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
context imported task: A direct programming interface (DPI) imported task declared with the “context”
property that is capable of calling exported subroutines and capable of accessing SystemVerilog objects via
the SystemVerilog Verification Procedural Interface (VPI) or Programming Language Interface (PLI) calls.
data object: A named entity that has a data value associated with it. Examples of data objects are nets,
variables, and parameters. A data object has a data type that determines which values the data object can
have.
data type: A set of values and a set of operations that can be performed on those values. Examples of data
types are , , and . Data types can be used to declare data objects or to define user-defined
logic real string
data types that are constructed from other data types.
direct programming interface (DPI): An interface between SystemVerilog and foreign programming
languages permitting direct function calls from SystemVerilog to foreign code and from foreign code to
SystemVerilog. It has been designed to have low inherent overhead and permit direct exchange of data
between SystemVerilog and foreign code.
disable protocol: A set of conventions for setting, checking, and handling disable status.
dynamic: Having values that can be resized or reallocated at run time. Dynamic arrays, associative arrays,
queues, class handles, and data types that include such data types are dynamic data types.
elaboration: The process of binding together the components that make up a design. These components can
include module instances, primitive instances, interfaces, and the top level of the design hierarchy.
enumerated type: Data types that can declare a data object that can have one of a set of named values. The
numerical equivalents of these values can be specified. Values of an enumerated data type can be easily
referenced or displayed using the enumerated names, as opposed to the enumerated values.
exported task: A SystemVerilog task that is declared in an export declaration and can be enabled from an
imported task.
imported task: A direct programming interface (DPI) foreign code subprogram that can call exported tasks
and can directly or indirectly consume simulation time.
integral: (A) A data type representing integer values. (B) A integer value that may be signed or unsigned,
sliced into smaller integral values, or concatenated into larger values. Syn: vectored value. (C) An
expression of an integral data type. (D) An object of an integral data type.
interface: An encapsulation of the communication between blocks of a design, allowing a smooth migration
from abstract system-level design through successive refinement down to lower level register transfer and
structural views of the design. By encapsulating the communication between blocks, the interface construct
also facilitates design reuse. The inclusion of interface capabilities is one of the major advantages of
SystemVerilog.
Language Reference Manual (LRM): A document describing the syntax, semantics, and usage of a
programming language. SystemVerilog LRM refers to this standard.
open array: A direct programming interface (DPI) array formal argument for which the packed or unpacked
dimension size (or both) is not specified and for which interface routines describe the size of corresponding
actual arguments at run time.
1311
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
packed array: An array where the dimensions are declared before an object name. Packed arrays can have
any number of dimensions. A one-dimensional packed array is the same as a vector width declaration in
IEEE 1364-2005 Verilog. Packed arrays provide a mechanism for subdividing a vector into subfields, which
can be conveniently accessed as array elements. A packed array differs from an unpacked array, in that the
whole array is treated as a single vector for arithmetic operations.
process: A thread of one or more programming statements that can be executed independently of other
programming statements. Each elaborated instance of an procedure, , ,
initial always always_comb
, procedure, or continuous assignment statement in SystemVerilog is a separate
always_latch always_ff
process. These are static processes; their existence is determined by the static instance hierarchy, their
execution begins at the start of simulation, and they cannot be created at run time. SystemVerilog also has
dynamic processes that can be created, stopped, restarted, and destroyed at run time.
signal: An informal term, usually meaning either a variable or net. The context where it is used may imply
further restrictions on allowed types.
singular: An expression, data object, or data type that represents a single value, symbol, or handle. A
singular data type is any data type except an unpacked structure, unpacked union, or unpacked array data
type.
subroutine: An encapsulation of executable code that can be invoked from one or more places. There are
two forms of subroutines, tasks and functions.
unpacked array: An array where the dimensions are declared after an object name. Unpacked arrays are the
same as arrays in IEEE 1364-2005 Verilog and can have any number of dimensions. An unpacked array
differs from a packed array in that the whole array cannot be used for arithmetic operations. Each element
shall be treated separately.
Verification Procedural Interface (VPI): The third generation programming language interface (PLI)
access libraries, providing object-oriented access to SystemVerilog behavioral, structural, assertion, and
coverage objects.
Verilog: The hardware description language (HDL) in IEEE Std 1364-2005.
1312
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE Std 1800-2017
IEEE Standard for SystemVerilog—Unified Hardware Design, Specification, and Verification Language
Annex Q
(informative)
Bibliography
[B1] IEEE Std 1497-2001, IEEE Standard for Standard Delay Format (SDF) for the Electronic Design
Process.15, 16
[B2] IEEE Std 1735-2014, IEEE Recommended Practice for Encryption and Management of Electronic
Design Intellectual Property (IP).
[B3] ISO/IEC 9899:1999, Programming Languages—C.17
[B4] SystemVerilog 3.1a Language Reference Manual, Accellera’s Extensions to Verilog®, 2004.18
15IEEE publications are available from The Institute of Electrical and Electronics Engineers (http://standards.ieee.org/).
16The IEEE standards or products referred to in this clause are trademarks of The Institute of Electrical and Electronics Engineers, Inc.
17ISO/IEC publications are available from the ISO Central Secretariat (http://www.iso.org/). ISO publications are also available in the
United States from the American National Standards Institute (http://www.ansi.org/).
18Available at http://www.eda-twiki.org/sv/SystemVerilog_3.1a.pdf.
1313
Authorized licensed use limited to: Siemens AG GBS B&CS oSpOyLri gGhMt S©. D2o0w1n8l oIaEdEeEd .o An lDl reigcehmtsb reer s0e3r,2v0e2d5. at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

IEEE
standards.ieee.org
Phone: +1 732 981 0060 Fax: +1 732 562 1571
© IEEE
Authorized licensed use limited to: Siemens AG GBS B&S SOL GMS. Downloaded on December 03,2025 at 05:44:49 UTC from IEEE Xplore. Restrictions apply.

